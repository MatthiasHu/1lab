<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="keywords" content="Agda,categories,topos" />

  <title>1Lab.Path - 1Lab</title>

  <link rel="stylesheet" href="/css/default.css" />
  <link rel="stylesheet" href="/css/katex.min.css" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="1Lab.Path - 1Lab" />
  <meta name="twitter:image" content="https://1lab.dev/static/cube-128x.png" />

  <meta name="og:title" content="1Lab.Path - 1Lab" />
  <meta name="og:image" content="https://1lab.dev/static/cube-128x.png" />
  <meta name="og:site-name" content="1Lab" />
  <meta name="og:type" content="website" />

    <meta name="og:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="twitter:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  
  <script defer src="/main.js"></script>

  <noscript>
    <style>
      body span.reasoning-step .as-written {
        display: inline;
      }

      body span.reasoning-step .alternate {
        display: none;
      }
    </style>
  </noscript>

  <!-- Google font embeds -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;0,800;1,400;1,500;1,600;1,700;1,800&amp;family=Inria+Sans:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&amp;display=swap" rel="stylesheet">
</head>

<body class="text-page">
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <!-- Table of contents (only if the page has a table of contents) -->
    <aside id="toc">
    <div id="toc-container" style="min-width: 10em; font-size: 15pt;">
      <!-- Title for the page -->
      <h3 class="Agda" style="margin-top: 0; margin-bottom: 0; white-space: pre;">
                <a class="Module">1Lab.Path</a>
              </h3>

      <!-- Cube logo -->
      <a id="logo" href="/">
        <img alt="1Lab" src="/static/cube-72x.png" style="display: block; margin-bottom: 1em; margin: auto;" width="32px" height="32px" />
      </a>

      <!-- Actual table of contents (separated from the rest by
      horizontal rules) -->
      <hr />
      <ul>
      <li><a href="#the-interval"><a href="#the-interval" class="header-link">The
      Interval<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#raising-dimension"><a href="#raising-dimension" class="header-link">Raising
      Dimension<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#symmetry"><a href="#symmetry" class="header-link">Symmetry<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      <li><a href="#paths"><a href="#paths" class="header-link">Paths<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#transport"><a href="#transport" class="header-link">Transport<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#computation"><a href="#computation" class="header-link">Computation<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      <li><a href="#path-induction"><a href="#path-induction" class="header-link">Path
      Induction<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#functorial-action"><a href="#functorial-action" class="header-link">Functorial
      Action<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      <li><a href="#composition"><a href="#composition" class="header-link">Composition<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#partial-elements"><a href="#partial-elements" class="header-link">Partial
      Elements<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#extensibility"><a href="#extensibility" class="header-link">Extensibility<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#uniqueness"><a href="#uniqueness" class="header-link">Uniqueness<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#syntax-sugar"><a href="#syntax-sugar" class="header-link">Syntax
      Sugar<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      <li><a href="#dependent-paths"><a href="#dependent-paths" class="header-link">Dependent
      Paths<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#coercion"><a href="#coercion" class="header-link">Coercion<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      <li><a href="#path-spaces"><a href="#path-spaces" class="header-link">Path
      Spaces<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#σ-types"><a href="#σ-types" class="header-link">Σ
      Types<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#π-types"><a href="#π-types" class="header-link">Π
      types<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#paths-1"><a href="#paths-1" class="header-link">Paths<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      </ul>
      <hr />

      <!-- Sidebar controls -->
      <div style="display: flex; gap: 0.25em; flex-flow: row wrap;">
        <!-- Sidebar equations control -->
        <span class="equations" style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-eqns" type="checkbox" class="equations" id="sidebar-eqns">
          <label for="sidebar-eqns">Equations</label>
        </span>

        <!-- Sidebar fonts control -->
        <span style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-font" type="checkbox" id="toggle-fonts">
          <label for="toggle-fonts">Serif Font</label>
        </span>

        <!-- Sidebar footnotes control -->
        <span class="inline-footnotes" style="display: none; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-fns" type="checkbox" class="inline-footnotes" id="sidebar-fns">
          <label for="sidebar-fns">Inline Footnotes</label>
        </span>
      </div>

      <hr />

      <!-- Navbar navigation (lol) -->
      <div id="return" style="white-space: nowrap;">
        <div class="search-form search-form-proxy" role="form">
          <input id="search-box-proxy" type_="text" placeholder="Search..." autocomplete="off" tabindex="0"></input>
        </div>

              <a href="/">back to index</a> <br />
              <a href="all-pages.html">view all pages</a> <br />
        <a href="https://github.com/plt-amy/cubical-1lab/blob/774b179f5266a7059060e1a1bd7c6434be5c9273/src/1Lab/Path.lagda.md">link to source</a> <br />
                <hr /> <div class="author-list">Written by Amélia Liao, Astra Kolomatskaia, Jonathan Coates, Reed Mullanix, szumixie and uni</div> <br />
              </div>
    </div>
  </aside>
  
  <article>
    <!-- Article navigation (narrow screens only) -->
    <div class="narrow-only" id="article-nav">
      <!-- Index return anchor (only if the page is not the index) -->
            <div id="return">
        <a href="/">back to index</a>
      </div>
      
      <!-- Navbar equations control -->
      <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-eqns" type="checkbox" class="equations" id="navbar-eqns">
        <label for="navbar-eqns">Equations</label>
      </span>

      <!-- Navbar footnotes control -->
      <span class="inline-footnotes" style="display: none; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-fns" type="checkbox" class="inline-footnotes" id="navbar-fns">
        <label for="navbar-fns">Inline Footnotes</label>
      </span>
    </div>

<pre class="Agda"><a id="9" class="Keyword">open</a> <a id="14" class="Keyword">import</a> <a id="21" href="1Lab.Type.html" class="Module">1Lab.Type</a>

<a id="32" class="Keyword">module</a> <a id="39" href="1Lab.Path.html" class="Module">1Lab.Path</a> <a id="49" class="Keyword">where</a>
</pre>
<h1 id="the-interval"><a href="#the-interval" class="header-link">The
Interval<span class="header-link-emoji">🔗</span></a></h1>
<p>In HoTT, the inductively-defined identity type gets a new meaning
explanation: continuous paths, in a topological sense. The “key idea” of
cubical type theory — and thus, Cubical Agda — is that we can take this
as a new <em>definition</em> of the identity type, where we interpret a
<span class="Agda"><a href="1Lab.Path.html#2466" class="Function">Path</a></span>
in a type by a function where the domain is the <em>interval
type</em>.</p>
<details>
<summary>
<strong>Aside</strong>: A brief comment on the meanings of “equal”,
“identical” and “identified”, and how we refer to inhabitants of path
types.
</summary>
<p>Before getting started, it’s worth taking a second to point out the
terminology that will be used in this module (and most of the other
pages). In intensional type theory, there is both an external notion of
“sameness” (definitional equality), and an internal notion of
“sameness”, which goes by many names: identity type, equality type,
propositional equality, path type, etc.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<p>In this module, we refer to the type <code>A ≡ B</code> as either
(the type of) <em>paths from A to B</em> or (the type of)
<em>identifications between A and B</em>, but <strong>never</strong> as
“equalities between A and B”. In particular, the HoTT book comments that
we may say
“<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span>
and
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>
are equal” when the type
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≡</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \equiv b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4637em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>
is inhabited, but in this development we refer this terminology for the
case where
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span>
and
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>
inhabit a <a href="1Lab.HLevel.html">set</a>.</p>
<p>Instead, for general types, we use
“<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span>
and
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>
are <strong>identical</strong>” or
“<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span>
and
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>
are <strong>identified</strong>” (or even the wordier, and rather more
literal, “there is a path between
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span>
and
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>”).
Depending on the type, we might use more specific words: Paths are said
to be <strong>homotopic</strong> when they’re connected by a
path-of-paths, and types are said to be <strong>equivalent</strong> when
they are connected by a path.</p>
</details>
<!--
<pre class="Agda"><a id="1960" class="Keyword">open</a> <a id="1965" class="Keyword">import</a> <a id="1972" href="Agda.Builtin.Cubical.Path.html" class="Module">Agda.Builtin.Cubical.Path</a> <a id="1998" class="Keyword">public</a>
<a id="2005" class="Keyword">open</a> <a id="2010" class="Keyword">import</a> <a id="2017" href="Agda.Builtin.Cubical.Sub.html" class="Module">Agda.Builtin.Cubical.Sub</a> <a id="2042" class="Keyword">public</a>
  <a id="2051" class="Keyword">renaming</a> <a id="2060" class="Symbol">(</a> <a id="2062" href="Agda.Builtin.Cubical.Sub.html#223" data-type="(x : A) → Sub A φ (λ _ → x)" class="Postulate">inc</a> <a id="2066" class="Symbol">to</a> <a id="2069" class="Postulate">inS</a>
           <a id="2084" class="Symbol">;</a> <a id="2086" href="Agda.Builtin.Cubical.Sub.html#407" data-type="Sub A φ u → A" class="Primitive">primSubOut</a> <a id="2097" class="Symbol">to</a> <a id="2100" class="Primitive">outS</a>
           <a id="2116" class="Symbol">)</a>
<a id="2118" class="Keyword">open</a> <a id="2123" class="Keyword">import</a> <a id="2130" href="Agda.Primitive.Cubical.html" class="Module">Agda.Primitive.Cubical</a> <a id="2153" class="Keyword">public</a>
  <a id="2162" class="Keyword">renaming</a> <a id="2171" class="Symbol">(</a> <a id="2173" href="Agda.Primitive.Cubical.html#350" class="Primitive">primIMin</a>       <a id="2188" class="Symbol">to</a> <a id="2191" class="Primitive">_∧_</a>
           <a id="2206" class="Symbol">;</a> <a id="2208" href="Agda.Primitive.Cubical.html#375" class="Primitive">primIMax</a>       <a id="2223" class="Symbol">to</a> <a id="2226" class="Primitive">_∨_</a>
           <a id="2241" class="Symbol">;</a> <a id="2243" href="Agda.Primitive.Cubical.html#400" class="Primitive">primINeg</a>       <a id="2258" class="Symbol">to</a> <a id="2261" class="Primitive">~_</a>
           <a id="2275" class="Symbol">;</a> <a id="2277" href="Agda.Primitive.Cubical.html#1132" class="Postulate">isOneEmpty</a>     <a id="2292" class="Symbol">to</a> <a id="2295" class="Postulate">empty</a>
           <a id="2312" class="Symbol">;</a> <a id="2314" href="Agda.Primitive.Cubical.html#1654" class="Primitive">primComp</a>       <a id="2329" class="Symbol">to</a> <a id="2332" class="Primitive">comp</a>
           <a id="2348" class="Symbol">;</a> <a id="2350" href="Agda.Primitive.Cubical.html#1881" class="Primitive">primHComp</a>      <a id="2365" class="Symbol">to</a> <a id="2368" class="Primitive">hcomp</a>
           <a id="2385" class="Symbol">;</a> <a id="2387" href="Agda.Primitive.Cubical.html#1808" class="Primitive">primTransp</a>     <a id="2402" class="Symbol">to</a> <a id="2405" class="Primitive">transp</a>
           <a id="2423" class="Symbol">;</a> <a id="2425" href="Agda.Primitive.Cubical.html#486" class="Postulate">itIsOne</a>        <a id="2440" class="Symbol">to</a> <a id="2443" class="Postulate">1=1</a> <a id="2447" class="Symbol">)</a>
</pre>-->
<pre class="Agda"><a id="Path"></a><a id="2466" href="1Lab.Path.html#2466" data-type="(A : Type ℓ) → A → A → Type ℓ" class="Function">Path</a> <a id="2471" class="Symbol">:</a> <a id="2473" class="Symbol">∀</a> <a id="2475" class="Symbol">{</a><a id="2476" href="1Lab.Path.html#2476" class="Bound">ℓ</a><a id="2477" class="Symbol">}</a> <a id="2479" class="Symbol">(</a><a id="2480" href="1Lab.Path.html#2480" class="Bound">A</a> <a id="2482" class="Symbol">:</a> <a id="2484" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="2489" href="1Lab.Path.html#2476" class="Bound">ℓ</a><a id="2490" class="Symbol">)</a> <a id="2492" class="Symbol">→</a> <a id="2494" href="1Lab.Path.html#2480" class="Bound">A</a> <a id="2496" class="Symbol">→</a> <a id="2498" href="1Lab.Path.html#2480" class="Bound">A</a> <a id="2500" class="Symbol">→</a> <a id="2502" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="2507" href="1Lab.Path.html#2476" class="Bound">ℓ</a>
<a id="2509" href="1Lab.Path.html#2466" data-type="(A : Type ℓ) → A → A → Type ℓ" class="Function">Path</a> <a id="2514" href="1Lab.Path.html#2514" class="Bound">A</a> <a id="2516" class="Symbol">=</a> <a id="2518" href="Agda.Builtin.Cubical.Path.html#197" data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" class="Postulate">PathP</a> <a id="2524" class="Symbol">(λ</a> <a id="2527" href="1Lab.Path.html#2527" class="Bound">i</a> <a id="2529" class="Symbol">→</a> <a id="2531" href="1Lab.Path.html#2514" class="Bound">A</a><a id="2532" class="Symbol">)</a>
</pre>
<p>The type
<span class="Agda"><a href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a></span>
is meant to represent the (real, closed) unit interval
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>,</span>
the same unit interval used in the topological definition of path.
Because the real unit interval has a least and greatest element — 0 and
1 — the interval <em>type</em> also has two global inhabitants,
<span class="Agda"><a href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a></span>
and
<span class="Agda"><a href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a></span>.
This is where the analogy with the reals breaks down: There’s no such
thing as <code>i0.5</code> (much less <code>i1/π</code>). In reality,
the interval type internalises an abstract interval <em>object</em>.</p>
<p>Regardless, since all functions definable in type theory are
automatically continuous, we can take a path to be any value in the
function type <code>I → A</code>. When working with paths, though, it’s
useful to mention the endpoints of a path in its type — that is, the
values the function takes when applied to <code>i0</code> and to
<code>i1</code>. We can “upgrade” any function <code>f : I → A</code> to
a
<span class="Agda"><a href="1Lab.Path.html#2466" class="Function">Path</a></span>,
using a definition that looks suspiciously like the identity
function:</p>
<pre class="Agda"><a id="3496" class="Keyword">private</a>
  <a id="to-path"></a><a id="3506" href="1Lab.Path.html#3506" data-type="(f : I → A) → Path A (f i0) (f i1)" class="Function">to-path</a> <a id="3514" class="Symbol">:</a> <a id="3516" class="Symbol">∀</a> <a id="3518" class="Symbol">{</a><a id="3519" href="1Lab.Path.html#3519" class="Bound">ℓ</a><a id="3520" class="Symbol">}</a> <a id="3522" class="Symbol">{</a><a id="3523" href="1Lab.Path.html#3523" class="Bound">A</a> <a id="3525" class="Symbol">:</a> <a id="3527" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="3532" href="1Lab.Path.html#3519" class="Bound">ℓ</a><a id="3533" class="Symbol">}</a> <a id="3535" class="Symbol">→</a> <a id="3537" class="Symbol">(</a><a id="3538" href="1Lab.Path.html#3538" class="Bound">f</a> <a id="3540" class="Symbol">:</a> <a id="3542" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a> <a id="3544" class="Symbol">→</a> <a id="3546" href="1Lab.Path.html#3523" class="Bound">A</a><a id="3547" class="Symbol">)</a> <a id="3549" class="Symbol">→</a> <a id="3551" href="1Lab.Path.html#2466" data-type="(A : Type ℓ) → A → A → Type ℓ" class="Function">Path</a> <a id="3556" href="1Lab.Path.html#3523" class="Bound">A</a> <a id="3558" class="Symbol">(</a><a id="3559" href="1Lab.Path.html#3538" class="Bound">f</a> <a id="3561" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a><a id="3563" class="Symbol">)</a> <a id="3565" class="Symbol">(</a><a id="3566" href="1Lab.Path.html#3538" class="Bound">f</a> <a id="3568" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a><a id="3570" class="Symbol">)</a>
  <a id="3574" href="1Lab.Path.html#3506" data-type="(f : I → A) → Path A (f i0) (f i1)" class="Function">to-path</a> <a id="3582" href="1Lab.Path.html#3582" class="Bound">f</a> <a id="3584" href="1Lab.Path.html#3584" class="Bound">i</a> <a id="3586" class="Symbol">=</a> <a id="3588" href="1Lab.Path.html#3582" class="Bound">f</a> <a id="3590" href="1Lab.Path.html#3584" class="Bound">i</a>

<a id="refl"></a><a id="3593" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="3598" class="Symbol">:</a> <a id="3600" class="Symbol">∀</a> <a id="3602" class="Symbol">{</a><a id="3603" href="1Lab.Path.html#3603" class="Bound">ℓ</a><a id="3604" class="Symbol">}</a> <a id="3606" class="Symbol">{</a><a id="3607" href="1Lab.Path.html#3607" class="Bound">A</a> <a id="3609" class="Symbol">:</a> <a id="3611" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="3616" href="1Lab.Path.html#3603" class="Bound">ℓ</a><a id="3617" class="Symbol">}</a> <a id="3619" class="Symbol">{</a><a id="3620" href="1Lab.Path.html#3620" class="Bound">x</a> <a id="3622" class="Symbol">:</a> <a id="3624" href="1Lab.Path.html#3607" class="Bound">A</a><a id="3625" class="Symbol">}</a> <a id="3627" class="Symbol">→</a> <a id="3629" href="1Lab.Path.html#3620" class="Bound">x</a> <a id="3631" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="3633" href="1Lab.Path.html#3620" class="Bound">x</a>
<a id="3635" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="3640" class="Symbol">{</a><a id="3641" class="Argument">x</a> <a id="3643" class="Symbol">=</a> <a id="3645" href="1Lab.Path.html#3645" class="Bound">x</a><a id="3646" class="Symbol">}</a> <a id="3648" class="Symbol">=</a> <a id="3650" href="1Lab.Path.html#3506" data-type="(f : I → A) → Path A (f i0) (f i1)" class="Function">to-path</a> <a id="3658" class="Symbol">(λ</a> <a id="3661" href="1Lab.Path.html#3661" class="Bound">i</a> <a id="3663" class="Symbol">→</a> <a id="3665" href="1Lab.Path.html#3645" class="Bound">x</a><a id="3666" class="Symbol">)</a>
</pre>
<p>The type <code>Path A x y</code> is also written <code>x ≡ y</code>,
when <code>A</code> is not important - i.e. when it can be inferred from
<code>x</code> and <code>y</code>. Under this interpretation, proof that
identification is reflexive (i.e. that
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">x = x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>)</span>
is given by a
<span class="Agda"><a href="1Lab.Path.html#2466" class="Function">Path</a></span>
which yields the same element everywhere on <code>I</code>: The function
that is constantly
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>.</span></p>
<p>If we have a
<span class="Agda"><a href="1Lab.Path.html#2466" class="Function">Path</a></span>,
we can apply it to a value of the interval type to get an element of the
underlying type. When a path is applied to one of the endpoints, the
result is the same as declared in its type — even when we’re applying a
path we don’t know the definition of.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<pre class="Agda"><a id="4522" class="Keyword">module</a> <a id="4529" href="1Lab.Path.html#4529" class="Module">_</a> <a id="4531" class="Symbol">{</a><a id="4532" href="1Lab.Path.html#4532" class="Bound">ℓ</a><a id="4533" class="Symbol">}</a> <a id="4535" class="Symbol">{</a><a id="4536" href="1Lab.Path.html#4536" class="Bound">A</a> <a id="4538" class="Symbol">:</a> <a id="4540" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="4545" href="1Lab.Path.html#4532" class="Bound">ℓ</a><a id="4546" class="Symbol">}</a> <a id="4548" class="Symbol">{</a><a id="4549" href="1Lab.Path.html#4549" class="Bound">x</a> <a id="4551" href="1Lab.Path.html#4551" class="Bound">y</a> <a id="4553" class="Symbol">:</a> <a id="4555" href="1Lab.Path.html#4536" class="Bound">A</a><a id="4556" class="Symbol">}</a> <a id="4558" class="Symbol">{</a><a id="4559" href="1Lab.Path.html#4559" class="Bound">p</a> <a id="4561" class="Symbol">:</a> <a id="4563" href="1Lab.Path.html#4549" class="Bound">x</a> <a id="4565" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="4567" href="1Lab.Path.html#4551" class="Bound">y</a><a id="4568" class="Symbol">}</a> <a id="4570" class="Keyword">where</a>
  <a id="4578" class="Keyword">private</a>
    <a id="4590" href="1Lab.Path.html#4590" class="Function">left-endpoint</a> <a id="4604" class="Symbol">:</a> <a id="4606" href="1Lab.Path.html#4559" class="Bound">p</a> <a id="4608" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a> <a id="4611" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="4613" href="1Lab.Path.html#4549" class="Bound">x</a>
    <a id="4619" href="1Lab.Path.html#4590" class="Function">left-endpoint</a> <a id="4633" href="1Lab.Path.html#4633" class="Bound">i</a> <a id="4635" class="Symbol">=</a> <a id="4637" href="1Lab.Path.html#4549" class="Bound">x</a>

    <a id="4644" href="1Lab.Path.html#4644" class="Function">right-endpoint</a> <a id="4659" class="Symbol">:</a> <a id="4661" href="1Lab.Path.html#4559" class="Bound">p</a> <a id="4663" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a> <a id="4666" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="4668" href="1Lab.Path.html#4551" class="Bound">y</a>
    <a id="4674" href="1Lab.Path.html#4644" class="Function">right-endpoint</a> <a id="4689" href="1Lab.Path.html#4689" class="Bound">i</a> <a id="4691" class="Symbol">=</a> <a id="4693" href="1Lab.Path.html#4551" class="Bound">y</a>
</pre>
<p>In addition to the two endpoints
<span class="Agda"><a href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a></span>
and
<span class="Agda"><a href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a></span>,
the interval has the structure of a De Morgan algebra. All the following
equations are respected (definitionally), but they can not be expressed
internally as a
<span class="Agda"><a href="1Lab.Path.html#2466" class="Function">Path</a></span>
because
<span class="Agda"><a href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a></span>
is not in
<span class="Agda"><a href="1Lab.Type.html#391" class="Primitive">Type</a></span>.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p>
<ul>
<li><span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∧</mo><mrow><mi mathvariant="normal">i</mi><mn>0</mn></mrow><mo>=</mo><mrow><mi mathvariant="normal">i</mi><mn>0</mn></mrow></mrow><annotation encoding="application/x-tex">x \land \id{i0} = \id{i0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i0</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i0</span></span></span></span></span>,</span>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∧</mo><mrow><mi mathvariant="normal">i</mi><mn>1</mn></mrow><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">x \land \id{i1} = x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i1</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></li>
<li><span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∨</mo><mrow><mi mathvariant="normal">i</mi><mn>0</mn></mrow><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">x \lor \id{i0} = x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i0</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>,</span>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∨</mo><mrow><mi mathvariant="normal">i</mi><mn>1</mn></mrow><mo>=</mo><mrow><mi mathvariant="normal">i</mi><mn>1</mn></mrow></mrow><annotation encoding="application/x-tex">x \lor \id{i1} = \id{i1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i1</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i1</span></span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">¬</mi><mo stretchy="false">(</mo><mi>x</mi><mo>∧</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">¬</mi><mi>x</mi><mo>∨</mo><mi mathvariant="normal">¬</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">\neg(x \land y) = \neg x \lor \neg y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">¬</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord">¬</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord">¬</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span></li>
<li><span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">¬</mi><mrow><mi mathvariant="normal">i</mi><mn>0</mn></mrow><mo>=</mo><mrow><mi mathvariant="normal">i</mi><mn>1</mn></mrow></mrow><annotation encoding="application/x-tex">\neg\id{i0} = \id{i1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord">¬</span><span class="mord"><span class="mord mathrm">i0</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i1</span></span></span></span></span>,</span>
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">¬</mi><mrow><mi mathvariant="normal">i</mi><mn>1</mn></mrow><mo>=</mo><mrow><mi mathvariant="normal">i</mi><mn>0</mn></mrow></mrow><annotation encoding="application/x-tex">\neg\id{i1} = \id{i0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord">¬</span><span class="mord"><span class="mord mathrm">i1</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i0</span></span></span></span></span>,</span>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">¬</mi><mi mathvariant="normal">¬</mi><mi>x</mi><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">\neg\neg x = x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">¬¬</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∧</mo></mrow><annotation encoding="application/x-tex">\land</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord">∧</span></span></span></span>
and
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∨</mo></mrow><annotation encoding="application/x-tex">\lor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord">∨</span></span></span></span>
are both associative, commutative and idempotent, and distribute over
eachother.</li>
</ul>
<p>Note that, in the formalisation,
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">¬</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">\neg x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">¬</span><span class="mord mathnormal">x</span></span></span></span>
is written <code>~ x</code>. As a more familiar description, a De Morgan
algebra is a Boolean algebra that does not (necessarily) satisfy the law
of excluded middle. This is necessary to maintain type safety.</p>
<h2 id="raising-dimension"><a href="#raising-dimension" class="header-link">Raising
Dimension<span class="header-link-emoji">🔗</span></a></h2>
<p>To wit: In cubical type theory, a term in a context with
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>
interval variables expresses a way of mapping an
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>-cube</span>
into that type. One very important class of these maps are the
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>-cubes</span>
— lines or
<em><span class="Agda"><a href="1Lab.Path.html#2466" class="Function">paths</a></span></em>
— which represent identifications between terms of that type.</p>
<p>Iterating this construction, a term in a context with 2 interval
variables represents a square in the type, which can be read as saying
that some <em>paths</em> (specialising one of the variables to
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">i0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mord">0</span></span></span></span>
or
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">i1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mord">1</span></span></span></span>)</span>
in that space are identical: A path between paths, which we call a
<em>homotopy</em>.</p>
<p>The structural operations on contexts, and the
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∧</mo></mrow><annotation encoding="application/x-tex">\land</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord">∧</span></span></span></span>
and
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∨</mo></mrow><annotation encoding="application/x-tex">\lor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord">∨</span></span></span></span>
operations on the interval, give a way of extending from
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>-dimensional</span>
cubes to
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">n+k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>-dimensional</span>
cubes. For instance, if we have a path like the one below, we can extend
it to any of a bunch of different squares:</p>
<div class="diagram-container">
<img src="light-a55f1868a3dfecb4f407b250660329b427839692.svg" title="commutative diagram" class="diagram diagram-light quiver short-2" />
<img src="dark-a55f1868a3dfecb4f407b250660329b427839692.svg" title="commutative diagram" class="diagram diagram-dark quiver short-2" />
</div>
<pre class="Agda"><a id="6798" class="Keyword">module</a> <a id="6805" href="1Lab.Path.html#6805" class="Module">_</a> <a id="6807" class="Symbol">{</a><a id="6808" href="1Lab.Path.html#6808" class="Bound">ℓ</a><a id="6809" class="Symbol">}</a> <a id="6811" class="Symbol">{</a><a id="6812" href="1Lab.Path.html#6812" class="Bound">A</a> <a id="6814" class="Symbol">:</a> <a id="6816" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="6821" href="1Lab.Path.html#6808" class="Bound">ℓ</a><a id="6822" class="Symbol">}</a> <a id="6824" class="Symbol">{</a><a id="6825" href="1Lab.Path.html#6825" class="Bound">a</a> <a id="6827" href="1Lab.Path.html#6827" class="Bound">b</a> <a id="6829" class="Symbol">:</a> <a id="6831" href="1Lab.Path.html#6812" class="Bound">A</a><a id="6832" class="Symbol">}</a> <a id="6834" class="Symbol">{</a><a id="6835" href="1Lab.Path.html#6835" class="Bound">p</a> <a id="6837" class="Symbol">:</a> <a id="6839" href="1Lab.Path.html#2466" data-type="(A : Type ℓ) → A → A → Type ℓ" class="Function">Path</a> <a id="6844" href="1Lab.Path.html#6812" class="Bound">A</a> <a id="6846" href="1Lab.Path.html#6825" class="Bound">a</a> <a id="6848" href="1Lab.Path.html#6827" class="Bound">b</a><a id="6849" class="Symbol">}</a> <a id="6851" class="Keyword">where</a>
</pre>
<p>The first thing we can do is introduce another interval variable and
ignore it, varying the path over the non-ignored variable. These give us
squares where either the top/bottom or left/right faces are the path
<code>p</code>, and the other two are refl.</p>
<pre class="Agda">  <a id="7117" class="Keyword">private</a>
    <a id="7129" href="1Lab.Path.html#7129" class="Function">drop-j</a> <a id="7136" class="Symbol">:</a> <a id="7138" href="Agda.Builtin.Cubical.Path.html#197" data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" class="Postulate">PathP</a> <a id="7144" class="Symbol">(λ</a> <a id="7147" href="1Lab.Path.html#7147" class="Bound">i</a> <a id="7149" class="Symbol">→</a> <a id="7151" href="1Lab.Path.html#6835" class="Bound">p</a> <a id="7153" href="1Lab.Path.html#7147" class="Bound">i</a> <a id="7155" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="7157" href="1Lab.Path.html#6835" class="Bound">p</a> <a id="7159" href="1Lab.Path.html#7147" class="Bound">i</a><a id="7160" class="Symbol">)</a> <a id="7162" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="7167" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
    <a id="7176" href="1Lab.Path.html#7129" class="Function">drop-j</a> <a id="7183" href="1Lab.Path.html#7183" class="Bound">i</a> <a id="7185" href="1Lab.Path.html#7185" class="Bound">j</a> <a id="7187" class="Symbol">=</a> <a id="7189" href="1Lab.Path.html#6835" class="Bound">p</a> <a id="7191" href="1Lab.Path.html#7183" class="Bound">i</a>

    <a id="7198" href="1Lab.Path.html#7198" class="Function">drop-i</a> <a id="7205" class="Symbol">:</a> <a id="7207" href="Agda.Builtin.Cubical.Path.html#197" data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" class="Postulate">PathP</a> <a id="7213" class="Symbol">(λ</a> <a id="7216" href="1Lab.Path.html#7216" class="Bound">i</a> <a id="7218" class="Symbol">→</a> <a id="7220" href="1Lab.Path.html#6825" class="Bound">a</a> <a id="7222" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="7224" href="1Lab.Path.html#6827" class="Bound">b</a><a id="7225" class="Symbol">)</a> <a id="7227" href="1Lab.Path.html#6835" class="Bound">p</a> <a id="7229" href="1Lab.Path.html#6835" class="Bound">p</a>
    <a id="7235" href="1Lab.Path.html#7198" class="Function">drop-i</a> <a id="7242" href="1Lab.Path.html#7242" class="Bound">i</a> <a id="7244" href="1Lab.Path.html#7244" class="Bound">j</a> <a id="7246" class="Symbol">=</a> <a id="7248" href="1Lab.Path.html#6835" class="Bound">p</a> <a id="7250" href="1Lab.Path.html#7244" class="Bound">j</a>
</pre>
<p>These squares can be drawn as below. Take a moment to appreciate how
the <em>types</em> of
<span class="Agda"><a href="1Lab.Path.html#7129" class="Function">drop-j</a></span>
and
<span class="Agda"><a href="1Lab.Path.html#7198" class="Function">drop-i</a></span>
specify the <em>boundary</em> of the diagram — A
<code>PathP (λ i → p i ≡ p i) refl refl</code> corresponds to a square
whose top/bottom faces are both <code>p</code>, and whose left/right
faces are both
<span class="Agda"><a href="1Lab.Path.html#3593" class="Function">refl</a></span>
(by convention). Similarly, <code>PathP (λ i → a ≡ b) p p</code> has
<span class="Agda"><a href="1Lab.Path.html#3593" class="Function">refl</a></span>
as top/bottom faces (recall that
<span class="Agda"><a href="1Lab.Path.html#3593" class="Function">refl</a></span>
is the constant function regarded as a path), and <code>p</code> as both
left/right faces.</p>
<div class="mathpar">
<div class="diagram-container">
<img src="light-9826005ee2148036bddca7f244d699da357cd43a.svg" title="commutative diagram" class="diagram diagram-light quiver" />
<img src="dark-9826005ee2148036bddca7f244d699da357cd43a.svg" title="commutative diagram" class="diagram diagram-dark quiver" />
</div>
<div class="diagram-container">
<img src="light-861395b4d0d00105d96d0e2acd5e30bd574b261d.svg" title="commutative diagram" class="diagram diagram-light quiver" />
<img src="dark-861395b4d0d00105d96d0e2acd5e30bd574b261d.svg" title="commutative diagram" class="diagram diagram-dark quiver" />
</div>
</div>
<p>The other thing we can do is use one of the binary operators on the
interval to get squares called <em>connections</em>, where two adjacent
faces are <code>p</code> and the other two are refl:</p>
<pre class="Agda">    <a id="8489" href="1Lab.Path.html#8489" class="Function">∧-conn</a> <a id="8496" class="Symbol">:</a> <a id="8498" href="Agda.Builtin.Cubical.Path.html#197" data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" class="Postulate">PathP</a> <a id="8504" class="Symbol">(λ</a> <a id="8507" href="1Lab.Path.html#8507" class="Bound">i</a> <a id="8509" class="Symbol">→</a> <a id="8511" href="1Lab.Path.html#6825" class="Bound">a</a> <a id="8513" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="8515" href="1Lab.Path.html#6835" class="Bound">p</a> <a id="8517" href="1Lab.Path.html#8507" class="Bound">i</a><a id="8518" class="Symbol">)</a> <a id="8520" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="8525" href="1Lab.Path.html#6835" class="Bound">p</a>
    <a id="8531" href="1Lab.Path.html#8489" class="Function">∧-conn</a> <a id="8538" href="1Lab.Path.html#8538" class="Bound">i</a> <a id="8540" href="1Lab.Path.html#8540" class="Bound">j</a> <a id="8542" class="Symbol">=</a> <a id="8544" href="1Lab.Path.html#6835" class="Bound">p</a> <a id="8546" class="Symbol">(</a><a id="8547" href="1Lab.Path.html#8538" class="Bound">i</a> <a id="8549" href="1Lab.Path.html#2191" class="Primitive Operator">∧</a> <a id="8551" href="1Lab.Path.html#8540" class="Bound">j</a><a id="8552" class="Symbol">)</a>

    <a id="8559" href="1Lab.Path.html#8559" class="Function">∨-conn</a> <a id="8566" class="Symbol">:</a> <a id="8568" href="Agda.Builtin.Cubical.Path.html#197" data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" class="Postulate">PathP</a> <a id="8574" class="Symbol">(λ</a> <a id="8577" href="1Lab.Path.html#8577" class="Bound">i</a> <a id="8579" class="Symbol">→</a> <a id="8581" href="1Lab.Path.html#6835" class="Bound">p</a> <a id="8583" href="1Lab.Path.html#8577" class="Bound">i</a> <a id="8585" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="8587" href="1Lab.Path.html#6827" class="Bound">b</a><a id="8588" class="Symbol">)</a> <a id="8590" href="1Lab.Path.html#6835" class="Bound">p</a> <a id="8592" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
    <a id="8601" href="1Lab.Path.html#8559" class="Function">∨-conn</a> <a id="8608" href="1Lab.Path.html#8608" class="Bound">i</a> <a id="8610" href="1Lab.Path.html#8610" class="Bound">j</a> <a id="8612" class="Symbol">=</a> <a id="8614" href="1Lab.Path.html#6835" class="Bound">p</a> <a id="8616" class="Symbol">(</a><a id="8617" href="1Lab.Path.html#8608" class="Bound">i</a> <a id="8619" href="1Lab.Path.html#2226" class="Primitive Operator">∨</a> <a id="8621" href="1Lab.Path.html#8610" class="Bound">j</a><a id="8622" class="Symbol">)</a>
</pre>
<p>These correspond to the following two squares:</p>
<div class="mathpar">
<div class="diagram-container">
<img src="light-a66b23a8b0cc893d70a6cfaa4f2b1b376acbfdc3.svg" title="commutative diagram" class="diagram diagram-light quiver" />
<img src="dark-a66b23a8b0cc893d70a6cfaa4f2b1b376acbfdc3.svg" title="commutative diagram" class="diagram diagram-dark quiver" />
</div>
<div class="diagram-container">
<img src="light-be731ec2df875ba27af6c3609878458aa88f2f63.svg" title="commutative diagram" class="diagram diagram-light quiver" />
<img src="dark-be731ec2df875ba27af6c3609878458aa88f2f63.svg" title="commutative diagram" class="diagram diagram-dark quiver" />
</div>
</div>
<p>Since iterated paths are used <em>a lot</em> in homotopy type theory,
we introduce a shorthand for 2D non-dependent paths. A
<span class="Agda"><a href="1Lab.Path.html#9409" class="Function">Square</a></span>
in a type is exactly what it says on the tin: a square.</p>
<pre class="Agda"><a id="Square"></a><a id="9409" href="1Lab.Path.html#9409" data-type="a00 ≡ a01 → a00 ≡ a10 → a01 ≡ a11 → a10 ≡ a11 → Type ℓ" class="Function">Square</a> <a id="9416" class="Symbol">:</a> <a id="9418" class="Symbol">∀</a> <a id="9420" class="Symbol">{</a><a id="9421" href="1Lab.Path.html#9421" class="Bound">ℓ</a><a id="9422" class="Symbol">}</a> <a id="9424" class="Symbol">{</a><a id="9425" href="1Lab.Path.html#9425" class="Bound">A</a> <a id="9427" class="Symbol">:</a> <a id="9429" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="9434" href="1Lab.Path.html#9421" class="Bound">ℓ</a><a id="9435" class="Symbol">}</a> <a id="9437" class="Symbol">{</a><a id="9438" href="1Lab.Path.html#9438" class="Bound">a00</a> <a id="9442" href="1Lab.Path.html#9442" class="Bound">a01</a> <a id="9446" href="1Lab.Path.html#9446" class="Bound">a10</a> <a id="9450" href="1Lab.Path.html#9450" class="Bound">a11</a> <a id="9454" class="Symbol">:</a> <a id="9456" href="1Lab.Path.html#9425" class="Bound">A</a><a id="9457" class="Symbol">}</a>
       <a id="9466" class="Symbol">→</a> <a id="9468" class="Symbol">(</a><a id="9469" href="1Lab.Path.html#9469" class="Bound">p</a> <a id="9471" class="Symbol">:</a> <a id="9473" href="1Lab.Path.html#9438" class="Bound">a00</a> <a id="9477" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="9479" href="1Lab.Path.html#9442" class="Bound">a01</a><a id="9482" class="Symbol">)</a>
       <a id="9491" class="Symbol">→</a> <a id="9493" class="Symbol">(</a><a id="9494" href="1Lab.Path.html#9494" class="Bound">q</a> <a id="9496" class="Symbol">:</a> <a id="9498" href="1Lab.Path.html#9438" class="Bound">a00</a> <a id="9502" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="9504" href="1Lab.Path.html#9446" class="Bound">a10</a><a id="9507" class="Symbol">)</a>
       <a id="9516" class="Symbol">→</a> <a id="9518" class="Symbol">(</a><a id="9519" href="1Lab.Path.html#9519" class="Bound">s</a> <a id="9521" class="Symbol">:</a> <a id="9523" href="1Lab.Path.html#9442" class="Bound">a01</a> <a id="9527" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="9529" href="1Lab.Path.html#9450" class="Bound">a11</a><a id="9532" class="Symbol">)</a>
       <a id="9541" class="Symbol">→</a> <a id="9543" class="Symbol">(</a><a id="9544" href="1Lab.Path.html#9544" class="Bound">r</a> <a id="9546" class="Symbol">:</a> <a id="9548" href="1Lab.Path.html#9446" class="Bound">a10</a> <a id="9552" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="9554" href="1Lab.Path.html#9450" class="Bound">a11</a><a id="9557" class="Symbol">)</a>
       <a id="9566" class="Symbol">→</a> <a id="9568" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="9573" href="1Lab.Path.html#9421" class="Bound">ℓ</a>
<a id="9575" href="1Lab.Path.html#9409" data-type="a00 ≡ a01 → a00 ≡ a10 → a01 ≡ a11 → a10 ≡ a11 → Type ℓ" class="Function">Square</a> <a id="9582" href="1Lab.Path.html#9582" class="Bound">p</a> <a id="9584" href="1Lab.Path.html#9584" class="Bound">q</a> <a id="9586" href="1Lab.Path.html#9586" class="Bound">s</a> <a id="9588" href="1Lab.Path.html#9588" class="Bound">r</a> <a id="9590" class="Symbol">=</a> <a id="9592" href="Agda.Builtin.Cubical.Path.html#197" data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" class="Postulate">PathP</a> <a id="9598" class="Symbol">(λ</a> <a id="9601" href="1Lab.Path.html#9601" class="Bound">i</a> <a id="9603" class="Symbol">→</a> <a id="9605" href="1Lab.Path.html#9582" class="Bound">p</a> <a id="9607" href="1Lab.Path.html#9601" class="Bound">i</a> <a id="9609" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="9611" href="1Lab.Path.html#9588" class="Bound">r</a> <a id="9613" href="1Lab.Path.html#9601" class="Bound">i</a><a id="9614" class="Symbol">)</a> <a id="9616" href="1Lab.Path.html#9584" class="Bound">q</a> <a id="9618" href="1Lab.Path.html#9586" class="Bound">s</a>
</pre>
<p>The arguments to
<span class="Agda"><a href="1Lab.Path.html#9409" class="Function">Square</a></span>
are as in the following diagram, listed in the order “PQSR”. This order
is a bit unusual (it’s one off from being alphabetical, for instance)
but it does have a significant benefit: If you imagine that the letters
are laid out in a circle, <em>identical paths are adjacent</em>. Reading
the square in the left-right direction, it says that
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>
and
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>
are identical — these are adjacent if you “fold up” the sequence
<code>p q s r</code>. Similarly, reading top-down, it says that
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span>
and
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span>
are identical - these are directly adjacent.</p>
<div class="diagram-container">
<img src="light-380d66cf53cf641227cfd3fdfef852d7db284189.svg" title="commutative diagram" class="diagram diagram-light quiver" />
<img src="dark-380d66cf53cf641227cfd3fdfef852d7db284189.svg" title="commutative diagram" class="diagram diagram-dark quiver" />
</div>
<h2 id="symmetry"><a href="#symmetry" class="header-link">Symmetry<span class="header-link-emoji">🔗</span></a></h2>
<p>The involution <code class="sourceCode agda">~<span class="ot">_</span></code> on the
interval type gives a way of inverting paths — a proof that
identification is symmetric.</p>
<pre class="Agda"><a id="sym"></a><a id="10558" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="10562" class="Symbol">:</a> <a id="10564" class="Symbol">∀</a> <a id="10566" class="Symbol">{</a><a id="10567" href="1Lab.Path.html#10567" class="Bound">ℓ₁</a><a id="10569" class="Symbol">}</a> <a id="10571" class="Symbol">{</a><a id="10572" href="1Lab.Path.html#10572" class="Bound">A</a> <a id="10574" class="Symbol">:</a> <a id="10576" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="10581" href="1Lab.Path.html#10567" class="Bound">ℓ₁</a><a id="10583" class="Symbol">}</a> <a id="10585" class="Symbol">{</a><a id="10586" href="1Lab.Path.html#10586" class="Bound">x</a> <a id="10588" href="1Lab.Path.html#10588" class="Bound">y</a> <a id="10590" class="Symbol">:</a> <a id="10592" href="1Lab.Path.html#10572" class="Bound">A</a><a id="10593" class="Symbol">}</a>
    <a id="10599" class="Symbol">→</a> <a id="10601" href="1Lab.Path.html#10586" class="Bound">x</a> <a id="10603" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="10605" href="1Lab.Path.html#10588" class="Bound">y</a> <a id="10607" class="Symbol">→</a> <a id="10609" href="1Lab.Path.html#10588" class="Bound">y</a> <a id="10611" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="10613" href="1Lab.Path.html#10586" class="Bound">x</a>
<a id="10615" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="10619" href="1Lab.Path.html#10619" class="Bound">p</a> <a id="10621" href="1Lab.Path.html#10621" class="Bound">i</a> <a id="10623" class="Symbol">=</a> <a id="10625" href="1Lab.Path.html#10619" class="Bound">p</a> <a id="10627" class="Symbol">(</a><a id="10628" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="10630" href="1Lab.Path.html#10621" class="Bound">i</a><a id="10631" class="Symbol">)</a>
</pre>
<!--
<pre class="Agda"><a id="symP"></a><a id="10647" href="1Lab.Path.html#10647" data-type="PathP A x y → PathP (λ i → A (~ i)) y x" class="Function">symP</a> <a id="10652" class="Symbol">:</a> <a id="10654" class="Symbol">∀</a> <a id="10656" class="Symbol">{</a><a id="10657" href="1Lab.Path.html#10657" class="Bound">ℓ₁</a><a id="10659" class="Symbol">}</a> <a id="10661" class="Symbol">{</a><a id="10662" href="1Lab.Path.html#10662" class="Bound">A</a> <a id="10664" class="Symbol">:</a> <a id="10666" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a> <a id="10668" class="Symbol">→</a> <a id="10670" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="10675" href="1Lab.Path.html#10657" class="Bound">ℓ₁</a><a id="10677" class="Symbol">}</a> <a id="10679" class="Symbol">{</a><a id="10680" href="1Lab.Path.html#10680" class="Bound">x</a> <a id="10682" class="Symbol">:</a> <a id="10684" href="1Lab.Path.html#10662" class="Bound">A</a> <a id="10686" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a><a id="10688" class="Symbol">}</a> <a id="10690" class="Symbol">{</a><a id="10691" href="1Lab.Path.html#10691" class="Bound">y</a> <a id="10693" class="Symbol">:</a> <a id="10695" href="1Lab.Path.html#10662" class="Bound">A</a> <a id="10697" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a><a id="10699" class="Symbol">}</a>
     <a id="10706" class="Symbol">→</a> <a id="10708" href="Agda.Builtin.Cubical.Path.html#197" data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" class="Postulate">PathP</a> <a id="10714" href="1Lab.Path.html#10662" class="Bound">A</a> <a id="10716" href="1Lab.Path.html#10680" class="Bound">x</a> <a id="10718" href="1Lab.Path.html#10691" class="Bound">y</a> <a id="10720" class="Symbol">→</a> <a id="10722" href="Agda.Builtin.Cubical.Path.html#197" data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" class="Postulate">PathP</a> <a id="10728" class="Symbol">(λ</a> <a id="10731" href="1Lab.Path.html#10731" class="Bound">i</a> <a id="10733" class="Symbol">→</a> <a id="10735" href="1Lab.Path.html#10662" class="Bound">A</a> <a id="10737" class="Symbol">(</a><a id="10738" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="10740" href="1Lab.Path.html#10731" class="Bound">i</a><a id="10741" class="Symbol">))</a> <a id="10744" href="1Lab.Path.html#10691" class="Bound">y</a> <a id="10746" href="1Lab.Path.html#10680" class="Bound">x</a>
<a id="10748" href="1Lab.Path.html#10647" data-type="PathP A x y → PathP (λ i → A (~ i)) y x" class="Function">symP</a> <a id="10753" href="1Lab.Path.html#10753" class="Bound">p</a> <a id="10755" href="1Lab.Path.html#10755" class="Bound">i</a> <a id="10757" class="Symbol">=</a> <a id="10759" href="1Lab.Path.html#10753" class="Bound">p</a> <a id="10761" class="Symbol">(</a><a id="10762" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="10764" href="1Lab.Path.html#10755" class="Bound">i</a><a id="10765" class="Symbol">)</a>
</pre>-->
<p>As a minor improvement over “Book HoTT”, this operation is
<em>definitionally</em> involutive:</p>
<pre class="Agda"><a id="10873" class="Keyword">module</a> <a id="10880" href="1Lab.Path.html#10880" class="Module">_</a> <a id="10882" class="Symbol">{</a><a id="10883" href="1Lab.Path.html#10883" class="Bound">ℓ</a><a id="10884" class="Symbol">}</a> <a id="10886" class="Symbol">{</a><a id="10887" href="1Lab.Path.html#10887" class="Bound">A</a> <a id="10889" class="Symbol">:</a> <a id="10891" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="10896" href="1Lab.Path.html#10883" class="Bound">ℓ</a><a id="10897" class="Symbol">}</a> <a id="10899" class="Symbol">{</a><a id="10900" href="1Lab.Path.html#10900" class="Bound">x</a> <a id="10902" href="1Lab.Path.html#10902" class="Bound">y</a> <a id="10904" class="Symbol">:</a> <a id="10906" href="1Lab.Path.html#10887" class="Bound">A</a><a id="10907" class="Symbol">}</a> <a id="10909" class="Symbol">{</a><a id="10910" href="1Lab.Path.html#10910" class="Bound">p</a> <a id="10912" class="Symbol">:</a> <a id="10914" href="1Lab.Path.html#10900" class="Bound">x</a> <a id="10916" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="10918" href="1Lab.Path.html#10902" class="Bound">y</a><a id="10919" class="Symbol">}</a> <a id="10921" class="Keyword">where</a>
  <a id="10929" class="Keyword">private</a>
    <a id="10941" href="1Lab.Path.html#10941" class="Function">sym-invol</a> <a id="10951" class="Symbol">:</a> <a id="10953" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="10957" class="Symbol">(</a><a id="10958" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="10962" href="1Lab.Path.html#10910" class="Bound">p</a><a id="10963" class="Symbol">)</a> <a id="10965" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="10967" href="1Lab.Path.html#10910" class="Bound">p</a>
    <a id="10973" href="1Lab.Path.html#10941" class="Function">sym-invol</a> <a id="10983" href="1Lab.Path.html#10983" class="Bound">i</a> <a id="10985" class="Symbol">=</a> <a id="10987" href="1Lab.Path.html#10910" class="Bound">p</a>
</pre>
<h1 id="paths"><a href="#paths" class="header-link">Paths<span class="header-link-emoji">🔗</span></a></h1>
<p>While the basic structure of the path type is inherited from its
nature as functions out of an internal De Morgan algebra, the structure
of <em>identifications</em> presented by paths is more complicated. For
starters, let’s see how paths correspond to identifications in that they
witness the logical principle of “indiscernibility of identicals”.</p>
<h2 id="transport"><a href="#transport" class="header-link">Transport<span class="header-link-emoji">🔗</span></a></h2>
<p>A basic principle of identity is that <em>identicals are
indiscernible</em>: if
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x = y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>
and
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>
holds, then
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>
also holds, for any choice of predicate
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>.</span>
In type theory, this is generalised, as
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>
can be not only a predicate, but any type family.</p>
<p>The way this is incarnated is by an operation called
<span class="Agda"><a href="1Lab.Path.html#11776" class="Function">transport</a></span>,
which says that every path between <code>A</code> and <code>B</code>
gives rise to a <em>function</em> <code>A → B</code>.</p>
<pre class="Agda"><a id="transport"></a><a id="11776" href="1Lab.Path.html#11776" data-type="A ≡ B₁ → A → B₁" class="Function">transport</a> <a id="11786" class="Symbol">:</a> <a id="11788" class="Symbol">∀</a> <a id="11790" class="Symbol">{</a><a id="11791" href="1Lab.Path.html#11791" class="Bound">ℓ</a><a id="11792" class="Symbol">}</a> <a id="11794" class="Symbol">{</a><a id="11795" href="1Lab.Path.html#11795" class="Bound">A</a> <a id="11797" href="1Lab.Path.html#11797" class="Bound">B</a> <a id="11799" class="Symbol">:</a> <a id="11801" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="11806" href="1Lab.Path.html#11791" class="Bound">ℓ</a><a id="11807" class="Symbol">}</a> <a id="11809" class="Symbol">→</a> <a id="11811" href="1Lab.Path.html#11795" class="Bound">A</a> <a id="11813" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="11815" href="1Lab.Path.html#11797" class="Bound">B</a> <a id="11817" class="Symbol">→</a> <a id="11819" href="1Lab.Path.html#11795" class="Bound">A</a> <a id="11821" class="Symbol">→</a> <a id="11823" href="1Lab.Path.html#11797" class="Bound">B</a>
<a id="11825" href="1Lab.Path.html#11776" data-type="A ≡ B₁ → A → B₁" class="Function">transport</a> <a id="11835" href="1Lab.Path.html#11835" class="Bound">p</a> <a id="11837" class="Symbol">=</a> <a id="11839" href="1Lab.Path.html#2405" class="Primitive">transp</a> <a id="11846" class="Symbol">(λ</a> <a id="11849" href="1Lab.Path.html#11849" class="Bound">i</a> <a id="11851" class="Symbol">→</a> <a id="11853" href="1Lab.Path.html#11835" class="Bound">p</a> <a id="11855" href="1Lab.Path.html#11849" class="Bound">i</a><a id="11856" class="Symbol">)</a> <a id="11858" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a>
</pre>
<p>The transport operation is the earliest case of when thinking of
<code>p : A ≡ B</code> as merely saying “A and B are equal” goes
seriously wrong. A path gives a <em>specific</em> identification of
<code>A</code> and <code>B</code>, which can be highly non-trivial.</p>
<p>As a concrete example, it can be shown that the type
<code>Bool ≡ Bool</code> has exactly two inhabitants (<a href="Data.Bool.html#Bool-aut≡2">see here</a>), which is something like
saying “the set of booleans is equal to itself in two ways”. That phrase
is nonsensical, which is why “there are two paths Bool → Bool” is
preferred: it’s not nonsense.</p>
<p>In Cubical Agda,
<span class="Agda"><a href="1Lab.Path.html#11776" class="Function">transport</a></span>
is a derived notion, with the actual primitive being
<span class="Agda"><a href="1Lab.Path.html#2405" class="Primitive">transp</a></span>.
Unlike
<span class="Agda"><a href="1Lab.Path.html#11776" class="Function">transport</a></span>,
which has two arguments (the path, and the point to transport),
<code>transp</code> has <em>three</em>:</p>
<ul>
<li><p>The first argument to
<span class="Agda"><a href="1Lab.Path.html#2405" class="Primitive">transp</a></span>
is a <em>line</em> of types, i.e. a function <code>A : I → Type</code>,
just as for
<span class="Agda"><a href="1Lab.Path.html#11776" class="Function">transport</a></span>.</p></li>
<li><p>The second argument to
<span class="Agda"><a href="1Lab.Path.html#2405" class="Primitive">transp</a></span>
has type
<span class="Agda"><a href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a></span>,
but it’s not playing the role of an endpoint of the interval. It’s
playing the role of a <em>formula</em>, which specifies <em>where the
transport is constant</em>: In <code>transp P i1</code>, <code>P</code>
is required to be constant, and the transport is the identity
function:</p>
<pre class="Agda"><a id="13096" href="1Lab.Path.html#13096" class="Function">_</a> <a id="13098" class="Symbol">:</a> <a id="13100" class="Symbol">∀</a> <a id="13102" class="Symbol">{</a><a id="13103" href="1Lab.Path.html#13103" class="Bound">ℓ</a><a id="13104" class="Symbol">}</a> <a id="13106" class="Symbol">{</a><a id="13107" href="1Lab.Path.html#13107" class="Bound">A</a> <a id="13109" class="Symbol">:</a> <a id="13111" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="13116" href="1Lab.Path.html#13103" class="Bound">ℓ</a><a id="13117" class="Symbol">}</a> <a id="13119" class="Symbol">→</a> <a id="13121" href="1Lab.Path.html#2405" class="Primitive">transp</a> <a id="13128" class="Symbol">(λ</a> <a id="13131" href="1Lab.Path.html#13131" class="Bound">i</a> <a id="13133" class="Symbol">→</a> <a id="13135" href="1Lab.Path.html#13107" class="Bound">A</a><a id="13136" class="Symbol">)</a> <a id="13138" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a> <a id="13141" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="13143" href="1Lab.Type.html#2424" data-type="A → A" class="Function">id</a>
<a id="13146" class="Symbol">_</a> <a id="13148" class="Symbol">=</a> <a id="13150" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
</pre></li>
<li><p>The third argument is an inhabitant of <code>A i0</code>, as for
<span class="Agda"><a href="1Lab.Path.html#11776" class="Function">transport</a></span>.</p></li>
</ul>
<p>This second argument, which lets us control where
<span class="Agda"><a href="1Lab.Path.html#2405" class="Primitive">transp</a></span>
is constant, brings a lot of power to the table! For example, the proof
that transporting along
<span class="Agda"><a href="1Lab.Path.html#3593" class="Function">refl</a></span>
is <code class="sourceCode agda">id</code> is as follows:</p>
<pre class="Agda"><a id="transport-refl"></a><a id="13454" href="1Lab.Path.html#13454" data-type="(x : A) → transport (λ i → A) x ≡ x" class="Function">transport-refl</a> <a id="13469" class="Symbol">:</a> <a id="13471" class="Symbol">∀</a> <a id="13473" class="Symbol">{</a><a id="13474" href="1Lab.Path.html#13474" class="Bound">ℓ</a><a id="13475" class="Symbol">}</a> <a id="13477" class="Symbol">{</a><a id="13478" href="1Lab.Path.html#13478" class="Bound">A</a> <a id="13480" class="Symbol">:</a> <a id="13482" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="13487" href="1Lab.Path.html#13474" class="Bound">ℓ</a><a id="13488" class="Symbol">}</a> <a id="13490" class="Symbol">(</a><a id="13491" href="1Lab.Path.html#13491" class="Bound">x</a> <a id="13493" class="Symbol">:</a> <a id="13495" href="1Lab.Path.html#13478" class="Bound">A</a><a id="13496" class="Symbol">)</a>
               <a id="13513" class="Symbol">→</a> <a id="13515" href="1Lab.Path.html#11776" data-type="A ≡ B₁ → A → B₁" class="Function">transport</a> <a id="13525" class="Symbol">(λ</a> <a id="13528" href="1Lab.Path.html#13528" class="Bound">i</a> <a id="13530" class="Symbol">→</a> <a id="13532" href="1Lab.Path.html#13478" class="Bound">A</a><a id="13533" class="Symbol">)</a> <a id="13535" href="1Lab.Path.html#13491" class="Bound">x</a> <a id="13537" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="13539" href="1Lab.Path.html#13491" class="Bound">x</a>
<a id="13541" href="1Lab.Path.html#13454" data-type="(x : A) → transport (λ i → A) x ≡ x" class="Function">transport-refl</a> <a id="13556" class="Symbol">{</a><a id="13557" class="Argument">A</a> <a id="13559" class="Symbol">=</a> <a id="13561" href="1Lab.Path.html#13561" class="Bound">A</a><a id="13562" class="Symbol">}</a> <a id="13564" href="1Lab.Path.html#13564" class="Bound">x</a> <a id="13566" href="1Lab.Path.html#13566" class="Bound">i</a> <a id="13568" class="Symbol">=</a> <a id="13570" href="1Lab.Path.html#2405" class="Primitive">transp</a> <a id="13577" class="Symbol">(λ</a> <a id="13580" href="1Lab.Path.html#13580" class="Bound">_</a> <a id="13582" class="Symbol">→</a> <a id="13584" href="1Lab.Path.html#13561" class="Bound">A</a><a id="13585" class="Symbol">)</a> <a id="13587" href="1Lab.Path.html#13566" class="Bound">i</a> <a id="13589" href="1Lab.Path.html#13564" class="Bound">x</a>
</pre>
<p>Since <code>λ i → A</code> is a constant function, the definition of
<span class="Agda"><a href="1Lab.Path.html#13454" class="Function">transport-refl</a></span>
is well-typed, and it has the stated endpoints because
<span class="Agda"><a href="1Lab.Path.html#11776" class="Function">transport</a></span>
is defined to be <code>transp P i0</code>, and <code>transp P i1</code>
is the identity function.</p>
<p>In fact, this generalises to something called the <em>filler</em> of
<span class="Agda"><a href="1Lab.Path.html#11776" class="Function">transport</a></span>:
<code>transport p x</code> and <code>x</code> <em>are</em> identical,
but they’re identical <em>over</em> the given path:</p>
<pre class="Agda"><a id="transport-filler"></a><a id="14006" href="1Lab.Path.html#14006" data-type="(p : A ≡ B₁) (x : A) → PathP (λ i → p i) x (transport p x)" class="Function">transport-filler</a> <a id="14023" class="Symbol">:</a> <a id="14025" class="Symbol">∀</a> <a id="14027" class="Symbol">{</a><a id="14028" href="1Lab.Path.html#14028" class="Bound">ℓ</a><a id="14029" class="Symbol">}</a> <a id="14031" class="Symbol">{</a><a id="14032" href="1Lab.Path.html#14032" class="Bound">A</a> <a id="14034" href="1Lab.Path.html#14034" class="Bound">B</a> <a id="14036" class="Symbol">:</a> <a id="14038" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="14043" href="1Lab.Path.html#14028" class="Bound">ℓ</a><a id="14044" class="Symbol">}</a>
                 <a id="14063" class="Symbol">→</a> <a id="14065" class="Symbol">(</a><a id="14066" href="1Lab.Path.html#14066" class="Bound">p</a> <a id="14068" class="Symbol">:</a> <a id="14070" href="1Lab.Path.html#14032" class="Bound">A</a> <a id="14072" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="14074" href="1Lab.Path.html#14034" class="Bound">B</a><a id="14075" class="Symbol">)</a> <a id="14077" class="Symbol">(</a><a id="14078" href="1Lab.Path.html#14078" class="Bound">x</a> <a id="14080" class="Symbol">:</a> <a id="14082" href="1Lab.Path.html#14032" class="Bound">A</a><a id="14083" class="Symbol">)</a>
                 <a id="14102" class="Symbol">→</a> <a id="14104" href="Agda.Builtin.Cubical.Path.html#197" data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" class="Postulate">PathP</a> <a id="14110" class="Symbol">(λ</a> <a id="14113" href="1Lab.Path.html#14113" class="Bound">i</a> <a id="14115" class="Symbol">→</a> <a id="14117" href="1Lab.Path.html#14066" class="Bound">p</a> <a id="14119" href="1Lab.Path.html#14113" class="Bound">i</a><a id="14120" class="Symbol">)</a> <a id="14122" href="1Lab.Path.html#14078" class="Bound">x</a> <a id="14124" class="Symbol">(</a><a id="14125" href="1Lab.Path.html#11776" data-type="A ≡ B₁ → A → B₁" class="Function">transport</a> <a id="14135" href="1Lab.Path.html#14066" class="Bound">p</a> <a id="14137" href="1Lab.Path.html#14078" class="Bound">x</a><a id="14138" class="Symbol">)</a>
<a id="14140" href="1Lab.Path.html#14006" data-type="(p : A ≡ B₁) (x : A) → PathP (λ i → p i) x (transport p x)" class="Function">transport-filler</a> <a id="14157" href="1Lab.Path.html#14157" class="Bound">p</a> <a id="14159" href="1Lab.Path.html#14159" class="Bound">x</a> <a id="14161" href="1Lab.Path.html#14161" class="Bound">i</a> <a id="14163" class="Symbol">=</a> <a id="14165" href="1Lab.Path.html#2405" class="Primitive">transp</a> <a id="14172" class="Symbol">(λ</a> <a id="14175" href="1Lab.Path.html#14175" class="Bound">j</a> <a id="14177" class="Symbol">→</a> <a id="14179" href="1Lab.Path.html#14157" class="Bound">p</a> <a id="14181" class="Symbol">(</a><a id="14182" href="1Lab.Path.html#14161" class="Bound">i</a> <a id="14184" href="1Lab.Path.html#2191" class="Primitive Operator">∧</a> <a id="14186" href="1Lab.Path.html#14175" class="Bound">j</a><a id="14187" class="Symbol">))</a> <a id="14190" class="Symbol">(</a><a id="14191" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="14193" href="1Lab.Path.html#14161" class="Bound">i</a><a id="14194" class="Symbol">)</a> <a id="14196" href="1Lab.Path.html#14159" class="Bound">x</a>
</pre>
<details>
<summary>
We also have some special cases of
<span class="Agda"><a href="1Lab.Path.html#14006" class="Function">transport-filler</a></span>
which are very convenient when working with iterated transports.
</summary>
<pre class="Agda"><a id="transport-filler-ext"></a><a id="14369" href="1Lab.Path.html#14369" data-type="(p : A ≡ B₁) → PathP (λ i → A → p i) (λ x → x) (transport p)" class="Function">transport-filler-ext</a> <a id="14390" class="Symbol">:</a> <a id="14392" class="Symbol">∀</a> <a id="14394" class="Symbol">{</a><a id="14395" href="1Lab.Path.html#14395" class="Bound">ℓ</a><a id="14396" class="Symbol">}</a> <a id="14398" class="Symbol">{</a><a id="14399" href="1Lab.Path.html#14399" class="Bound">A</a> <a id="14401" href="1Lab.Path.html#14401" class="Bound">B</a> <a id="14403" class="Symbol">:</a> <a id="14405" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="14410" href="1Lab.Path.html#14395" class="Bound">ℓ</a><a id="14411" class="Symbol">}</a> <a id="14413" class="Symbol">(</a><a id="14414" href="1Lab.Path.html#14414" class="Bound">p</a> <a id="14416" class="Symbol">:</a> <a id="14418" href="1Lab.Path.html#14399" class="Bound">A</a> <a id="14420" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="14422" href="1Lab.Path.html#14401" class="Bound">B</a><a id="14423" class="Symbol">)</a>
                     <a id="14446" class="Symbol">→</a> <a id="14448" href="Agda.Builtin.Cubical.Path.html#197" data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" class="Postulate">PathP</a> <a id="14454" class="Symbol">(λ</a> <a id="14457" href="1Lab.Path.html#14457" class="Bound">i</a> <a id="14459" class="Symbol">→</a> <a id="14461" href="1Lab.Path.html#14399" class="Bound">A</a> <a id="14463" class="Symbol">→</a> <a id="14465" href="1Lab.Path.html#14414" class="Bound">p</a> <a id="14467" href="1Lab.Path.html#14457" class="Bound">i</a><a id="14468" class="Symbol">)</a> <a id="14470" class="Symbol">(λ</a> <a id="14473" href="1Lab.Path.html#14473" class="Bound">x</a> <a id="14475" class="Symbol">→</a> <a id="14477" href="1Lab.Path.html#14473" class="Bound">x</a><a id="14478" class="Symbol">)</a> <a id="14480" class="Symbol">(</a><a id="14481" href="1Lab.Path.html#11776" data-type="A ≡ B₁ → A → B₁" class="Function">transport</a> <a id="14491" href="1Lab.Path.html#14414" class="Bound">p</a><a id="14492" class="Symbol">)</a>
<a id="14494" href="1Lab.Path.html#14369" data-type="(p : A ≡ B₁) → PathP (λ i → A → p i) (λ x → x) (transport p)" class="Function">transport-filler-ext</a> <a id="14515" href="1Lab.Path.html#14515" class="Bound">p</a> <a id="14517" href="1Lab.Path.html#14517" class="Bound">i</a> <a id="14519" href="1Lab.Path.html#14519" class="Bound">x</a> <a id="14521" class="Symbol">=</a> <a id="14523" href="1Lab.Path.html#14006" data-type="(p : A ≡ B₁) (x : A) → PathP (λ i → p i) x (transport p x)" class="Function">transport-filler</a> <a id="14540" href="1Lab.Path.html#14515" class="Bound">p</a> <a id="14542" href="1Lab.Path.html#14519" class="Bound">x</a> <a id="14544" href="1Lab.Path.html#14517" class="Bound">i</a>

<a id="transport⁻-filler-ext"></a><a id="14547" href="1Lab.Path.html#14547" data-type="(p : A ≡ B₁) → PathP (λ i → p i → A) (λ x → x) (transport (sym p))" class="Function">transport⁻-filler-ext</a> <a id="14569" class="Symbol">:</a> <a id="14571" class="Symbol">∀</a> <a id="14573" class="Symbol">{</a><a id="14574" href="1Lab.Path.html#14574" class="Bound">ℓ</a><a id="14575" class="Symbol">}</a> <a id="14577" class="Symbol">{</a><a id="14578" href="1Lab.Path.html#14578" class="Bound">A</a> <a id="14580" href="1Lab.Path.html#14580" class="Bound">B</a> <a id="14582" class="Symbol">:</a> <a id="14584" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="14589" href="1Lab.Path.html#14574" class="Bound">ℓ</a><a id="14590" class="Symbol">}</a> <a id="14592" class="Symbol">(</a><a id="14593" href="1Lab.Path.html#14593" class="Bound">p</a> <a id="14595" class="Symbol">:</a> <a id="14597" href="1Lab.Path.html#14578" class="Bound">A</a> <a id="14599" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="14601" href="1Lab.Path.html#14580" class="Bound">B</a><a id="14602" class="Symbol">)</a>
                     <a id="14625" class="Symbol">→</a> <a id="14627" href="Agda.Builtin.Cubical.Path.html#197" data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" class="Postulate">PathP</a> <a id="14633" class="Symbol">(λ</a> <a id="14636" href="1Lab.Path.html#14636" class="Bound">i</a> <a id="14638" class="Symbol">→</a> <a id="14640" href="1Lab.Path.html#14593" class="Bound">p</a> <a id="14642" href="1Lab.Path.html#14636" class="Bound">i</a> <a id="14644" class="Symbol">→</a> <a id="14646" href="1Lab.Path.html#14578" class="Bound">A</a><a id="14647" class="Symbol">)</a> <a id="14649" class="Symbol">(λ</a> <a id="14652" href="1Lab.Path.html#14652" class="Bound">x</a> <a id="14654" class="Symbol">→</a> <a id="14656" href="1Lab.Path.html#14652" class="Bound">x</a><a id="14657" class="Symbol">)</a> <a id="14659" class="Symbol">(</a><a id="14660" href="1Lab.Path.html#11776" data-type="A ≡ B₁ → A → B₁" class="Function">transport</a> <a id="14670" class="Symbol">(</a><a id="14671" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="14675" href="1Lab.Path.html#14593" class="Bound">p</a><a id="14676" class="Symbol">))</a>
<a id="14679" href="1Lab.Path.html#14547" data-type="(p : A ≡ B₁) → PathP (λ i → p i → A) (λ x → x) (transport (sym p))" class="Function">transport⁻-filler-ext</a> <a id="14701" href="1Lab.Path.html#14701" class="Bound">p</a> <a id="14703" href="1Lab.Path.html#14703" class="Bound">i</a> <a id="14705" href="1Lab.Path.html#14705" class="Bound">x</a> <a id="14707" class="Symbol">=</a> <a id="14709" href="1Lab.Path.html#2405" class="Primitive">transp</a> <a id="14716" class="Symbol">(λ</a> <a id="14719" href="1Lab.Path.html#14719" class="Bound">j</a> <a id="14721" class="Symbol">→</a> <a id="14723" href="1Lab.Path.html#14701" class="Bound">p</a> <a id="14725" class="Symbol">(</a><a id="14726" href="1Lab.Path.html#14703" class="Bound">i</a> <a id="14728" href="1Lab.Path.html#2191" class="Primitive Operator">∧</a> <a id="14730" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="14732" href="1Lab.Path.html#14719" class="Bound">j</a><a id="14733" class="Symbol">))</a> <a id="14736" class="Symbol">(</a><a id="14737" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="14739" href="1Lab.Path.html#14703" class="Bound">i</a><a id="14740" class="Symbol">)</a> <a id="14742" href="1Lab.Path.html#14705" class="Bound">x</a>

<a id="transport⁻transport"></a><a id="14745" href="1Lab.Path.html#14745" data-type="(p : A ≡ B₁) (a : A) → transport (sym p) (transport p a) ≡ a" class="Function">transport⁻transport</a> <a id="14765" class="Symbol">:</a> <a id="14767" class="Symbol">∀</a> <a id="14769" class="Symbol">{</a><a id="14770" href="1Lab.Path.html#14770" class="Bound">ℓ</a><a id="14771" class="Symbol">}</a> <a id="14773" class="Symbol">{</a><a id="14774" href="1Lab.Path.html#14774" class="Bound">A</a> <a id="14776" href="1Lab.Path.html#14776" class="Bound">B</a> <a id="14778" class="Symbol">:</a> <a id="14780" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="14785" href="1Lab.Path.html#14770" class="Bound">ℓ</a><a id="14786" class="Symbol">}</a> <a id="14788" class="Symbol">(</a><a id="14789" href="1Lab.Path.html#14789" class="Bound">p</a> <a id="14791" class="Symbol">:</a> <a id="14793" href="1Lab.Path.html#14774" class="Bound">A</a> <a id="14795" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="14797" href="1Lab.Path.html#14776" class="Bound">B</a><a id="14798" class="Symbol">)</a> <a id="14800" class="Symbol">(</a><a id="14801" href="1Lab.Path.html#14801" class="Bound">a</a> <a id="14803" class="Symbol">:</a> <a id="14805" href="1Lab.Path.html#14774" class="Bound">A</a><a id="14806" class="Symbol">)</a>
                    <a id="14828" class="Symbol">→</a> <a id="14830" href="1Lab.Path.html#11776" data-type="A ≡ B₁ → A → B₁" class="Function">transport</a> <a id="14840" class="Symbol">(</a><a id="14841" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="14845" href="1Lab.Path.html#14789" class="Bound">p</a><a id="14846" class="Symbol">)</a> <a id="14848" class="Symbol">(</a><a id="14849" href="1Lab.Path.html#11776" data-type="A ≡ B₁ → A → B₁" class="Function">transport</a> <a id="14859" href="1Lab.Path.html#14789" class="Bound">p</a> <a id="14861" href="1Lab.Path.html#14801" class="Bound">a</a><a id="14862" class="Symbol">)</a> <a id="14864" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="14866" href="1Lab.Path.html#14801" class="Bound">a</a>
<a id="14868" href="1Lab.Path.html#14745" data-type="(p : A ≡ B₁) (a : A) → transport (sym p) (transport p a) ≡ a" class="Function">transport⁻transport</a> <a id="14888" href="1Lab.Path.html#14888" class="Bound">p</a> <a id="14890" href="1Lab.Path.html#14890" class="Bound">a</a> <a id="14892" href="1Lab.Path.html#14892" class="Bound">i</a> <a id="14894" class="Symbol">=</a>
  <a id="14898" href="1Lab.Path.html#14547" data-type="(p : A ≡ B₁) → PathP (λ i → p i → A) (λ x → x) (transport (sym p))" class="Function">transport⁻-filler-ext</a> <a id="14920" href="1Lab.Path.html#14888" class="Bound">p</a> <a id="14922" class="Symbol">(</a><a id="14923" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="14925" href="1Lab.Path.html#14892" class="Bound">i</a><a id="14926" class="Symbol">)</a> <a id="14928" class="Symbol">(</a><a id="14929" href="1Lab.Path.html#14369" data-type="(p : A ≡ B₁) → PathP (λ i → A → p i) (λ x → x) (transport p)" class="Function">transport-filler-ext</a> <a id="14950" href="1Lab.Path.html#14888" class="Bound">p</a> <a id="14952" class="Symbol">(</a><a id="14953" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="14955" href="1Lab.Path.html#14892" class="Bound">i</a><a id="14956" class="Symbol">)</a> <a id="14958" href="1Lab.Path.html#14890" class="Bound">a</a><a id="14959" class="Symbol">)</a>
</pre>
</details>
<p>The path is constant when <code>i = i0</code> because
<code>(λ j → p (i0 ∧ j))</code> is <code>(λ j → p i0)</code> (by the
reduction rules for <code class="sourceCode agda"><span class="ot">_</span>∧<span class="ot">_</span></code>).
It has the stated endpoints, again, because <code>transp P i1</code> is
the identity function.</p>
<p>By altering a path <code>p</code> using a predicate <code>P</code>,
we get the promised principle of <em>indiscernibility of
identicals</em>:</p>
<pre class="Agda"><a id="subst"></a><a id="15309" href="1Lab.Path.html#15309" data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" class="Function">subst</a> <a id="15315" class="Symbol">:</a> <a id="15317" class="Symbol">∀</a> <a id="15319" class="Symbol">{</a><a id="15320" href="1Lab.Path.html#15320" class="Bound">ℓ₁</a> <a id="15323" href="1Lab.Path.html#15323" class="Bound">ℓ₂</a><a id="15325" class="Symbol">}</a> <a id="15327" class="Symbol">{</a><a id="15328" href="1Lab.Path.html#15328" class="Bound">A</a> <a id="15330" class="Symbol">:</a> <a id="15332" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="15337" href="1Lab.Path.html#15320" class="Bound">ℓ₁</a><a id="15339" class="Symbol">}</a> <a id="15341" class="Symbol">(</a><a id="15342" href="1Lab.Path.html#15342" class="Bound">P</a> <a id="15344" class="Symbol">:</a> <a id="15346" href="1Lab.Path.html#15328" class="Bound">A</a> <a id="15348" class="Symbol">→</a> <a id="15350" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="15355" href="1Lab.Path.html#15323" class="Bound">ℓ₂</a><a id="15357" class="Symbol">)</a> <a id="15359" class="Symbol">{</a><a id="15360" href="1Lab.Path.html#15360" class="Bound">x</a> <a id="15362" href="1Lab.Path.html#15362" class="Bound">y</a> <a id="15364" class="Symbol">:</a> <a id="15366" href="1Lab.Path.html#15328" class="Bound">A</a><a id="15367" class="Symbol">}</a>
      <a id="15375" class="Symbol">→</a> <a id="15377" href="1Lab.Path.html#15360" class="Bound">x</a> <a id="15379" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="15381" href="1Lab.Path.html#15362" class="Bound">y</a> <a id="15383" class="Symbol">→</a> <a id="15385" href="1Lab.Path.html#15342" class="Bound">P</a> <a id="15387" href="1Lab.Path.html#15360" class="Bound">x</a> <a id="15389" class="Symbol">→</a> <a id="15391" href="1Lab.Path.html#15342" class="Bound">P</a> <a id="15393" href="1Lab.Path.html#15362" class="Bound">y</a>
<a id="15395" href="1Lab.Path.html#15309" data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" class="Function">subst</a> <a id="15401" href="1Lab.Path.html#15401" class="Bound">P</a> <a id="15403" href="1Lab.Path.html#15403" class="Bound">p</a> <a id="15405" href="1Lab.Path.html#15405" class="Bound">x</a> <a id="15407" class="Symbol">=</a> <a id="15409" href="1Lab.Path.html#2405" class="Primitive">transp</a> <a id="15416" class="Symbol">(λ</a> <a id="15419" href="1Lab.Path.html#15419" class="Bound">i</a> <a id="15421" class="Symbol">→</a> <a id="15423" href="1Lab.Path.html#15401" class="Bound">P</a> <a id="15425" class="Symbol">(</a><a id="15426" href="1Lab.Path.html#15403" class="Bound">p</a> <a id="15428" href="1Lab.Path.html#15419" class="Bound">i</a><a id="15429" class="Symbol">))</a> <a id="15432" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a> <a id="15435" href="1Lab.Path.html#15405" class="Bound">x</a>
</pre>
<h3 id="computation"><a href="#computation" class="header-link">Computation<span class="header-link-emoji">🔗</span></a></h3>
<p>In “Book HoTT”,
<span class="Agda"><a href="1Lab.Path.html#11776" class="Function">transport</a></span>
is defined using path induction, and it computes definitionally on
<span class="Agda"><a href="1Lab.Path.html#3593" class="Function">refl</a></span>.
We have already seen that this is not definitional in cubical type
theory, which might lead you to ask: When does
<span class="Agda"><a href="1Lab.Path.html#11776" class="Function">transport</a></span>
compute? The answer is: By cases on the path. The structure of the path
<code>P</code> is what guides reduction of
<span class="Agda"><a href="1Lab.Path.html#11776" class="Function">transport</a></span>.
Here are some reductions:</p>
<p>For the natural numbers, and other inductive types without
parameters, transport is always the identity function. This is justified
because there’s nothing to vary in
<span class="Agda"><a href="Agda.Builtin.Nat.html#192" class="Datatype">Nat</a></span>,
so we can just ignore the transport:</p>
<pre class="Agda"><a id="16087" href="1Lab.Path.html#16087" class="Function">_</a> <a id="16089" class="Symbol">:</a> <a id="16091" class="Symbol">{</a><a id="16092" href="1Lab.Path.html#16092" class="Bound">x</a> <a id="16094" class="Symbol">:</a> <a id="16096" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a><a id="16099" class="Symbol">}</a> <a id="16101" class="Symbol">→</a> <a id="16103" href="1Lab.Path.html#11776" data-type="A ≡ B₁ → A → B₁" class="Function">transport</a> <a id="16113" class="Symbol">(λ</a> <a id="16116" href="1Lab.Path.html#16116" class="Bound">i</a> <a id="16118" class="Symbol">→</a> <a id="16120" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a><a id="16123" class="Symbol">)</a> <a id="16125" href="1Lab.Path.html#16092" class="Bound">x</a> <a id="16127" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="16129" href="1Lab.Path.html#16092" class="Bound">x</a>
<a id="16131" class="Symbol">_</a> <a id="16133" class="Symbol">=</a> <a id="16135" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
</pre>
<p>For other type formers, the definition is a bit more involved. Let’s
assume that we have two lines, <code>A</code> and <code>B</code>, to see
how transport reduces in types built out of <code>A</code> and
<code>B</code>:</p>
<pre class="Agda"><a id="16331" class="Keyword">module</a> <a id="16338" href="1Lab.Path.html#16338" class="Module">_</a> <a id="16340" class="Symbol">{</a><a id="16341" href="1Lab.Path.html#16341" class="Bound">A</a> <a id="16343" class="Symbol">:</a> <a id="16345" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a> <a id="16347" class="Symbol">→</a> <a id="16349" href="1Lab.Type.html#391" class="Primitive">Type</a><a id="16353" class="Symbol">}</a> <a id="16355" class="Symbol">{</a><a id="16356" href="1Lab.Path.html#16356" class="Bound">B</a> <a id="16358" class="Symbol">:</a> <a id="16360" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a> <a id="16362" class="Symbol">→</a> <a id="16364" href="1Lab.Type.html#391" class="Primitive">Type</a><a id="16368" class="Symbol">}</a> <a id="16370" class="Keyword">where</a> <a id="16376" class="Keyword">private</a>
</pre>
<p>For non-dependent products, the reduction rule says that
“<span class="Agda"><a href="1Lab.Path.html#11776" class="Function">transport</a></span>
is homomorphic over forming products”:</p>
<pre class="Agda">  <a id="16516" href="1Lab.Path.html#16516" class="Function">_</a> <a id="16518" class="Symbol">:</a> <a id="16520" class="Symbol">{</a><a id="16521" href="1Lab.Path.html#16521" class="Bound">x</a> <a id="16523" class="Symbol">:</a> <a id="16525" href="1Lab.Path.html#16341" class="Bound">A</a> <a id="16527" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a><a id="16529" class="Symbol">}</a> <a id="16531" class="Symbol">{</a><a id="16532" href="1Lab.Path.html#16532" class="Bound">y</a> <a id="16534" class="Symbol">:</a> <a id="16536" href="1Lab.Path.html#16356" class="Bound">B</a> <a id="16538" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a><a id="16540" class="Symbol">}</a>
    <a id="16546" class="Symbol">→</a> <a id="16548" href="1Lab.Path.html#11776" data-type="A ≡ B₁ → A → B₁" class="Function">transport</a> <a id="16558" class="Symbol">(λ</a> <a id="16561" href="1Lab.Path.html#16561" class="Bound">i</a> <a id="16563" class="Symbol">→</a> <a id="16565" href="1Lab.Path.html#16341" class="Bound">A</a> <a id="16567" href="1Lab.Path.html#16561" class="Bound">i</a> <a id="16569" href="1Lab.Type.html#1846" data-type="Type a → Type b → Type (a ⊔ b)" class="Function Operator">×</a> <a id="16571" href="1Lab.Path.html#16356" class="Bound">B</a> <a id="16573" href="1Lab.Path.html#16561" class="Bound">i</a><a id="16574" class="Symbol">)</a> <a id="16576" class="Symbol">(</a><a id="16577" href="1Lab.Path.html#16521" class="Bound">x</a> <a id="16579" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="16581" href="1Lab.Path.html#16532" class="Bound">y</a><a id="16582" class="Symbol">)</a>
    <a id="16588" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="16590" class="Symbol">(</a><a id="16591" href="1Lab.Path.html#11776" data-type="A ≡ B₁ → A → B₁" class="Function">transport</a> <a id="16601" class="Symbol">(λ</a> <a id="16604" href="1Lab.Path.html#16604" class="Bound">i</a> <a id="16606" class="Symbol">→</a> <a id="16608" href="1Lab.Path.html#16341" class="Bound">A</a> <a id="16610" href="1Lab.Path.html#16604" class="Bound">i</a><a id="16611" class="Symbol">)</a> <a id="16613" href="1Lab.Path.html#16521" class="Bound">x</a> <a id="16615" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="16617" href="1Lab.Path.html#11776" data-type="A ≡ B₁ → A → B₁" class="Function">transport</a> <a id="16627" class="Symbol">(λ</a> <a id="16630" href="1Lab.Path.html#16630" class="Bound">i</a> <a id="16632" class="Symbol">→</a> <a id="16634" href="1Lab.Path.html#16356" class="Bound">B</a> <a id="16636" href="1Lab.Path.html#16630" class="Bound">i</a><a id="16637" class="Symbol">)</a> <a id="16639" href="1Lab.Path.html#16532" class="Bound">y</a><a id="16640" class="Symbol">)</a>
  <a id="16644" class="Symbol">_</a> <a id="16646" class="Symbol">=</a> <a id="16648" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
</pre>
<p>For non-dependent functions, we have a similar situation, except one
the transports is <em>backwards</em>. This is because, given an
<code>f : A i0 → B i0</code>, we have to turn an <code>A i1</code> into
an <code>A i0</code> to apply f!</p>
<pre class="Agda">  <a id="16867" href="1Lab.Path.html#16867" class="Function">_</a> <a id="16869" class="Symbol">:</a> <a id="16871" class="Symbol">{</a><a id="16872" href="1Lab.Path.html#16872" class="Bound">f</a> <a id="16874" class="Symbol">:</a> <a id="16876" href="1Lab.Path.html#16341" class="Bound">A</a> <a id="16878" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a> <a id="16881" class="Symbol">→</a> <a id="16883" href="1Lab.Path.html#16356" class="Bound">B</a> <a id="16885" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a><a id="16887" class="Symbol">}</a>
    <a id="16893" class="Symbol">→</a> <a id="16895" href="1Lab.Path.html#11776" data-type="A ≡ B₁ → A → B₁" class="Function">transport</a> <a id="16905" class="Symbol">(λ</a> <a id="16908" href="1Lab.Path.html#16908" class="Bound">i</a> <a id="16910" class="Symbol">→</a> <a id="16912" href="1Lab.Path.html#16341" class="Bound">A</a> <a id="16914" href="1Lab.Path.html#16908" class="Bound">i</a> <a id="16916" class="Symbol">→</a> <a id="16918" href="1Lab.Path.html#16356" class="Bound">B</a> <a id="16920" href="1Lab.Path.html#16908" class="Bound">i</a><a id="16921" class="Symbol">)</a> <a id="16923" href="1Lab.Path.html#16872" class="Bound">f</a>
    <a id="16929" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="16931" class="Symbol">λ</a> <a id="16933" href="1Lab.Path.html#16933" class="Bound">x</a> <a id="16935" class="Symbol">→</a> <a id="16937" href="1Lab.Path.html#11776" data-type="A ≡ B₁ → A → B₁" class="Function">transport</a> <a id="16947" class="Symbol">(λ</a> <a id="16950" href="1Lab.Path.html#16950" class="Bound">i</a> <a id="16952" class="Symbol">→</a> <a id="16954" href="1Lab.Path.html#16356" class="Bound">B</a> <a id="16956" href="1Lab.Path.html#16950" class="Bound">i</a><a id="16957" class="Symbol">)</a> <a id="16959" class="Symbol">(</a><a id="16960" href="1Lab.Path.html#16872" class="Bound">f</a> <a id="16962" class="Symbol">(</a><a id="16963" href="1Lab.Path.html#11776" data-type="A ≡ B₁ → A → B₁" class="Function">transport</a> <a id="16973" class="Symbol">(λ</a> <a id="16976" href="1Lab.Path.html#16976" class="Bound">i</a> <a id="16978" class="Symbol">→</a> <a id="16980" href="1Lab.Path.html#16341" class="Bound">A</a> <a id="16982" class="Symbol">(</a><a id="16983" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="16985" href="1Lab.Path.html#16976" class="Bound">i</a><a id="16986" class="Symbol">))</a> <a id="16989" href="1Lab.Path.html#16933" class="Bound">x</a><a id="16990" class="Symbol">))</a>
  <a id="16995" class="Symbol">_</a> <a id="16997" class="Symbol">=</a> <a id="16999" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>

<a id="17005" class="Keyword">module</a> <a id="17012" href="1Lab.Path.html#17012" class="Module">_</a> <a id="17014" class="Symbol">{</a><a id="17015" href="1Lab.Path.html#17015" class="Bound">A</a> <a id="17017" class="Symbol">:</a> <a id="17019" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a> <a id="17021" class="Symbol">→</a> <a id="17023" href="1Lab.Type.html#391" class="Primitive">Type</a><a id="17027" class="Symbol">}</a> <a id="17029" class="Symbol">{</a><a id="17030" href="1Lab.Path.html#17030" class="Bound">B</a> <a id="17032" class="Symbol">:</a> <a id="17034" class="Symbol">(</a><a id="17035" href="1Lab.Path.html#17035" class="Bound">i</a> <a id="17037" class="Symbol">:</a> <a id="17039" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a><a id="17040" class="Symbol">)</a> <a id="17042" class="Symbol">→</a> <a id="17044" href="1Lab.Path.html#17015" class="Bound">A</a> <a id="17046" href="1Lab.Path.html#17035" class="Bound">i</a> <a id="17048" class="Symbol">→</a> <a id="17050" href="1Lab.Type.html#391" class="Primitive">Type</a><a id="17054" class="Symbol">}</a> <a id="17056" class="Keyword">where</a> <a id="17062" class="Keyword">private</a>
</pre>
<p>In the dependent cases, we have slightly more work to do. Suppose
that we have a line <code>A : I → Type ℓ</code> and a <em>dependent</em>
line <code>B : (i : I) → A i → Type ℓ</code>. Let’s characterise
<span class="Agda"><a href="1Lab.Path.html#11776" class="Function">transport</a></span>
in the lines <code>(λ i → (x : A i) → B i x)</code>. A first attempt
would be to repeat the non-dependent construction: Given an
<code>f : (x : A i0) → B i0 x</code> and an argument
<code>x : A i1</code>, we first get <code>x&#39; : A i0</code> by
transporting along <code>λ i → A (~ i)</code>, compute
<code>f x&#39; : B i0 x</code>, then transport along
<code>(λ i → B i x&#39;)</code> to g- Wait.</p>
<pre class="Agda">  <a id="17591" href="1Lab.Path.html#17591" class="Function">_</a> <a id="17593" class="Symbol">:</a> <a id="17595" class="Symbol">{</a><a id="17596" href="1Lab.Path.html#17596" class="Bound">f</a> <a id="17598" class="Symbol">:</a> <a id="17600" class="Symbol">(</a><a id="17601" href="1Lab.Path.html#17601" class="Bound">x</a> <a id="17603" class="Symbol">:</a> <a id="17605" href="1Lab.Path.html#17015" class="Bound">A</a> <a id="17607" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a><a id="17609" class="Symbol">)</a> <a id="17611" class="Symbol">→</a> <a id="17613" href="1Lab.Path.html#17030" class="Bound">B</a> <a id="17615" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a> <a id="17618" href="1Lab.Path.html#17601" class="Bound">x</a><a id="17619" class="Symbol">}</a>
    <a id="17625" class="Symbol">→</a> <a id="17627" href="1Lab.Path.html#11776" data-type="A ≡ B₁ → A → B₁" class="Function">transport</a> <a id="17637" class="Symbol">(λ</a> <a id="17640" href="1Lab.Path.html#17640" class="Bound">i</a> <a id="17642" class="Symbol">→</a> <a id="17644" class="Symbol">(</a><a id="17645" href="1Lab.Path.html#17645" class="Bound">x</a> <a id="17647" class="Symbol">:</a> <a id="17649" href="1Lab.Path.html#17015" class="Bound">A</a> <a id="17651" href="1Lab.Path.html#17640" class="Bound">i</a><a id="17652" class="Symbol">)</a> <a id="17654" class="Symbol">→</a> <a id="17656" href="1Lab.Path.html#17030" class="Bound">B</a> <a id="17658" href="1Lab.Path.html#17640" class="Bound">i</a> <a id="17660" href="1Lab.Path.html#17645" class="Bound">x</a><a id="17661" class="Symbol">)</a> <a id="17663" href="1Lab.Path.html#17596" class="Bound">f</a>
    <a id="17669" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="17671" class="Symbol">λ</a> <a id="17673" class="Symbol">(</a><a id="17674" href="1Lab.Path.html#17674" class="Bound">x</a> <a id="17676" class="Symbol">:</a> <a id="17678" href="1Lab.Path.html#17015" class="Bound">A</a> <a id="17680" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a><a id="17682" class="Symbol">)</a> <a id="17684" class="Symbol">→</a>
        <a id="17694" class="Keyword">let</a>
          <a id="17708" href="1Lab.Path.html#17708" class="Bound">x&#39;</a> <a id="17711" class="Symbol">:</a> <a id="17713" href="1Lab.Path.html#17015" class="Bound">A</a> <a id="17715" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a>
          <a id="17728" href="1Lab.Path.html#17708" class="Bound">x&#39;</a> <a id="17731" class="Symbol">=</a> <a id="17733" href="1Lab.Path.html#11776" data-type="A ≡ B₁ → A → B₁" class="Function">transport</a> <a id="17743" class="Symbol">(λ</a> <a id="17746" href="1Lab.Path.html#17746" class="Bound">i</a> <a id="17748" class="Symbol">→</a> <a id="17750" href="1Lab.Path.html#17015" class="Bound">A</a> <a id="17752" class="Symbol">(</a><a id="17753" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="17755" href="1Lab.Path.html#17746" class="Bound">i</a><a id="17756" class="Symbol">))</a> <a id="17759" href="1Lab.Path.html#17674" class="Bound">x</a>
</pre>
<p>We can’t “transport along <code>(λ i → B i x&#39;)</code>”, that’s not
even a well-formed type! Indeed, <code>B i : A i → Type</code>, but
<code>x&#39; : A i1</code>. What we need is some way of connecting our
original <code>x</code> and <code>x&#39;</code>, so that we may get a
<code>B i1 x&#39;</code>. This is where
<span class="Agda"><a href="1Lab.Path.html#14006" class="Function">transport-filler</a></span>
comes in:</p>
<pre class="Agda">          <a id="18059" href="1Lab.Path.html#18059" class="Bound">x≡x&#39;</a> <a id="18064" class="Symbol">:</a> <a id="18066" href="Agda.Builtin.Cubical.Path.html#197" data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" class="Postulate">PathP</a> <a id="18072" class="Symbol">(λ</a> <a id="18075" href="1Lab.Path.html#18075" class="Bound">i</a> <a id="18077" class="Symbol">→</a> <a id="18079" href="1Lab.Path.html#17015" class="Bound">A</a> <a id="18081" class="Symbol">(</a><a id="18082" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="18084" href="1Lab.Path.html#18075" class="Bound">i</a><a id="18085" class="Symbol">))</a> <a id="18088" href="1Lab.Path.html#17674" class="Bound">x</a> <a id="18090" href="1Lab.Path.html#17708" class="Bound">x&#39;</a>
          <a id="18103" href="1Lab.Path.html#18059" class="Bound">x≡x&#39;</a> <a id="18108" class="Symbol">=</a> <a id="18110" href="1Lab.Path.html#14006" data-type="(p : A ≡ B₁) (x : A) → PathP (λ i → p i) x (transport p x)" class="Function">transport-filler</a> <a id="18127" class="Symbol">(λ</a> <a id="18130" href="1Lab.Path.html#18130" class="Bound">i</a> <a id="18132" class="Symbol">→</a> <a id="18134" href="1Lab.Path.html#17015" class="Bound">A</a> <a id="18136" class="Symbol">(</a><a id="18137" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="18139" href="1Lab.Path.html#18130" class="Bound">i</a><a id="18140" class="Symbol">))</a> <a id="18143" href="1Lab.Path.html#17674" class="Bound">x</a>
</pre>
<p>By using <code>λ i → B i (x≡x&#39; (~ i))</code> as our path, we a) get
something type-correct, and b) get something with the right endpoints.
<code>(λ i → B i (x≡x&#39; (~ i)))</code> connects <code>B i0 x</code> and
<code>B i1 x&#39;</code>, which is what we wanted.</p>
<pre class="Agda">          <a id="18382" href="1Lab.Path.html#18382" class="Bound">fx&#39;</a> <a id="18386" class="Symbol">:</a> <a id="18388" href="1Lab.Path.html#17030" class="Bound">B</a> <a id="18390" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a> <a id="18393" href="1Lab.Path.html#17708" class="Bound">x&#39;</a>
          <a id="18406" href="1Lab.Path.html#18382" class="Bound">fx&#39;</a> <a id="18410" class="Symbol">=</a> <a id="18412" href="1Lab.Path.html#17596" class="Bound">f</a> <a id="18414" href="1Lab.Path.html#17708" class="Bound">x&#39;</a>
        <a id="18425" class="Keyword">in</a> <a id="18428" href="1Lab.Path.html#11776" data-type="A ≡ B₁ → A → B₁" class="Function">transport</a> <a id="18438" class="Symbol">(λ</a> <a id="18441" href="1Lab.Path.html#18441" class="Bound">i</a> <a id="18443" class="Symbol">→</a> <a id="18445" href="1Lab.Path.html#17030" class="Bound">B</a> <a id="18447" href="1Lab.Path.html#18441" class="Bound">i</a> <a id="18449" class="Symbol">(</a><a id="18450" href="1Lab.Path.html#18059" class="Bound">x≡x&#39;</a> <a id="18455" class="Symbol">(</a><a id="18456" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="18458" href="1Lab.Path.html#18441" class="Bound">i</a><a id="18459" class="Symbol">)))</a> <a id="18463" href="1Lab.Path.html#18382" class="Bound">fx&#39;</a>
  <a id="18469" class="Symbol">_</a> <a id="18471" class="Symbol">=</a> <a id="18473" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
</pre>
<p>The case for dependent products (i.e. general
<span class="Agda"><a href="1Lab.Type.html#1573" class="Function">Σ</a></span>
types) is analogous, but without any inverse transports.</p>
<h2 id="path-induction"><a href="#path-induction" class="header-link">Path
Induction<span class="header-link-emoji">🔗</span></a></h2>
<p>The path induction principle, also known as “axiom J”, essentially
breaks down as the following two statements:</p>
<ul>
<li><p>Identicals are indiscernible
(<span class="Agda"><a href="1Lab.Path.html#11776" class="Function">transport</a></span>)</p></li>
<li><p>Singletons are contractible. The type <code>Singleton A x</code>
is the “subtype of A of the elements identical to x”:</p></li>
</ul>
<pre class="Agda"><a id="Singleton"></a><a id="18902" href="1Lab.Path.html#18902" data-type="A → Type ℓ" class="Function">Singleton</a> <a id="18912" class="Symbol">:</a> <a id="18914" class="Symbol">∀</a> <a id="18916" class="Symbol">{</a><a id="18917" href="1Lab.Path.html#18917" class="Bound">ℓ</a><a id="18918" class="Symbol">}</a> <a id="18920" class="Symbol">{</a><a id="18921" href="1Lab.Path.html#18921" class="Bound">A</a> <a id="18923" class="Symbol">:</a> <a id="18925" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="18930" href="1Lab.Path.html#18917" class="Bound">ℓ</a><a id="18931" class="Symbol">}</a> <a id="18933" class="Symbol">→</a> <a id="18935" href="1Lab.Path.html#18921" class="Bound">A</a> <a id="18937" class="Symbol">→</a> <a id="18939" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="18944" class="Symbol">_</a>
<a id="18946" href="1Lab.Path.html#18902" data-type="A → Type ℓ" class="Function">Singleton</a> <a id="18956" href="1Lab.Path.html#18956" class="Bound">x</a> <a id="18958" class="Symbol">=</a> <a id="18960" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">Σ[</a> <a id="18963" href="1Lab.Path.html#18963" class="Bound">y</a> <a id="18965" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">∈</a> <a id="18967" class="Symbol">_</a> <a id="18969" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">]</a> <a id="18971" class="Symbol">(</a><a id="18972" href="1Lab.Path.html#18956" class="Bound">x</a> <a id="18974" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="18976" href="1Lab.Path.html#18963" class="Bound">y</a><a id="18977" class="Symbol">)</a>
</pre>
<p>There is a canonical inhabitant of <code>Singleton x</code>, namely
<code>(x, refl)</code>. To say that <code class="sourceCode agda" data-ident="singleton">singletons</code> are contractible is to say that
every other inhabitant has a path to <code>(x, refl)</code>:</p>
<pre class="Agda"><a id="Singleton-is-contr"></a><a id="19193" href="1Lab.Path.html#19193" data-type="(y : Singleton x) → Path (Singleton x) (x , refl) y" class="Function">Singleton-is-contr</a> <a id="19212" class="Symbol">:</a> <a id="19214" class="Symbol">∀</a> <a id="19216" class="Symbol">{</a><a id="19217" href="1Lab.Path.html#19217" class="Bound">ℓ</a><a id="19218" class="Symbol">}</a> <a id="19220" class="Symbol">{</a><a id="19221" href="1Lab.Path.html#19221" class="Bound">A</a> <a id="19223" class="Symbol">:</a> <a id="19225" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="19230" href="1Lab.Path.html#19217" class="Bound">ℓ</a><a id="19231" class="Symbol">}</a> <a id="19233" class="Symbol">{</a><a id="19234" href="1Lab.Path.html#19234" class="Bound">x</a> <a id="19236" class="Symbol">:</a> <a id="19238" href="1Lab.Path.html#19221" class="Bound">A</a><a id="19239" class="Symbol">}</a> <a id="19241" class="Symbol">(</a><a id="19242" href="1Lab.Path.html#19242" class="Bound">y</a> <a id="19244" class="Symbol">:</a> <a id="19246" href="1Lab.Path.html#18902" data-type="A → Type ℓ" class="Function">Singleton</a> <a id="19256" href="1Lab.Path.html#19234" class="Bound">x</a><a id="19257" class="Symbol">)</a>
                   <a id="19278" class="Symbol">→</a> <a id="19280" href="1Lab.Path.html#2466" data-type="(A : Type ℓ) → A → A → Type ℓ" class="Function">Path</a> <a id="19285" class="Symbol">(</a><a id="19286" href="1Lab.Path.html#18902" data-type="A → Type ℓ" class="Function">Singleton</a> <a id="19296" href="1Lab.Path.html#19234" class="Bound">x</a><a id="19297" class="Symbol">)</a> <a id="19299" class="Symbol">(</a><a id="19300" href="1Lab.Path.html#19234" class="Bound">x</a> <a id="19302" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="19304" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a><a id="19308" class="Symbol">)</a> <a id="19310" href="1Lab.Path.html#19242" class="Bound">y</a>
<a id="19312" href="1Lab.Path.html#19193" data-type="(y : Singleton x) → Path (Singleton x) (x , refl) y" class="Function">Singleton-is-contr</a> <a id="19331" class="Symbol">{</a><a id="19332" class="Argument">x</a> <a id="19334" class="Symbol">=</a> <a id="19336" href="1Lab.Path.html#19336" class="Bound">x</a><a id="19337" class="Symbol">}</a> <a id="19339" class="Symbol">(</a><a id="19340" href="1Lab.Path.html#19340" class="Bound">y</a> <a id="19342" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="19344" href="1Lab.Path.html#19344" class="Bound">path</a><a id="19348" class="Symbol">)</a> <a id="19350" href="1Lab.Path.html#19350" class="Bound">i</a> <a id="19352" class="Symbol">=</a> <a id="19354" href="1Lab.Path.html#19344" class="Bound">path</a> <a id="19359" href="1Lab.Path.html#19350" class="Bound">i</a> <a id="19361" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="19363" href="1Lab.Path.html#19380" data-type="(y : A) (path₁ : x ≡ y) (i : I) → Square refl refl path₁ path₁" class="Function">square</a> <a id="19370" href="1Lab.Path.html#19350" class="Bound">i</a> <a id="19372" class="Keyword">where</a>
  <a id="19380" href="1Lab.Path.html#19380" data-type="(y : A) (path₁ : x ≡ y) (i : I) → Square refl refl path₁ path₁" class="Function">square</a> <a id="19387" class="Symbol">:</a> <a id="19389" href="1Lab.Path.html#9409" data-type="a00 ≡ a01 → a00 ≡ a10 → a01 ≡ a11 → a10 ≡ a11 → Type ℓ" class="Function">Square</a> <a id="19396" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="19401" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="19406" href="1Lab.Path.html#19344" class="Bound">path</a> <a id="19411" href="1Lab.Path.html#19344" class="Bound">path</a>
  <a id="19418" href="1Lab.Path.html#19380" data-type="(y : A) (path₁ : x ≡ y) (i : I) → Square refl refl path₁ path₁" class="Function">square</a> <a id="19425" href="1Lab.Path.html#19425" class="Bound">i</a> <a id="19427" href="1Lab.Path.html#19427" class="Bound">j</a> <a id="19429" class="Symbol">=</a> <a id="19431" href="1Lab.Path.html#19344" class="Bound">path</a> <a id="19436" class="Symbol">(</a><a id="19437" href="1Lab.Path.html#19425" class="Bound">i</a> <a id="19439" href="1Lab.Path.html#2191" class="Primitive Operator">∧</a> <a id="19441" href="1Lab.Path.html#19427" class="Bound">j</a><a id="19442" class="Symbol">)</a>
</pre>
<p>Thus, the definition of
<span class="Agda"><a href="1Lab.Path.html#19544" class="Function">J</a></span>:
<span class="Agda"><a href="1Lab.Path.html#11776" class="Function">transport</a></span>
+
<span class="Agda"><a href="1Lab.Path.html#19193" class="Function">Singleton-is-contr</a></span>.</p>
<pre class="Agda"><a id="J"></a><a id="19544" href="1Lab.Path.html#19544" data-type="(P : (y : A) → x ≡ y → Type ℓ₂) → P x refl → (p : x ≡ y) → P y p" class="Function">J</a> <a id="19546" class="Symbol">:</a> <a id="19548" class="Symbol">∀</a> <a id="19550" class="Symbol">{</a><a id="19551" href="1Lab.Path.html#19551" class="Bound">ℓ₁</a> <a id="19554" href="1Lab.Path.html#19554" class="Bound">ℓ₂</a><a id="19556" class="Symbol">}</a> <a id="19558" class="Symbol">{</a><a id="19559" href="1Lab.Path.html#19559" class="Bound">A</a> <a id="19561" class="Symbol">:</a> <a id="19563" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="19568" href="1Lab.Path.html#19551" class="Bound">ℓ₁</a><a id="19570" class="Symbol">}</a> <a id="19572" class="Symbol">{</a><a id="19573" href="1Lab.Path.html#19573" class="Bound">x</a> <a id="19575" class="Symbol">:</a> <a id="19577" href="1Lab.Path.html#19559" class="Bound">A</a><a id="19578" class="Symbol">}</a>
    <a id="19584" class="Symbol">(</a><a id="19585" href="1Lab.Path.html#19585" class="Bound">P</a> <a id="19587" class="Symbol">:</a> <a id="19589" class="Symbol">(</a><a id="19590" href="1Lab.Path.html#19590" class="Bound">y</a> <a id="19592" class="Symbol">:</a> <a id="19594" href="1Lab.Path.html#19559" class="Bound">A</a><a id="19595" class="Symbol">)</a> <a id="19597" class="Symbol">→</a> <a id="19599" href="1Lab.Path.html#19573" class="Bound">x</a> <a id="19601" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="19603" href="1Lab.Path.html#19590" class="Bound">y</a> <a id="19605" class="Symbol">→</a> <a id="19607" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="19612" href="1Lab.Path.html#19554" class="Bound">ℓ₂</a><a id="19614" class="Symbol">)</a>
  <a id="19618" class="Symbol">→</a> <a id="19620" href="1Lab.Path.html#19585" class="Bound">P</a> <a id="19622" href="1Lab.Path.html#19573" class="Bound">x</a> <a id="19624" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
  <a id="19631" class="Symbol">→</a> <a id="19633" class="Symbol">{</a><a id="19634" href="1Lab.Path.html#19634" class="Bound">y</a> <a id="19636" class="Symbol">:</a> <a id="19638" href="1Lab.Path.html#19559" class="Bound">A</a><a id="19639" class="Symbol">}</a> <a id="19641" class="Symbol">(</a><a id="19642" href="1Lab.Path.html#19642" class="Bound">p</a> <a id="19644" class="Symbol">:</a> <a id="19646" href="1Lab.Path.html#19573" class="Bound">x</a> <a id="19648" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="19650" href="1Lab.Path.html#19634" class="Bound">y</a><a id="19651" class="Symbol">)</a>
  <a id="19655" class="Symbol">→</a> <a id="19657" href="1Lab.Path.html#19585" class="Bound">P</a> <a id="19659" href="1Lab.Path.html#19634" class="Bound">y</a> <a id="19661" href="1Lab.Path.html#19642" class="Bound">p</a>
<a id="19663" href="1Lab.Path.html#19544" data-type="(P : (y : A) → x ≡ y → Type ℓ₂) → P x refl → (p : x ≡ y) → P y p" class="Function">J</a> <a id="19665" class="Symbol">{</a><a id="19666" class="Argument">x</a> <a id="19668" class="Symbol">=</a> <a id="19670" href="1Lab.Path.html#19670" class="Bound">x</a><a id="19671" class="Symbol">}</a> <a id="19673" href="1Lab.Path.html#19673" class="Bound">P</a> <a id="19675" href="1Lab.Path.html#19675" class="Bound">prefl</a> <a id="19681" class="Symbol">{</a><a id="19682" href="1Lab.Path.html#19682" class="Bound">y</a><a id="19683" class="Symbol">}</a> <a id="19685" href="1Lab.Path.html#19685" class="Bound">p</a> <a id="19687" class="Symbol">=</a> <a id="19689" href="1Lab.Path.html#11776" data-type="A ≡ B₁ → A → B₁" class="Function">transport</a> <a id="19699" class="Symbol">(λ</a> <a id="19702" href="1Lab.Path.html#19702" class="Bound">i</a> <a id="19704" class="Symbol">→</a> <a id="19706" href="1Lab.Path.html#19673" class="Bound">P</a> <a id="19708" class="Symbol">(</a><a id="19709" href="1Lab.Path.html#19751" data-type="(P : (y : A) → x ≡ y → Type ℓ₂) (prefl : P x refl) (p : x ≡ y) →
(x , refl) ≡ (y , p)" class="Function">path</a> <a id="19714" href="1Lab.Path.html#19702" class="Bound">i</a> <a id="19716" class="Symbol">.</a><a id="19717" href="Agda.Builtin.Sigma.html#252" data-type="∑ A B₁ → A" class="Field">fst</a><a id="19720" class="Symbol">)</a> <a id="19722" class="Symbol">(</a><a id="19723" href="1Lab.Path.html#19751" data-type="(P : (y : A) → x ≡ y → Type ℓ₂) (prefl : P x refl) (p : x ≡ y) →
(x , refl) ≡ (y , p)" class="Function">path</a> <a id="19728" href="1Lab.Path.html#19702" class="Bound">i</a> <a id="19730" class="Symbol">.</a><a id="19731" href="Agda.Builtin.Sigma.html#264" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a><a id="19734" class="Symbol">))</a> <a id="19737" href="1Lab.Path.html#19675" class="Bound">prefl</a> <a id="19743" class="Keyword">where</a>
  <a id="19751" href="1Lab.Path.html#19751" data-type="(P : (y : A) → x ≡ y → Type ℓ₂) (prefl : P x refl) (p : x ≡ y) →
(x , refl) ≡ (y , p)" class="Function">path</a> <a id="19756" class="Symbol">:</a> <a id="19758" class="Symbol">(</a><a id="19759" href="1Lab.Path.html#19670" class="Bound">x</a> <a id="19761" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="19763" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a><a id="19767" class="Symbol">)</a> <a id="19769" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="19771" class="Symbol">(</a><a id="19772" href="1Lab.Path.html#19682" class="Bound">y</a> <a id="19774" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="19776" href="1Lab.Path.html#19685" class="Bound">p</a><a id="19777" class="Symbol">)</a>
  <a id="19781" href="1Lab.Path.html#19751" data-type="(P : (y : A) → x ≡ y → Type ℓ₂) (prefl : P x refl) (p : x ≡ y) →
(x , refl) ≡ (y , p)" class="Function">path</a> <a id="19786" class="Symbol">=</a> <a id="19788" href="1Lab.Path.html#19193" data-type="(y : Singleton x) → Path (Singleton x) (x , refl) y" class="Function">Singleton-is-contr</a> <a id="19807" class="Symbol">(</a><a id="19808" href="1Lab.Path.html#19682" class="Bound">y</a> <a id="19810" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="19812" href="1Lab.Path.html#19685" class="Bound">p</a><a id="19813" class="Symbol">)</a>
</pre>
<p>This eliminator <em>doesn’t</em> definitionally compute to
<code>prefl</code> when <code>p</code> is <code>refl</code>, again since
<code>transport (λ i → A)</code> isn’t definitionally the identity.
However, since it <em>is</em> a transport, we can use the
<span class="Agda"><a href="1Lab.Path.html#14006" class="Function">transport-filler</a></span>
to get a path expressing the computation rule.</p>
<pre class="Agda"><a id="J-refl"></a><a id="20103" href="1Lab.Path.html#20103" data-type="(P : (y : A) → x ≡ y → Type ℓ₂) (pxr : P x refl) →
J P pxr refl ≡ pxr" class="Function">J-refl</a> <a id="20110" class="Symbol">:</a> <a id="20112" class="Symbol">∀</a> <a id="20114" class="Symbol">{</a><a id="20115" href="1Lab.Path.html#20115" class="Bound">ℓ₁</a> <a id="20118" href="1Lab.Path.html#20118" class="Bound">ℓ₂</a><a id="20120" class="Symbol">}</a> <a id="20122" class="Symbol">{</a><a id="20123" href="1Lab.Path.html#20123" class="Bound">A</a> <a id="20125" class="Symbol">:</a> <a id="20127" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="20132" href="1Lab.Path.html#20115" class="Bound">ℓ₁</a><a id="20134" class="Symbol">}</a> <a id="20136" class="Symbol">{</a><a id="20137" href="1Lab.Path.html#20137" class="Bound">x</a> <a id="20139" class="Symbol">:</a> <a id="20141" href="1Lab.Path.html#20123" class="Bound">A</a><a id="20142" class="Symbol">}</a>
           <a id="20155" class="Symbol">(</a><a id="20156" href="1Lab.Path.html#20156" class="Bound">P</a> <a id="20158" class="Symbol">:</a> <a id="20160" class="Symbol">(</a><a id="20161" href="1Lab.Path.html#20161" class="Bound">y</a> <a id="20163" class="Symbol">:</a> <a id="20165" href="1Lab.Path.html#20123" class="Bound">A</a><a id="20166" class="Symbol">)</a> <a id="20168" class="Symbol">→</a> <a id="20170" href="1Lab.Path.html#20137" class="Bound">x</a> <a id="20172" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="20174" href="1Lab.Path.html#20161" class="Bound">y</a> <a id="20176" class="Symbol">→</a> <a id="20178" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="20183" href="1Lab.Path.html#20118" class="Bound">ℓ₂</a><a id="20185" class="Symbol">)</a>
       <a id="20194" class="Symbol">→</a> <a id="20196" class="Symbol">(</a><a id="20197" href="1Lab.Path.html#20197" class="Bound">pxr</a> <a id="20201" class="Symbol">:</a> <a id="20203" href="1Lab.Path.html#20156" class="Bound">P</a> <a id="20205" href="1Lab.Path.html#20137" class="Bound">x</a> <a id="20207" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a><a id="20211" class="Symbol">)</a>
       <a id="20220" class="Symbol">→</a> <a id="20222" href="1Lab.Path.html#19544" data-type="(P : (y : A) → x ≡ y → Type ℓ₂) → P x refl → (p : x ≡ y) → P y p" class="Function">J</a> <a id="20224" href="1Lab.Path.html#20156" class="Bound">P</a> <a id="20226" href="1Lab.Path.html#20197" class="Bound">pxr</a> <a id="20230" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="20235" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="20237" href="1Lab.Path.html#20197" class="Bound">pxr</a>
<a id="20241" href="1Lab.Path.html#20103" data-type="(P : (y : A) → x ≡ y → Type ℓ₂) (pxr : P x refl) →
J P pxr refl ≡ pxr" class="Function">J-refl</a> <a id="20248" class="Symbol">{</a><a id="20249" class="Argument">x</a> <a id="20251" class="Symbol">=</a> <a id="20253" href="1Lab.Path.html#20253" class="Bound">x</a><a id="20254" class="Symbol">}</a> <a id="20256" href="1Lab.Path.html#20256" class="Bound">P</a> <a id="20258" href="1Lab.Path.html#20258" class="Bound">prefl</a> <a id="20264" href="1Lab.Path.html#20264" class="Bound">i</a> <a id="20266" class="Symbol">=</a> <a id="20268" href="1Lab.Path.html#14006" data-type="(p : A ≡ B₁) (x : A) → PathP (λ i → p i) x (transport p x)" class="Function">transport-filler</a> <a id="20285" class="Symbol">(λ</a> <a id="20288" href="1Lab.Path.html#20288" class="Bound">i</a> <a id="20290" class="Symbol">→</a> <a id="20292" href="1Lab.Path.html#20256" class="Bound">P</a> <a id="20294" class="Symbol">_</a> <a id="20296" class="Symbol">(λ</a> <a id="20299" href="1Lab.Path.html#20299" class="Bound">j</a> <a id="20301" class="Symbol">→</a> <a id="20303" href="1Lab.Path.html#20253" class="Bound">x</a><a id="20304" class="Symbol">))</a> <a id="20307" href="1Lab.Path.html#20258" class="Bound">prefl</a> <a id="20313" class="Symbol">(</a><a id="20314" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="20316" href="1Lab.Path.html#20264" class="Bound">i</a><a id="20317" class="Symbol">)</a>
</pre>
<!--
<pre class="Agda"><a id="inspect"></a><a id="20337" href="1Lab.Path.html#20337" data-type="(x : A) → Singleton x" class="Function">inspect</a> <a id="20345" class="Symbol">:</a> <a id="20347" class="Symbol">∀</a> <a id="20349" class="Symbol">{</a><a id="20350" href="1Lab.Path.html#20350" class="Bound">a</a><a id="20351" class="Symbol">}</a> <a id="20353" class="Symbol">{</a><a id="20354" href="1Lab.Path.html#20354" class="Bound">A</a> <a id="20356" class="Symbol">:</a> <a id="20358" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="20363" href="1Lab.Path.html#20350" class="Bound">a</a><a id="20364" class="Symbol">}</a> <a id="20366" class="Symbol">(</a><a id="20367" href="1Lab.Path.html#20367" class="Bound">x</a> <a id="20369" class="Symbol">:</a> <a id="20371" href="1Lab.Path.html#20354" class="Bound">A</a><a id="20372" class="Symbol">)</a> <a id="20374" class="Symbol">→</a> <a id="20376" href="1Lab.Path.html#18902" data-type="A → Type ℓ" class="Function">Singleton</a> <a id="20386" href="1Lab.Path.html#20367" class="Bound">x</a>
<a id="20388" href="1Lab.Path.html#20337" data-type="(x : A) → Singleton x" class="Function">inspect</a> <a id="20396" href="1Lab.Path.html#20396" class="Bound">x</a> <a id="20398" class="Symbol">=</a> <a id="20400" href="1Lab.Path.html#20396" class="Bound">x</a> <a id="20402" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="20404" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
</pre>-->
<h2 id="functorial-action"><a href="#functorial-action" class="header-link">Functorial
Action<span class="header-link-emoji">🔗</span></a></h2>
<p>In HoTT, every function behaves like a funct<strong>or</strong>, in
that it has an action on objects (the actual computational content of
the function) and an action on <em>morphisms</em> — how that function
acts on paths. Reading paths as identity, this is a proof that functions
take identical inputs to identical outputs.</p>
<pre class="Agda"><a id="ap"></a><a id="20756" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="20759" class="Symbol">:</a> <a id="20761" class="Symbol">∀</a> <a id="20763" class="Symbol">{</a><a id="20764" href="1Lab.Path.html#20764" class="Bound">a</a> <a id="20766" href="1Lab.Path.html#20766" class="Bound">b</a><a id="20767" class="Symbol">}</a> <a id="20769" class="Symbol">{</a><a id="20770" href="1Lab.Path.html#20770" class="Bound">A</a> <a id="20772" class="Symbol">:</a> <a id="20774" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="20779" href="1Lab.Path.html#20764" class="Bound">a</a><a id="20780" class="Symbol">}</a> <a id="20782" class="Symbol">{</a><a id="20783" href="1Lab.Path.html#20783" class="Bound">B</a> <a id="20785" class="Symbol">:</a> <a id="20787" href="1Lab.Path.html#20770" class="Bound">A</a> <a id="20789" class="Symbol">→</a> <a id="20791" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="20796" href="1Lab.Path.html#20766" class="Bound">b</a><a id="20797" class="Symbol">}</a> <a id="20799" class="Symbol">(</a><a id="20800" href="1Lab.Path.html#20800" class="Bound">f</a> <a id="20802" class="Symbol">:</a> <a id="20804" class="Symbol">(</a><a id="20805" href="1Lab.Path.html#20805" class="Bound">x</a> <a id="20807" class="Symbol">:</a> <a id="20809" href="1Lab.Path.html#20770" class="Bound">A</a><a id="20810" class="Symbol">)</a> <a id="20812" class="Symbol">→</a> <a id="20814" href="1Lab.Path.html#20783" class="Bound">B</a> <a id="20816" href="1Lab.Path.html#20805" class="Bound">x</a><a id="20817" class="Symbol">)</a> <a id="20819" class="Symbol">{</a><a id="20820" href="1Lab.Path.html#20820" class="Bound">x</a> <a id="20822" href="1Lab.Path.html#20822" class="Bound">y</a> <a id="20824" class="Symbol">:</a> <a id="20826" href="1Lab.Path.html#20770" class="Bound">A</a><a id="20827" class="Symbol">}</a>
   <a id="20832" class="Symbol">→</a> <a id="20834" class="Symbol">(</a><a id="20835" href="1Lab.Path.html#20835" class="Bound">p</a> <a id="20837" class="Symbol">:</a> <a id="20839" href="1Lab.Path.html#20820" class="Bound">x</a> <a id="20841" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="20843" href="1Lab.Path.html#20822" class="Bound">y</a><a id="20844" class="Symbol">)</a> <a id="20846" class="Symbol">→</a> <a id="20848" href="Agda.Builtin.Cubical.Path.html#197" data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" class="Postulate">PathP</a> <a id="20854" class="Symbol">(λ</a> <a id="20857" href="1Lab.Path.html#20857" class="Bound">i</a> <a id="20859" class="Symbol">→</a> <a id="20861" href="1Lab.Path.html#20783" class="Bound">B</a> <a id="20863" class="Symbol">(</a><a id="20864" href="1Lab.Path.html#20835" class="Bound">p</a> <a id="20866" href="1Lab.Path.html#20857" class="Bound">i</a><a id="20867" class="Symbol">))</a> <a id="20870" class="Symbol">(</a><a id="20871" href="1Lab.Path.html#20800" class="Bound">f</a> <a id="20873" href="1Lab.Path.html#20820" class="Bound">x</a><a id="20874" class="Symbol">)</a> <a id="20876" class="Symbol">(</a><a id="20877" href="1Lab.Path.html#20800" class="Bound">f</a> <a id="20879" href="1Lab.Path.html#20822" class="Bound">y</a><a id="20880" class="Symbol">)</a>
<a id="20882" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="20885" href="1Lab.Path.html#20885" class="Bound">f</a> <a id="20887" href="1Lab.Path.html#20887" class="Bound">p</a> <a id="20889" href="1Lab.Path.html#20889" class="Bound">i</a> <a id="20891" class="Symbol">=</a> <a id="20893" href="1Lab.Path.html#20885" class="Bound">f</a> <a id="20895" class="Symbol">(</a><a id="20896" href="1Lab.Path.html#20887" class="Bound">p</a> <a id="20898" href="1Lab.Path.html#20889" class="Bound">i</a><a id="20899" class="Symbol">)</a>
</pre>
<p>The following function expresses the same thing as
<span class="Agda"><a href="1Lab.Path.html#20756" class="Function">ap</a></span>,
but for binary functions. The type is huge! That’s because it applies to
the most general type of 2-argument dependent function possible:
<code>(x : A) (y : B x) → C x y</code>. Even then, the proof is
beautifully short:</p>
<pre class="Agda"><a id="ap₂"></a><a id="21189" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="21193" class="Symbol">:</a> <a id="21195" class="Symbol">∀</a> <a id="21197" class="Symbol">{</a><a id="21198" href="1Lab.Path.html#21198" class="Bound">a</a> <a id="21200" href="1Lab.Path.html#21200" class="Bound">b</a> <a id="21202" href="1Lab.Path.html#21202" class="Bound">c</a><a id="21203" class="Symbol">}</a> <a id="21205" class="Symbol">{</a><a id="21206" href="1Lab.Path.html#21206" class="Bound">A</a> <a id="21208" class="Symbol">:</a> <a id="21210" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="21215" href="1Lab.Path.html#21198" class="Bound">a</a><a id="21216" class="Symbol">}</a> <a id="21218" class="Symbol">{</a><a id="21219" href="1Lab.Path.html#21219" class="Bound">B</a> <a id="21221" class="Symbol">:</a> <a id="21223" href="1Lab.Path.html#21206" class="Bound">A</a> <a id="21225" class="Symbol">→</a> <a id="21227" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="21232" href="1Lab.Path.html#21200" class="Bound">b</a><a id="21233" class="Symbol">}</a> <a id="21235" class="Symbol">{</a><a id="21236" href="1Lab.Path.html#21236" class="Bound">C</a> <a id="21238" class="Symbol">:</a> <a id="21240" class="Symbol">(</a><a id="21241" href="1Lab.Path.html#21241" class="Bound">x</a> <a id="21243" class="Symbol">:</a> <a id="21245" href="1Lab.Path.html#21206" class="Bound">A</a><a id="21246" class="Symbol">)</a> <a id="21248" class="Symbol">→</a> <a id="21250" href="1Lab.Path.html#21219" class="Bound">B</a> <a id="21252" href="1Lab.Path.html#21241" class="Bound">x</a> <a id="21254" class="Symbol">→</a> <a id="21256" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="21261" href="1Lab.Path.html#21202" class="Bound">c</a><a id="21262" class="Symbol">}</a>
      <a id="21270" class="Symbol">(</a><a id="21271" href="1Lab.Path.html#21271" class="Bound">f</a> <a id="21273" class="Symbol">:</a> <a id="21275" class="Symbol">(</a><a id="21276" href="1Lab.Path.html#21276" class="Bound">x</a> <a id="21278" class="Symbol">:</a> <a id="21280" href="1Lab.Path.html#21206" class="Bound">A</a><a id="21281" class="Symbol">)</a> <a id="21283" class="Symbol">(</a><a id="21284" href="1Lab.Path.html#21284" class="Bound">y</a> <a id="21286" class="Symbol">:</a> <a id="21288" href="1Lab.Path.html#21219" class="Bound">B</a> <a id="21290" href="1Lab.Path.html#21276" class="Bound">x</a><a id="21291" class="Symbol">)</a> <a id="21293" class="Symbol">→</a> <a id="21295" href="1Lab.Path.html#21236" class="Bound">C</a> <a id="21297" href="1Lab.Path.html#21276" class="Bound">x</a> <a id="21299" href="1Lab.Path.html#21284" class="Bound">y</a><a id="21300" class="Symbol">)</a>
      <a id="21308" class="Symbol">{</a><a id="21309" href="1Lab.Path.html#21309" class="Bound">x</a> <a id="21311" href="1Lab.Path.html#21311" class="Bound">y</a> <a id="21313" class="Symbol">:</a> <a id="21315" href="1Lab.Path.html#21206" class="Bound">A</a><a id="21316" class="Symbol">}</a> <a id="21318" class="Symbol">{</a><a id="21319" href="1Lab.Path.html#21319" class="Bound">α</a> <a id="21321" class="Symbol">:</a> <a id="21323" href="1Lab.Path.html#21219" class="Bound">B</a> <a id="21325" href="1Lab.Path.html#21309" class="Bound">x</a><a id="21326" class="Symbol">}</a> <a id="21328" class="Symbol">{</a><a id="21329" href="1Lab.Path.html#21329" class="Bound">β</a> <a id="21331" class="Symbol">:</a> <a id="21333" href="1Lab.Path.html#21219" class="Bound">B</a> <a id="21335" href="1Lab.Path.html#21311" class="Bound">y</a><a id="21336" class="Symbol">}</a>
    <a id="21342" class="Symbol">→</a> <a id="21344" class="Symbol">(</a><a id="21345" href="1Lab.Path.html#21345" class="Bound">p</a> <a id="21347" class="Symbol">:</a> <a id="21349" href="1Lab.Path.html#21309" class="Bound">x</a> <a id="21351" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="21353" href="1Lab.Path.html#21311" class="Bound">y</a><a id="21354" class="Symbol">)</a>
    <a id="21360" class="Symbol">→</a> <a id="21362" class="Symbol">(</a><a id="21363" href="1Lab.Path.html#21363" class="Bound">q</a> <a id="21365" class="Symbol">:</a> <a id="21367" href="Agda.Builtin.Cubical.Path.html#197" data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" class="Postulate">PathP</a> <a id="21373" class="Symbol">(λ</a> <a id="21376" href="1Lab.Path.html#21376" class="Bound">i</a> <a id="21378" class="Symbol">→</a> <a id="21380" href="1Lab.Path.html#21219" class="Bound">B</a> <a id="21382" class="Symbol">(</a><a id="21383" href="1Lab.Path.html#21345" class="Bound">p</a> <a id="21385" href="1Lab.Path.html#21376" class="Bound">i</a><a id="21386" class="Symbol">))</a> <a id="21389" href="1Lab.Path.html#21319" class="Bound">α</a> <a id="21391" href="1Lab.Path.html#21329" class="Bound">β</a><a id="21392" class="Symbol">)</a>
    <a id="21398" class="Symbol">→</a> <a id="21400" href="Agda.Builtin.Cubical.Path.html#197" data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" class="Postulate">PathP</a> <a id="21406" class="Symbol">(λ</a> <a id="21409" href="1Lab.Path.html#21409" class="Bound">i</a> <a id="21411" class="Symbol">→</a> <a id="21413" href="1Lab.Path.html#21236" class="Bound">C</a> <a id="21415" class="Symbol">(</a><a id="21416" href="1Lab.Path.html#21345" class="Bound">p</a> <a id="21418" href="1Lab.Path.html#21409" class="Bound">i</a><a id="21419" class="Symbol">)</a> <a id="21421" class="Symbol">(</a><a id="21422" href="1Lab.Path.html#21363" class="Bound">q</a> <a id="21424" href="1Lab.Path.html#21409" class="Bound">i</a><a id="21425" class="Symbol">))</a>
            <a id="21440" class="Symbol">(</a><a id="21441" href="1Lab.Path.html#21271" class="Bound">f</a> <a id="21443" href="1Lab.Path.html#21309" class="Bound">x</a> <a id="21445" href="1Lab.Path.html#21319" class="Bound">α</a><a id="21446" class="Symbol">)</a>
            <a id="21460" class="Symbol">(</a><a id="21461" href="1Lab.Path.html#21271" class="Bound">f</a> <a id="21463" href="1Lab.Path.html#21311" class="Bound">y</a> <a id="21465" href="1Lab.Path.html#21329" class="Bound">β</a><a id="21466" class="Symbol">)</a>
<a id="21468" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="21472" href="1Lab.Path.html#21472" class="Bound">f</a> <a id="21474" href="1Lab.Path.html#21474" class="Bound">p</a> <a id="21476" href="1Lab.Path.html#21476" class="Bound">q</a> <a id="21478" href="1Lab.Path.html#21478" class="Bound">i</a> <a id="21480" class="Symbol">=</a> <a id="21482" href="1Lab.Path.html#21472" class="Bound">f</a> <a id="21484" class="Symbol">(</a><a id="21485" href="1Lab.Path.html#21474" class="Bound">p</a> <a id="21487" href="1Lab.Path.html#21478" class="Bound">i</a><a id="21488" class="Symbol">)</a> <a id="21490" class="Symbol">(</a><a id="21491" href="1Lab.Path.html#21476" class="Bound">q</a> <a id="21493" href="1Lab.Path.html#21478" class="Bound">i</a><a id="21494" class="Symbol">)</a>
</pre>
<p>This operation satisfies many identities definitionally that are only
propositional when
<span class="Agda"><a href="1Lab.Path.html#20756" class="Function">ap</a></span>
is defined in terms of
<span class="Agda"><a href="1Lab.Path.html#19544" class="Function">J</a></span>.
For instance:</p>
<pre class="Agda"><a id="21660" class="Keyword">module</a> <a id="21667" href="1Lab.Path.html#21667" class="Module">_</a> <a id="21669" class="Symbol">{</a><a id="21670" href="1Lab.Path.html#21670" class="Bound">A</a> <a id="21672" href="1Lab.Path.html#21672" class="Bound">B</a> <a id="21674" href="1Lab.Path.html#21674" class="Bound">C</a> <a id="21676" class="Symbol">:</a> <a id="21678" href="1Lab.Type.html#391" class="Primitive">Type</a><a id="21682" class="Symbol">}</a> <a id="21684" class="Symbol">{</a><a id="21685" href="1Lab.Path.html#21685" class="Bound">f</a> <a id="21687" class="Symbol">:</a> <a id="21689" href="1Lab.Path.html#21670" class="Bound">A</a> <a id="21691" class="Symbol">→</a> <a id="21693" href="1Lab.Path.html#21672" class="Bound">B</a><a id="21694" class="Symbol">}</a> <a id="21696" class="Symbol">{</a><a id="21697" href="1Lab.Path.html#21697" class="Bound">g</a> <a id="21699" class="Symbol">:</a> <a id="21701" href="1Lab.Path.html#21672" class="Bound">B</a> <a id="21703" class="Symbol">→</a> <a id="21705" href="1Lab.Path.html#21674" class="Bound">C</a><a id="21706" class="Symbol">}</a> <a id="21708" class="Keyword">where</a>
  <a id="21716" href="1Lab.Path.html#21716" data-type="ap (λ x → g (f x)) p ≡ ap g (ap f p)" class="Function">ap-comp</a> <a id="21724" class="Symbol">:</a> <a id="21726" class="Symbol">{</a><a id="21727" href="1Lab.Path.html#21727" class="Bound">x</a> <a id="21729" href="1Lab.Path.html#21729" class="Bound">y</a> <a id="21731" class="Symbol">:</a> <a id="21733" href="1Lab.Path.html#21670" class="Bound">A</a><a id="21734" class="Symbol">}</a> <a id="21736" class="Symbol">{</a><a id="21737" href="1Lab.Path.html#21737" class="Bound">p</a> <a id="21739" class="Symbol">:</a> <a id="21741" href="1Lab.Path.html#21727" class="Bound">x</a> <a id="21743" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="21745" href="1Lab.Path.html#21729" class="Bound">y</a><a id="21746" class="Symbol">}</a>
          <a id="21758" class="Symbol">→</a> <a id="21760" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="21763" class="Symbol">(λ</a> <a id="21766" href="1Lab.Path.html#21766" class="Bound">x</a> <a id="21768" class="Symbol">→</a> <a id="21770" href="1Lab.Path.html#21697" class="Bound">g</a> <a id="21772" class="Symbol">(</a><a id="21773" href="1Lab.Path.html#21685" class="Bound">f</a> <a id="21775" href="1Lab.Path.html#21766" class="Bound">x</a><a id="21776" class="Symbol">))</a> <a id="21779" href="1Lab.Path.html#21737" class="Bound">p</a> <a id="21781" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="21783" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="21786" href="1Lab.Path.html#21697" class="Bound">g</a> <a id="21788" class="Symbol">(</a><a id="21789" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="21792" href="1Lab.Path.html#21685" class="Bound">f</a> <a id="21794" href="1Lab.Path.html#21737" class="Bound">p</a><a id="21795" class="Symbol">)</a>
  <a id="21799" href="1Lab.Path.html#21716" data-type="ap (λ x → g (f x)) p ≡ ap g (ap f p)" class="Function">ap-comp</a> <a id="21807" class="Symbol">=</a> <a id="21809" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>

  <a id="21817" href="1Lab.Path.html#21817" data-type="ap (λ x → x) p ≡ p" class="Function">ap-id</a> <a id="21823" class="Symbol">:</a> <a id="21825" class="Symbol">{</a><a id="21826" href="1Lab.Path.html#21826" class="Bound">x</a> <a id="21828" href="1Lab.Path.html#21828" class="Bound">y</a> <a id="21830" class="Symbol">:</a> <a id="21832" href="1Lab.Path.html#21670" class="Bound">A</a><a id="21833" class="Symbol">}</a> <a id="21835" class="Symbol">{</a><a id="21836" href="1Lab.Path.html#21836" class="Bound">p</a> <a id="21838" class="Symbol">:</a> <a id="21840" href="1Lab.Path.html#21826" class="Bound">x</a> <a id="21842" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="21844" href="1Lab.Path.html#21828" class="Bound">y</a><a id="21845" class="Symbol">}</a>
        <a id="21855" class="Symbol">→</a> <a id="21857" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="21860" class="Symbol">(λ</a> <a id="21863" href="1Lab.Path.html#21863" class="Bound">x</a> <a id="21865" class="Symbol">→</a> <a id="21867" href="1Lab.Path.html#21863" class="Bound">x</a><a id="21868" class="Symbol">)</a> <a id="21870" href="1Lab.Path.html#21836" class="Bound">p</a> <a id="21872" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="21874" href="1Lab.Path.html#21836" class="Bound">p</a>
  <a id="21878" href="1Lab.Path.html#21817" data-type="ap (λ x → x) p ≡ p" class="Function">ap-id</a> <a id="21884" class="Symbol">=</a> <a id="21886" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>

  <a id="21894" href="1Lab.Path.html#21894" data-type="sym (ap f p) ≡ ap f (sym p)" class="Function">ap-sym</a> <a id="21901" class="Symbol">:</a> <a id="21903" class="Symbol">{</a><a id="21904" href="1Lab.Path.html#21904" class="Bound">x</a> <a id="21906" href="1Lab.Path.html#21906" class="Bound">y</a> <a id="21908" class="Symbol">:</a> <a id="21910" href="1Lab.Path.html#21670" class="Bound">A</a><a id="21911" class="Symbol">}</a> <a id="21913" class="Symbol">{</a><a id="21914" href="1Lab.Path.html#21914" class="Bound">p</a> <a id="21916" class="Symbol">:</a> <a id="21918" href="1Lab.Path.html#21904" class="Bound">x</a> <a id="21920" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="21922" href="1Lab.Path.html#21906" class="Bound">y</a><a id="21923" class="Symbol">}</a>
          <a id="21935" class="Symbol">→</a> <a id="21937" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="21941" class="Symbol">(</a><a id="21942" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="21945" href="1Lab.Path.html#21685" class="Bound">f</a> <a id="21947" href="1Lab.Path.html#21914" class="Bound">p</a><a id="21948" class="Symbol">)</a> <a id="21950" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="21952" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="21955" href="1Lab.Path.html#21685" class="Bound">f</a> <a id="21957" class="Symbol">(</a><a id="21958" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="21962" href="1Lab.Path.html#21914" class="Bound">p</a><a id="21963" class="Symbol">)</a>
  <a id="21967" href="1Lab.Path.html#21894" data-type="sym (ap f p) ≡ ap f (sym p)" class="Function">ap-sym</a> <a id="21974" class="Symbol">=</a> <a id="21976" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>

  <a id="21984" href="1Lab.Path.html#21984" data-type="ap f (λ i → x) ≡ (λ i → f x)" class="Function">ap-refl</a> <a id="21992" class="Symbol">:</a> <a id="21994" class="Symbol">{</a><a id="21995" href="1Lab.Path.html#21995" class="Bound">x</a> <a id="21997" class="Symbol">:</a> <a id="21999" href="1Lab.Path.html#21670" class="Bound">A</a><a id="22000" class="Symbol">}</a> <a id="22002" class="Symbol">→</a> <a id="22004" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="22007" href="1Lab.Path.html#21685" class="Bound">f</a> <a id="22009" class="Symbol">(λ</a> <a id="22012" href="1Lab.Path.html#22012" class="Bound">i</a> <a id="22014" class="Symbol">→</a> <a id="22016" href="1Lab.Path.html#21995" class="Bound">x</a><a id="22017" class="Symbol">)</a> <a id="22019" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="22021" class="Symbol">(λ</a> <a id="22024" href="1Lab.Path.html#22024" class="Bound">i</a> <a id="22026" class="Symbol">→</a> <a id="22028" href="1Lab.Path.html#21685" class="Bound">f</a> <a id="22030" href="1Lab.Path.html#21995" class="Bound">x</a><a id="22031" class="Symbol">)</a>
  <a id="22035" href="1Lab.Path.html#21984" data-type="ap f (λ i → x) ≡ (λ i → f x)" class="Function">ap-refl</a> <a id="22043" class="Symbol">=</a> <a id="22045" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
</pre>
<p>The last lemma, that <code>ap</code> respects composition of
<em>paths</em>, needs path induction, and the rest of the groupoid
structure on type formers, so it’s in <a href="1Lab.Path.Groupoid.html#ap-comp-path">a different module</a>.</p>
<h1 id="composition"><a href="#composition" class="header-link">Composition<span class="header-link-emoji">🔗</span></a></h1>
<p>In “Book HoTT”, the primitive operation from which the
higher-dimensional structure of types is derived is the
<span class="Agda"><a href="1Lab.Path.html#19544" class="Function">J</a></span>
eliminator, with
<span class="Agda"><a href="1Lab.Path.html#20103" class="Function">J-refl</a></span>
as a <em>definitional</em> computation rule. This has the benefit of
being very elegant: This one elimination rule generates an infinite
amount of coherent data. However, it’s very hard to make compute in the
presence of higher inductive types and univalence, so much so that, in
the book, univalence and HITs only compute up to paths.</p>
<p>In Cubical Agda, types are interpreted as objects called <em>cubical
Kan complexes</em><a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>, which are a <em>geometric</em>
description description of spaces as “sets we can probe by cubes”. In
Agda, this “probing” is reflected by mapping the interval into a type: A
“probe” of
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>
by an
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>-cube</span>
is a term of type
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>
in a context with
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>
variables of type
<span class="Agda"><a href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a></span>
— points, lines, squares, cubes, etc. This structure lets us “explore”
the higher dimensional structure of a type, but it does not specify how
this structure behaves.</p>
<p>That’s where the “Kan” part of “cubical Kan complex” comes in:
Semantically, <em>every open box extends to a cube</em>. The concept of
“open box” might make even less sense than the concept of “cube in a
type” initially, so it helps to picture them! Suppose we have three
paths
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>:</mo><mi>w</mi><mo>≡</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">p : w ≡ x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4637em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>,</span>
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo>:</mo><mi>x</mi><mo>≡</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">q : x ≡ y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4637em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>,</span>
and
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>:</mo><mi>y</mi><mo>≡</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">r : y ≡ z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6582em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span>.</span>
We can pictorially arrange them into an open box like in the diagram
below, by joining the paths by their common endpoints:</p>
<figure>
<div class="diagram-container">
<img src="light-671cd1ff8852af450c3a380476c023316a927c27.svg" title="commutative diagram" class="diagram diagram-light quiver" />
<img src="dark-671cd1ff8852af450c3a380476c023316a927c27.svg" title="commutative diagram" class="diagram diagram-dark quiver" />
</div>
</figure>
<p>In the diagram above, we have a square assembled of three lines
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>≡</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">w ≡ x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4637em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>,</span>
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≡</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x ≡ y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4637em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>,</span>
and
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>≡</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">y ≡ z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6582em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span>.</span>
Note that in the left face of the diagram, the path was inverted; This
is because while we have a path
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>≡</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">w ≡ x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4637em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>,</span>
we need a path
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≡</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">x ≡ w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4637em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span>,</span>
and all parallel faces of a cube must “point” in the same direction. The
way the diagram is drawn strongly implies that there is a face missing —
the line
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>≡</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">w ≡ z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4637em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span>.</span>
The interpretation of types as <em>Kan</em> cubical sets guarantees that
the open box above extends to a complete square, and thus the line
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>≡</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">w ≡ z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4637em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span>
exists.</p>
<h2 id="partial-elements"><a href="#partial-elements" class="header-link">Partial
Elements<span class="header-link-emoji">🔗</span></a></h2>
<p>The definition of Kan cubical sets as those having fillers for all
open boxes is all well and good, but to use this from within type theory
we need a way of reflecting the idea of “open box” as syntax. This is
done is by using the
<span class="Agda"><a href="Agda.Primitive.Cubical.html#1072" class="Primitive">Partial</a></span>
type former.</p>
<p>The
<span class="Agda"><a href="Agda.Primitive.Cubical.html#1072" class="Primitive">Partial</a></span>
type former takes two arguments: A <em>formula</em>
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">φ</span></span></span></span>,</span>
and a <em>type</em>
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>.</span>
The idea is that a term of type
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">P</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">l</mi></mrow><mtext> </mtext><mi>φ</mi><mtext> </mtext><mi>A</mi></mrow><annotation encoding="application/x-tex">\id{Partial}\ \varphi\ A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathrm">Partial</span></span><span class="mspace"> </span><span class="mord mathnormal">φ</span><span class="mspace"> </span><span class="mord mathnormal">A</span></span></span></span>
in a context with
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>
<span class="Agda"><a href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a></span>-typed
variables is a
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>-cube</span>
that is only defined when
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">φ</span></span></span></span>
“is true”. In Agda, formulas are represented using the De Morgan
structure of the interval, and they are “true” when they are equal to 1.
The predicate <code class="sourceCode agda">IsOne</code> represents
truth of a formula, and there is a canonical inhabitant
<span class="Agda"><a href="1Lab.Path.html#2443" class="Postulate">1=1</a></span>
which says
<span class="Agda"><a href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a></span>
is
<span class="Agda"><a href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a></span>.</p>
<p>For instance, if we have a variable <code>i : I</code> of interval
type, we can represent <em>disjoint endpoints</em> of a
<span class="Agda"><a href="1Lab.Path.html#2466" class="Function">Path</a></span>
by a partial element with formula
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">¬</mi><mi>i</mi><mo>∨</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">\neg i \lor i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord">¬</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>.</span>
Note that this is not the same thing as
<span class="Agda"><a href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a></span>!
Since elements of <code>I</code> are meant to represent real numbers
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">r \in [0,1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>,</span>
it suffices to find one for which
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mn>1</mn><mo>−</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\max(x, 1 - x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>
is not
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>
— like 0.5.</p>
<pre class="Agda"><a id="25869" class="Keyword">private</a>
  <a id="not-a-path"></a><a id="25879" href="1Lab.Path.html#25879" class="Function">not-a-path</a> <a id="25890" class="Symbol">:</a> <a id="25892" class="Symbol">(</a><a id="25893" href="1Lab.Path.html#25893" class="Bound">i</a> <a id="25895" class="Symbol">:</a> <a id="25897" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a><a id="25898" class="Symbol">)</a> <a id="25900" class="Symbol">→</a> <a id="25902" href="Agda.Primitive.Cubical.html#1072" class="Primitive">Partial</a> <a id="25910" class="Symbol">(</a><a id="25911" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="25913" href="1Lab.Path.html#25893" class="Bound">i</a> <a id="25915" href="1Lab.Path.html#2226" class="Primitive Operator">∨</a> <a id="25917" href="1Lab.Path.html#25893" class="Bound">i</a><a id="25918" class="Symbol">)</a> <a id="25920" href="Agda.Builtin.Bool.html#163" data-type="Type" class="Datatype">Bool</a>
  <a id="25927" href="1Lab.Path.html#25879" class="Function">not-a-path</a> <a id="25938" href="1Lab.Path.html#25938" class="Bound">i</a> <a id="25940" class="Symbol">(</a><a id="25941" href="1Lab.Path.html#25938" class="Bound">i</a> <a id="25943" class="Symbol">=</a> <a id="25945" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a><a id="25947" class="Symbol">)</a> <a id="25949" class="Symbol">=</a> <a id="25951" href="Agda.Builtin.Bool.html#188" data-type="Bool" class="InductiveConstructor">true</a>
  <a id="25958" href="1Lab.Path.html#25879" class="Function">not-a-path</a> <a id="25969" href="1Lab.Path.html#25969" class="Bound">i</a> <a id="25971" class="Symbol">(</a><a id="25972" href="1Lab.Path.html#25969" class="Bound">i</a> <a id="25974" class="Symbol">=</a> <a id="25976" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a><a id="25978" class="Symbol">)</a> <a id="25980" class="Symbol">=</a> <a id="25982" href="Agda.Builtin.Bool.html#182" data-type="Bool" class="InductiveConstructor">false</a>
</pre>
<p>This represents the following shape: Two disconnected points, with
completely unrelated values at each endpoint of the interval.</p>
<div class="diagram-container">
<img src="light-b9a4eb48b1fab518a43d7a15f443a4ac7a15d642.svg" title="commutative diagram" class="diagram diagram-light quiver short-2" />
<img src="dark-b9a4eb48b1fab518a43d7a15f443a4ac7a15d642.svg" title="commutative diagram" class="diagram diagram-dark quiver short-2" />
</div>
<p>More concretely, an element of
<span class="Agda"><a href="Agda.Primitive.Cubical.html#1072" class="Primitive">Partial</a></span>
can be understood as a function where the domain is the predicate <code class="sourceCode agda">IsOne</code>, which has an inhabitant
<span class="Agda"><a href="1Lab.Path.html#2443" class="Postulate">1=1</a></span>,
stating that one is one. Indeed, we can <em>apply</em> a
<span class="Agda"><a href="Agda.Primitive.Cubical.html#1072" class="Primitive">Partial</a></span>
to an argument of type <code class="sourceCode agda">IsOne</code> to get
a value of the underlying type.</p>
<pre class="Agda">  <a id="26535" href="1Lab.Path.html#26535" class="Function">_</a> <a id="26537" class="Symbol">:</a> <a id="26539" href="1Lab.Path.html#25879" class="Function">not-a-path</a> <a id="26550" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a> <a id="26553" href="1Lab.Path.html#2443" class="Postulate">1=1</a> <a id="26557" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="26559" href="Agda.Builtin.Bool.html#188" data-type="Bool" class="InductiveConstructor">true</a>
  <a id="26566" class="Symbol">_</a> <a id="26568" class="Symbol">=</a> <a id="26570" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
</pre>
<p>Note that if we <em>did</em> have <code>(~i ∨ i) = i1</code>
(i.e. our De Morgan algebra was a Boolean algebra), the partial element
above would give us a contradiction, since any
<code>I → Partial i1 T</code> extends to a path:</p>
<pre class="Agda">  <a id="26787" href="1Lab.Path.html#26787" class="Function">_</a> <a id="26789" class="Symbol">:</a> <a id="26791" class="Symbol">(</a><a id="26792" href="1Lab.Path.html#26792" class="Bound">f</a> <a id="26794" class="Symbol">:</a> <a id="26796" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a> <a id="26798" class="Symbol">→</a> <a id="26800" href="Agda.Primitive.Cubical.html#1072" class="Primitive">Partial</a> <a id="26808" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a> <a id="26811" href="Agda.Builtin.Bool.html#163" data-type="Type" class="Datatype">Bool</a><a id="26815" class="Symbol">)</a> <a id="26817" class="Symbol">→</a> <a id="26819" href="1Lab.Path.html#2466" data-type="(A : Type ℓ) → A → A → Type ℓ" class="Function">Path</a> <a id="26824" href="Agda.Builtin.Bool.html#163" data-type="Type" class="Datatype">Bool</a> <a id="26829" class="Symbol">(</a><a id="26830" href="1Lab.Path.html#26792" class="Bound">f</a> <a id="26832" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a> <a id="26835" href="1Lab.Path.html#2443" class="Postulate">1=1</a><a id="26838" class="Symbol">)</a> <a id="26840" class="Symbol">(</a><a id="26841" href="1Lab.Path.html#26792" class="Bound">f</a> <a id="26843" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a> <a id="26846" href="1Lab.Path.html#2443" class="Postulate">1=1</a><a id="26849" class="Symbol">)</a>
  <a id="26853" class="Symbol">_</a> <a id="26855" class="Symbol">=</a> <a id="26857" class="Symbol">λ</a> <a id="26859" href="1Lab.Path.html#26859" class="Bound">f</a> <a id="26861" href="1Lab.Path.html#26861" class="Bound">i</a> <a id="26863" class="Symbol">→</a> <a id="26865" href="1Lab.Path.html#26859" class="Bound">f</a> <a id="26867" href="1Lab.Path.html#26861" class="Bound">i</a> <a id="26869" href="1Lab.Path.html#2443" class="Postulate">1=1</a>
</pre>
<h2 id="extensibility"><a href="#extensibility" class="header-link">Extensibility<span class="header-link-emoji">🔗</span></a></h2>
<p>A partial element in a context with
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>-variables</span>
gives us a way of mapping some subobject of the
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>-cube</span>
into a type. A natural question to ask, then, is: Given a partial
element
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span>
of
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>,</span>
can we extend that to a honest-to-god <em>element</em> of
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>,</span>
which agrees with
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span>
where it is defined?</p>
<p>Specifically, when this is the case, we say that
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">x : A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>
<em>extends</em>
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>:</mo><mrow><mi mathvariant="normal">P</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">l</mi></mrow><mtext> </mtext><mi>φ</mi><mtext> </mtext><mi>A</mi></mrow><annotation encoding="application/x-tex">e : \id{Partial}\ \varphi\ A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathrm">Partial</span></span><span class="mspace"> </span><span class="mord mathnormal">φ</span><span class="mspace"> </span><span class="mord mathnormal">A</span></span></span></span>.</span>
We could represent this very generically as a <em>lifting problem</em>,
i.e. trying to find a map
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">□</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\square^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.675em;"></span><span class="mord"><span class="mord amsrm">□</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>
which agrees with
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span>
when restricted to
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">φ</span></span></span></span>,</span>
but I believe a specific example will be more helpful.</p>
<p>Suppose we have a partial element of
<span class="Agda"><a href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a></span>
which is
<span class="Agda"><a href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a></span>
on the left endpoint of the interval, and undefined elsewhere. This is a
partial element with one interval variable, so it would be extended by a
<em>path</em> — a 1-dimensional cube. The reflexivity path is a line in
<code>Bool</code>, which is
<span class="Agda"><a href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a></span>
on the left endpoint of the interval (in fact, it is
<span class="Agda"><a href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a></span>
everywhere), so we say that
<span class="Agda"><a href="1Lab.Path.html#3593" class="Function">refl</a></span>
<em>extends</em> the partial element.</p>
<div class="diagram-container">
<img src="light-15b638ed340a5226a78c409f86a3650733723155.svg" title="commutative diagram" class="diagram diagram-light quiver short-1" />
<img src="dark-15b638ed340a5226a78c409f86a3650733723155.svg" title="commutative diagram" class="diagram diagram-dark quiver short-1" />
</div>
<p>In the diagram, we draw the specific partial element being extended
in red, and the total path extending it in black. In Agda, extensions
are represented by the type former
<span class="Agda"><a href="Agda.Builtin.Cubical.Sub.html#198" class="Postulate">Sub</a></span>,
which we abbreviate by
<span class="Agda"><a href="1Lab.Path.html#28586" class="Function Operator">_[_↦_]</a></span>.
Fully applied, that operator looks like <code>A [ φ → u ]</code>.<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a></p>
<pre class="Agda"><a id="_[_↦_]"></a><a id="28586" href="1Lab.Path.html#28586" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">_[_↦_]</a> <a id="28593" class="Symbol">:</a> <a id="28595" class="Symbol">∀</a> <a id="28597" class="Symbol">{</a><a id="28598" href="1Lab.Path.html#28598" class="Bound">ℓ</a><a id="28599" class="Symbol">}</a> <a id="28601" class="Symbol">(</a><a id="28602" href="1Lab.Path.html#28602" class="Bound">A</a> <a id="28604" class="Symbol">:</a> <a id="28606" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="28611" href="1Lab.Path.html#28598" class="Bound">ℓ</a><a id="28612" class="Symbol">)</a> <a id="28614" class="Symbol">(</a><a id="28615" href="1Lab.Path.html#28615" class="Bound">φ</a> <a id="28617" class="Symbol">:</a> <a id="28619" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a><a id="28620" class="Symbol">)</a> <a id="28622" class="Symbol">(</a><a id="28623" href="1Lab.Path.html#28623" class="Bound">u</a> <a id="28625" class="Symbol">:</a> <a id="28627" href="Agda.Primitive.Cubical.html#1072" class="Primitive">Partial</a> <a id="28635" href="1Lab.Path.html#28615" class="Bound">φ</a> <a id="28637" href="1Lab.Path.html#28602" class="Bound">A</a><a id="28638" class="Symbol">)</a> <a id="28640" class="Symbol">→</a> <a id="28642" class="Symbol">_</a>
<a id="28644" href="1Lab.Path.html#28644" class="Bound">A</a> <a id="28646" href="1Lab.Path.html#28586" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">[</a> <a id="28648" href="1Lab.Path.html#28648" class="Bound">φ</a> <a id="28650" href="1Lab.Path.html#28586" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">↦</a> <a id="28652" href="1Lab.Path.html#28652" class="Bound">u</a> <a id="28654" href="1Lab.Path.html#28586" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">]</a> <a id="28656" class="Symbol">=</a> <a id="28658" href="Agda.Builtin.Cubical.Sub.html#198" data-type="(A : Type a) (φ : I) → Partial φ A → SSet a" class="Postulate">Sub</a> <a id="28662" href="1Lab.Path.html#28644" class="Bound">A</a> <a id="28664" href="1Lab.Path.html#28648" class="Bound">φ</a> <a id="28666" href="1Lab.Path.html#28652" class="Bound">u</a>
</pre>
<p>We can formalise the red-black extensibility diagram above by
defining the partial element
<span class="Agda"><a href="1Lab.Path.html#28881" class="Function">left-true</a></span>
and giving
<span class="Agda"><a href="1Lab.Path.html#3593" class="Function">refl</a></span>
to
<span class="Agda"><a href="1Lab.Path.html#2069" class="Postulate">inS</a></span>,
the constructor for
<span class="Agda"><a href="1Lab.Path.html#28586" class="Function Operator">_[_↦_]</a></span>.</p>
<pre class="Agda"><a id="28871" class="Keyword">private</a>
  <a id="left-true"></a><a id="28881" href="1Lab.Path.html#28881" class="Function">left-true</a> <a id="28891" class="Symbol">:</a> <a id="28893" class="Symbol">(</a><a id="28894" href="1Lab.Path.html#28894" class="Bound">i</a> <a id="28896" class="Symbol">:</a> <a id="28898" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a><a id="28899" class="Symbol">)</a> <a id="28901" class="Symbol">→</a> <a id="28903" href="Agda.Primitive.Cubical.html#1072" class="Primitive">Partial</a> <a id="28911" class="Symbol">(</a><a id="28912" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="28914" href="1Lab.Path.html#28894" class="Bound">i</a><a id="28915" class="Symbol">)</a> <a id="28917" href="Agda.Builtin.Bool.html#163" data-type="Type" class="Datatype">Bool</a>
  <a id="28924" href="1Lab.Path.html#28881" class="Function">left-true</a> <a id="28934" href="1Lab.Path.html#28934" class="Bound">i</a> <a id="28936" class="Symbol">(</a><a id="28937" href="1Lab.Path.html#28934" class="Bound">i</a> <a id="28939" class="Symbol">=</a> <a id="28941" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a><a id="28943" class="Symbol">)</a> <a id="28945" class="Symbol">=</a> <a id="28947" href="Agda.Builtin.Bool.html#188" data-type="Bool" class="InductiveConstructor">true</a>

  <a id="refl-extends"></a><a id="28955" href="1Lab.Path.html#28955" class="Function">refl-extends</a> <a id="28968" class="Symbol">:</a> <a id="28970" class="Symbol">(</a><a id="28971" href="1Lab.Path.html#28971" class="Bound">i</a> <a id="28973" class="Symbol">:</a> <a id="28975" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a><a id="28976" class="Symbol">)</a> <a id="28978" class="Symbol">→</a> <a id="28980" href="Agda.Builtin.Bool.html#163" data-type="Type" class="Datatype">Bool</a> <a id="28985" href="1Lab.Path.html#28586" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">[</a> <a id="28987" class="Symbol">(</a><a id="28988" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="28990" href="1Lab.Path.html#28971" class="Bound">i</a><a id="28991" class="Symbol">)</a> <a id="28993" href="1Lab.Path.html#28586" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">↦</a> <a id="28995" href="1Lab.Path.html#28881" class="Function">left-true</a> <a id="29005" href="1Lab.Path.html#28971" class="Bound">i</a> <a id="29007" href="1Lab.Path.html#28586" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">]</a>
  <a id="29011" href="1Lab.Path.html#28955" class="Function">refl-extends</a> <a id="29024" href="1Lab.Path.html#29024" class="Bound">i</a> <a id="29026" class="Symbol">=</a> <a id="29028" href="1Lab.Path.html#2069" class="Postulate">inS</a> <a id="29032" class="Symbol">(</a><a id="29033" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="29038" class="Symbol">{</a><a id="29039" class="Argument">x</a> <a id="29041" class="Symbol">=</a> <a id="29043" href="Agda.Builtin.Bool.html#188" data-type="Bool" class="InductiveConstructor">true</a><a id="29047" class="Symbol">}</a> <a id="29049" href="1Lab.Path.html#29024" class="Bound">i</a><a id="29050" class="Symbol">)</a>
</pre>
<p>The constructor <code>inS</code> expresses that <em>any</em>
totally-defined cube
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span>
can be seen as a partial cube, one that agrees with
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span>
for any choice of formula
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">φ</span></span></span></span>.</span>
This might be a bit abstract, so let’s diagram the case where we have
some square
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span>,</span>
and the partial element has formula
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>∧</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i \land j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>.</span>
This extension can be drawn as in the diagram below: The red “backwards
L” shape is the partial element, which is “extended by” the black lines
to make a complete square.</p>
<div class="diagram-container">
<img src="light-09793c4c4587fb5157ddad8e04975301c309a266.svg" title="commutative diagram" class="diagram diagram-light quiver" />
<img src="dark-09793c4c4587fb5157ddad8e04975301c309a266.svg" title="commutative diagram" class="diagram diagram-dark quiver" />
</div>
<pre class="Agda">  <a id="29980" href="1Lab.Path.html#29980" class="Function">_</a> <a id="29982" class="Symbol">:</a> <a id="29984" class="Symbol">∀</a> <a id="29986" class="Symbol">{</a><a id="29987" href="1Lab.Path.html#29987" class="Bound">ℓ</a><a id="29988" class="Symbol">}</a> <a id="29990" class="Symbol">{</a><a id="29991" href="1Lab.Path.html#29991" class="Bound">A</a> <a id="29993" class="Symbol">:</a> <a id="29995" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="30000" href="1Lab.Path.html#29987" class="Bound">ℓ</a><a id="30001" class="Symbol">}</a> <a id="30003" class="Symbol">{</a><a id="30004" href="1Lab.Path.html#30004" class="Bound">φ</a> <a id="30006" class="Symbol">:</a> <a id="30008" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a><a id="30009" class="Symbol">}</a> <a id="30011" class="Symbol">(</a><a id="30012" href="1Lab.Path.html#30012" class="Bound">u</a> <a id="30014" class="Symbol">:</a> <a id="30016" href="1Lab.Path.html#29991" class="Bound">A</a><a id="30017" class="Symbol">)</a> <a id="30019" class="Symbol">→</a> <a id="30021" href="1Lab.Path.html#29991" class="Bound">A</a> <a id="30023" href="1Lab.Path.html#28586" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">[</a> <a id="30025" href="1Lab.Path.html#30004" class="Bound">φ</a> <a id="30027" href="1Lab.Path.html#28586" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">↦</a> <a id="30029" class="Symbol">(λ</a> <a id="30032" href="1Lab.Path.html#30032" class="Bound">_</a> <a id="30034" class="Symbol">→</a> <a id="30036" href="1Lab.Path.html#30012" class="Bound">u</a><a id="30037" class="Symbol">)</a> <a id="30039" href="1Lab.Path.html#28586" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">]</a>
  <a id="30043" class="Symbol">_</a> <a id="30045" class="Symbol">=</a> <a id="30047" href="1Lab.Path.html#2069" class="Postulate">inS</a>
</pre>
<p>Note that since an extension must agree with the partial element
<em>everywhere</em>, there are elements that can not be extended at all.
Take <code class="sourceCode agda">notAPath</code> from before — since
there is no path that is
<span class="Agda"><a href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a></span>
at
<span class="Agda"><a href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a></span>
and
<span class="Agda"><a href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a></span>
at
<span class="Agda"><a href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a></span>,
it is not extensible. If it were extensible, we would have
<code>true ≡ false</code> — a contradiction.<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a></p>
<pre class="Agda">  <a id="not-extensible"></a><a id="30581" href="1Lab.Path.html#30581" class="Function">not-extensible</a> <a id="30596" class="Symbol">:</a> <a id="30598" class="Symbol">((</a><a id="30600" href="1Lab.Path.html#30600" class="Bound">i</a> <a id="30602" class="Symbol">:</a> <a id="30604" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a><a id="30605" class="Symbol">)</a> <a id="30607" class="Symbol">→</a> <a id="30609" href="Agda.Builtin.Bool.html#163" data-type="Type" class="Datatype">Bool</a> <a id="30614" href="1Lab.Path.html#28586" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">[</a> <a id="30616" class="Symbol">(</a><a id="30617" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="30619" href="1Lab.Path.html#30600" class="Bound">i</a> <a id="30621" href="1Lab.Path.html#2226" class="Primitive Operator">∨</a> <a id="30623" href="1Lab.Path.html#30600" class="Bound">i</a><a id="30624" class="Symbol">)</a> <a id="30626" href="1Lab.Path.html#28586" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">↦</a> <a id="30628" href="1Lab.Path.html#25879" class="Function">not-a-path</a> <a id="30639" href="1Lab.Path.html#30600" class="Bound">i</a> <a id="30641" href="1Lab.Path.html#28586" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">]</a><a id="30642" class="Symbol">)</a> <a id="30644" class="Symbol">→</a> <a id="30646" href="Agda.Builtin.Bool.html#188" data-type="Bool" class="InductiveConstructor">true</a> <a id="30651" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="30653" href="Agda.Builtin.Bool.html#182" data-type="Bool" class="InductiveConstructor">false</a>
  <a id="30661" href="1Lab.Path.html#30581" class="Function">not-extensible</a> <a id="30676" href="1Lab.Path.html#30676" class="Bound">ext</a> <a id="30680" href="1Lab.Path.html#30680" class="Bound">i</a> <a id="30682" class="Symbol">=</a> <a id="30684" href="1Lab.Path.html#2100" class="Primitive">outS</a> <a id="30689" class="Symbol">(</a><a id="30690" href="1Lab.Path.html#30676" class="Bound">ext</a> <a id="30694" href="1Lab.Path.html#30680" class="Bound">i</a><a id="30695" class="Symbol">)</a>
</pre>
<p>This counterexample demonstrates the eliminator for
<span class="Agda"><a href="1Lab.Path.html#28586" class="Function Operator">_[_↦_]</a></span>,
<span class="Agda"><a href="1Lab.Path.html#2100" class="Primitive">outS</a></span>,
which turns an <code>A [ φ ↦ u ]</code> to <code>A</code>, with a
computation rule saying that, for <code>x : A [ i1 ↦ u ]</code>,
<code>outS x</code> computes to <code>u 1=1</code>:</p>
<pre class="Agda">  <a id="30925" href="1Lab.Path.html#30925" class="Function">_</a> <a id="30927" class="Symbol">:</a> <a id="30929" class="Symbol">∀</a> <a id="30931" class="Symbol">{</a><a id="30932" href="1Lab.Path.html#30932" class="Bound">A</a> <a id="30934" class="Symbol">:</a> <a id="30936" href="1Lab.Type.html#391" class="Primitive">Type</a><a id="30940" class="Symbol">}</a> <a id="30942" class="Symbol">{</a><a id="30943" href="1Lab.Path.html#30943" class="Bound">u</a> <a id="30945" class="Symbol">:</a> <a id="30947" href="Agda.Primitive.Cubical.html#1072" class="Primitive">Partial</a> <a id="30955" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a> <a id="30958" href="1Lab.Path.html#30932" class="Bound">A</a><a id="30959" class="Symbol">}</a> <a id="30961" class="Symbol">{</a><a id="30962" href="1Lab.Path.html#30962" class="Bound">x</a> <a id="30964" class="Symbol">:</a> <a id="30966" href="1Lab.Path.html#30932" class="Bound">A</a> <a id="30968" href="1Lab.Path.html#28586" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">[</a> <a id="30970" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a> <a id="30973" href="1Lab.Path.html#28586" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">↦</a> <a id="30975" href="1Lab.Path.html#30943" class="Bound">u</a> <a id="30977" href="1Lab.Path.html#28586" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">]</a><a id="30978" class="Symbol">}</a>
    <a id="30984" class="Symbol">→</a> <a id="30986" href="1Lab.Path.html#2100" class="Primitive">outS</a> <a id="30991" href="1Lab.Path.html#30962" class="Bound">x</a> <a id="30993" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="30995" href="1Lab.Path.html#30943" class="Bound">u</a> <a id="30997" href="1Lab.Path.html#2443" class="Postulate">1=1</a>
  <a id="31003" class="Symbol">_</a> <a id="31005" class="Symbol">=</a> <a id="31007" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
</pre>
<p>The notion of partial elements and extensibility captures the
specific interface of the Kan operations, which can be summed up in the
following sentence: <em>If a partial path is extensible at
<span class="Agda"><a href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a></span>,
then it is extensible at
<span class="Agda"><a href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a></span></em>.
Let’s unpack that a bit:</p>
<p>A <em>partial path</em> is anything of type
<code>I → Partial φ A</code> – let’s say we have an <code>f</code> in
that type. It takes a value at
<span class="Agda"><a href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a></span>
(that’s <code>f i0</code>), and a value at
<span class="Agda"><a href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a></span>.
The Kan condition expresses that, if there exists an
<code>A [ φ → f i0 ]</code>, then we also have an
<code>A [ φ → f i1 ]</code>. In other words: Extensibility is preserved
by paths.</p>
<p>Recall the open box we drew by gluing paths together at the start of
the section (on the left). It has a <em>top face</em> <code>q</code>,
and it has a <em>tube</em> — its left/right faces, which can be
considered as a partial (in the left-right direction) path going in the
top-down direction.</p>
<div class="mathpar" style="gap: 2em;">
<div style="display: flex; flex-flow: column nowrap; align-items: center;">
<div class="diagram-container">
<img src="light-e218a497d90eef612fb1782492e2385120f8cb04.svg" title="commutative diagram" class="diagram diagram-light quiver" />
<img src="dark-e218a497d90eef612fb1782492e2385120f8cb04.svg" title="commutative diagram" class="diagram diagram-dark quiver" />
</div>
<figcaption>
The complete “open box”.
</figcaption>
</div>
<div style="display: flex; flex-flow: column nowrap; align-items: center;">
<div class="diagram-container">
<img src="light-f3686ca904b8514e25dbd267542b858267456c77.svg" title="commutative diagram" class="diagram diagram-light quiver" />
<img src="dark-f3686ca904b8514e25dbd267542b858267456c77.svg" title="commutative diagram" class="diagram diagram-dark quiver" />
</div>
<figcaption>
The partially-defined “tube”.
</figcaption>
</div>
</div>
<p>We can make this the construction of this “tube” formal by giving a
<span class="Agda"><a href="Agda.Primitive.Cubical.html#1072" class="Primitive">Partial</a></span>
element of <code>A</code>, which is defined on
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">¬</mi><mi>i</mi><mo>∨</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">\neg i \lor i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord">¬</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>
(that is: only the left/right faces of a square), as is done below.
Since it is a tube of a <em>square</em>, it has <em>two</em> interval
variables:
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>
gives the top-down direction.<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a></p>
<pre class="Agda"><a id="33171" class="Keyword">module</a> <a id="33178" href="1Lab.Path.html#33178" class="Module">_</a> <a id="33180" class="Symbol">{</a><a id="33181" href="1Lab.Path.html#33181" class="Bound">A</a> <a id="33183" class="Symbol">:</a> <a id="33185" href="1Lab.Type.html#391" class="Primitive">Type</a><a id="33189" class="Symbol">}</a> <a id="33191" class="Symbol">{</a><a id="33192" href="1Lab.Path.html#33192" class="Bound">w</a> <a id="33194" href="1Lab.Path.html#33194" class="Bound">x</a> <a id="33196" href="1Lab.Path.html#33196" class="Bound">y</a> <a id="33198" href="1Lab.Path.html#33198" class="Bound">z</a> <a id="33200" class="Symbol">:</a> <a id="33202" href="1Lab.Path.html#33181" class="Bound">A</a><a id="33203" class="Symbol">}</a> <a id="33205" class="Symbol">{</a><a id="33206" href="1Lab.Path.html#33206" class="Bound">p</a> <a id="33208" class="Symbol">:</a> <a id="33210" href="1Lab.Path.html#33192" class="Bound">w</a> <a id="33212" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="33214" href="1Lab.Path.html#33194" class="Bound">x</a><a id="33215" class="Symbol">}</a> <a id="33217" class="Symbol">{</a><a id="33218" href="1Lab.Path.html#33218" class="Bound">q</a> <a id="33220" class="Symbol">:</a> <a id="33222" href="1Lab.Path.html#33194" class="Bound">x</a> <a id="33224" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="33226" href="1Lab.Path.html#33196" class="Bound">y</a><a id="33227" class="Symbol">}</a> <a id="33229" class="Symbol">{</a><a id="33230" href="1Lab.Path.html#33230" class="Bound">r</a> <a id="33232" class="Symbol">:</a> <a id="33234" href="1Lab.Path.html#33196" class="Bound">y</a> <a id="33236" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="33238" href="1Lab.Path.html#33198" class="Bound">z</a><a id="33239" class="Symbol">}</a> <a id="33241" class="Keyword">where</a> <a id="33247" class="Keyword">private</a>
  <a id="33257" href="1Lab.Path.html#33257" class="Function">double-comp-tube</a> <a id="33274" class="Symbol">:</a> <a id="33276" class="Symbol">(</a><a id="33277" href="1Lab.Path.html#33277" class="Bound">i</a> <a id="33279" class="Symbol">:</a> <a id="33281" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a><a id="33282" class="Symbol">)</a> <a id="33284" class="Symbol">→</a> <a id="33286" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a> <a id="33288" class="Symbol">→</a> <a id="33290" href="Agda.Primitive.Cubical.html#1072" class="Primitive">Partial</a> <a id="33298" class="Symbol">(</a><a id="33299" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="33301" href="1Lab.Path.html#33277" class="Bound">i</a> <a id="33303" href="1Lab.Path.html#2226" class="Primitive Operator">∨</a> <a id="33305" href="1Lab.Path.html#33277" class="Bound">i</a><a id="33306" class="Symbol">)</a> <a id="33308" href="1Lab.Path.html#33181" class="Bound">A</a>
  <a id="33312" href="1Lab.Path.html#33257" class="Function">double-comp-tube</a> <a id="33329" href="1Lab.Path.html#33329" class="Bound">i</a> <a id="33331" href="1Lab.Path.html#33331" class="Bound">j</a> <a id="33333" class="Symbol">(</a><a id="33334" href="1Lab.Path.html#33329" class="Bound">i</a> <a id="33336" class="Symbol">=</a> <a id="33338" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a><a id="33340" class="Symbol">)</a> <a id="33342" class="Symbol">=</a> <a id="33344" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="33348" href="1Lab.Path.html#33206" class="Bound">p</a> <a id="33350" href="1Lab.Path.html#33331" class="Bound">j</a>
  <a id="33354" href="1Lab.Path.html#33257" class="Function">double-comp-tube</a> <a id="33371" href="1Lab.Path.html#33371" class="Bound">i</a> <a id="33373" href="1Lab.Path.html#33373" class="Bound">j</a> <a id="33375" class="Symbol">(</a><a id="33376" href="1Lab.Path.html#33371" class="Bound">i</a> <a id="33378" class="Symbol">=</a> <a id="33380" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a><a id="33382" class="Symbol">)</a> <a id="33384" class="Symbol">=</a> <a id="33386" href="1Lab.Path.html#33230" class="Bound">r</a> <a id="33388" href="1Lab.Path.html#33373" class="Bound">j</a>
</pre>
<p>When given
<span class="Agda"><a href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a></span>
as <code>j</code>,
<span class="Agda"><a href="1Lab.Path.html#33257" class="Function">double-comp-tube</a></span>
has boundary
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mtext> </mtext><mrow><mi mathvariant="normal">i</mi><mn>1</mn></mrow><mo>→</mo><mi>r</mi><mtext> </mtext><mrow><mi mathvariant="normal">i</mi><mn>0</mn></mrow></mrow><annotation encoding="application/x-tex">p\ \id{i1} \to r\ \id{i0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8623em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace"> </span><span class="mord"><span class="mord mathrm">i1</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace"> </span><span class="mord"><span class="mord mathrm">i0</span></span></span></span></span>,</span>
which computes to
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>→</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \to y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>.</span>
This means that for this path to be extensible at
<span class="Agda"><a href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a></span>,
we need a path with that boundary. By assumption, <code>q</code> extends
<span class="Agda"><a href="1Lab.Path.html#33257" class="Function">double-comp-tube</a></span>
at
<span class="Agda"><a href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a></span>.</p>
<pre class="Agda">  <a id="33701" href="1Lab.Path.html#33701" class="Function">extensible-at-i0</a> <a id="33718" class="Symbol">:</a> <a id="33720" class="Symbol">(</a><a id="33721" href="1Lab.Path.html#33721" class="Bound">i</a> <a id="33723" class="Symbol">:</a> <a id="33725" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a><a id="33726" class="Symbol">)</a> <a id="33728" class="Symbol">→</a> <a id="33730" href="1Lab.Path.html#33181" class="Bound">A</a> <a id="33732" href="1Lab.Path.html#28586" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">[</a> <a id="33734" class="Symbol">(</a><a id="33735" href="1Lab.Path.html#33721" class="Bound">i</a> <a id="33737" href="1Lab.Path.html#2226" class="Primitive Operator">∨</a> <a id="33739" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="33741" href="1Lab.Path.html#33721" class="Bound">i</a><a id="33742" class="Symbol">)</a> <a id="33744" href="1Lab.Path.html#28586" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">↦</a> <a id="33746" href="1Lab.Path.html#33257" class="Function">double-comp-tube</a> <a id="33763" href="1Lab.Path.html#33721" class="Bound">i</a> <a id="33765" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a> <a id="33768" href="1Lab.Path.html#28586" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">]</a>
  <a id="33772" href="1Lab.Path.html#33701" class="Function">extensible-at-i0</a> <a id="33789" href="1Lab.Path.html#33789" class="Bound">i</a> <a id="33791" class="Symbol">=</a> <a id="33793" href="1Lab.Path.html#2069" class="Postulate">inS</a> <a id="33797" class="Symbol">(</a><a id="33798" href="1Lab.Path.html#33218" class="Bound">q</a> <a id="33800" href="1Lab.Path.html#33789" class="Bound">i</a><a id="33801" class="Symbol">)</a>
</pre>
<p>We can draw this as one of our red-black extensibility diagrams
colouring the left/right faces in red — since that is the partial
element — and colouring the top face black, since that is a
totally-defined cube.</p>
<div class="diagram-container">
<img src="light-d7c7f865553e6d11e4ddff5bec6d0ed719abca49.svg" title="commutative diagram" class="diagram diagram-light quiver" />
<img src="dark-d7c7f865553e6d11e4ddff5bec6d0ed719abca49.svg" title="commutative diagram" class="diagram diagram-dark quiver" />
</div>
<p>The Kan condition says that this path is then extensible at
<code>i1</code>, i.e. there is some inhabitant of
<code>A [ (i ∨ ~ i) ↦ double-comp-tube i i1 ]</code>. This element is
written using the operator
<span class="Agda"><a href="1Lab.Path.html#2368" class="Primitive">hcomp</a></span>:</p>
<pre class="Agda">  <a id="34703" href="1Lab.Path.html#34703" class="Function">extensible-at-i1</a> <a id="34720" class="Symbol">:</a> <a id="34722" class="Symbol">(</a><a id="34723" href="1Lab.Path.html#34723" class="Bound">i</a> <a id="34725" class="Symbol">:</a> <a id="34727" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a><a id="34728" class="Symbol">)</a> <a id="34730" class="Symbol">→</a> <a id="34732" href="1Lab.Path.html#33181" class="Bound">A</a> <a id="34734" href="1Lab.Path.html#28586" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">[</a> <a id="34736" class="Symbol">(</a><a id="34737" href="1Lab.Path.html#34723" class="Bound">i</a> <a id="34739" href="1Lab.Path.html#2226" class="Primitive Operator">∨</a> <a id="34741" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="34743" href="1Lab.Path.html#34723" class="Bound">i</a><a id="34744" class="Symbol">)</a> <a id="34746" href="1Lab.Path.html#28586" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">↦</a> <a id="34748" href="1Lab.Path.html#33257" class="Function">double-comp-tube</a> <a id="34765" href="1Lab.Path.html#34723" class="Bound">i</a> <a id="34767" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a> <a id="34770" href="1Lab.Path.html#28586" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">]</a>
  <a id="34774" href="1Lab.Path.html#34703" class="Function">extensible-at-i1</a> <a id="34791" href="1Lab.Path.html#34791" class="Bound">i</a> <a id="34793" class="Symbol">=</a>
    <a id="34799" href="1Lab.Path.html#2069" class="Postulate">inS</a> <a id="34803" class="Symbol">(</a><a id="34804" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="34810" class="Symbol">{</a><a id="34811" class="Argument">φ</a> <a id="34813" class="Symbol">=</a> <a id="34815" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="34817" href="1Lab.Path.html#34791" class="Bound">i</a> <a id="34819" href="1Lab.Path.html#2226" class="Primitive Operator">∨</a> <a id="34821" href="1Lab.Path.html#34791" class="Bound">i</a><a id="34822" class="Symbol">}</a> <a id="34824" class="Symbol">(λ</a> <a id="34827" href="1Lab.Path.html#34827" class="Bound">k</a> <a id="34829" href="1Lab.Path.html#34829" class="Bound">is1</a> <a id="34833" class="Symbol">→</a> <a id="34835" href="1Lab.Path.html#33257" class="Function">double-comp-tube</a> <a id="34852" href="1Lab.Path.html#34791" class="Bound">i</a> <a id="34854" href="1Lab.Path.html#34827" class="Bound">k</a> <a id="34856" href="1Lab.Path.html#34829" class="Bound">is1</a><a id="34859" class="Symbol">)</a> <a id="34861" class="Symbol">(</a><a id="34862" href="1Lab.Path.html#33218" class="Bound">q</a> <a id="34864" href="1Lab.Path.html#34791" class="Bound">i</a><a id="34865" class="Symbol">))</a>
</pre>
<p>Unwinding what it means for this element to exist, we see that the
<span class="Agda"><a href="1Lab.Path.html#2368" class="Primitive">hcomp</a></span>
operation guarantees the existence of a path
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>→</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">w \to z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span>.</span>
It is the face that is hinted at by completing the open box above to a
complete square.</p>
<pre class="Agda">  <a id="35110" href="1Lab.Path.html#35110" class="Function">double-comp</a> <a id="35122" class="Symbol">:</a> <a id="35124" href="1Lab.Path.html#33192" class="Bound">w</a> <a id="35126" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="35128" href="1Lab.Path.html#33198" class="Bound">z</a>
  <a id="35132" href="1Lab.Path.html#35110" class="Function">double-comp</a> <a id="35144" href="1Lab.Path.html#35144" class="Bound">i</a> <a id="35146" class="Symbol">=</a> <a id="35148" href="1Lab.Path.html#2100" class="Primitive">outS</a> <a id="35153" class="Symbol">(</a><a id="35154" href="1Lab.Path.html#34703" class="Function">extensible-at-i1</a> <a id="35171" href="1Lab.Path.html#35144" class="Bound">i</a><a id="35172" class="Symbol">)</a>
</pre>
<p>Note that
<span class="Agda"><a href="1Lab.Path.html#2368" class="Primitive">hcomp</a></span>
gives us the missing face of the open box, but the semantics guarantees
the existence of the box itself, as a
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>-cube.</span>
From the De Morgan structure on the interval, we can derive the
existence of the cubes themselves (called <strong>fillers</strong>) from
the existence of the missing faces:</p>
<pre class="Agda"><a id="hfill"></a><a id="35493" href="1Lab.Path.html#35493" data-type="(u : I → Partial φ A) (u0 : A [ φ ↦ u i0 ]) →
outS u0 ≡ hcomp u (outS u0)" class="Function">hfill</a> <a id="35499" class="Symbol">:</a> <a id="35501" class="Symbol">∀</a> <a id="35503" class="Symbol">{</a><a id="35504" href="1Lab.Path.html#35504" class="Bound">ℓ</a><a id="35505" class="Symbol">}</a> <a id="35507" class="Symbol">{</a><a id="35508" href="1Lab.Path.html#35508" class="Bound">A</a> <a id="35510" class="Symbol">:</a> <a id="35512" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="35517" href="1Lab.Path.html#35504" class="Bound">ℓ</a><a id="35518" class="Symbol">}</a> <a id="35520" class="Symbol">{</a><a id="35521" href="1Lab.Path.html#35521" class="Bound">φ</a> <a id="35523" class="Symbol">:</a> <a id="35525" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a><a id="35526" class="Symbol">}</a>
        <a id="35536" class="Symbol">(</a><a id="35537" href="1Lab.Path.html#35537" class="Bound">u</a> <a id="35539" class="Symbol">:</a> <a id="35541" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a> <a id="35543" class="Symbol">→</a> <a id="35545" href="Agda.Primitive.Cubical.html#1072" class="Primitive">Partial</a> <a id="35553" href="1Lab.Path.html#35521" class="Bound">φ</a> <a id="35555" href="1Lab.Path.html#35508" class="Bound">A</a><a id="35556" class="Symbol">)</a>
        <a id="35566" class="Symbol">(</a><a id="35567" href="1Lab.Path.html#35567" class="Bound">u0</a> <a id="35570" class="Symbol">:</a> <a id="35572" href="1Lab.Path.html#35508" class="Bound">A</a> <a id="35574" href="1Lab.Path.html#28586" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">[</a> <a id="35576" href="1Lab.Path.html#35521" class="Bound">φ</a> <a id="35578" href="1Lab.Path.html#28586" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">↦</a> <a id="35580" href="1Lab.Path.html#35537" class="Bound">u</a> <a id="35582" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a> <a id="35585" href="1Lab.Path.html#28586" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">]</a><a id="35586" class="Symbol">)</a>
      <a id="35594" class="Symbol">→</a> <a id="35596" href="1Lab.Path.html#2100" class="Primitive">outS</a> <a id="35601" href="1Lab.Path.html#35567" class="Bound">u0</a> <a id="35604" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="35606" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="35612" href="1Lab.Path.html#35537" class="Bound">u</a> <a id="35614" class="Symbol">(</a><a id="35615" href="1Lab.Path.html#2100" class="Primitive">outS</a> <a id="35620" href="1Lab.Path.html#35567" class="Bound">u0</a><a id="35622" class="Symbol">)</a>
<a id="35624" href="1Lab.Path.html#35493" data-type="(u : I → Partial φ A) (u0 : A [ φ ↦ u i0 ]) →
outS u0 ≡ hcomp u (outS u0)" class="Function">hfill</a> <a id="35630" class="Symbol">{</a><a id="35631" class="Argument">φ</a> <a id="35633" class="Symbol">=</a> <a id="35635" href="1Lab.Path.html#35635" class="Bound">φ</a><a id="35636" class="Symbol">}</a> <a id="35638" href="1Lab.Path.html#35638" class="Bound">u</a> <a id="35640" href="1Lab.Path.html#35640" class="Bound">u0</a> <a id="35643" href="1Lab.Path.html#35643" class="Bound">i</a> <a id="35645" class="Symbol">=</a>
  <a id="35649" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="35655" class="Symbol">(λ</a> <a id="35658" href="1Lab.Path.html#35658" class="Bound">j</a> <a id="35660" class="Symbol">→</a> <a id="35662" class="Symbol">λ</a> <a id="35664" class="Symbol">{</a> <a id="35666" class="Symbol">(</a><a id="35667" href="1Lab.Path.html#35635" class="Bound">φ</a> <a id="35669" class="Symbol">=</a> <a id="35671" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a><a id="35673" class="Symbol">)</a> <a id="35675" class="Symbol">→</a> <a id="35677" href="1Lab.Path.html#35638" class="Bound">u</a> <a id="35679" class="Symbol">(</a><a id="35680" href="1Lab.Path.html#35643" class="Bound">i</a> <a id="35682" href="1Lab.Path.html#2191" class="Primitive Operator">∧</a> <a id="35684" href="1Lab.Path.html#35658" class="Bound">j</a><a id="35685" class="Symbol">)</a> <a id="35687" href="1Lab.Path.html#2443" class="Postulate">1=1</a>
                 <a id="35708" class="Symbol">;</a> <a id="35710" class="Symbol">(</a><a id="35711" href="1Lab.Path.html#35643" class="Bound">i</a> <a id="35713" class="Symbol">=</a> <a id="35715" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a><a id="35717" class="Symbol">)</a> <a id="35719" class="Symbol">→</a> <a id="35721" href="1Lab.Path.html#2100" class="Primitive">outS</a> <a id="35726" href="1Lab.Path.html#35640" class="Bound">u0</a> <a id="35729" class="Symbol">})</a>
        <a id="35740" class="Symbol">(</a><a id="35741" href="1Lab.Path.html#2100" class="Primitive">outS</a> <a id="35746" href="1Lab.Path.html#35640" class="Bound">u0</a><a id="35748" class="Symbol">)</a>
</pre>
<p><strong>Note</strong>: While every inhabitant of
<span class="Agda"><a href="1Lab.Type.html#391" class="Primitive">Type</a></span>
has a composition operation, not every <em>type</em> (something that can
be on the right of type signature <code>e : T</code>) does. We call the
types that <em>do</em> have a composition operation “fibrant”, since
these are semantically the cubical sets which are Kan complices.
Examples of types which are <em>not</em> fibrant include the interval
<span class="Agda"><a href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a></span>,
the partial elements
<span class="Agda"><a href="Agda.Primitive.Cubical.html#1072" class="Primitive">Partial</a></span>,
and the extensions <code>_[_↦_]</code><a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a>.</p>
<blockquote>
<p><a id="fibrant"><strong>Definition</strong></a>: A type is
<em>fibrant</em> if it supports
<span class="Agda"><a href="1Lab.Path.html#2368" class="Primitive">hcomp</a></span>.
This word comes up a lot when discussing not only the semantics of
Cubical type theory, but also its practice! For instance, the fibrancy
of
<span class="Agda"><a href="1Lab.Type.html#391" class="Primitive">Type</a></span>
is what powers <a href="1Lab.Univalence.html">univalence</a>.</p>
</blockquote>
<p>Agda also provides a <em>heterogeneous</em> version of composition
(also called CCHM composition), called
<span class="Agda"><a href="1Lab.Path.html#2332" class="Primitive">comp</a></span>.
It too has a corresponding filler, called
<span class="Agda"><a href="1Lab.Path.html#37552" class="Function">fill</a></span>.
The idea behind CCHM composition is — by analogy with
<span class="Agda"><a href="1Lab.Path.html#2368" class="Primitive">hcomp</a></span>
expressing that “paths preserve extensibility” — that
<span class="Agda"><a href="Agda.Builtin.Cubical.Path.html#197" class="Postulate">PathP</a></span>s
preserve extensibility. Thus we have:</p>
<pre class="Agda"><a id="37304" class="Keyword">private</a>
  <a id="comp-verbose"></a><a id="37314" href="1Lab.Path.html#37314" class="Function">comp-verbose</a> <a id="37327" class="Symbol">:</a> <a id="37329" class="Symbol">∀</a> <a id="37331" class="Symbol">{</a><a id="37332" href="1Lab.Path.html#37332" class="Bound">ℓ</a><a id="37333" class="Symbol">}</a> <a id="37335" class="Symbol">(</a><a id="37336" href="1Lab.Path.html#37336" class="Bound">A</a> <a id="37338" class="Symbol">:</a> <a id="37340" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a> <a id="37342" class="Symbol">→</a> <a id="37344" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="37349" href="1Lab.Path.html#37332" class="Bound">ℓ</a><a id="37350" class="Symbol">)</a>
                   <a id="37371" class="Symbol">{</a><a id="37372" href="1Lab.Path.html#37372" class="Bound">φ</a> <a id="37374" class="Symbol">:</a> <a id="37376" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a><a id="37377" class="Symbol">}</a>
               <a id="37394" class="Symbol">→</a> <a id="37396" class="Symbol">(</a><a id="37397" href="1Lab.Path.html#37397" class="Bound">u</a> <a id="37399" class="Symbol">:</a> <a id="37401" class="Symbol">∀</a> <a id="37403" href="1Lab.Path.html#37403" class="Bound">i</a> <a id="37405" class="Symbol">→</a> <a id="37407" href="Agda.Primitive.Cubical.html#1072" class="Primitive">Partial</a> <a id="37415" href="1Lab.Path.html#37372" class="Bound">φ</a> <a id="37417" class="Symbol">(</a><a id="37418" href="1Lab.Path.html#37336" class="Bound">A</a> <a id="37420" href="1Lab.Path.html#37403" class="Bound">i</a><a id="37421" class="Symbol">))</a>
               <a id="37439" class="Symbol">→</a> <a id="37441" class="Symbol">(</a><a id="37442" href="1Lab.Path.html#37442" class="Bound">u0</a> <a id="37445" class="Symbol">:</a> <a id="37447" href="1Lab.Path.html#37336" class="Bound">A</a> <a id="37449" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a> <a id="37452" href="1Lab.Path.html#28586" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">[</a> <a id="37454" href="1Lab.Path.html#37372" class="Bound">φ</a> <a id="37456" href="1Lab.Path.html#28586" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">↦</a> <a id="37458" href="1Lab.Path.html#37397" class="Bound">u</a> <a id="37460" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a> <a id="37463" href="1Lab.Path.html#28586" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">]</a> <a id="37465" class="Symbol">)</a>
               <a id="37482" class="Symbol">→</a> <a id="37484" href="1Lab.Path.html#37336" class="Bound">A</a> <a id="37486" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a> <a id="37489" href="1Lab.Path.html#28586" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">[</a> <a id="37491" href="1Lab.Path.html#37372" class="Bound">φ</a> <a id="37493" href="1Lab.Path.html#28586" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">↦</a> <a id="37495" href="1Lab.Path.html#37397" class="Bound">u</a> <a id="37497" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a> <a id="37500" href="1Lab.Path.html#28586" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">]</a>
  <a id="37504" href="1Lab.Path.html#37314" class="Function">comp-verbose</a> <a id="37517" href="1Lab.Path.html#37517" class="Bound">A</a> <a id="37519" href="1Lab.Path.html#37519" class="Bound">u</a> <a id="37521" href="1Lab.Path.html#37521" class="Bound">u0</a> <a id="37524" class="Symbol">=</a> <a id="37526" href="1Lab.Path.html#2069" class="Postulate">inS</a> <a id="37530" class="Symbol">(</a><a id="37531" href="1Lab.Path.html#2332" class="Primitive">comp</a> <a id="37536" href="1Lab.Path.html#37517" class="Bound">A</a> <a id="37538" href="1Lab.Path.html#37519" class="Bound">u</a> <a id="37540" class="Symbol">(</a><a id="37541" href="1Lab.Path.html#2100" class="Primitive">outS</a> <a id="37546" href="1Lab.Path.html#37521" class="Bound">u0</a><a id="37548" class="Symbol">))</a>

<a id="fill"></a><a id="37552" href="1Lab.Path.html#37552" data-type="(A : (i : I) → Type (ℓ i)) (u : (i : I) → Partial φ (A i)) →
A i0 [ φ ↦ u i0 ] → (i : I) → A i" class="Function">fill</a> <a id="37557" class="Symbol">:</a> <a id="37559" class="Symbol">∀</a> <a id="37561" class="Symbol">{</a><a id="37562" href="1Lab.Path.html#37562" class="Bound">ℓ</a> <a id="37564" class="Symbol">:</a> <a id="37566" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a> <a id="37568" class="Symbol">→</a> <a id="37570" href="Agda.Primitive.html#597" data-type="Type" class="Postulate">Level</a><a id="37575" class="Symbol">}</a> <a id="37577" class="Symbol">(</a><a id="37578" href="1Lab.Path.html#37578" class="Bound">A</a> <a id="37580" class="Symbol">:</a> <a id="37582" class="Symbol">∀</a> <a id="37584" href="1Lab.Path.html#37584" class="Bound">i</a> <a id="37586" class="Symbol">→</a> <a id="37588" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="37593" class="Symbol">(</a><a id="37594" href="1Lab.Path.html#37562" class="Bound">ℓ</a> <a id="37596" href="1Lab.Path.html#37584" class="Bound">i</a><a id="37597" class="Symbol">))</a>
       <a id="37607" class="Symbol">{</a><a id="37608" href="1Lab.Path.html#37608" class="Bound">φ</a> <a id="37610" class="Symbol">:</a> <a id="37612" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a><a id="37613" class="Symbol">}</a>
     <a id="37620" class="Symbol">→</a> <a id="37622" class="Symbol">(</a><a id="37623" href="1Lab.Path.html#37623" class="Bound">u</a> <a id="37625" class="Symbol">:</a> <a id="37627" class="Symbol">∀</a> <a id="37629" href="1Lab.Path.html#37629" class="Bound">i</a> <a id="37631" class="Symbol">→</a> <a id="37633" href="Agda.Primitive.Cubical.html#1072" class="Primitive">Partial</a> <a id="37641" href="1Lab.Path.html#37608" class="Bound">φ</a> <a id="37643" class="Symbol">(</a><a id="37644" href="1Lab.Path.html#37578" class="Bound">A</a> <a id="37646" href="1Lab.Path.html#37629" class="Bound">i</a><a id="37647" class="Symbol">))</a>
     <a id="37655" class="Symbol">→</a> <a id="37657" class="Symbol">(</a><a id="37658" href="1Lab.Path.html#37658" class="Bound">u0</a> <a id="37661" class="Symbol">:</a> <a id="37663" href="1Lab.Path.html#37578" class="Bound">A</a> <a id="37665" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a> <a id="37668" href="1Lab.Path.html#28586" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">[</a> <a id="37670" href="1Lab.Path.html#37608" class="Bound">φ</a> <a id="37672" href="1Lab.Path.html#28586" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">↦</a> <a id="37674" href="1Lab.Path.html#37623" class="Bound">u</a> <a id="37676" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a> <a id="37679" href="1Lab.Path.html#28586" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">]</a><a id="37680" class="Symbol">)</a>
     <a id="37687" class="Symbol">→</a> <a id="37689" class="Symbol">∀</a> <a id="37691" href="1Lab.Path.html#37691" class="Bound">i</a> <a id="37693" class="Symbol">→</a> <a id="37695" href="1Lab.Path.html#37578" class="Bound">A</a> <a id="37697" href="1Lab.Path.html#37691" class="Bound">i</a>
<a id="37699" href="1Lab.Path.html#37552" data-type="(A : (i : I) → Type (ℓ i)) (u : (i : I) → Partial φ (A i)) →
A i0 [ φ ↦ u i0 ] → (i : I) → A i" class="Function">fill</a> <a id="37704" href="1Lab.Path.html#37704" class="Bound">A</a> <a id="37706" class="Symbol">{</a><a id="37707" class="Argument">φ</a> <a id="37709" class="Symbol">=</a> <a id="37711" href="1Lab.Path.html#37711" class="Bound">φ</a><a id="37712" class="Symbol">}</a> <a id="37714" href="1Lab.Path.html#37714" class="Bound">u</a> <a id="37716" href="1Lab.Path.html#37716" class="Bound">u0</a> <a id="37719" href="1Lab.Path.html#37719" class="Bound">i</a> <a id="37721" class="Symbol">=</a>
  <a id="37725" href="1Lab.Path.html#2332" class="Primitive">comp</a> <a id="37730" class="Symbol">(λ</a> <a id="37733" href="1Lab.Path.html#37733" class="Bound">j</a> <a id="37735" class="Symbol">→</a> <a id="37737" href="1Lab.Path.html#37704" class="Bound">A</a> <a id="37739" class="Symbol">(</a><a id="37740" href="1Lab.Path.html#37719" class="Bound">i</a> <a id="37742" href="1Lab.Path.html#2191" class="Primitive Operator">∧</a> <a id="37744" href="1Lab.Path.html#37733" class="Bound">j</a><a id="37745" class="Symbol">))</a>
       <a id="37755" class="Symbol">(λ</a> <a id="37758" href="1Lab.Path.html#37758" class="Bound">j</a> <a id="37760" class="Symbol">→</a> <a id="37762" class="Symbol">λ</a> <a id="37764" class="Symbol">{</a> <a id="37766" class="Symbol">(</a><a id="37767" href="1Lab.Path.html#37711" class="Bound">φ</a> <a id="37769" class="Symbol">=</a> <a id="37771" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a><a id="37773" class="Symbol">)</a> <a id="37775" class="Symbol">→</a> <a id="37777" href="1Lab.Path.html#37714" class="Bound">u</a> <a id="37779" class="Symbol">(</a><a id="37780" href="1Lab.Path.html#37719" class="Bound">i</a> <a id="37782" href="1Lab.Path.html#2191" class="Primitive Operator">∧</a> <a id="37784" href="1Lab.Path.html#37758" class="Bound">j</a><a id="37785" class="Symbol">)</a> <a id="37787" href="1Lab.Path.html#2443" class="Postulate">1=1</a>
                <a id="37807" class="Symbol">;</a> <a id="37809" class="Symbol">(</a><a id="37810" href="1Lab.Path.html#37719" class="Bound">i</a> <a id="37812" class="Symbol">=</a> <a id="37814" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a><a id="37816" class="Symbol">)</a> <a id="37818" class="Symbol">→</a> <a id="37820" href="1Lab.Path.html#2100" class="Primitive">outS</a> <a id="37825" href="1Lab.Path.html#37716" class="Bound">u0</a> <a id="37828" class="Symbol">})</a>
       <a id="37838" class="Symbol">(</a><a id="37839" href="1Lab.Path.html#2100" class="Primitive">outS</a> <a id="37844" href="1Lab.Path.html#37716" class="Bound">u0</a><a id="37846" class="Symbol">)</a>
</pre>
<p>Given the inputs to a composition — a family of partial paths
<code>u</code> and a base <code>u0</code> —
<span class="Agda"><a href="1Lab.Path.html#35493" class="Function">hfill</a></span>
connects the input of the composition (<code>u0</code>) and the output.
The cubical shape of iterated identifications causes a slight oddity:
The only unbiased definition of path composition we can give is
<em>double composition</em>, which corresponds to the missing face for
the <a href="1Lab.Path.html#composition">square</a> at the start of this
section.</p>
<pre class="Agda"><a id="_··_··_"></a><a id="38305" href="1Lab.Path.html#38305" data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" class="Function Operator">_··_··_</a> <a id="38313" class="Symbol">:</a> <a id="38315" class="Symbol">∀</a> <a id="38317" class="Symbol">{</a><a id="38318" href="1Lab.Path.html#38318" class="Bound">ℓ</a><a id="38319" class="Symbol">}</a> <a id="38321" class="Symbol">{</a><a id="38322" href="1Lab.Path.html#38322" class="Bound">A</a> <a id="38324" class="Symbol">:</a> <a id="38326" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="38331" href="1Lab.Path.html#38318" class="Bound">ℓ</a><a id="38332" class="Symbol">}</a> <a id="38334" class="Symbol">{</a><a id="38335" href="1Lab.Path.html#38335" class="Bound">w</a> <a id="38337" href="1Lab.Path.html#38337" class="Bound">x</a> <a id="38339" href="1Lab.Path.html#38339" class="Bound">y</a> <a id="38341" href="1Lab.Path.html#38341" class="Bound">z</a> <a id="38343" class="Symbol">:</a> <a id="38345" href="1Lab.Path.html#38322" class="Bound">A</a><a id="38346" class="Symbol">}</a>
        <a id="38356" class="Symbol">→</a> <a id="38358" href="1Lab.Path.html#38335" class="Bound">w</a> <a id="38360" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="38362" href="1Lab.Path.html#38337" class="Bound">x</a> <a id="38364" class="Symbol">→</a> <a id="38366" href="1Lab.Path.html#38337" class="Bound">x</a> <a id="38368" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="38370" href="1Lab.Path.html#38339" class="Bound">y</a> <a id="38372" class="Symbol">→</a> <a id="38374" href="1Lab.Path.html#38339" class="Bound">y</a> <a id="38376" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="38378" href="1Lab.Path.html#38341" class="Bound">z</a>
        <a id="38388" class="Symbol">→</a> <a id="38390" href="1Lab.Path.html#38335" class="Bound">w</a> <a id="38392" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="38394" href="1Lab.Path.html#38341" class="Bound">z</a>
<a id="38396" class="Symbol">(</a><a id="38397" href="1Lab.Path.html#38397" class="Bound">p</a> <a id="38399" href="1Lab.Path.html#38305" data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" class="Function Operator">··</a> <a id="38402" href="1Lab.Path.html#38402" class="Bound">q</a> <a id="38404" href="1Lab.Path.html#38305" data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" class="Function Operator">··</a> <a id="38407" href="1Lab.Path.html#38407" class="Bound">r</a><a id="38408" class="Symbol">)</a> <a id="38410" href="1Lab.Path.html#38410" class="Bound">i</a> <a id="38412" class="Symbol">=</a>
  <a id="38416" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="38422" class="Symbol">(λ</a> <a id="38425" href="1Lab.Path.html#38425" class="Bound">j</a> <a id="38427" class="Symbol">→</a> <a id="38429" class="Symbol">λ</a> <a id="38431" class="Symbol">{</a> <a id="38433" class="Symbol">(</a><a id="38434" href="1Lab.Path.html#38410" class="Bound">i</a> <a id="38436" class="Symbol">=</a> <a id="38438" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a><a id="38440" class="Symbol">)</a> <a id="38442" class="Symbol">→</a> <a id="38444" href="1Lab.Path.html#38397" class="Bound">p</a> <a id="38446" class="Symbol">(</a><a id="38447" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="38449" href="1Lab.Path.html#38425" class="Bound">j</a><a id="38450" class="Symbol">)</a>
                 <a id="38469" class="Symbol">;</a> <a id="38471" class="Symbol">(</a><a id="38472" href="1Lab.Path.html#38410" class="Bound">i</a> <a id="38474" class="Symbol">=</a> <a id="38476" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a><a id="38478" class="Symbol">)</a> <a id="38480" class="Symbol">→</a> <a id="38482" href="1Lab.Path.html#38407" class="Bound">r</a> <a id="38484" href="1Lab.Path.html#38425" class="Bound">j</a> <a id="38486" class="Symbol">})</a>
        <a id="38497" class="Symbol">(</a><a id="38498" href="1Lab.Path.html#38402" class="Bound">q</a> <a id="38500" href="1Lab.Path.html#38410" class="Bound">i</a><a id="38501" class="Symbol">)</a>
</pre>
<p>Since it will be useful later, we also give an explicit name for the
filler of the double composition square.</p>
<pre class="Agda"><a id="··-filler"></a><a id="38623" href="1Lab.Path.html#38623" data-type="(p : w ≡ x) (q : x ≡ y) (r : y ≡ z) →
Square (sym p) q (p ·· q ·· r) r" class="Function">··-filler</a> <a id="38633" class="Symbol">:</a> <a id="38635" class="Symbol">∀</a> <a id="38637" class="Symbol">{</a><a id="38638" href="1Lab.Path.html#38638" class="Bound">ℓ</a><a id="38639" class="Symbol">}</a> <a id="38641" class="Symbol">{</a><a id="38642" href="1Lab.Path.html#38642" class="Bound">A</a> <a id="38644" class="Symbol">:</a> <a id="38646" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="38651" href="1Lab.Path.html#38638" class="Bound">ℓ</a><a id="38652" class="Symbol">}</a> <a id="38654" class="Symbol">{</a><a id="38655" href="1Lab.Path.html#38655" class="Bound">w</a> <a id="38657" href="1Lab.Path.html#38657" class="Bound">x</a> <a id="38659" href="1Lab.Path.html#38659" class="Bound">y</a> <a id="38661" href="1Lab.Path.html#38661" class="Bound">z</a> <a id="38663" class="Symbol">:</a> <a id="38665" href="1Lab.Path.html#38642" class="Bound">A</a><a id="38666" class="Symbol">}</a>
          <a id="38678" class="Symbol">→</a> <a id="38680" class="Symbol">(</a><a id="38681" href="1Lab.Path.html#38681" class="Bound">p</a> <a id="38683" class="Symbol">:</a> <a id="38685" href="1Lab.Path.html#38655" class="Bound">w</a> <a id="38687" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="38689" href="1Lab.Path.html#38657" class="Bound">x</a><a id="38690" class="Symbol">)</a> <a id="38692" class="Symbol">(</a><a id="38693" href="1Lab.Path.html#38693" class="Bound">q</a> <a id="38695" class="Symbol">:</a> <a id="38697" href="1Lab.Path.html#38657" class="Bound">x</a> <a id="38699" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="38701" href="1Lab.Path.html#38659" class="Bound">y</a><a id="38702" class="Symbol">)</a> <a id="38704" class="Symbol">(</a><a id="38705" href="1Lab.Path.html#38705" class="Bound">r</a> <a id="38707" class="Symbol">:</a> <a id="38709" href="1Lab.Path.html#38659" class="Bound">y</a> <a id="38711" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="38713" href="1Lab.Path.html#38661" class="Bound">z</a><a id="38714" class="Symbol">)</a>
          <a id="38726" class="Symbol">→</a> <a id="38728" href="1Lab.Path.html#9409" data-type="a00 ≡ a01 → a00 ≡ a10 → a01 ≡ a11 → a10 ≡ a11 → Type ℓ" class="Function">Square</a> <a id="38735" class="Symbol">(</a><a id="38736" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="38740" href="1Lab.Path.html#38681" class="Bound">p</a><a id="38741" class="Symbol">)</a> <a id="38743" href="1Lab.Path.html#38693" class="Bound">q</a> <a id="38745" class="Symbol">(</a><a id="38746" href="1Lab.Path.html#38681" class="Bound">p</a> <a id="38748" href="1Lab.Path.html#38305" data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" class="Function Operator">··</a> <a id="38751" href="1Lab.Path.html#38693" class="Bound">q</a> <a id="38753" href="1Lab.Path.html#38305" data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" class="Function Operator">··</a> <a id="38756" href="1Lab.Path.html#38705" class="Bound">r</a><a id="38757" class="Symbol">)</a> <a id="38759" href="1Lab.Path.html#38705" class="Bound">r</a>
<a id="38761" href="1Lab.Path.html#38623" data-type="(p : w ≡ x) (q : x ≡ y) (r : y ≡ z) →
Square (sym p) q (p ·· q ·· r) r" class="Function">··-filler</a> <a id="38771" href="1Lab.Path.html#38771" class="Bound">p</a> <a id="38773" href="1Lab.Path.html#38773" class="Bound">q</a> <a id="38775" href="1Lab.Path.html#38775" class="Bound">r</a> <a id="38777" href="1Lab.Path.html#38777" class="Bound">i</a> <a id="38779" href="1Lab.Path.html#38779" class="Bound">j</a> <a id="38781" class="Symbol">=</a>
  <a id="38785" href="1Lab.Path.html#35493" data-type="(u : I → Partial φ A) (u0 : A [ φ ↦ u i0 ]) →
outS u0 ≡ hcomp u (outS u0)" class="Function">hfill</a> <a id="38791" class="Symbol">(λ</a> <a id="38794" href="1Lab.Path.html#38794" class="Bound">k</a> <a id="38796" class="Symbol">→</a> <a id="38798" class="Symbol">λ</a> <a id="38800" class="Symbol">{</a> <a id="38802" class="Symbol">(</a><a id="38803" href="1Lab.Path.html#38779" class="Bound">j</a> <a id="38805" class="Symbol">=</a> <a id="38807" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a><a id="38809" class="Symbol">)</a> <a id="38811" class="Symbol">→</a> <a id="38813" href="1Lab.Path.html#38771" class="Bound">p</a> <a id="38815" class="Symbol">(</a><a id="38816" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="38818" href="1Lab.Path.html#38794" class="Bound">k</a><a id="38819" class="Symbol">)</a>
                 <a id="38838" class="Symbol">;</a> <a id="38840" class="Symbol">(</a><a id="38841" href="1Lab.Path.html#38779" class="Bound">j</a> <a id="38843" class="Symbol">=</a> <a id="38845" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a><a id="38847" class="Symbol">)</a> <a id="38849" class="Symbol">→</a> <a id="38851" href="1Lab.Path.html#38775" class="Bound">r</a> <a id="38853" href="1Lab.Path.html#38794" class="Bound">k</a> <a id="38855" class="Symbol">})</a>
        <a id="38866" class="Symbol">(</a><a id="38867" href="1Lab.Path.html#2069" class="Postulate">inS</a> <a id="38871" class="Symbol">(</a><a id="38872" href="1Lab.Path.html#38773" class="Bound">q</a> <a id="38874" href="1Lab.Path.html#38779" class="Bound">j</a><a id="38875" class="Symbol">))</a> <a id="38878" href="1Lab.Path.html#38777" class="Bound">i</a>
</pre>
<p>We can define the ordinary, single composition by taking
<code>p = refl</code>, as is done below. The square associated with the
binary composition operation is obtained as the same open box at the
start of the section, the same
<span class="Agda"><a href="1Lab.Path.html#33257" class="Function">double-comp-tube</a></span>,
but by setting any of the faces to be reflexivity. For definiteness, we
chose the left face:</p>
<div class="diagram-container">
<img src="light-5622d691d0f13745b0c402e20b953eed68026ee0.svg" title="commutative diagram" class="diagram diagram-light quiver" />
<img src="dark-5622d691d0f13745b0c402e20b953eed68026ee0.svg" title="commutative diagram" class="diagram diagram-dark quiver" />
</div>
<pre class="Agda"><a id="_∙_"></a><a id="39472" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">_∙_</a> <a id="39476" class="Symbol">:</a> <a id="39478" class="Symbol">∀</a> <a id="39480" class="Symbol">{</a><a id="39481" href="1Lab.Path.html#39481" class="Bound">ℓ</a><a id="39482" class="Symbol">}</a> <a id="39484" class="Symbol">{</a><a id="39485" href="1Lab.Path.html#39485" class="Bound">A</a> <a id="39487" class="Symbol">:</a> <a id="39489" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="39494" href="1Lab.Path.html#39481" class="Bound">ℓ</a><a id="39495" class="Symbol">}</a> <a id="39497" class="Symbol">{</a><a id="39498" href="1Lab.Path.html#39498" class="Bound">x</a> <a id="39500" href="1Lab.Path.html#39500" class="Bound">y</a> <a id="39502" href="1Lab.Path.html#39502" class="Bound">z</a> <a id="39504" class="Symbol">:</a> <a id="39506" href="1Lab.Path.html#39485" class="Bound">A</a><a id="39507" class="Symbol">}</a>
    <a id="39513" class="Symbol">→</a> <a id="39515" href="1Lab.Path.html#39498" class="Bound">x</a> <a id="39517" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="39519" href="1Lab.Path.html#39500" class="Bound">y</a> <a id="39521" class="Symbol">→</a> <a id="39523" href="1Lab.Path.html#39500" class="Bound">y</a> <a id="39525" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="39527" href="1Lab.Path.html#39502" class="Bound">z</a> <a id="39529" class="Symbol">→</a> <a id="39531" href="1Lab.Path.html#39498" class="Bound">x</a> <a id="39533" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="39535" href="1Lab.Path.html#39502" class="Bound">z</a>
<a id="39537" href="1Lab.Path.html#39537" class="Bound">p</a> <a id="39539" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="39541" href="1Lab.Path.html#39541" class="Bound">q</a> <a id="39543" class="Symbol">=</a> <a id="39545" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="39550" href="1Lab.Path.html#38305" data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" class="Function Operator">··</a> <a id="39553" href="1Lab.Path.html#39537" class="Bound">p</a> <a id="39555" href="1Lab.Path.html#38305" data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" class="Function Operator">··</a> <a id="39558" href="1Lab.Path.html#39541" class="Bound">q</a>
</pre>
<p>The ordinary, “single composite” of
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>
and
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span>
is the dashed face in the diagram above. Since we bound
<span class="Agda"><a href="1Lab.Path.html#38623" class="Function">··-filler</a></span>
above, and defined
<span class="Agda"><a href="1Lab.Path.html#39472" class="Function Operator">_∙_</a></span>
in terms of
<span class="Agda"><a href="1Lab.Path.html#38305" class="Function Operator">_··_··_</a></span>,
we can reuse the latter’s filler to get one for the former:</p>
<pre class="Agda"><a id="∙-filler"></a><a id="39820" href="1Lab.Path.html#39820" data-type="(p : x ≡ y) (q : y ≡ z) → Square refl p (p ∙ q) q" class="Function">∙-filler</a> <a id="39829" class="Symbol">:</a> <a id="39831" class="Symbol">∀</a> <a id="39833" class="Symbol">{</a><a id="39834" href="1Lab.Path.html#39834" class="Bound">ℓ</a><a id="39835" class="Symbol">}</a> <a id="39837" class="Symbol">{</a><a id="39838" href="1Lab.Path.html#39838" class="Bound">A</a> <a id="39840" class="Symbol">:</a> <a id="39842" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="39847" href="1Lab.Path.html#39834" class="Bound">ℓ</a><a id="39848" class="Symbol">}</a> <a id="39850" class="Symbol">{</a><a id="39851" href="1Lab.Path.html#39851" class="Bound">x</a> <a id="39853" href="1Lab.Path.html#39853" class="Bound">y</a> <a id="39855" href="1Lab.Path.html#39855" class="Bound">z</a> <a id="39857" class="Symbol">:</a> <a id="39859" href="1Lab.Path.html#39838" class="Bound">A</a><a id="39860" class="Symbol">}</a>
         <a id="39871" class="Symbol">→</a> <a id="39873" class="Symbol">(</a><a id="39874" href="1Lab.Path.html#39874" class="Bound">p</a> <a id="39876" class="Symbol">:</a> <a id="39878" href="1Lab.Path.html#39851" class="Bound">x</a> <a id="39880" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="39882" href="1Lab.Path.html#39853" class="Bound">y</a><a id="39883" class="Symbol">)</a> <a id="39885" class="Symbol">(</a><a id="39886" href="1Lab.Path.html#39886" class="Bound">q</a> <a id="39888" class="Symbol">:</a> <a id="39890" href="1Lab.Path.html#39853" class="Bound">y</a> <a id="39892" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="39894" href="1Lab.Path.html#39855" class="Bound">z</a><a id="39895" class="Symbol">)</a>
         <a id="39906" class="Symbol">→</a> <a id="39908" href="1Lab.Path.html#9409" data-type="a00 ≡ a01 → a00 ≡ a10 → a01 ≡ a11 → a10 ≡ a11 → Type ℓ" class="Function">Square</a> <a id="39915" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="39920" href="1Lab.Path.html#39874" class="Bound">p</a> <a id="39922" class="Symbol">(</a><a id="39923" href="1Lab.Path.html#39874" class="Bound">p</a> <a id="39925" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="39927" href="1Lab.Path.html#39886" class="Bound">q</a><a id="39928" class="Symbol">)</a> <a id="39930" href="1Lab.Path.html#39886" class="Bound">q</a>
<a id="39932" href="1Lab.Path.html#39820" data-type="(p : x ≡ y) (q : y ≡ z) → Square refl p (p ∙ q) q" class="Function">∙-filler</a> <a id="39941" class="Symbol">{</a><a id="39942" class="Argument">x</a> <a id="39944" class="Symbol">=</a> <a id="39946" href="1Lab.Path.html#39946" class="Bound">x</a><a id="39947" class="Symbol">}</a> <a id="39949" class="Symbol">{</a><a id="39950" href="1Lab.Path.html#39950" class="Bound">y</a><a id="39951" class="Symbol">}</a> <a id="39953" class="Symbol">{</a><a id="39954" href="1Lab.Path.html#39954" class="Bound">z</a><a id="39955" class="Symbol">}</a> <a id="39957" href="1Lab.Path.html#39957" class="Bound">p</a> <a id="39959" href="1Lab.Path.html#39959" class="Bound">q</a> <a id="39961" class="Symbol">=</a> <a id="39963" href="1Lab.Path.html#38623" data-type="(p : w ≡ x) (q : x ≡ y) (r : y ≡ z) →
Square (sym p) q (p ·· q ·· r) r" class="Function">··-filler</a> <a id="39973" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="39978" href="1Lab.Path.html#39957" class="Bound">p</a> <a id="39980" href="1Lab.Path.html#39959" class="Bound">q</a>
</pre>
<p>The single composition has a filler “in the other direction”, which
connects
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span>
and
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>∙</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">p \bullet q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∙</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span>.</span>
This is, essentially, because the choice of setting the left face to
<span class="Agda"><a href="1Lab.Path.html#3593" class="Function">refl</a></span>
was completely arbitrary in the definition of
<span class="Agda"><a href="1Lab.Path.html#39472" class="Function Operator">_∙_</a></span>:
we could just as well have gone with setting the <em>right</em> face to
<span class="Agda"><a href="1Lab.Path.html#3593" class="Function">refl</a></span>.</p>
<pre class="Agda"><a id="∙-filler&#39;"></a><a id="40319" href="1Lab.Path.html#40319" data-type="(p : x ≡ y) (q : y ≡ z) → Square (sym p) q (p ∙ q) refl" class="Function">∙-filler&#39;</a> <a id="40329" class="Symbol">:</a> <a id="40331" class="Symbol">∀</a> <a id="40333" class="Symbol">{</a><a id="40334" href="1Lab.Path.html#40334" class="Bound">ℓ</a><a id="40335" class="Symbol">}</a> <a id="40337" class="Symbol">{</a><a id="40338" href="1Lab.Path.html#40338" class="Bound">A</a> <a id="40340" class="Symbol">:</a> <a id="40342" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="40347" href="1Lab.Path.html#40334" class="Bound">ℓ</a><a id="40348" class="Symbol">}</a> <a id="40350" class="Symbol">{</a><a id="40351" href="1Lab.Path.html#40351" class="Bound">x</a> <a id="40353" href="1Lab.Path.html#40353" class="Bound">y</a> <a id="40355" href="1Lab.Path.html#40355" class="Bound">z</a> <a id="40357" class="Symbol">:</a> <a id="40359" href="1Lab.Path.html#40338" class="Bound">A</a><a id="40360" class="Symbol">}</a>
          <a id="40372" class="Symbol">→</a> <a id="40374" class="Symbol">(</a><a id="40375" href="1Lab.Path.html#40375" class="Bound">p</a> <a id="40377" class="Symbol">:</a> <a id="40379" href="1Lab.Path.html#40351" class="Bound">x</a> <a id="40381" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="40383" href="1Lab.Path.html#40353" class="Bound">y</a><a id="40384" class="Symbol">)</a> <a id="40386" class="Symbol">(</a><a id="40387" href="1Lab.Path.html#40387" class="Bound">q</a> <a id="40389" class="Symbol">:</a> <a id="40391" href="1Lab.Path.html#40353" class="Bound">y</a> <a id="40393" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="40395" href="1Lab.Path.html#40355" class="Bound">z</a><a id="40396" class="Symbol">)</a>
          <a id="40408" class="Symbol">→</a> <a id="40410" href="1Lab.Path.html#9409" data-type="a00 ≡ a01 → a00 ≡ a10 → a01 ≡ a11 → a10 ≡ a11 → Type ℓ" class="Function">Square</a> <a id="40417" class="Symbol">(</a><a id="40418" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="40422" href="1Lab.Path.html#40375" class="Bound">p</a><a id="40423" class="Symbol">)</a> <a id="40425" href="1Lab.Path.html#40387" class="Bound">q</a> <a id="40427" class="Symbol">(</a><a id="40428" href="1Lab.Path.html#40375" class="Bound">p</a> <a id="40430" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="40432" href="1Lab.Path.html#40387" class="Bound">q</a><a id="40433" class="Symbol">)</a> <a id="40435" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
<a id="40440" href="1Lab.Path.html#40319" data-type="(p : x ≡ y) (q : y ≡ z) → Square (sym p) q (p ∙ q) refl" class="Function">∙-filler&#39;</a> <a id="40450" class="Symbol">{</a><a id="40451" class="Argument">x</a> <a id="40453" class="Symbol">=</a> <a id="40455" href="1Lab.Path.html#40455" class="Bound">x</a><a id="40456" class="Symbol">}</a> <a id="40458" class="Symbol">{</a><a id="40459" href="1Lab.Path.html#40459" class="Bound">y</a><a id="40460" class="Symbol">}</a> <a id="40462" class="Symbol">{</a><a id="40463" href="1Lab.Path.html#40463" class="Bound">z</a><a id="40464" class="Symbol">}</a> <a id="40466" href="1Lab.Path.html#40466" class="Bound">p</a> <a id="40468" href="1Lab.Path.html#40468" class="Bound">q</a> <a id="40470" href="1Lab.Path.html#40470" class="Bound">j</a> <a id="40472" href="1Lab.Path.html#40472" class="Bound">i</a> <a id="40474" class="Symbol">=</a>
  <a id="40478" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="40484" class="Symbol">(λ</a> <a id="40487" href="1Lab.Path.html#40487" class="Bound">k</a> <a id="40489" class="Symbol">→</a> <a id="40491" class="Symbol">λ</a> <a id="40493" class="Symbol">{</a> <a id="40495" class="Symbol">(</a><a id="40496" href="1Lab.Path.html#40472" class="Bound">i</a> <a id="40498" class="Symbol">=</a> <a id="40500" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a><a id="40502" class="Symbol">)</a> <a id="40504" class="Symbol">→</a> <a id="40506" href="1Lab.Path.html#40466" class="Bound">p</a> <a id="40508" class="Symbol">(</a><a id="40509" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="40511" href="1Lab.Path.html#40470" class="Bound">j</a><a id="40512" class="Symbol">)</a>
                 <a id="40531" class="Symbol">;</a> <a id="40533" class="Symbol">(</a><a id="40534" href="1Lab.Path.html#40472" class="Bound">i</a> <a id="40536" class="Symbol">=</a> <a id="40538" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a><a id="40540" class="Symbol">)</a> <a id="40542" class="Symbol">→</a> <a id="40544" href="1Lab.Path.html#40468" class="Bound">q</a> <a id="40546" href="1Lab.Path.html#40487" class="Bound">k</a>
                 <a id="40565" class="Symbol">;</a> <a id="40567" class="Symbol">(</a><a id="40568" href="1Lab.Path.html#40470" class="Bound">j</a> <a id="40570" class="Symbol">=</a> <a id="40572" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a><a id="40574" class="Symbol">)</a> <a id="40576" class="Symbol">→</a> <a id="40578" href="1Lab.Path.html#40468" class="Bound">q</a> <a id="40580" class="Symbol">(</a><a id="40581" href="1Lab.Path.html#40472" class="Bound">i</a> <a id="40583" href="1Lab.Path.html#2191" class="Primitive Operator">∧</a> <a id="40585" href="1Lab.Path.html#40487" class="Bound">k</a><a id="40586" class="Symbol">)</a> <a id="40588" class="Symbol">})</a>
        <a id="40599" class="Symbol">(</a><a id="40600" href="1Lab.Path.html#40466" class="Bound">p</a> <a id="40602" class="Symbol">(</a><a id="40603" href="1Lab.Path.html#40472" class="Bound">i</a> <a id="40605" href="1Lab.Path.html#2226" class="Primitive Operator">∨</a> <a id="40607" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="40609" href="1Lab.Path.html#40470" class="Bound">j</a><a id="40610" class="Symbol">))</a>
</pre>
<h2 id="uniqueness"><a href="#uniqueness" class="header-link">Uniqueness<span class="header-link-emoji">🔗</span></a></h2>
<p>A common characteristic of <em>geometric</em> interpretations of
higher categories — like the one we have here — when compared to
algebraic definitions is that there is no prescription in general for
how to find composites of morphisms. Instead, we have that each triple
of morphism has a <em>contractible space</em> of composites. We call the
proof of this fact
<span class="Agda"><a href="1Lab.Path.html#41015" class="Function">··-unique</a></span>:</p>
<pre class="Agda"><a id="··-unique"></a><a id="41015" href="1Lab.Path.html#41015" data-type="(p : w ≡ x) (q : x ≡ y) (r : y ≡ z)
(α β : Σ (λ s → Square (sym p) q s r)) →
α ≡ β" class="Function">··-unique</a> <a id="41025" class="Symbol">:</a> <a id="41027" class="Symbol">∀</a> <a id="41029" class="Symbol">{</a><a id="41030" href="1Lab.Path.html#41030" class="Bound">ℓ</a><a id="41031" class="Symbol">}</a> <a id="41033" class="Symbol">{</a><a id="41034" href="1Lab.Path.html#41034" class="Bound">A</a> <a id="41036" class="Symbol">:</a> <a id="41038" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="41043" href="1Lab.Path.html#41030" class="Bound">ℓ</a><a id="41044" class="Symbol">}</a> <a id="41046" class="Symbol">{</a><a id="41047" href="1Lab.Path.html#41047" class="Bound">w</a> <a id="41049" href="1Lab.Path.html#41049" class="Bound">x</a> <a id="41051" href="1Lab.Path.html#41051" class="Bound">y</a> <a id="41053" href="1Lab.Path.html#41053" class="Bound">z</a> <a id="41055" class="Symbol">:</a> <a id="41057" href="1Lab.Path.html#41034" class="Bound">A</a><a id="41058" class="Symbol">}</a>
          <a id="41070" class="Symbol">→</a> <a id="41072" class="Symbol">(</a><a id="41073" href="1Lab.Path.html#41073" class="Bound">p</a> <a id="41075" class="Symbol">:</a> <a id="41077" href="1Lab.Path.html#41047" class="Bound">w</a> <a id="41079" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="41081" href="1Lab.Path.html#41049" class="Bound">x</a><a id="41082" class="Symbol">)</a> <a id="41084" class="Symbol">(</a><a id="41085" href="1Lab.Path.html#41085" class="Bound">q</a> <a id="41087" class="Symbol">:</a> <a id="41089" href="1Lab.Path.html#41049" class="Bound">x</a> <a id="41091" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="41093" href="1Lab.Path.html#41051" class="Bound">y</a><a id="41094" class="Symbol">)</a> <a id="41096" class="Symbol">(</a><a id="41097" href="1Lab.Path.html#41097" class="Bound">r</a> <a id="41099" class="Symbol">:</a> <a id="41101" href="1Lab.Path.html#41051" class="Bound">y</a> <a id="41103" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="41105" href="1Lab.Path.html#41053" class="Bound">z</a><a id="41106" class="Symbol">)</a>
          <a id="41118" class="Symbol">→</a> <a id="41120" class="Symbol">(</a><a id="41121" href="1Lab.Path.html#41121" class="Bound">α</a> <a id="41123" href="1Lab.Path.html#41123" class="Bound">β</a> <a id="41125" class="Symbol">:</a> <a id="41127" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">Σ[</a> <a id="41130" href="1Lab.Path.html#41130" class="Bound">s</a> <a id="41132" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">∈</a> <a id="41134" class="Symbol">(</a><a id="41135" href="1Lab.Path.html#41047" class="Bound">w</a> <a id="41137" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="41139" href="1Lab.Path.html#41053" class="Bound">z</a><a id="41140" class="Symbol">)</a> <a id="41142" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">]</a> <a id="41144" href="1Lab.Path.html#9409" data-type="a00 ≡ a01 → a00 ≡ a10 → a01 ≡ a11 → a10 ≡ a11 → Type ℓ" class="Function">Square</a> <a id="41151" class="Symbol">(</a><a id="41152" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="41156" href="1Lab.Path.html#41073" class="Bound">p</a><a id="41157" class="Symbol">)</a> <a id="41159" href="1Lab.Path.html#41085" class="Bound">q</a> <a id="41161" href="1Lab.Path.html#41130" class="Bound">s</a> <a id="41163" href="1Lab.Path.html#41097" class="Bound">r</a><a id="41164" class="Symbol">)</a>
          <a id="41176" class="Symbol">→</a> <a id="41178" href="1Lab.Path.html#41121" class="Bound">α</a> <a id="41180" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="41182" href="1Lab.Path.html#41123" class="Bound">β</a>
</pre>
<p>Note that the type of <code>α</code> and <code>β</code> asks for a
path <code>w ≡ z</code> which <em>specifically</em> completes the open
box for double composition. We would not in general expect that
<code>w ≡ z</code> is contractible for an arbitrary <code>a</code>! Note
that the proof of this involves filling a cube in a context that
<em>already</em> has an interval variable in scope - a hypercube!</p>
<pre class="Agda"><a id="41535" href="1Lab.Path.html#41015" data-type="(p : w ≡ x) (q : x ≡ y) (r : y ≡ z)
(α β : Σ (λ s → Square (sym p) q s r)) →
α ≡ β" class="Function">··-unique</a> <a id="41545" class="Symbol">{</a><a id="41546" class="Argument">w</a> <a id="41548" class="Symbol">=</a> <a id="41550" href="1Lab.Path.html#41550" class="Bound">w</a><a id="41551" class="Symbol">}</a> <a id="41553" class="Symbol">{</a><a id="41554" href="1Lab.Path.html#41554" class="Bound">x</a><a id="41555" class="Symbol">}</a> <a id="41557" class="Symbol">{</a><a id="41558" href="1Lab.Path.html#41558" class="Bound">y</a><a id="41559" class="Symbol">}</a> <a id="41561" class="Symbol">{</a><a id="41562" href="1Lab.Path.html#41562" class="Bound">z</a><a id="41563" class="Symbol">}</a> <a id="41565" href="1Lab.Path.html#41565" class="Bound">p</a> <a id="41567" href="1Lab.Path.html#41567" class="Bound">q</a> <a id="41569" href="1Lab.Path.html#41569" class="Bound">r</a> <a id="41571" class="Symbol">(</a><a id="41572" href="1Lab.Path.html#41572" class="Bound">α</a> <a id="41574" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="41576" href="1Lab.Path.html#41576" class="Bound">α-fill</a><a id="41582" class="Symbol">)</a> <a id="41584" class="Symbol">(</a><a id="41585" href="1Lab.Path.html#41585" class="Bound">β</a> <a id="41587" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="41589" href="1Lab.Path.html#41589" class="Bound">β-fill</a><a id="41595" class="Symbol">)</a> <a id="41597" class="Symbol">=</a>
  <a id="41601" class="Symbol">λ</a> <a id="41603" href="1Lab.Path.html#41603" class="Bound">i</a> <a id="41605" class="Symbol">→</a> <a id="41607" class="Symbol">(λ</a> <a id="41610" href="1Lab.Path.html#41610" class="Bound">j</a> <a id="41612" class="Symbol">→</a> <a id="41614" href="1Lab.Path.html#41936" data-type="(p : w ≡ x) (q : x ≡ y) (r : y ≡ z) (α : w ≡ z)
(α-fill : Square (sym p) q α r) (β : w ≡ z)
(β-fill : Square (sym p) q β r) →
α ≡ β" class="Function">square</a> <a id="41621" href="1Lab.Path.html#41603" class="Bound">i</a> <a id="41623" href="1Lab.Path.html#41610" class="Bound">j</a><a id="41624" class="Symbol">)</a> <a id="41626" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="41628" class="Symbol">(λ</a> <a id="41631" href="1Lab.Path.html#41631" class="Bound">j</a> <a id="41633" href="1Lab.Path.html#41633" class="Bound">k</a> <a id="41635" class="Symbol">→</a> <a id="41637" href="1Lab.Path.html#41661" data-type="(p : w ≡ x) (q : x ≡ y) (r : y ≡ z) (α : w ≡ z) →
Square (sym p) q α r →
(β : w ≡ z) → Square (sym p) q β r → I → (j : I) → p (~ j) ≡ r j" class="Function">cube</a> <a id="41642" href="1Lab.Path.html#41603" class="Bound">i</a> <a id="41644" href="1Lab.Path.html#41631" class="Bound">j</a> <a id="41646" href="1Lab.Path.html#41633" class="Bound">k</a><a id="41647" class="Symbol">)</a>
  <a id="41651" class="Keyword">where</a>
    <a id="41661" href="1Lab.Path.html#41661" data-type="(p : w ≡ x) (q : x ≡ y) (r : y ≡ z) (α : w ≡ z) →
Square (sym p) q α r →
(β : w ≡ z) → Square (sym p) q β r → I → (j : I) → p (~ j) ≡ r j" class="Function">cube</a> <a id="41666" class="Symbol">:</a> <a id="41668" class="Symbol">(</a><a id="41669" href="1Lab.Path.html#41669" class="Bound">i</a> <a id="41671" href="1Lab.Path.html#41671" class="Bound">j</a> <a id="41673" class="Symbol">:</a> <a id="41675" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a><a id="41676" class="Symbol">)</a> <a id="41678" class="Symbol">→</a> <a id="41680" href="1Lab.Path.html#41565" class="Bound">p</a> <a id="41682" class="Symbol">(</a><a id="41683" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="41685" href="1Lab.Path.html#41671" class="Bound">j</a><a id="41686" class="Symbol">)</a> <a id="41688" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="41690" href="1Lab.Path.html#41569" class="Bound">r</a> <a id="41692" href="1Lab.Path.html#41671" class="Bound">j</a>
    <a id="41698" href="1Lab.Path.html#41661" data-type="(p : w ≡ x) (q : x ≡ y) (r : y ≡ z) (α : w ≡ z) →
Square (sym p) q α r →
(β : w ≡ z) → Square (sym p) q β r → I → (j : I) → p (~ j) ≡ r j" class="Function">cube</a> <a id="41703" href="1Lab.Path.html#41703" class="Bound">i</a> <a id="41705" href="1Lab.Path.html#41705" class="Bound">j</a> <a id="41707" href="1Lab.Path.html#41707" class="Bound">k</a> <a id="41709" class="Symbol">=</a>
      <a id="41717" href="1Lab.Path.html#35493" data-type="(u : I → Partial φ A) (u0 : A [ φ ↦ u i0 ]) →
outS u0 ≡ hcomp u (outS u0)" class="Function">hfill</a> <a id="41723" class="Symbol">(λ</a> <a id="41726" href="1Lab.Path.html#41726" class="Bound">l</a> <a id="41728" class="Symbol">→</a> <a id="41730" class="Symbol">λ</a> <a id="41732" class="Symbol">{</a> <a id="41734" class="Symbol">(</a><a id="41735" href="1Lab.Path.html#41703" class="Bound">i</a> <a id="41737" class="Symbol">=</a> <a id="41739" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a><a id="41741" class="Symbol">)</a> <a id="41743" class="Symbol">→</a> <a id="41745" href="1Lab.Path.html#41576" class="Bound">α-fill</a> <a id="41752" href="1Lab.Path.html#41726" class="Bound">l</a> <a id="41754" href="1Lab.Path.html#41707" class="Bound">k</a>
                     <a id="41777" class="Symbol">;</a> <a id="41779" class="Symbol">(</a><a id="41780" href="1Lab.Path.html#41703" class="Bound">i</a> <a id="41782" class="Symbol">=</a> <a id="41784" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a><a id="41786" class="Symbol">)</a> <a id="41788" class="Symbol">→</a> <a id="41790" href="1Lab.Path.html#41589" class="Bound">β-fill</a> <a id="41797" href="1Lab.Path.html#41726" class="Bound">l</a> <a id="41799" href="1Lab.Path.html#41707" class="Bound">k</a>
                     <a id="41822" class="Symbol">;</a> <a id="41824" class="Symbol">(</a><a id="41825" href="1Lab.Path.html#41707" class="Bound">k</a> <a id="41827" class="Symbol">=</a> <a id="41829" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a><a id="41831" class="Symbol">)</a> <a id="41833" class="Symbol">→</a> <a id="41835" href="1Lab.Path.html#41565" class="Bound">p</a> <a id="41837" class="Symbol">(</a><a id="41838" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="41840" href="1Lab.Path.html#41726" class="Bound">l</a><a id="41841" class="Symbol">)</a>
                     <a id="41864" class="Symbol">;</a> <a id="41866" class="Symbol">(</a><a id="41867" href="1Lab.Path.html#41707" class="Bound">k</a> <a id="41869" class="Symbol">=</a> <a id="41871" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a><a id="41873" class="Symbol">)</a> <a id="41875" class="Symbol">→</a> <a id="41877" href="1Lab.Path.html#41569" class="Bound">r</a> <a id="41879" href="1Lab.Path.html#41726" class="Bound">l</a>
                     <a id="41902" class="Symbol">})</a>
            <a id="41917" class="Symbol">(</a><a id="41918" href="1Lab.Path.html#2069" class="Postulate">inS</a> <a id="41922" class="Symbol">(</a><a id="41923" href="1Lab.Path.html#41567" class="Bound">q</a> <a id="41925" href="1Lab.Path.html#41707" class="Bound">k</a><a id="41926" class="Symbol">))</a> <a id="41929" href="1Lab.Path.html#41705" class="Bound">j</a>

    <a id="41936" href="1Lab.Path.html#41936" data-type="(p : w ≡ x) (q : x ≡ y) (r : y ≡ z) (α : w ≡ z)
(α-fill : Square (sym p) q α r) (β : w ≡ z)
(β-fill : Square (sym p) q β r) →
α ≡ β" class="Function">square</a> <a id="41943" class="Symbol">:</a> <a id="41945" href="1Lab.Path.html#41572" class="Bound">α</a> <a id="41947" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="41949" href="1Lab.Path.html#41585" class="Bound">β</a>
    <a id="41955" href="1Lab.Path.html#41936" data-type="(p : w ≡ x) (q : x ≡ y) (r : y ≡ z) (α : w ≡ z)
(α-fill : Square (sym p) q α r) (β : w ≡ z)
(β-fill : Square (sym p) q β r) →
α ≡ β" class="Function">square</a> <a id="41962" href="1Lab.Path.html#41962" class="Bound">i</a> <a id="41964" href="1Lab.Path.html#41964" class="Bound">j</a> <a id="41966" class="Symbol">=</a> <a id="41968" href="1Lab.Path.html#41661" data-type="(p : w ≡ x) (q : x ≡ y) (r : y ≡ z) (α : w ≡ z) →
Square (sym p) q α r →
(β : w ≡ z) → Square (sym p) q β r → I → (j : I) → p (~ j) ≡ r j" class="Function">cube</a> <a id="41973" href="1Lab.Path.html#41962" class="Bound">i</a> <a id="41975" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a> <a id="41978" href="1Lab.Path.html#41964" class="Bound">j</a>
</pre>
<p>The term <code>cube</code> above has the following cube as a
boundary. Since it is a filler, there is a missing face at the bottom
which has no name, so we denote it by <code>hcomp...</code> in the
diagram.</p>
<div class="diagram-container">
<img src="light-83e814dbdd4ad3b3d046557af54435bc81c0ccd8.svg" title="commutative diagram" class="diagram diagram-light quiver tall-2" />
<img src="dark-83e814dbdd4ad3b3d046557af54435bc81c0ccd8.svg" title="commutative diagram" class="diagram diagram-dark quiver tall-2" />
</div>
<p>This diagram is quite busy because it is a 3D commutative diagram,
but it could be busier: all of the unimportant edges were not annotated.
By the way, the lavender face (including the lavender
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mtext> </mtext><mi mathvariant="normal">¬</mi><mi>j</mi></mrow><annotation encoding="application/x-tex">p\ \neg j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace"> </span><span class="mord">¬</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>)</span>
is the
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mrow><mi mathvariant="normal">i</mi><mn>0</mn></mrow></mrow><annotation encoding="application/x-tex">k = \id{i0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i0</span></span></span></span></span>
face, and the red face is the
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mrow><mi mathvariant="normal">i</mi><mn>1</mn></mrow></mrow><annotation encoding="application/x-tex">k = \id{i1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i1</span></span></span></span></span>
face.</p>
<p>However, even though the diagram is very busy, most of the detail it
contains can be ignored. Reading it in the left-right direction, it
expresses an identification between <code>α-filler j k</code> and
<code>β-filler j k</code>, lying over a homotopy <code>α = β</code>.
That homotopy is what you get when you read the bottom square of the
diagram in the left-right direction. Explicitly, here is that bottom
square:</p>
<div class="diagram-container">
<img src="light-b3ce0946d02e131a8ccfe48417469ce06d3fc69c.svg" title="commutative diagram" class="diagram diagram-light quiver" />
<img src="dark-b3ce0946d02e131a8ccfe48417469ce06d3fc69c.svg" title="commutative diagram" class="diagram diagram-dark quiver" />
</div>
<p>Note that, exceptionally, this diagram is drawn with the left/right
edges going up rather than down. This is to match the direction of the
3D diagram above. The colours are also matching.</p>
<p>Readers who are already familiar with the notion of h-level will have
noticed that the proof
<span class="Agda"><a href="1Lab.Path.html#41015" class="Function">··-unique</a></span>
expresses that the type of double composites <code>p ·· q ·· r</code> is
a <em>proposition</em>, not that it is contractible. However, since it
is inhabited (by
<span class="Agda"><a href="1Lab.Path.html#38305" class="Function Operator">_··_··_</a></span>
and its filler), it is contractible:</p>
<pre class="Agda"><a id="··-contract"></a><a id="46109" href="1Lab.Path.html#46109" data-type="(p : w ≡ x) (q : x ≡ y) (r : y ≡ z)
(β : Σ (λ s → Square (sym p) q s r)) →
((p ·· q ·· r) , ··-filler p q r) ≡ β" class="Function">··-contract</a> <a id="46121" class="Symbol">:</a> <a id="46123" class="Symbol">∀</a> <a id="46125" class="Symbol">{</a><a id="46126" href="1Lab.Path.html#46126" class="Bound">ℓ</a><a id="46127" class="Symbol">}</a> <a id="46129" class="Symbol">{</a><a id="46130" href="1Lab.Path.html#46130" class="Bound">A</a> <a id="46132" class="Symbol">:</a> <a id="46134" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="46139" href="1Lab.Path.html#46126" class="Bound">ℓ</a><a id="46140" class="Symbol">}</a> <a id="46142" class="Symbol">{</a><a id="46143" href="1Lab.Path.html#46143" class="Bound">w</a> <a id="46145" href="1Lab.Path.html#46145" class="Bound">x</a> <a id="46147" href="1Lab.Path.html#46147" class="Bound">y</a> <a id="46149" href="1Lab.Path.html#46149" class="Bound">z</a> <a id="46151" class="Symbol">:</a> <a id="46153" href="1Lab.Path.html#46130" class="Bound">A</a><a id="46154" class="Symbol">}</a>
            <a id="46168" class="Symbol">→</a> <a id="46170" class="Symbol">(</a><a id="46171" href="1Lab.Path.html#46171" class="Bound">p</a> <a id="46173" class="Symbol">:</a> <a id="46175" href="1Lab.Path.html#46143" class="Bound">w</a> <a id="46177" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="46179" href="1Lab.Path.html#46145" class="Bound">x</a><a id="46180" class="Symbol">)</a> <a id="46182" class="Symbol">(</a><a id="46183" href="1Lab.Path.html#46183" class="Bound">q</a> <a id="46185" class="Symbol">:</a> <a id="46187" href="1Lab.Path.html#46145" class="Bound">x</a> <a id="46189" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="46191" href="1Lab.Path.html#46147" class="Bound">y</a><a id="46192" class="Symbol">)</a> <a id="46194" class="Symbol">(</a><a id="46195" href="1Lab.Path.html#46195" class="Bound">r</a> <a id="46197" class="Symbol">:</a> <a id="46199" href="1Lab.Path.html#46147" class="Bound">y</a> <a id="46201" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="46203" href="1Lab.Path.html#46149" class="Bound">z</a><a id="46204" class="Symbol">)</a>
            <a id="46218" class="Symbol">→</a> <a id="46220" class="Symbol">(</a><a id="46221" href="1Lab.Path.html#46221" class="Bound">β</a> <a id="46223" class="Symbol">:</a> <a id="46225" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">Σ[</a> <a id="46228" href="1Lab.Path.html#46228" class="Bound">s</a> <a id="46230" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">∈</a> <a id="46232" class="Symbol">(</a><a id="46233" href="1Lab.Path.html#46143" class="Bound">w</a> <a id="46235" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="46237" href="1Lab.Path.html#46149" class="Bound">z</a><a id="46238" class="Symbol">)</a> <a id="46240" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">]</a> <a id="46242" href="1Lab.Path.html#9409" data-type="a00 ≡ a01 → a00 ≡ a10 → a01 ≡ a11 → a10 ≡ a11 → Type ℓ" class="Function">Square</a> <a id="46249" class="Symbol">(</a><a id="46250" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="46254" href="1Lab.Path.html#46171" class="Bound">p</a><a id="46255" class="Symbol">)</a> <a id="46257" href="1Lab.Path.html#46183" class="Bound">q</a> <a id="46259" href="1Lab.Path.html#46228" class="Bound">s</a> <a id="46261" href="1Lab.Path.html#46195" class="Bound">r</a><a id="46262" class="Symbol">)</a>
            <a id="46276" class="Symbol">→</a> <a id="46278" class="Symbol">(</a><a id="46279" href="1Lab.Path.html#46171" class="Bound">p</a> <a id="46281" href="1Lab.Path.html#38305" data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" class="Function Operator">··</a> <a id="46284" href="1Lab.Path.html#46183" class="Bound">q</a> <a id="46286" href="1Lab.Path.html#38305" data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" class="Function Operator">··</a> <a id="46289" href="1Lab.Path.html#46195" class="Bound">r</a> <a id="46291" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="46293" href="1Lab.Path.html#38623" data-type="(p : w ≡ x) (q : x ≡ y) (r : y ≡ z) →
Square (sym p) q (p ·· q ·· r) r" class="Function">··-filler</a> <a id="46303" href="1Lab.Path.html#46171" class="Bound">p</a> <a id="46305" href="1Lab.Path.html#46183" class="Bound">q</a> <a id="46307" href="1Lab.Path.html#46195" class="Bound">r</a><a id="46308" class="Symbol">)</a> <a id="46310" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="46312" href="1Lab.Path.html#46221" class="Bound">β</a>
<a id="46314" href="1Lab.Path.html#46109" data-type="(p : w ≡ x) (q : x ≡ y) (r : y ≡ z)
(β : Σ (λ s → Square (sym p) q s r)) →
((p ·· q ·· r) , ··-filler p q r) ≡ β" class="Function">··-contract</a> <a id="46326" href="1Lab.Path.html#46326" class="Bound">p</a> <a id="46328" href="1Lab.Path.html#46328" class="Bound">q</a> <a id="46330" href="1Lab.Path.html#46330" class="Bound">r</a> <a id="46332" href="1Lab.Path.html#46332" class="Bound">β</a> <a id="46334" class="Symbol">=</a> <a id="46336" href="1Lab.Path.html#41015" data-type="(p : w ≡ x) (q : x ≡ y) (r : y ≡ z)
(α β : Σ (λ s → Square (sym p) q s r)) →
α ≡ β" class="Function">··-unique</a> <a id="46346" href="1Lab.Path.html#46326" class="Bound">p</a> <a id="46348" href="1Lab.Path.html#46328" class="Bound">q</a> <a id="46350" href="1Lab.Path.html#46330" class="Bound">r</a> <a id="46352" class="Symbol">_</a> <a id="46354" href="1Lab.Path.html#46332" class="Bound">β</a>
</pre>
<h2 id="syntax-sugar"><a href="#syntax-sugar" class="header-link">Syntax
Sugar<span class="header-link-emoji">🔗</span></a></h2>
<p>When constructing long chains of identifications, it’s rather helpful
to be able to visualise <em>what</em> is being identified with more
“priority” than <em>how</em> it is being identified. For this, a handful
of combinators with weird names are defined:</p>
<pre class="Agda"><a id="≡⟨⟩-syntax"></a><a id="46629" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨⟩-syntax</a> <a id="46640" class="Symbol">:</a> <a id="46642" class="Symbol">∀</a> <a id="46644" class="Symbol">{</a><a id="46645" href="1Lab.Path.html#46645" class="Bound">ℓ</a><a id="46646" class="Symbol">}</a> <a id="46648" class="Symbol">{</a><a id="46649" href="1Lab.Path.html#46649" class="Bound">A</a> <a id="46651" class="Symbol">:</a> <a id="46653" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="46658" href="1Lab.Path.html#46645" class="Bound">ℓ</a><a id="46659" class="Symbol">}</a> <a id="46661" class="Symbol">(</a><a id="46662" href="1Lab.Path.html#46662" class="Bound">x</a> <a id="46664" class="Symbol">:</a> <a id="46666" href="1Lab.Path.html#46649" class="Bound">A</a><a id="46667" class="Symbol">)</a> <a id="46669" class="Symbol">{</a><a id="46670" href="1Lab.Path.html#46670" class="Bound">y</a> <a id="46672" href="1Lab.Path.html#46672" class="Bound">z</a><a id="46673" class="Symbol">}</a> <a id="46675" class="Symbol">→</a> <a id="46677" href="1Lab.Path.html#46670" class="Bound">y</a> <a id="46679" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="46681" href="1Lab.Path.html#46672" class="Bound">z</a> <a id="46683" class="Symbol">→</a> <a id="46685" href="1Lab.Path.html#46662" class="Bound">x</a> <a id="46687" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="46689" href="1Lab.Path.html#46670" class="Bound">y</a> <a id="46691" class="Symbol">→</a> <a id="46693" href="1Lab.Path.html#46662" class="Bound">x</a> <a id="46695" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="46697" href="1Lab.Path.html#46672" class="Bound">z</a>
<a id="46699" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨⟩-syntax</a> <a id="46710" href="1Lab.Path.html#46710" class="Bound">x</a> <a id="46712" href="1Lab.Path.html#46712" class="Bound">q</a> <a id="46714" href="1Lab.Path.html#46714" class="Bound">p</a> <a id="46716" class="Symbol">=</a> <a id="46718" href="1Lab.Path.html#46714" class="Bound">p</a> <a id="46720" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="46722" href="1Lab.Path.html#46712" class="Bound">q</a>

<a id="46725" class="Keyword">infixr</a> <a id="46732" class="Number">2</a> <a id="46734" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨⟩-syntax</a>
<a id="46745" class="Keyword">syntax</a> <a id="46752" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨⟩-syntax</a> <a id="46763" class="Bound">x</a> <a id="46765" class="Bound">q</a> <a id="46767" class="Bound">p</a> <a id="46769" class="Symbol">=</a> <a id="46771" class="Bound">x</a> <a id="46773" class="Function">≡⟨</a> <a id="46776" class="Bound">p</a> <a id="46778" class="Function">⟩</a> <a id="46780" class="Bound">q</a>

<a id="_≡˘⟨_⟩_"></a><a id="46783" href="1Lab.Path.html#46783" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">_≡˘⟨_⟩_</a> <a id="46791" class="Symbol">:</a> <a id="46793" class="Symbol">∀</a> <a id="46795" class="Symbol">{</a><a id="46796" href="1Lab.Path.html#46796" class="Bound">ℓ</a><a id="46797" class="Symbol">}</a> <a id="46799" class="Symbol">{</a><a id="46800" href="1Lab.Path.html#46800" class="Bound">A</a> <a id="46802" class="Symbol">:</a> <a id="46804" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="46809" href="1Lab.Path.html#46796" class="Bound">ℓ</a><a id="46810" class="Symbol">}</a> <a id="46812" class="Symbol">(</a><a id="46813" href="1Lab.Path.html#46813" class="Bound">x</a> <a id="46815" class="Symbol">:</a> <a id="46817" href="1Lab.Path.html#46800" class="Bound">A</a><a id="46818" class="Symbol">)</a> <a id="46820" class="Symbol">{</a><a id="46821" href="1Lab.Path.html#46821" class="Bound">y</a> <a id="46823" href="1Lab.Path.html#46823" class="Bound">z</a> <a id="46825" class="Symbol">:</a> <a id="46827" href="1Lab.Path.html#46800" class="Bound">A</a><a id="46828" class="Symbol">}</a> <a id="46830" class="Symbol">→</a> <a id="46832" href="1Lab.Path.html#46821" class="Bound">y</a> <a id="46834" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="46836" href="1Lab.Path.html#46813" class="Bound">x</a> <a id="46838" class="Symbol">→</a> <a id="46840" href="1Lab.Path.html#46821" class="Bound">y</a> <a id="46842" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="46844" href="1Lab.Path.html#46823" class="Bound">z</a> <a id="46846" class="Symbol">→</a> <a id="46848" href="1Lab.Path.html#46813" class="Bound">x</a> <a id="46850" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="46852" href="1Lab.Path.html#46823" class="Bound">z</a>
<a id="46854" href="1Lab.Path.html#46854" class="Bound">x</a> <span class="reasoning-step"><span class="as-written Function Operator"><a id="46856" href="1Lab.Path.html#46783" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">≡˘⟨</a> <a id="46860" href="1Lab.Path.html#46860" class="Bound">p</a> <a id="46862" href="1Lab.Path.html#46783" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡˘</span></span> <a id="46864" href="1Lab.Path.html#46864" class="Bound">q</a> <a id="46866" class="Symbol">=</a> <a id="46868" class="Symbol">(</a><a id="46869" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="46873" href="1Lab.Path.html#46860" class="Bound">p</a><a id="46874" class="Symbol">)</a> <a id="46876" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="46878" href="1Lab.Path.html#46864" class="Bound">q</a>

<a id="_≡⟨⟩_"></a><a id="46881" href="1Lab.Path.html#46881" data-type="(x : A) → x ≡ y → x ≡ y" class="Function Operator">_≡⟨⟩_</a> <a id="46887" class="Symbol">:</a> <a id="46889" class="Symbol">∀</a> <a id="46891" class="Symbol">{</a><a id="46892" href="1Lab.Path.html#46892" class="Bound">ℓ</a><a id="46893" class="Symbol">}</a> <a id="46895" class="Symbol">{</a><a id="46896" href="1Lab.Path.html#46896" class="Bound">A</a> <a id="46898" class="Symbol">:</a> <a id="46900" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="46905" href="1Lab.Path.html#46892" class="Bound">ℓ</a><a id="46906" class="Symbol">}</a> <a id="46908" class="Symbol">(</a><a id="46909" href="1Lab.Path.html#46909" class="Bound">x</a> <a id="46911" class="Symbol">:</a> <a id="46913" href="1Lab.Path.html#46896" class="Bound">A</a><a id="46914" class="Symbol">)</a> <a id="46916" class="Symbol">{</a><a id="46917" href="1Lab.Path.html#46917" class="Bound">y</a> <a id="46919" class="Symbol">:</a> <a id="46921" href="1Lab.Path.html#46896" class="Bound">A</a><a id="46922" class="Symbol">}</a> <a id="46924" class="Symbol">→</a> <a id="46926" href="1Lab.Path.html#46909" class="Bound">x</a> <a id="46928" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="46930" href="1Lab.Path.html#46917" class="Bound">y</a> <a id="46932" class="Symbol">→</a> <a id="46934" href="1Lab.Path.html#46909" class="Bound">x</a> <a id="46936" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="46938" href="1Lab.Path.html#46917" class="Bound">y</a>
<a id="46940" href="1Lab.Path.html#46940" class="Bound">x</a> <a id="46942" href="1Lab.Path.html#46881" data-type="(x : A) → x ≡ y → x ≡ y" class="Function Operator">≡⟨⟩</a> <a id="46946" href="1Lab.Path.html#46946" class="Bound">x≡y</a> <a id="46950" class="Symbol">=</a> <a id="46952" href="1Lab.Path.html#46946" class="Bound">x≡y</a>

<a id="_∎"></a><a id="46957" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">_∎</a> <a id="46960" class="Symbol">:</a> <a id="46962" class="Symbol">∀</a> <a id="46964" class="Symbol">{</a><a id="46965" href="1Lab.Path.html#46965" class="Bound">ℓ</a><a id="46966" class="Symbol">}</a> <a id="46968" class="Symbol">{</a><a id="46969" href="1Lab.Path.html#46969" class="Bound">A</a> <a id="46971" class="Symbol">:</a> <a id="46973" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="46978" href="1Lab.Path.html#46965" class="Bound">ℓ</a><a id="46979" class="Symbol">}</a> <a id="46981" class="Symbol">(</a><a id="46982" href="1Lab.Path.html#46982" class="Bound">x</a> <a id="46984" class="Symbol">:</a> <a id="46986" href="1Lab.Path.html#46969" class="Bound">A</a><a id="46987" class="Symbol">)</a> <a id="46989" class="Symbol">→</a> <a id="46991" href="1Lab.Path.html#46982" class="Bound">x</a> <a id="46993" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="46995" href="1Lab.Path.html#46982" class="Bound">x</a>
<a id="46997" href="1Lab.Path.html#46997" class="Bound">x</a> <a id="46999" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a> <a id="47001" class="Symbol">=</a> <a id="47003" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>

<a id="47009" class="Keyword">infixr</a> <a id="47016" class="Number">30</a> <a id="47019" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">_∙_</a>
<a id="47023" class="Keyword">infixr</a> <a id="47030" class="Number">2</a> <a id="47032" href="1Lab.Path.html#46881" data-type="(x : A) → x ≡ y → x ≡ y" class="Function Operator">_≡⟨⟩_</a> <a id="47038" href="1Lab.Path.html#46783" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">_≡˘⟨_⟩_</a>
<a id="47046" class="Keyword">infix</a>  <a id="47053" class="Number">3</a> <a id="47055" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">_∎</a>
</pre>
<p>These functions are used to make <em>equational reasoning
chains</em>. For instance, the following proof that addition of naturals
is associative is done in equational reasoning style:</p>
<pre class="Agda"><a id="47250" class="Keyword">private</a>
  <a id="+-associative"></a><a id="47260" href="1Lab.Path.html#47260" class="Function">+-associative</a> <a id="47274" class="Symbol">:</a> <a id="47276" class="Symbol">(</a><a id="47277" href="1Lab.Path.html#47277" class="Bound">x</a> <a id="47279" href="1Lab.Path.html#47279" class="Bound">y</a> <a id="47281" href="1Lab.Path.html#47281" class="Bound">z</a> <a id="47283" class="Symbol">:</a> <a id="47285" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a><a id="47288" class="Symbol">)</a> <a id="47290" class="Symbol">→</a> <a id="47292" class="Symbol">(</a><a id="47293" href="1Lab.Path.html#47277" class="Bound">x</a> <a id="47295" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="47297" href="1Lab.Path.html#47279" class="Bound">y</a><a id="47298" class="Symbol">)</a> <a id="47300" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="47302" href="1Lab.Path.html#47281" class="Bound">z</a> <a id="47304" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="47306" href="1Lab.Path.html#47277" class="Bound">x</a> <a id="47308" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="47310" class="Symbol">(</a><a id="47311" href="1Lab.Path.html#47279" class="Bound">y</a> <a id="47313" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="47315" href="1Lab.Path.html#47281" class="Bound">z</a><a id="47316" class="Symbol">)</a>
  <a id="47320" href="1Lab.Path.html#47260" class="Function">+-associative</a> <a id="47334" href="Agda.Builtin.Nat.html#210" data-type="Nat" class="InductiveConstructor">zero</a> <a id="47339" href="1Lab.Path.html#47339" class="Bound">y</a> <a id="47341" href="1Lab.Path.html#47341" class="Bound">z</a> <a id="47343" class="Symbol">=</a> <a id="47345" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
  <a id="47352" href="1Lab.Path.html#47260" class="Function">+-associative</a> <a id="47366" class="Symbol">(</a><a id="47367" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="47371" href="1Lab.Path.html#47371" class="Bound">x</a><a id="47372" class="Symbol">)</a> <a id="47374" href="1Lab.Path.html#47374" class="Bound">y</a> <a id="47376" href="1Lab.Path.html#47376" class="Bound">z</a> <a id="47378" class="Symbol">=</a>
    <a id="47384" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="47388" class="Symbol">((</a><a id="47390" href="1Lab.Path.html#47371" class="Bound">x</a> <a id="47392" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="47394" href="1Lab.Path.html#47374" class="Bound">y</a><a id="47395" class="Symbol">)</a> <a id="47397" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="47399" href="1Lab.Path.html#47376" class="Bound">z</a><a id="47400" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function"><a id="47402" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="47405" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="47408" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="47412" class="Symbol">(</a><a id="47413" href="1Lab.Path.html#47260" class="Function">+-associative</a> <a id="47427" href="1Lab.Path.html#47371" class="Bound">x</a> <a id="47429" href="1Lab.Path.html#47374" class="Bound">y</a> <a id="47431" href="1Lab.Path.html#47376" class="Bound">z</a><a id="47432" class="Symbol">)</a> <a id="47434" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="47440" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="47444" class="Symbol">(</a><a id="47445" href="1Lab.Path.html#47371" class="Bound">x</a> <a id="47447" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="47449" class="Symbol">(</a><a id="47450" href="1Lab.Path.html#47374" class="Bound">y</a> <a id="47452" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="47454" href="1Lab.Path.html#47376" class="Bound">z</a><a id="47455" class="Symbol">))</a> <a id="47458" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
</pre>
<p>If your browser runs JavaScript, these equational reasoning chains,
by default, render with the <em>justifications</em> (the argument
written between <code>⟨ ⟩</code>) hidden; There is a checkbox to display
them, either on the sidebar or on the top bar depending on how narrow
your screen is. For your convenience, it’s here too:</p>
<div style="display: flex; flex-direction: column; align-items: center;">
<p><span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
<input name="body-eqns" type="checkbox" class="equations" id="body-eqns">
<label for="body-eqns">Equations</label> </span></p>
</div>
<p>Try pressing it!</p>
<!--
<pre class="Agda"><a id="SquareP"></a><a id="48096" href="1Lab.Path.html#48096" data-type="(A : I → I → Type ℓ) →
PathP (λ i → A i i0) a₀₀ a₁₀ →
PathP (A i0) a₀₀ a₀₁ →
PathP (A i1) a₁₀ a₁₁ → PathP (λ i → A i i1) a₀₁ a₁₁ → Type ℓ" class="Function">SquareP</a> <a id="48104" class="Symbol">:</a> <a id="48106" class="Symbol">∀</a> <a id="48108" class="Symbol">{</a><a id="48109" href="1Lab.Path.html#48109" class="Bound">ℓ</a><a id="48110" class="Symbol">}</a>
  <a id="48114" class="Symbol">(</a><a id="48115" href="1Lab.Path.html#48115" class="Bound">A</a> <a id="48117" class="Symbol">:</a> <a id="48119" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a> <a id="48121" class="Symbol">→</a> <a id="48123" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a> <a id="48125" class="Symbol">→</a> <a id="48127" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="48132" href="1Lab.Path.html#48109" class="Bound">ℓ</a><a id="48133" class="Symbol">)</a>
  <a id="48137" class="Symbol">{</a><a id="48138" href="1Lab.Path.html#48138" class="Bound">a₀₀</a> <a id="48142" class="Symbol">:</a> <a id="48144" href="1Lab.Path.html#48115" class="Bound">A</a> <a id="48146" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a> <a id="48149" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a><a id="48151" class="Symbol">}</a> <a id="48153" class="Symbol">{</a><a id="48154" href="1Lab.Path.html#48154" class="Bound">a₀₁</a> <a id="48158" class="Symbol">:</a> <a id="48160" href="1Lab.Path.html#48115" class="Bound">A</a> <a id="48162" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a> <a id="48165" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a><a id="48167" class="Symbol">}</a>
  <a id="48171" class="Symbol">{</a><a id="48172" href="1Lab.Path.html#48172" class="Bound">a₁₀</a> <a id="48176" class="Symbol">:</a> <a id="48178" href="1Lab.Path.html#48115" class="Bound">A</a> <a id="48180" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a> <a id="48183" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a><a id="48185" class="Symbol">}</a> <a id="48187" class="Symbol">{</a><a id="48188" href="1Lab.Path.html#48188" class="Bound">a₁₁</a> <a id="48192" class="Symbol">:</a> <a id="48194" href="1Lab.Path.html#48115" class="Bound">A</a> <a id="48196" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a> <a id="48199" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a><a id="48201" class="Symbol">}</a>
  <a id="48205" class="Symbol">(</a><a id="48206" href="1Lab.Path.html#48206" class="Bound">p</a> <a id="48208" class="Symbol">:</a> <a id="48210" href="Agda.Builtin.Cubical.Path.html#197" data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" class="Postulate">PathP</a> <a id="48216" class="Symbol">(λ</a> <a id="48219" href="1Lab.Path.html#48219" class="Bound">i</a> <a id="48221" class="Symbol">→</a> <a id="48223" href="1Lab.Path.html#48115" class="Bound">A</a> <a id="48225" href="1Lab.Path.html#48219" class="Bound">i</a> <a id="48227" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a><a id="48229" class="Symbol">)</a> <a id="48231" href="1Lab.Path.html#48138" class="Bound">a₀₀</a> <a id="48235" href="1Lab.Path.html#48172" class="Bound">a₁₀</a><a id="48238" class="Symbol">)</a>
  <a id="48242" class="Symbol">(</a><a id="48243" href="1Lab.Path.html#48243" class="Bound">q</a> <a id="48245" class="Symbol">:</a> <a id="48247" href="Agda.Builtin.Cubical.Path.html#197" data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" class="Postulate">PathP</a> <a id="48253" class="Symbol">(λ</a> <a id="48256" href="1Lab.Path.html#48256" class="Bound">j</a> <a id="48258" class="Symbol">→</a> <a id="48260" href="1Lab.Path.html#48115" class="Bound">A</a> <a id="48262" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a> <a id="48265" href="1Lab.Path.html#48256" class="Bound">j</a><a id="48266" class="Symbol">)</a> <a id="48268" href="1Lab.Path.html#48138" class="Bound">a₀₀</a> <a id="48272" href="1Lab.Path.html#48154" class="Bound">a₀₁</a><a id="48275" class="Symbol">)</a>
  <a id="48279" class="Symbol">(</a><a id="48280" href="1Lab.Path.html#48280" class="Bound">s</a> <a id="48282" class="Symbol">:</a> <a id="48284" href="Agda.Builtin.Cubical.Path.html#197" data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" class="Postulate">PathP</a> <a id="48290" class="Symbol">(λ</a> <a id="48293" href="1Lab.Path.html#48293" class="Bound">j</a> <a id="48295" class="Symbol">→</a> <a id="48297" href="1Lab.Path.html#48115" class="Bound">A</a> <a id="48299" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a> <a id="48302" href="1Lab.Path.html#48293" class="Bound">j</a><a id="48303" class="Symbol">)</a> <a id="48305" href="1Lab.Path.html#48172" class="Bound">a₁₀</a> <a id="48309" href="1Lab.Path.html#48188" class="Bound">a₁₁</a><a id="48312" class="Symbol">)</a>
  <a id="48316" class="Symbol">(</a><a id="48317" href="1Lab.Path.html#48317" class="Bound">r</a> <a id="48319" class="Symbol">:</a> <a id="48321" href="Agda.Builtin.Cubical.Path.html#197" data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" class="Postulate">PathP</a> <a id="48327" class="Symbol">(λ</a> <a id="48330" href="1Lab.Path.html#48330" class="Bound">i</a> <a id="48332" class="Symbol">→</a> <a id="48334" href="1Lab.Path.html#48115" class="Bound">A</a> <a id="48336" href="1Lab.Path.html#48330" class="Bound">i</a> <a id="48338" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a><a id="48340" class="Symbol">)</a> <a id="48342" href="1Lab.Path.html#48154" class="Bound">a₀₁</a> <a id="48346" href="1Lab.Path.html#48188" class="Bound">a₁₁</a><a id="48349" class="Symbol">)</a>
  <a id="48353" class="Symbol">→</a> <a id="48355" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="48360" href="1Lab.Path.html#48109" class="Bound">ℓ</a>
<a id="48362" href="1Lab.Path.html#48096" data-type="(A : I → I → Type ℓ) →
PathP (λ i → A i i0) a₀₀ a₁₀ →
PathP (A i0) a₀₀ a₀₁ →
PathP (A i1) a₁₀ a₁₁ → PathP (λ i → A i i1) a₀₁ a₁₁ → Type ℓ" class="Function">SquareP</a> <a id="48370" href="1Lab.Path.html#48370" class="Bound">A</a> <a id="48372" href="1Lab.Path.html#48372" class="Bound">p</a> <a id="48374" href="1Lab.Path.html#48374" class="Bound">q</a> <a id="48376" href="1Lab.Path.html#48376" class="Bound">s</a> <a id="48378" href="1Lab.Path.html#48378" class="Bound">r</a> <a id="48380" class="Symbol">=</a> <a id="48382" href="Agda.Builtin.Cubical.Path.html#197" data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" class="Postulate">PathP</a> <a id="48388" class="Symbol">(λ</a> <a id="48391" href="1Lab.Path.html#48391" class="Bound">i</a> <a id="48393" class="Symbol">→</a> <a id="48395" href="Agda.Builtin.Cubical.Path.html#197" data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" class="Postulate">PathP</a> <a id="48401" class="Symbol">(λ</a> <a id="48404" href="1Lab.Path.html#48404" class="Bound">j</a> <a id="48406" class="Symbol">→</a> <a id="48408" href="1Lab.Path.html#48370" class="Bound">A</a> <a id="48410" href="1Lab.Path.html#48391" class="Bound">i</a> <a id="48412" href="1Lab.Path.html#48404" class="Bound">j</a><a id="48413" class="Symbol">)</a> <a id="48415" class="Symbol">(</a><a id="48416" href="1Lab.Path.html#48372" class="Bound">p</a> <a id="48418" href="1Lab.Path.html#48391" class="Bound">i</a><a id="48419" class="Symbol">)</a> <a id="48421" class="Symbol">(</a><a id="48422" href="1Lab.Path.html#48378" class="Bound">r</a> <a id="48424" href="1Lab.Path.html#48391" class="Bound">i</a><a id="48425" class="Symbol">))</a> <a id="48428" href="1Lab.Path.html#48374" class="Bound">q</a> <a id="48430" href="1Lab.Path.html#48376" class="Bound">s</a>
</pre>-->
<h1 id="dependent-paths"><a href="#dependent-paths" class="header-link">Dependent
Paths<span class="header-link-emoji">🔗</span></a></h1>
<p>Surprisingly often, we want to compare inhabitants
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a : A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>
and
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>:</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">b : B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>
where the types
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>
and
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>
are not <em>definitionally</em> equal, but only identified in some
specified way. We call these “<strong>paths</strong> over
<strong>p</strong>paths”, or
<span class="Agda"><a href="Agda.Builtin.Cubical.Path.html#197" class="Postulate">PathP</a></span>
for short. In the same way that a
<span class="Agda"><a href="1Lab.Path.html#2466" class="Function">Path</a></span>
can be understood as a function <code>I → A</code> with specified
endpoints, a
<span class="Agda"><a href="Agda.Builtin.Cubical.Path.html#197" class="Postulate">PathP</a></span>
(<em>path</em> over <em>p</em>ath) can be understood as a
<em>dependent</em> function <code>(i : I) → A i</code>.</p>
<p>In the Book, paths over paths are implemented in terms of the
<span class="Agda"><a href="1Lab.Path.html#11776" class="Function">transport</a></span>
operation: A path <code>x ≡ y</code> over <code>p</code> is a path
<code>transport p x ≡ y</code>, thus defining dependent identifications
using non-dependent ones. Fortunately, a cubical argument shows us that
these notions coincide:</p>
<pre class="Agda"><a id="PathP≡Path"></a><a id="49201" href="1Lab.Path.html#49201" data-type="(P : I → Type ℓ) (p : P i0) (q : P i1) →
PathP P p q ≡ Path (P i1) (transport P p) q" class="Function">PathP≡Path</a> <a id="49212" class="Symbol">:</a> <a id="49214" class="Symbol">∀</a> <a id="49216" class="Symbol">{</a><a id="49217" href="1Lab.Path.html#49217" class="Bound">ℓ</a><a id="49218" class="Symbol">}</a> <a id="49220" class="Symbol">(</a><a id="49221" href="1Lab.Path.html#49221" class="Bound">P</a> <a id="49223" class="Symbol">:</a> <a id="49225" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a> <a id="49227" class="Symbol">→</a> <a id="49229" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="49234" href="1Lab.Path.html#49217" class="Bound">ℓ</a><a id="49235" class="Symbol">)</a> <a id="49237" class="Symbol">(</a><a id="49238" href="1Lab.Path.html#49238" class="Bound">p</a> <a id="49240" class="Symbol">:</a> <a id="49242" href="1Lab.Path.html#49221" class="Bound">P</a> <a id="49244" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a><a id="49246" class="Symbol">)</a> <a id="49248" class="Symbol">(</a><a id="49249" href="1Lab.Path.html#49249" class="Bound">q</a> <a id="49251" class="Symbol">:</a> <a id="49253" href="1Lab.Path.html#49221" class="Bound">P</a> <a id="49255" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a><a id="49257" class="Symbol">)</a>
           <a id="49270" class="Symbol">→</a> <a id="49272" href="Agda.Builtin.Cubical.Path.html#197" data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" class="Postulate">PathP</a> <a id="49278" href="1Lab.Path.html#49221" class="Bound">P</a> <a id="49280" href="1Lab.Path.html#49238" class="Bound">p</a> <a id="49282" href="1Lab.Path.html#49249" class="Bound">q</a> <a id="49284" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="49286" href="1Lab.Path.html#2466" data-type="(A : Type ℓ) → A → A → Type ℓ" class="Function">Path</a> <a id="49291" class="Symbol">(</a><a id="49292" href="1Lab.Path.html#49221" class="Bound">P</a> <a id="49294" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a><a id="49296" class="Symbol">)</a> <a id="49298" class="Symbol">(</a><a id="49299" href="1Lab.Path.html#11776" data-type="A ≡ B₁ → A → B₁" class="Function">transport</a> <a id="49309" class="Symbol">(λ</a> <a id="49312" href="1Lab.Path.html#49312" class="Bound">i</a> <a id="49314" class="Symbol">→</a> <a id="49316" href="1Lab.Path.html#49221" class="Bound">P</a> <a id="49318" href="1Lab.Path.html#49312" class="Bound">i</a><a id="49319" class="Symbol">)</a> <a id="49321" href="1Lab.Path.html#49238" class="Bound">p</a><a id="49322" class="Symbol">)</a> <a id="49324" href="1Lab.Path.html#49249" class="Bound">q</a>
<a id="49326" href="1Lab.Path.html#49201" data-type="(P : I → Type ℓ) (p : P i0) (q : P i1) →
PathP P p q ≡ Path (P i1) (transport P p) q" class="Function">PathP≡Path</a> <a id="49337" href="1Lab.Path.html#49337" class="Bound">P</a> <a id="49339" href="1Lab.Path.html#49339" class="Bound">p</a> <a id="49341" href="1Lab.Path.html#49341" class="Bound">q</a> <a id="49343" href="1Lab.Path.html#49343" class="Bound">i</a> <a id="49345" class="Symbol">=</a> <a id="49347" href="Agda.Builtin.Cubical.Path.html#197" data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" class="Postulate">PathP</a> <a id="49353" class="Symbol">(λ</a> <a id="49356" href="1Lab.Path.html#49356" class="Bound">j</a> <a id="49358" class="Symbol">→</a> <a id="49360" href="1Lab.Path.html#49337" class="Bound">P</a> <a id="49362" class="Symbol">(</a><a id="49363" href="1Lab.Path.html#49343" class="Bound">i</a> <a id="49365" href="1Lab.Path.html#2226" class="Primitive Operator">∨</a> <a id="49367" href="1Lab.Path.html#49356" class="Bound">j</a><a id="49368" class="Symbol">))</a> <a id="49371" class="Symbol">(</a><a id="49372" href="1Lab.Path.html#14006" data-type="(p : A ≡ B₁) (x : A) → PathP (λ i → p i) x (transport p x)" class="Function">transport-filler</a> <a id="49389" class="Symbol">(λ</a> <a id="49392" href="1Lab.Path.html#49392" class="Bound">j</a> <a id="49394" class="Symbol">→</a> <a id="49396" href="1Lab.Path.html#49337" class="Bound">P</a> <a id="49398" href="1Lab.Path.html#49392" class="Bound">j</a><a id="49399" class="Symbol">)</a> <a id="49401" href="1Lab.Path.html#49339" class="Bound">p</a> <a id="49403" href="1Lab.Path.html#49343" class="Bound">i</a><a id="49404" class="Symbol">)</a> <a id="49406" href="1Lab.Path.html#49341" class="Bound">q</a>

<a id="PathP≡Path⁻"></a><a id="49409" href="1Lab.Path.html#49409" data-type="(P : I → Type ℓ) (p : P i0) (q : P i1) →
PathP P p q ≡ Path (P i0) p (transport (λ i → P (~ i)) q)" class="Function">PathP≡Path⁻</a> <a id="49421" class="Symbol">:</a> <a id="49423" class="Symbol">∀</a> <a id="49425" class="Symbol">{</a><a id="49426" href="1Lab.Path.html#49426" class="Bound">ℓ</a><a id="49427" class="Symbol">}</a> <a id="49429" class="Symbol">(</a><a id="49430" href="1Lab.Path.html#49430" class="Bound">P</a> <a id="49432" class="Symbol">:</a> <a id="49434" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a> <a id="49436" class="Symbol">→</a> <a id="49438" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="49443" href="1Lab.Path.html#49426" class="Bound">ℓ</a><a id="49444" class="Symbol">)</a> <a id="49446" class="Symbol">(</a><a id="49447" href="1Lab.Path.html#49447" class="Bound">p</a> <a id="49449" class="Symbol">:</a> <a id="49451" href="1Lab.Path.html#49430" class="Bound">P</a> <a id="49453" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a><a id="49455" class="Symbol">)</a> <a id="49457" class="Symbol">(</a><a id="49458" href="1Lab.Path.html#49458" class="Bound">q</a> <a id="49460" class="Symbol">:</a> <a id="49462" href="1Lab.Path.html#49430" class="Bound">P</a> <a id="49464" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a><a id="49466" class="Symbol">)</a>
            <a id="49480" class="Symbol">→</a> <a id="49482" href="Agda.Builtin.Cubical.Path.html#197" data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" class="Postulate">PathP</a> <a id="49488" href="1Lab.Path.html#49430" class="Bound">P</a> <a id="49490" href="1Lab.Path.html#49447" class="Bound">p</a> <a id="49492" href="1Lab.Path.html#49458" class="Bound">q</a> <a id="49494" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="49496" href="1Lab.Path.html#2466" data-type="(A : Type ℓ) → A → A → Type ℓ" class="Function">Path</a> <a id="49501" class="Symbol">(</a><a id="49502" href="1Lab.Path.html#49430" class="Bound">P</a> <a id="49504" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a><a id="49506" class="Symbol">)</a> <a id="49508" href="1Lab.Path.html#49447" class="Bound">p</a> <a id="49510" class="Symbol">(</a><a id="49511" href="1Lab.Path.html#11776" data-type="A ≡ B₁ → A → B₁" class="Function">transport</a> <a id="49521" class="Symbol">(λ</a> <a id="49524" href="1Lab.Path.html#49524" class="Bound">i</a> <a id="49526" class="Symbol">→</a> <a id="49528" href="1Lab.Path.html#49430" class="Bound">P</a> <a id="49530" class="Symbol">(</a><a id="49531" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="49533" href="1Lab.Path.html#49524" class="Bound">i</a><a id="49534" class="Symbol">))</a> <a id="49537" href="1Lab.Path.html#49458" class="Bound">q</a><a id="49538" class="Symbol">)</a>
<a id="49540" href="1Lab.Path.html#49409" data-type="(P : I → Type ℓ) (p : P i0) (q : P i1) →
PathP P p q ≡ Path (P i0) p (transport (λ i → P (~ i)) q)" class="Function">PathP≡Path⁻</a> <a id="49552" href="1Lab.Path.html#49552" class="Bound">P</a> <a id="49554" href="1Lab.Path.html#49554" class="Bound">p</a> <a id="49556" href="1Lab.Path.html#49556" class="Bound">q</a> <a id="49558" href="1Lab.Path.html#49558" class="Bound">i</a> <a id="49560" class="Symbol">=</a> <a id="49562" href="Agda.Builtin.Cubical.Path.html#197" data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" class="Postulate">PathP</a> <a id="49568" class="Symbol">(λ</a> <a id="49571" href="1Lab.Path.html#49571" class="Bound">j</a> <a id="49573" class="Symbol">→</a> <a id="49575" href="1Lab.Path.html#49552" class="Bound">P</a> <a id="49577" class="Symbol">(</a><a id="49578" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="49580" href="1Lab.Path.html#49558" class="Bound">i</a> <a id="49582" href="1Lab.Path.html#2191" class="Primitive Operator">∧</a> <a id="49584" href="1Lab.Path.html#49571" class="Bound">j</a><a id="49585" class="Symbol">))</a> <a id="49588" href="1Lab.Path.html#49554" class="Bound">p</a>
                            <a id="49618" class="Symbol">(</a><a id="49619" href="1Lab.Path.html#14006" data-type="(p : A ≡ B₁) (x : A) → PathP (λ i → p i) x (transport p x)" class="Function">transport-filler</a> <a id="49636" class="Symbol">(λ</a> <a id="49639" href="1Lab.Path.html#49639" class="Bound">j</a> <a id="49641" class="Symbol">→</a> <a id="49643" href="1Lab.Path.html#49552" class="Bound">P</a> <a id="49645" class="Symbol">(</a><a id="49646" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="49648" href="1Lab.Path.html#49639" class="Bound">j</a><a id="49649" class="Symbol">))</a> <a id="49652" href="1Lab.Path.html#49556" class="Bound">q</a> <a id="49654" href="1Lab.Path.html#49558" class="Bound">i</a><a id="49655" class="Symbol">)</a>
</pre>
<p>We can see this by substituting either <code>i0</code> or
<code>i1</code> for the variable <code>i</code>.</p>
<ul>
<li><p>When <code>i = i0</code>, we have
<code>PathP (λ j → P j) p q</code>, by the endpoint rule for
<span class="Agda"><a href="1Lab.Path.html#14006" class="Function">transport-filler</a></span>.</p></li>
<li><p>When <code>i = i1</code>, we have
<code>PathP (λ j → P i1) (transport P p) q</code>, again by the endpoint
rule for
<span class="Agda"><a href="1Lab.Path.html#14006" class="Function">transport-filler</a></span>.</p></li>
</ul>
<p>The existence of paths over paths gives another “counterexample” to
thinking of paths as <em>equality</em>. For instance, it’s hard to
imagine a world in which <code>true</code> and <code>false</code> can be
equal in any interesting sense of the word <em>equal</em> — but over the
identification
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">B</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">l</mi></mrow><mo>≡</mo><mrow><mi mathvariant="normal">B</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">l</mi></mrow></mrow><annotation encoding="application/x-tex">\id{Bool} \equiv \id{Bool}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">Bool</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">Bool</span></span></span></span></span>
that switches the points around, <code>true</code> and
<code>false</code> can be identified!</p>
<h2 id="coercion"><a href="#coercion" class="header-link">Coercion<span class="header-link-emoji">🔗</span></a></h2>
<p>In Cubical Agda, the interval is given the structure of a De Morgan
algebra. This is not the only choice of structure on the interval that
gives a model of univalent type theory: We could also subject the
interval to <em>no</em> additional structure other than what comes from
the structural rules of type theory (introducing variables, ignoring
variables, swapping variables, etc). This is a different cubical type
theory, called <em>Cartesian cubical type theory</em>.</p>
<p>In Cartesian cubical type theory, instead of having a
<span class="Agda"><a href="1Lab.Path.html#2405" class="Primitive">transp</a></span>
operation which takes
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">i</mi><mn>0</mn></mrow><mo stretchy="false">)</mo><mo>→</mo><mi>A</mi><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">i</mi><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A(\id{i0}) \to A(\id{i1})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">i0</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">i1</span></span><span class="mclose">)</span></span></span></span>,</span>
there is a “more powerful” <em>coercion</em> operation, written
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">e</mi></mrow><mrow><mi>i</mi><mo>→</mo><mi>j</mi></mrow><mi>A</mi></msubsup></mrow><annotation encoding="application/x-tex">\id{coe}^A_{i \to j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2361em;vertical-align:-0.3948em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">coe</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-2.4413em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">→</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3948em;"><span></span></span></span></span></span></span></span></span></span>,</span>
which takes
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>→</mo><mi>A</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A(i) \to A(j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>,</span>
as in the subscript. However, despite the seeming added power, the
coercion operation can be implemented in Cubical Agda: First, we
introduce alternative names for several uses of
<span class="Agda"><a href="1Lab.Path.html#2405" class="Primitive">transp</a></span>.</p>
<pre class="Agda"><a id="coe0→1"></a><a id="51235" href="1Lab.Path.html#51235" data-type="(A : I → Type ℓ) → A i0 → A i1" class="Function">coe0→1</a> <a id="51242" class="Symbol">:</a> <a id="51244" class="Symbol">∀</a> <a id="51246" class="Symbol">{</a><a id="51247" href="1Lab.Path.html#51247" class="Bound">ℓ</a><a id="51248" class="Symbol">}</a> <a id="51250" class="Symbol">(</a><a id="51251" href="1Lab.Path.html#51251" class="Bound">A</a> <a id="51253" class="Symbol">:</a> <a id="51255" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a> <a id="51257" class="Symbol">→</a> <a id="51259" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="51264" href="1Lab.Path.html#51247" class="Bound">ℓ</a><a id="51265" class="Symbol">)</a> <a id="51267" class="Symbol">→</a> <a id="51269" href="1Lab.Path.html#51251" class="Bound">A</a> <a id="51271" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a> <a id="51274" class="Symbol">→</a> <a id="51276" href="1Lab.Path.html#51251" class="Bound">A</a> <a id="51278" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a>
<a id="51281" href="1Lab.Path.html#51235" data-type="(A : I → Type ℓ) → A i0 → A i1" class="Function">coe0→1</a> <a id="51288" href="1Lab.Path.html#51288" class="Bound">A</a> <a id="51290" href="1Lab.Path.html#51290" class="Bound">a</a> <a id="51292" class="Symbol">=</a> <a id="51294" href="1Lab.Path.html#2405" class="Primitive">transp</a> <a id="51301" class="Symbol">(λ</a> <a id="51304" href="1Lab.Path.html#51304" class="Bound">i</a> <a id="51306" class="Symbol">→</a> <a id="51308" href="1Lab.Path.html#51288" class="Bound">A</a> <a id="51310" href="1Lab.Path.html#51304" class="Bound">i</a><a id="51311" class="Symbol">)</a> <a id="51313" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a> <a id="51316" href="1Lab.Path.html#51290" class="Bound">a</a>
<a id="51318" class="Comment">-- ^ This is another name for transport</a>

<a id="coe1→0"></a><a id="51359" href="1Lab.Path.html#51359" data-type="(A : I → Type ℓ) → A i1 → A i0" class="Function">coe1→0</a> <a id="51366" class="Symbol">:</a> <a id="51368" class="Symbol">∀</a> <a id="51370" class="Symbol">{</a><a id="51371" href="1Lab.Path.html#51371" class="Bound">ℓ</a><a id="51372" class="Symbol">}</a> <a id="51374" class="Symbol">(</a><a id="51375" href="1Lab.Path.html#51375" class="Bound">A</a> <a id="51377" class="Symbol">:</a> <a id="51379" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a> <a id="51381" class="Symbol">→</a> <a id="51383" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="51388" href="1Lab.Path.html#51371" class="Bound">ℓ</a><a id="51389" class="Symbol">)</a> <a id="51391" class="Symbol">→</a> <a id="51393" href="1Lab.Path.html#51375" class="Bound">A</a> <a id="51395" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a> <a id="51398" class="Symbol">→</a> <a id="51400" href="1Lab.Path.html#51375" class="Bound">A</a> <a id="51402" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a>
<a id="51405" href="1Lab.Path.html#51359" data-type="(A : I → Type ℓ) → A i1 → A i0" class="Function">coe1→0</a> <a id="51412" href="1Lab.Path.html#51412" class="Bound">A</a> <a id="51414" href="1Lab.Path.html#51414" class="Bound">a</a> <a id="51416" class="Symbol">=</a> <a id="51418" href="1Lab.Path.html#2405" class="Primitive">transp</a> <a id="51425" class="Symbol">(λ</a> <a id="51428" href="1Lab.Path.html#51428" class="Bound">i</a> <a id="51430" class="Symbol">→</a> <a id="51432" href="1Lab.Path.html#51412" class="Bound">A</a> <a id="51434" class="Symbol">(</a><a id="51435" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="51437" href="1Lab.Path.html#51428" class="Bound">i</a><a id="51438" class="Symbol">))</a> <a id="51441" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a> <a id="51444" href="1Lab.Path.html#51414" class="Bound">a</a>
<a id="51446" class="Comment">-- ^ This is equivalent to transport ∘ sym</a>
</pre>
<p>There are also “more exciting” operations, which transport from one
of the endpoints to a path which can vary over the interval. These
generalise the
<span class="Agda"><a href="1Lab.Path.html#14006" class="Function">transport-filler</a></span>
operation.</p>
<pre class="Agda"><a id="coe0→i"></a><a id="51690" href="1Lab.Path.html#51690" data-type="(A : (i : I) → Type (ℓ i)) (i : I) → A i0 → A i" class="Function">coe0→i</a> <a id="51697" class="Symbol">:</a> <a id="51699" class="Symbol">∀</a> <a id="51701" class="Symbol">{</a><a id="51702" href="1Lab.Path.html#51702" class="Bound">ℓ</a> <a id="51704" class="Symbol">:</a> <a id="51706" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a> <a id="51708" class="Symbol">→</a> <a id="51710" href="Agda.Primitive.html#597" data-type="Type" class="Postulate">Level</a><a id="51715" class="Symbol">}</a> <a id="51717" class="Symbol">(</a><a id="51718" href="1Lab.Path.html#51718" class="Bound">A</a> <a id="51720" class="Symbol">:</a> <a id="51722" class="Symbol">∀</a> <a id="51724" href="1Lab.Path.html#51724" class="Bound">i</a> <a id="51726" class="Symbol">→</a> <a id="51728" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="51733" class="Symbol">(</a><a id="51734" href="1Lab.Path.html#51702" class="Bound">ℓ</a> <a id="51736" href="1Lab.Path.html#51724" class="Bound">i</a><a id="51737" class="Symbol">))</a> <a id="51740" class="Symbol">(</a><a id="51741" href="1Lab.Path.html#51741" class="Bound">i</a> <a id="51743" class="Symbol">:</a> <a id="51745" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a><a id="51746" class="Symbol">)</a> <a id="51748" class="Symbol">→</a> <a id="51750" href="1Lab.Path.html#51718" class="Bound">A</a> <a id="51752" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a> <a id="51755" class="Symbol">→</a> <a id="51757" href="1Lab.Path.html#51718" class="Bound">A</a> <a id="51759" href="1Lab.Path.html#51741" class="Bound">i</a>
<a id="51761" href="1Lab.Path.html#51690" data-type="(A : (i : I) → Type (ℓ i)) (i : I) → A i0 → A i" class="Function">coe0→i</a> <a id="51768" href="1Lab.Path.html#51768" class="Bound">A</a> <a id="51770" href="1Lab.Path.html#51770" class="Bound">i</a> <a id="51772" href="1Lab.Path.html#51772" class="Bound">a</a> <a id="51774" class="Symbol">=</a> <a id="51776" href="1Lab.Path.html#2405" class="Primitive">transp</a> <a id="51783" class="Symbol">(λ</a> <a id="51786" href="1Lab.Path.html#51786" class="Bound">j</a> <a id="51788" class="Symbol">→</a> <a id="51790" href="1Lab.Path.html#51768" class="Bound">A</a> <a id="51792" class="Symbol">(</a><a id="51793" href="1Lab.Path.html#51770" class="Bound">i</a> <a id="51795" href="1Lab.Path.html#2191" class="Primitive Operator">∧</a> <a id="51797" href="1Lab.Path.html#51786" class="Bound">j</a><a id="51798" class="Symbol">))</a> <a id="51801" class="Symbol">(</a><a id="51802" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="51804" href="1Lab.Path.html#51770" class="Bound">i</a><a id="51805" class="Symbol">)</a> <a id="51807" href="1Lab.Path.html#51772" class="Bound">a</a>

<a id="coe1→i"></a><a id="51810" href="1Lab.Path.html#51810" data-type="(A : (i : I) → Type (ℓ i)) (i : I) → A i1 → A i" class="Function">coe1→i</a> <a id="51817" class="Symbol">:</a> <a id="51819" class="Symbol">∀</a> <a id="51821" class="Symbol">{</a><a id="51822" href="1Lab.Path.html#51822" class="Bound">ℓ</a> <a id="51824" class="Symbol">:</a> <a id="51826" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a> <a id="51828" class="Symbol">→</a> <a id="51830" href="Agda.Primitive.html#597" data-type="Type" class="Postulate">Level</a><a id="51835" class="Symbol">}</a> <a id="51837" class="Symbol">(</a><a id="51838" href="1Lab.Path.html#51838" class="Bound">A</a> <a id="51840" class="Symbol">:</a> <a id="51842" class="Symbol">∀</a> <a id="51844" href="1Lab.Path.html#51844" class="Bound">i</a> <a id="51846" class="Symbol">→</a> <a id="51848" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="51853" class="Symbol">(</a><a id="51854" href="1Lab.Path.html#51822" class="Bound">ℓ</a> <a id="51856" href="1Lab.Path.html#51844" class="Bound">i</a><a id="51857" class="Symbol">))</a> <a id="51860" class="Symbol">(</a><a id="51861" href="1Lab.Path.html#51861" class="Bound">i</a> <a id="51863" class="Symbol">:</a> <a id="51865" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a><a id="51866" class="Symbol">)</a> <a id="51868" class="Symbol">→</a> <a id="51870" href="1Lab.Path.html#51838" class="Bound">A</a> <a id="51872" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a> <a id="51875" class="Symbol">→</a> <a id="51877" href="1Lab.Path.html#51838" class="Bound">A</a> <a id="51879" href="1Lab.Path.html#51861" class="Bound">i</a>
<a id="51881" href="1Lab.Path.html#51810" data-type="(A : (i : I) → Type (ℓ i)) (i : I) → A i1 → A i" class="Function">coe1→i</a> <a id="51888" href="1Lab.Path.html#51888" class="Bound">A</a> <a id="51890" href="1Lab.Path.html#51890" class="Bound">i</a> <a id="51892" href="1Lab.Path.html#51892" class="Bound">a</a> <a id="51894" class="Symbol">=</a> <a id="51896" href="1Lab.Path.html#2405" class="Primitive">transp</a> <a id="51903" class="Symbol">(λ</a> <a id="51906" href="1Lab.Path.html#51906" class="Bound">j</a> <a id="51908" class="Symbol">→</a> <a id="51910" href="1Lab.Path.html#51888" class="Bound">A</a> <a id="51912" class="Symbol">(</a><a id="51913" href="1Lab.Path.html#51890" class="Bound">i</a> <a id="51915" href="1Lab.Path.html#2226" class="Primitive Operator">∨</a> <a id="51917" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="51919" href="1Lab.Path.html#51906" class="Bound">j</a><a id="51920" class="Symbol">))</a> <a id="51923" href="1Lab.Path.html#51890" class="Bound">i</a> <a id="51925" href="1Lab.Path.html#51892" class="Bound">a</a>
</pre>
<p>We visualise
<span class="Agda"><a href="1Lab.Path.html#51690" class="Function">coe0→i</a></span>
and
<span class="Agda"><a href="1Lab.Path.html#51810" class="Function">coe1→i</a></span>
as being “spread” operations, since they take a value from one endpoint
of the interval (0 or 1, respectively) and “spread it” to a line varying
over the variable <code>i</code>. Similarly, we have “squeeze”
operations, which take a line varying over <code>i</code> to one of the
endpoints:</p>
<pre class="Agda"><a id="coei→0"></a><a id="52255" href="1Lab.Path.html#52255" data-type="(A : (i : I) → Type (ℓ i)) (i : I) → A i → A i0" class="Function">coei→0</a> <a id="52262" class="Symbol">:</a> <a id="52264" class="Symbol">∀</a> <a id="52266" class="Symbol">{</a><a id="52267" href="1Lab.Path.html#52267" class="Bound">ℓ</a> <a id="52269" class="Symbol">:</a> <a id="52271" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a> <a id="52273" class="Symbol">→</a> <a id="52275" href="Agda.Primitive.html#597" data-type="Type" class="Postulate">Level</a><a id="52280" class="Symbol">}</a> <a id="52282" class="Symbol">(</a><a id="52283" href="1Lab.Path.html#52283" class="Bound">A</a> <a id="52285" class="Symbol">:</a> <a id="52287" class="Symbol">∀</a> <a id="52289" href="1Lab.Path.html#52289" class="Bound">i</a> <a id="52291" class="Symbol">→</a> <a id="52293" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="52298" class="Symbol">(</a><a id="52299" href="1Lab.Path.html#52267" class="Bound">ℓ</a> <a id="52301" href="1Lab.Path.html#52289" class="Bound">i</a><a id="52302" class="Symbol">))</a> <a id="52305" class="Symbol">(</a><a id="52306" href="1Lab.Path.html#52306" class="Bound">i</a> <a id="52308" class="Symbol">:</a> <a id="52310" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a><a id="52311" class="Symbol">)</a> <a id="52313" class="Symbol">→</a> <a id="52315" href="1Lab.Path.html#52283" class="Bound">A</a> <a id="52317" href="1Lab.Path.html#52306" class="Bound">i</a> <a id="52319" class="Symbol">→</a> <a id="52321" href="1Lab.Path.html#52283" class="Bound">A</a> <a id="52323" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a>
<a id="52326" href="1Lab.Path.html#52255" data-type="(A : (i : I) → Type (ℓ i)) (i : I) → A i → A i0" class="Function">coei→0</a> <a id="52333" href="1Lab.Path.html#52333" class="Bound">A</a> <a id="52335" href="1Lab.Path.html#52335" class="Bound">i</a> <a id="52337" href="1Lab.Path.html#52337" class="Bound">a</a> <a id="52339" class="Symbol">=</a> <a id="52341" href="1Lab.Path.html#2405" class="Primitive">transp</a> <a id="52348" class="Symbol">(λ</a> <a id="52351" href="1Lab.Path.html#52351" class="Bound">j</a> <a id="52353" class="Symbol">→</a> <a id="52355" href="1Lab.Path.html#52333" class="Bound">A</a> <a id="52357" class="Symbol">(</a><a id="52358" href="1Lab.Path.html#52335" class="Bound">i</a> <a id="52360" href="1Lab.Path.html#2191" class="Primitive Operator">∧</a> <a id="52362" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="52364" href="1Lab.Path.html#52351" class="Bound">j</a><a id="52365" class="Symbol">))</a> <a id="52368" class="Symbol">(</a><a id="52369" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="52371" href="1Lab.Path.html#52335" class="Bound">i</a><a id="52372" class="Symbol">)</a> <a id="52374" href="1Lab.Path.html#52337" class="Bound">a</a>
</pre>
<p>Using the filler of a square, we can put together the
<code>0→i</code> and <code>1→i</code> coercions to get the “master
coercion” operation. That square is drawn as the diagram below, where
the edges are more important than the corners, and the dashed line is
<code>coe A i i1</code>.</p>
<div class="diagram-container">
<img src="light-dfdef1819b245987b0caad39466424e7a0c71e9d.svg" title="commutative diagram" class="diagram diagram-light quiver" />
<img src="dark-dfdef1819b245987b0caad39466424e7a0c71e9d.svg" title="commutative diagram" class="diagram diagram-dark quiver" />
</div>
<pre class="Agda"><a id="coe"></a><a id="53162" href="1Lab.Path.html#53162" data-type="(A : (i : I) → Type (ℓ i)) (i j : I) → A i → A j" class="Function">coe</a> <a id="53166" class="Symbol">:</a> <a id="53168" class="Symbol">∀</a> <a id="53170" class="Symbol">{</a><a id="53171" href="1Lab.Path.html#53171" class="Bound">ℓ</a> <a id="53173" class="Symbol">:</a> <a id="53175" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a> <a id="53177" class="Symbol">→</a> <a id="53179" href="Agda.Primitive.html#597" data-type="Type" class="Postulate">Level</a><a id="53184" class="Symbol">}</a> <a id="53186" class="Symbol">(</a><a id="53187" href="1Lab.Path.html#53187" class="Bound">A</a> <a id="53189" class="Symbol">:</a> <a id="53191" class="Symbol">∀</a> <a id="53193" href="1Lab.Path.html#53193" class="Bound">i</a> <a id="53195" class="Symbol">→</a> <a id="53197" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="53202" class="Symbol">(</a><a id="53203" href="1Lab.Path.html#53171" class="Bound">ℓ</a> <a id="53205" href="1Lab.Path.html#53193" class="Bound">i</a><a id="53206" class="Symbol">))</a> <a id="53209" class="Symbol">(</a><a id="53210" href="1Lab.Path.html#53210" class="Bound">i</a> <a id="53212" href="1Lab.Path.html#53212" class="Bound">j</a> <a id="53214" class="Symbol">:</a> <a id="53216" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a><a id="53217" class="Symbol">)</a> <a id="53219" class="Symbol">→</a> <a id="53221" href="1Lab.Path.html#53187" class="Bound">A</a> <a id="53223" href="1Lab.Path.html#53210" class="Bound">i</a> <a id="53225" class="Symbol">→</a> <a id="53227" href="1Lab.Path.html#53187" class="Bound">A</a> <a id="53229" href="1Lab.Path.html#53212" class="Bound">j</a>
<a id="53231" href="1Lab.Path.html#53162" data-type="(A : (i : I) → Type (ℓ i)) (i j : I) → A i → A j" class="Function">coe</a> <a id="53235" href="1Lab.Path.html#53235" class="Bound">A</a> <a id="53237" href="1Lab.Path.html#53237" class="Bound">i</a> <a id="53239" href="1Lab.Path.html#53239" class="Bound">j</a> <a id="53241" href="1Lab.Path.html#53241" class="Bound">a</a> <a id="53243" class="Symbol">=</a>
  <a id="53247" href="1Lab.Path.html#37552" data-type="(A : (i : I) → Type (ℓ i)) (u : (i : I) → Partial φ (A i)) →
A i0 [ φ ↦ u i0 ] → (i : I) → A i" class="Function">fill</a> <a id="53252" href="1Lab.Path.html#53235" class="Bound">A</a> <a id="53254" class="Symbol">(λ</a> <a id="53257" href="1Lab.Path.html#53257" class="Bound">j</a> <a id="53259" class="Symbol">→</a> <a id="53261" class="Symbol">λ</a> <a id="53263" class="Symbol">{</a> <a id="53265" class="Symbol">(</a><a id="53266" href="1Lab.Path.html#53237" class="Bound">i</a> <a id="53268" class="Symbol">=</a> <a id="53270" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a><a id="53272" class="Symbol">)</a> <a id="53274" class="Symbol">→</a> <a id="53276" href="1Lab.Path.html#51690" data-type="(A : (i : I) → Type (ℓ i)) (i : I) → A i0 → A i" class="Function">coe0→i</a> <a id="53283" href="1Lab.Path.html#53235" class="Bound">A</a> <a id="53285" href="1Lab.Path.html#53257" class="Bound">j</a> <a id="53287" href="1Lab.Path.html#53241" class="Bound">a</a>
                  <a id="53307" class="Symbol">;</a> <a id="53309" class="Symbol">(</a><a id="53310" href="1Lab.Path.html#53237" class="Bound">i</a> <a id="53312" class="Symbol">=</a> <a id="53314" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a><a id="53316" class="Symbol">)</a> <a id="53318" class="Symbol">→</a> <a id="53320" href="1Lab.Path.html#51810" data-type="(A : (i : I) → Type (ℓ i)) (i : I) → A i1 → A i" class="Function">coe1→i</a> <a id="53327" href="1Lab.Path.html#53235" class="Bound">A</a> <a id="53329" href="1Lab.Path.html#53257" class="Bound">j</a> <a id="53331" href="1Lab.Path.html#53241" class="Bound">a</a>
                  <a id="53351" class="Symbol">})</a>
    <a id="53358" class="Symbol">(</a><a id="53359" href="1Lab.Path.html#2069" class="Postulate">inS</a> <a id="53363" class="Symbol">(</a><a id="53364" href="1Lab.Path.html#52255" data-type="(A : (i : I) → Type (ℓ i)) (i : I) → A i → A i0" class="Function">coei→0</a> <a id="53371" href="1Lab.Path.html#53235" class="Bound">A</a> <a id="53373" href="1Lab.Path.html#53237" class="Bound">i</a> <a id="53375" href="1Lab.Path.html#53241" class="Bound">a</a><a id="53376" class="Symbol">))</a> <a id="53379" href="1Lab.Path.html#53239" class="Bound">j</a>
</pre>
<p>As the square implies, when <code>j = i1</code>, we have the squeeze
operation opposite to
<span class="Agda"><a href="1Lab.Path.html#52255" class="Function">coei→0</a></span>,
which we call
<span class="Agda"><a href="1Lab.Path.html#53519" class="Function">coei→1</a></span>.</p>
<pre class="Agda"><a id="coei→1"></a><a id="53519" href="1Lab.Path.html#53519" data-type="(A : (i : I) → Type (ℓ i)) (i : I) → A i → A i1" class="Function">coei→1</a> <a id="53526" class="Symbol">:</a> <a id="53528" class="Symbol">∀</a> <a id="53530" class="Symbol">{</a><a id="53531" href="1Lab.Path.html#53531" class="Bound">ℓ</a> <a id="53533" class="Symbol">:</a> <a id="53535" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a> <a id="53537" class="Symbol">→</a> <a id="53539" href="Agda.Primitive.html#597" data-type="Type" class="Postulate">Level</a><a id="53544" class="Symbol">}</a> <a id="53546" class="Symbol">(</a><a id="53547" href="1Lab.Path.html#53547" class="Bound">A</a> <a id="53549" class="Symbol">:</a> <a id="53551" class="Symbol">∀</a> <a id="53553" href="1Lab.Path.html#53553" class="Bound">i</a> <a id="53555" class="Symbol">→</a> <a id="53557" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="53562" class="Symbol">(</a><a id="53563" href="1Lab.Path.html#53531" class="Bound">ℓ</a> <a id="53565" href="1Lab.Path.html#53553" class="Bound">i</a><a id="53566" class="Symbol">))</a> <a id="53569" class="Symbol">(</a><a id="53570" href="1Lab.Path.html#53570" class="Bound">i</a> <a id="53572" class="Symbol">:</a> <a id="53574" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a><a id="53575" class="Symbol">)</a> <a id="53577" class="Symbol">→</a> <a id="53579" href="1Lab.Path.html#53547" class="Bound">A</a> <a id="53581" href="1Lab.Path.html#53570" class="Bound">i</a> <a id="53583" class="Symbol">→</a> <a id="53585" href="1Lab.Path.html#53547" class="Bound">A</a> <a id="53587" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a>
<a id="53590" href="1Lab.Path.html#53519" data-type="(A : (i : I) → Type (ℓ i)) (i : I) → A i → A i1" class="Function">coei→1</a> <a id="53597" href="1Lab.Path.html#53597" class="Bound">A</a> <a id="53599" href="1Lab.Path.html#53599" class="Bound">i</a> <a id="53601" href="1Lab.Path.html#53601" class="Bound">a</a> <a id="53603" class="Symbol">=</a> <a id="53605" href="1Lab.Path.html#53162" data-type="(A : (i : I) → Type (ℓ i)) (i j : I) → A i → A j" class="Function">coe</a> <a id="53609" href="1Lab.Path.html#53597" class="Bound">A</a> <a id="53611" href="1Lab.Path.html#53599" class="Bound">i</a> <a id="53613" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a> <a id="53616" href="1Lab.Path.html#53601" class="Bound">a</a>
</pre>
<p><strong>Sidenote</strong>: The boundary for the square implies that
we can give a more verbose type for
<span class="Agda"><a href="1Lab.Path.html#53162" class="Function">coe</a></span>,
one which mentions all of the spreads and squeezes. Note that this is a
<em>dependent path between functions
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mtext> </mtext><mi>i</mi><mo>→</mo><mi>A</mi><mtext> </mtext><mi>j</mi></mrow><annotation encoding="application/x-tex">A\ i \to A\ j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace"> </span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">A</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span></em>,
a very complicated construction indeed!</p>
<pre class="Agda"><a id="53901" class="Keyword">private</a>
  <a id="coe-verbose"></a><a id="53911" href="1Lab.Path.html#53911" class="Function">coe-verbose</a> <a id="53923" class="Symbol">:</a> <a id="53925" class="Symbol">∀</a> <a id="53927" class="Symbol">{</a><a id="53928" href="1Lab.Path.html#53928" class="Bound">ℓ</a><a id="53929" class="Symbol">}</a> <a id="53931" class="Symbol">(</a><a id="53932" href="1Lab.Path.html#53932" class="Bound">A</a> <a id="53934" class="Symbol">:</a> <a id="53936" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a> <a id="53938" class="Symbol">→</a> <a id="53940" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="53945" href="1Lab.Path.html#53928" class="Bound">ℓ</a><a id="53946" class="Symbol">)</a>
              <a id="53962" class="Symbol">→</a> <a id="53964" href="Agda.Builtin.Cubical.Path.html#197" data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" class="Postulate">PathP</a> <a id="53970" class="Symbol">(λ</a> <a id="53973" href="1Lab.Path.html#53973" class="Bound">i</a> <a id="53975" class="Symbol">→</a> <a id="53977" href="Agda.Builtin.Cubical.Path.html#197" data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" class="Postulate">PathP</a> <a id="53983" class="Symbol">(λ</a> <a id="53986" href="1Lab.Path.html#53986" class="Bound">j</a> <a id="53988" class="Symbol">→</a> <a id="53990" href="1Lab.Path.html#53932" class="Bound">A</a> <a id="53992" href="1Lab.Path.html#53973" class="Bound">i</a> <a id="53994" class="Symbol">→</a> <a id="53996" href="1Lab.Path.html#53932" class="Bound">A</a> <a id="53998" href="1Lab.Path.html#53986" class="Bound">j</a><a id="53999" class="Symbol">)</a>
                                <a id="54033" class="Symbol">(</a><a id="54034" href="1Lab.Path.html#52255" data-type="(A : (i : I) → Type (ℓ i)) (i : I) → A i → A i0" class="Function">coei→0</a> <a id="54041" href="1Lab.Path.html#53932" class="Bound">A</a> <a id="54043" href="1Lab.Path.html#53973" class="Bound">i</a><a id="54044" class="Symbol">)</a>
                                <a id="54078" class="Symbol">(</a><a id="54079" href="1Lab.Path.html#53519" data-type="(A : (i : I) → Type (ℓ i)) (i : I) → A i → A i1" class="Function">coei→1</a> <a id="54086" href="1Lab.Path.html#53932" class="Bound">A</a> <a id="54088" href="1Lab.Path.html#53973" class="Bound">i</a><a id="54089" class="Symbol">))</a>
                      <a id="54114" class="Symbol">(λ</a> <a id="54117" href="1Lab.Path.html#54117" class="Bound">j</a> <a id="54119" class="Symbol">→</a> <a id="54121" href="1Lab.Path.html#51690" data-type="(A : (i : I) → Type (ℓ i)) (i : I) → A i0 → A i" class="Function">coe0→i</a> <a id="54128" href="1Lab.Path.html#53932" class="Bound">A</a> <a id="54130" href="1Lab.Path.html#54117" class="Bound">j</a><a id="54131" class="Symbol">)</a>
                      <a id="54155" class="Symbol">(λ</a> <a id="54158" href="1Lab.Path.html#54158" class="Bound">j</a> <a id="54160" class="Symbol">→</a> <a id="54162" href="1Lab.Path.html#51810" data-type="(A : (i : I) → Type (ℓ i)) (i : I) → A i1 → A i" class="Function">coe1→i</a> <a id="54169" href="1Lab.Path.html#53932" class="Bound">A</a> <a id="54171" href="1Lab.Path.html#54158" class="Bound">j</a><a id="54172" class="Symbol">)</a>
  <a id="54176" href="1Lab.Path.html#53911" class="Function">coe-verbose</a> <a id="54188" href="1Lab.Path.html#54188" class="Bound">A</a> <a id="54190" href="1Lab.Path.html#54190" class="Bound">i</a> <a id="54192" href="1Lab.Path.html#54192" class="Bound">j</a> <a id="54194" class="Symbol">=</a> <a id="54196" href="1Lab.Path.html#53162" data-type="(A : (i : I) → Type (ℓ i)) (i j : I) → A i → A j" class="Function">coe</a> <a id="54200" href="1Lab.Path.html#54188" class="Bound">A</a> <a id="54202" href="1Lab.Path.html#54190" class="Bound">i</a> <a id="54204" href="1Lab.Path.html#54192" class="Bound">j</a>
</pre>
<p>This operation satisfies, <em>definitionally</em>, a whole host of
equations. For starters, we have that the
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">e</mi></mrow><mrow><mi>i</mi><mo>→</mo><mn>1</mn></mrow><mi>A</mi></msubsup></mrow><annotation encoding="application/x-tex">\id{coe}^A_{i\to1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1em;vertical-align:-0.2587em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">coe</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-2.4413em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">→</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2587em;"><span></span></span></span></span></span></span></span></span></span>
(resp
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>→</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">i \to 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>)</span>
specialises to transport when
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">i = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>
(resp.
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>),</span>
and to the identity when
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>
(resp.
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">i = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>):</span></p>
<pre class="Agda"><a id="coei0→1"></a><a id="54465" href="1Lab.Path.html#54465" data-type="(A : I → Type ℓ) (a : A i0) → coei→1 A i0 a ≡ coe0→1 A a" class="Function">coei0→1</a> <a id="54473" class="Symbol">:</a> <a id="54475" class="Symbol">∀</a> <a id="54477" class="Symbol">{</a><a id="54478" href="1Lab.Path.html#54478" class="Bound">ℓ</a><a id="54479" class="Symbol">}</a> <a id="54481" class="Symbol">(</a><a id="54482" href="1Lab.Path.html#54482" class="Bound">A</a> <a id="54484" class="Symbol">:</a> <a id="54486" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a> <a id="54488" class="Symbol">→</a> <a id="54490" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="54495" href="1Lab.Path.html#54478" class="Bound">ℓ</a><a id="54496" class="Symbol">)</a> <a id="54498" class="Symbol">(</a><a id="54499" href="1Lab.Path.html#54499" class="Bound">a</a> <a id="54501" class="Symbol">:</a> <a id="54503" href="1Lab.Path.html#54482" class="Bound">A</a> <a id="54505" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a><a id="54507" class="Symbol">)</a> <a id="54509" class="Symbol">→</a> <a id="54511" href="1Lab.Path.html#53519" data-type="(A : (i : I) → Type (ℓ i)) (i : I) → A i → A i1" class="Function">coei→1</a> <a id="54518" href="1Lab.Path.html#54482" class="Bound">A</a> <a id="54520" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a> <a id="54523" href="1Lab.Path.html#54499" class="Bound">a</a> <a id="54525" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="54527" href="1Lab.Path.html#51235" data-type="(A : I → Type ℓ) → A i0 → A i1" class="Function">coe0→1</a> <a id="54534" href="1Lab.Path.html#54482" class="Bound">A</a> <a id="54536" href="1Lab.Path.html#54499" class="Bound">a</a>
<a id="54538" href="1Lab.Path.html#54465" data-type="(A : I → Type ℓ) (a : A i0) → coei→1 A i0 a ≡ coe0→1 A a" class="Function">coei0→1</a> <a id="54546" href="1Lab.Path.html#54546" class="Bound">A</a> <a id="54548" href="1Lab.Path.html#54548" class="Bound">a</a> <a id="54550" class="Symbol">=</a> <a id="54552" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>

<a id="coei1→1"></a><a id="54558" href="1Lab.Path.html#54558" data-type="(A : I → Type ℓ) (a : A i1) → coei→1 A i1 a ≡ a" class="Function">coei1→1</a> <a id="54566" class="Symbol">:</a> <a id="54568" class="Symbol">∀</a> <a id="54570" class="Symbol">{</a><a id="54571" href="1Lab.Path.html#54571" class="Bound">ℓ</a><a id="54572" class="Symbol">}</a> <a id="54574" class="Symbol">(</a><a id="54575" href="1Lab.Path.html#54575" class="Bound">A</a> <a id="54577" class="Symbol">:</a> <a id="54579" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a> <a id="54581" class="Symbol">→</a> <a id="54583" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="54588" href="1Lab.Path.html#54571" class="Bound">ℓ</a><a id="54589" class="Symbol">)</a> <a id="54591" class="Symbol">(</a><a id="54592" href="1Lab.Path.html#54592" class="Bound">a</a> <a id="54594" class="Symbol">:</a> <a id="54596" href="1Lab.Path.html#54575" class="Bound">A</a> <a id="54598" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a><a id="54600" class="Symbol">)</a> <a id="54602" class="Symbol">→</a> <a id="54604" href="1Lab.Path.html#53519" data-type="(A : (i : I) → Type (ℓ i)) (i : I) → A i → A i1" class="Function">coei→1</a> <a id="54611" href="1Lab.Path.html#54575" class="Bound">A</a> <a id="54613" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a> <a id="54616" href="1Lab.Path.html#54592" class="Bound">a</a> <a id="54618" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="54620" href="1Lab.Path.html#54592" class="Bound">a</a>
<a id="54622" href="1Lab.Path.html#54558" data-type="(A : I → Type ℓ) (a : A i1) → coei→1 A i1 a ≡ a" class="Function">coei1→1</a> <a id="54630" href="1Lab.Path.html#54630" class="Bound">A</a> <a id="54632" href="1Lab.Path.html#54632" class="Bound">a</a> <a id="54634" class="Symbol">=</a> <a id="54636" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>

<a id="coei1→0"></a><a id="54642" href="1Lab.Path.html#54642" data-type="(A : I → Type ℓ) (a : A i1) → coei→0 A i1 a ≡ coe1→0 A a" class="Function">coei1→0</a> <a id="54650" class="Symbol">:</a> <a id="54652" class="Symbol">∀</a> <a id="54654" class="Symbol">{</a><a id="54655" href="1Lab.Path.html#54655" class="Bound">ℓ</a><a id="54656" class="Symbol">}</a> <a id="54658" class="Symbol">(</a><a id="54659" href="1Lab.Path.html#54659" class="Bound">A</a> <a id="54661" class="Symbol">:</a> <a id="54663" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a> <a id="54665" class="Symbol">→</a> <a id="54667" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="54672" href="1Lab.Path.html#54655" class="Bound">ℓ</a><a id="54673" class="Symbol">)</a> <a id="54675" class="Symbol">(</a><a id="54676" href="1Lab.Path.html#54676" class="Bound">a</a> <a id="54678" class="Symbol">:</a> <a id="54680" href="1Lab.Path.html#54659" class="Bound">A</a> <a id="54682" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a><a id="54684" class="Symbol">)</a> <a id="54686" class="Symbol">→</a> <a id="54688" href="1Lab.Path.html#52255" data-type="(A : (i : I) → Type (ℓ i)) (i : I) → A i → A i0" class="Function">coei→0</a> <a id="54695" href="1Lab.Path.html#54659" class="Bound">A</a> <a id="54697" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a> <a id="54700" href="1Lab.Path.html#54676" class="Bound">a</a> <a id="54702" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="54704" href="1Lab.Path.html#51359" data-type="(A : I → Type ℓ) → A i1 → A i0" class="Function">coe1→0</a> <a id="54711" href="1Lab.Path.html#54659" class="Bound">A</a> <a id="54713" href="1Lab.Path.html#54676" class="Bound">a</a>
<a id="54715" href="1Lab.Path.html#54642" data-type="(A : I → Type ℓ) (a : A i1) → coei→0 A i1 a ≡ coe1→0 A a" class="Function">coei1→0</a> <a id="54723" href="1Lab.Path.html#54723" class="Bound">A</a> <a id="54725" href="1Lab.Path.html#54725" class="Bound">a</a> <a id="54727" class="Symbol">=</a> <a id="54729" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>

<a id="coei0→0"></a><a id="54735" href="1Lab.Path.html#54735" data-type="(A : I → Type ℓ) (a : A i0) → coei→0 A i0 a ≡ a" class="Function">coei0→0</a> <a id="54743" class="Symbol">:</a> <a id="54745" class="Symbol">∀</a> <a id="54747" class="Symbol">{</a><a id="54748" href="1Lab.Path.html#54748" class="Bound">ℓ</a><a id="54749" class="Symbol">}</a> <a id="54751" class="Symbol">(</a><a id="54752" href="1Lab.Path.html#54752" class="Bound">A</a> <a id="54754" class="Symbol">:</a> <a id="54756" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a> <a id="54758" class="Symbol">→</a> <a id="54760" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="54765" href="1Lab.Path.html#54748" class="Bound">ℓ</a><a id="54766" class="Symbol">)</a> <a id="54768" class="Symbol">(</a><a id="54769" href="1Lab.Path.html#54769" class="Bound">a</a> <a id="54771" class="Symbol">:</a> <a id="54773" href="1Lab.Path.html#54752" class="Bound">A</a> <a id="54775" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a><a id="54777" class="Symbol">)</a> <a id="54779" class="Symbol">→</a> <a id="54781" href="1Lab.Path.html#52255" data-type="(A : (i : I) → Type (ℓ i)) (i : I) → A i → A i0" class="Function">coei→0</a> <a id="54788" href="1Lab.Path.html#54752" class="Bound">A</a> <a id="54790" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a> <a id="54793" href="1Lab.Path.html#54769" class="Bound">a</a> <a id="54795" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="54797" href="1Lab.Path.html#54769" class="Bound">a</a>
<a id="54799" href="1Lab.Path.html#54735" data-type="(A : I → Type ℓ) (a : A i0) → coei→0 A i0 a ≡ a" class="Function">coei0→0</a> <a id="54807" href="1Lab.Path.html#54807" class="Bound">A</a> <a id="54809" href="1Lab.Path.html#54809" class="Bound">a</a> <a id="54811" class="Symbol">=</a> <a id="54813" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
</pre>
<p>Then we have paths connecting the “master coercion”
<span class="Agda"><a href="1Lab.Path.html#53162" class="Function">coe</a></span>
and its several faces:</p>
<pre class="Agda"><a id="coei→i0"></a><a id="54916" href="1Lab.Path.html#54916" data-type="(A : I → Type ℓ) (i : I) (a : A i) → coe A i i0 a ≡ coei→0 A i a" class="Function">coei→i0</a> <a id="54924" class="Symbol">:</a> <a id="54926" class="Symbol">∀</a> <a id="54928" class="Symbol">{</a><a id="54929" href="1Lab.Path.html#54929" class="Bound">ℓ</a><a id="54930" class="Symbol">}</a> <a id="54932" class="Symbol">(</a><a id="54933" href="1Lab.Path.html#54933" class="Bound">A</a> <a id="54935" class="Symbol">:</a> <a id="54937" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a> <a id="54939" class="Symbol">→</a> <a id="54941" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="54946" href="1Lab.Path.html#54929" class="Bound">ℓ</a><a id="54947" class="Symbol">)</a> <a id="54949" class="Symbol">(</a><a id="54950" href="1Lab.Path.html#54950" class="Bound">i</a> <a id="54952" class="Symbol">:</a> <a id="54954" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a><a id="54955" class="Symbol">)</a> <a id="54957" class="Symbol">(</a><a id="54958" href="1Lab.Path.html#54958" class="Bound">a</a> <a id="54960" class="Symbol">:</a> <a id="54962" href="1Lab.Path.html#54933" class="Bound">A</a> <a id="54964" href="1Lab.Path.html#54950" class="Bound">i</a><a id="54965" class="Symbol">)</a>
        <a id="54975" class="Symbol">→</a> <a id="54977" href="1Lab.Path.html#53162" data-type="(A : (i : I) → Type (ℓ i)) (i j : I) → A i → A j" class="Function">coe</a> <a id="54981" href="1Lab.Path.html#54933" class="Bound">A</a> <a id="54983" href="1Lab.Path.html#54950" class="Bound">i</a> <a id="54985" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a> <a id="54988" href="1Lab.Path.html#54958" class="Bound">a</a> <a id="54990" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="54992" href="1Lab.Path.html#52255" data-type="(A : (i : I) → Type (ℓ i)) (i : I) → A i → A i0" class="Function">coei→0</a> <a id="54999" href="1Lab.Path.html#54933" class="Bound">A</a> <a id="55001" href="1Lab.Path.html#54950" class="Bound">i</a> <a id="55003" href="1Lab.Path.html#54958" class="Bound">a</a>
<a id="55005" href="1Lab.Path.html#54916" data-type="(A : I → Type ℓ) (i : I) (a : A i) → coe A i i0 a ≡ coei→0 A i a" class="Function">coei→i0</a> <a id="55013" href="1Lab.Path.html#55013" class="Bound">A</a> <a id="55015" href="1Lab.Path.html#55015" class="Bound">i</a> <a id="55017" href="1Lab.Path.html#55017" class="Bound">a</a> <a id="55019" class="Symbol">=</a> <a id="55021" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>

<a id="coei0→i"></a><a id="55027" href="1Lab.Path.html#55027" data-type="(A : I → Type ℓ) (i : I) (a : A i0) → coe A i0 i a ≡ coe0→i A i a" class="Function">coei0→i</a> <a id="55035" class="Symbol">:</a> <a id="55037" class="Symbol">∀</a> <a id="55039" class="Symbol">{</a><a id="55040" href="1Lab.Path.html#55040" class="Bound">ℓ</a><a id="55041" class="Symbol">}</a> <a id="55043" class="Symbol">(</a><a id="55044" href="1Lab.Path.html#55044" class="Bound">A</a> <a id="55046" class="Symbol">:</a> <a id="55048" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a> <a id="55050" class="Symbol">→</a> <a id="55052" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="55057" href="1Lab.Path.html#55040" class="Bound">ℓ</a><a id="55058" class="Symbol">)</a> <a id="55060" class="Symbol">(</a><a id="55061" href="1Lab.Path.html#55061" class="Bound">i</a> <a id="55063" class="Symbol">:</a> <a id="55065" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a><a id="55066" class="Symbol">)</a> <a id="55068" class="Symbol">(</a><a id="55069" href="1Lab.Path.html#55069" class="Bound">a</a> <a id="55071" class="Symbol">:</a> <a id="55073" href="1Lab.Path.html#55044" class="Bound">A</a> <a id="55075" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a><a id="55077" class="Symbol">)</a>
        <a id="55087" class="Symbol">→</a> <a id="55089" href="1Lab.Path.html#53162" data-type="(A : (i : I) → Type (ℓ i)) (i j : I) → A i → A j" class="Function">coe</a> <a id="55093" href="1Lab.Path.html#55044" class="Bound">A</a> <a id="55095" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a> <a id="55098" href="1Lab.Path.html#55061" class="Bound">i</a> <a id="55100" href="1Lab.Path.html#55069" class="Bound">a</a> <a id="55102" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="55104" href="1Lab.Path.html#51690" data-type="(A : (i : I) → Type (ℓ i)) (i : I) → A i0 → A i" class="Function">coe0→i</a> <a id="55111" href="1Lab.Path.html#55044" class="Bound">A</a> <a id="55113" href="1Lab.Path.html#55061" class="Bound">i</a> <a id="55115" href="1Lab.Path.html#55069" class="Bound">a</a>
<a id="55117" href="1Lab.Path.html#55027" data-type="(A : I → Type ℓ) (i : I) (a : A i0) → coe A i0 i a ≡ coe0→i A i a" class="Function">coei0→i</a> <a id="55125" href="1Lab.Path.html#55125" class="Bound">A</a> <a id="55127" href="1Lab.Path.html#55127" class="Bound">i</a> <a id="55129" href="1Lab.Path.html#55129" class="Bound">a</a> <a id="55131" class="Symbol">=</a> <a id="55133" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>

<a id="coei→i1"></a><a id="55139" href="1Lab.Path.html#55139" data-type="(A : I → Type ℓ) (i : I) (a : A i) → coe A i i1 a ≡ coei→1 A i a" class="Function">coei→i1</a> <a id="55147" class="Symbol">:</a> <a id="55149" class="Symbol">∀</a> <a id="55151" class="Symbol">{</a><a id="55152" href="1Lab.Path.html#55152" class="Bound">ℓ</a><a id="55153" class="Symbol">}</a> <a id="55155" class="Symbol">(</a><a id="55156" href="1Lab.Path.html#55156" class="Bound">A</a> <a id="55158" class="Symbol">:</a> <a id="55160" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a> <a id="55162" class="Symbol">→</a> <a id="55164" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="55169" href="1Lab.Path.html#55152" class="Bound">ℓ</a><a id="55170" class="Symbol">)</a> <a id="55172" class="Symbol">(</a><a id="55173" href="1Lab.Path.html#55173" class="Bound">i</a> <a id="55175" class="Symbol">:</a> <a id="55177" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a><a id="55178" class="Symbol">)</a> <a id="55180" class="Symbol">(</a><a id="55181" href="1Lab.Path.html#55181" class="Bound">a</a> <a id="55183" class="Symbol">:</a> <a id="55185" href="1Lab.Path.html#55156" class="Bound">A</a> <a id="55187" href="1Lab.Path.html#55173" class="Bound">i</a><a id="55188" class="Symbol">)</a>
        <a id="55198" class="Symbol">→</a> <a id="55200" href="1Lab.Path.html#53162" data-type="(A : (i : I) → Type (ℓ i)) (i j : I) → A i → A j" class="Function">coe</a> <a id="55204" href="1Lab.Path.html#55156" class="Bound">A</a> <a id="55206" href="1Lab.Path.html#55173" class="Bound">i</a> <a id="55208" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a> <a id="55211" href="1Lab.Path.html#55181" class="Bound">a</a> <a id="55213" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="55215" href="1Lab.Path.html#53519" data-type="(A : (i : I) → Type (ℓ i)) (i : I) → A i → A i1" class="Function">coei→1</a> <a id="55222" href="1Lab.Path.html#55156" class="Bound">A</a> <a id="55224" href="1Lab.Path.html#55173" class="Bound">i</a> <a id="55226" href="1Lab.Path.html#55181" class="Bound">a</a>
<a id="55228" href="1Lab.Path.html#55139" data-type="(A : I → Type ℓ) (i : I) (a : A i) → coe A i i1 a ≡ coei→1 A i a" class="Function">coei→i1</a> <a id="55236" href="1Lab.Path.html#55236" class="Bound">A</a> <a id="55238" href="1Lab.Path.html#55238" class="Bound">i</a> <a id="55240" href="1Lab.Path.html#55240" class="Bound">a</a> <a id="55242" class="Symbol">=</a> <a id="55244" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>

<a id="coei1→i"></a><a id="55250" href="1Lab.Path.html#55250" data-type="(A : I → Type ℓ) (i : I) (a : A i1) → coe A i1 i a ≡ coe1→i A i a" class="Function">coei1→i</a> <a id="55258" class="Symbol">:</a> <a id="55260" class="Symbol">∀</a> <a id="55262" class="Symbol">{</a><a id="55263" href="1Lab.Path.html#55263" class="Bound">ℓ</a><a id="55264" class="Symbol">}</a> <a id="55266" class="Symbol">(</a><a id="55267" href="1Lab.Path.html#55267" class="Bound">A</a> <a id="55269" class="Symbol">:</a> <a id="55271" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a> <a id="55273" class="Symbol">→</a> <a id="55275" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="55280" href="1Lab.Path.html#55263" class="Bound">ℓ</a><a id="55281" class="Symbol">)</a> <a id="55283" class="Symbol">(</a><a id="55284" href="1Lab.Path.html#55284" class="Bound">i</a> <a id="55286" class="Symbol">:</a> <a id="55288" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a><a id="55289" class="Symbol">)</a> <a id="55291" class="Symbol">(</a><a id="55292" href="1Lab.Path.html#55292" class="Bound">a</a> <a id="55294" class="Symbol">:</a> <a id="55296" href="1Lab.Path.html#55267" class="Bound">A</a> <a id="55298" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a><a id="55300" class="Symbol">)</a>
        <a id="55310" class="Symbol">→</a> <a id="55312" href="1Lab.Path.html#53162" data-type="(A : (i : I) → Type (ℓ i)) (i j : I) → A i → A j" class="Function">coe</a> <a id="55316" href="1Lab.Path.html#55267" class="Bound">A</a> <a id="55318" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a> <a id="55321" href="1Lab.Path.html#55284" class="Bound">i</a> <a id="55323" href="1Lab.Path.html#55292" class="Bound">a</a> <a id="55325" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="55327" href="1Lab.Path.html#51810" data-type="(A : (i : I) → Type (ℓ i)) (i : I) → A i1 → A i" class="Function">coe1→i</a> <a id="55334" href="1Lab.Path.html#55267" class="Bound">A</a> <a id="55336" href="1Lab.Path.html#55284" class="Bound">i</a> <a id="55338" href="1Lab.Path.html#55292" class="Bound">a</a>
<a id="55340" href="1Lab.Path.html#55250" data-type="(A : I → Type ℓ) (i : I) (a : A i1) → coe A i1 i a ≡ coe1→i A i a" class="Function">coei1→i</a> <a id="55348" href="1Lab.Path.html#55348" class="Bound">A</a> <a id="55350" href="1Lab.Path.html#55350" class="Bound">i</a> <a id="55352" href="1Lab.Path.html#55352" class="Bound">a</a> <a id="55354" class="Symbol">=</a> <a id="55356" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
</pre>
<p>In Cartesian cubical type theory, the following equation is
definitional. It says that the top right and bottom left corners of the
diagram are indeed what I said they were! However, in Cubical Agda, it
is only propositional:</p>
<pre class="Agda"><a id="coei→i"></a><a id="55601" href="1Lab.Path.html#55601" data-type="(A : I → Type ℓ) (i : I) (a : A i) → coe A i i a ≡ a" class="Function">coei→i</a> <a id="55608" class="Symbol">:</a> <a id="55610" class="Symbol">∀</a> <a id="55612" class="Symbol">{</a><a id="55613" href="1Lab.Path.html#55613" class="Bound">ℓ</a><a id="55614" class="Symbol">}</a> <a id="55616" class="Symbol">(</a><a id="55617" href="1Lab.Path.html#55617" class="Bound">A</a> <a id="55619" class="Symbol">:</a> <a id="55621" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a> <a id="55623" class="Symbol">→</a> <a id="55625" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="55630" href="1Lab.Path.html#55613" class="Bound">ℓ</a><a id="55631" class="Symbol">)</a> <a id="55633" class="Symbol">(</a><a id="55634" href="1Lab.Path.html#55634" class="Bound">i</a> <a id="55636" class="Symbol">:</a> <a id="55638" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a><a id="55639" class="Symbol">)</a> <a id="55641" class="Symbol">(</a><a id="55642" href="1Lab.Path.html#55642" class="Bound">a</a> <a id="55644" class="Symbol">:</a> <a id="55646" href="1Lab.Path.html#55617" class="Bound">A</a> <a id="55648" href="1Lab.Path.html#55634" class="Bound">i</a><a id="55649" class="Symbol">)</a> <a id="55651" class="Symbol">→</a> <a id="55653" href="1Lab.Path.html#53162" data-type="(A : (i : I) → Type (ℓ i)) (i j : I) → A i → A j" class="Function">coe</a> <a id="55657" href="1Lab.Path.html#55617" class="Bound">A</a> <a id="55659" href="1Lab.Path.html#55634" class="Bound">i</a> <a id="55661" href="1Lab.Path.html#55634" class="Bound">i</a> <a id="55663" href="1Lab.Path.html#55642" class="Bound">a</a> <a id="55665" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="55667" href="1Lab.Path.html#55642" class="Bound">a</a>
<a id="55669" href="1Lab.Path.html#55601" data-type="(A : I → Type ℓ) (i : I) (a : A i) → coe A i i a ≡ a" class="Function">coei→i</a> <a id="55676" href="1Lab.Path.html#55676" class="Bound">A</a> <a id="55678" href="1Lab.Path.html#55678" class="Bound">i</a> <a id="55680" class="Symbol">=</a> <a id="55682" href="1Lab.Path.html#51690" data-type="(A : (i : I) → Type (ℓ i)) (i : I) → A i0 → A i" class="Function">coe0→i</a> <a id="55689" class="Symbol">(λ</a> <a id="55692" href="1Lab.Path.html#55692" class="Bound">i</a> <a id="55694" class="Symbol">→</a> <a id="55696" class="Symbol">(</a><a id="55697" href="1Lab.Path.html#55697" class="Bound">a</a> <a id="55699" class="Symbol">:</a> <a id="55701" href="1Lab.Path.html#55676" class="Bound">A</a> <a id="55703" href="1Lab.Path.html#55692" class="Bound">i</a><a id="55704" class="Symbol">)</a> <a id="55706" class="Symbol">→</a> <a id="55708" href="1Lab.Path.html#53162" data-type="(A : (i : I) → Type (ℓ i)) (i j : I) → A i → A j" class="Function">coe</a> <a id="55712" href="1Lab.Path.html#55676" class="Bound">A</a> <a id="55714" href="1Lab.Path.html#55692" class="Bound">i</a> <a id="55716" href="1Lab.Path.html#55692" class="Bound">i</a> <a id="55718" href="1Lab.Path.html#55697" class="Bound">a</a> <a id="55720" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="55722" href="1Lab.Path.html#55697" class="Bound">a</a><a id="55723" class="Symbol">)</a> <a id="55725" href="1Lab.Path.html#55678" class="Bound">i</a> <a id="55727" class="Symbol">(λ</a> <a id="55730" href="1Lab.Path.html#55730" class="Bound">_</a> <a id="55732" class="Symbol">→</a> <a id="55734" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a><a id="55738" class="Symbol">)</a>
</pre>
<p>Using the Cartesian coercions, we define maps that convert between
<span class="Agda"><a href="Agda.Builtin.Cubical.Path.html#197" class="Postulate">PathP</a></span>s
and Book dependent paths. These maps could also be defined in terms of
<span class="Agda"><a href="1Lab.Path.html#2405" class="Primitive">transp</a></span>
and
<span class="Agda"><a href="1Lab.Path.html#49201" class="Function">PathP≡Path</a></span>,
but this definition is more efficient.</p>
<pre class="Agda"><a id="to-pathp"></a><a id="55988" href="1Lab.Path.html#55988" data-type="coe0→1 A x ≡ y → PathP A x y" class="Function">to-pathp</a> <a id="55997" class="Symbol">:</a> <a id="55999" class="Symbol">∀</a> <a id="56001" class="Symbol">{</a><a id="56002" href="1Lab.Path.html#56002" class="Bound">ℓ</a><a id="56003" class="Symbol">}</a> <a id="56005" class="Symbol">{</a><a id="56006" href="1Lab.Path.html#56006" class="Bound">A</a> <a id="56008" class="Symbol">:</a> <a id="56010" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a> <a id="56012" class="Symbol">→</a> <a id="56014" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="56019" href="1Lab.Path.html#56002" class="Bound">ℓ</a><a id="56020" class="Symbol">}</a> <a id="56022" class="Symbol">{</a><a id="56023" href="1Lab.Path.html#56023" class="Bound">x</a> <a id="56025" class="Symbol">:</a> <a id="56027" href="1Lab.Path.html#56006" class="Bound">A</a> <a id="56029" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a><a id="56031" class="Symbol">}</a> <a id="56033" class="Symbol">{</a><a id="56034" href="1Lab.Path.html#56034" class="Bound">y</a> <a id="56036" class="Symbol">:</a> <a id="56038" href="1Lab.Path.html#56006" class="Bound">A</a> <a id="56040" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a><a id="56042" class="Symbol">}</a>
         <a id="56053" class="Symbol">→</a> <a id="56055" href="1Lab.Path.html#51235" data-type="(A : I → Type ℓ) → A i0 → A i1" class="Function">coe0→1</a> <a id="56062" href="1Lab.Path.html#56006" class="Bound">A</a> <a id="56064" href="1Lab.Path.html#56023" class="Bound">x</a> <a id="56066" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="56068" href="1Lab.Path.html#56034" class="Bound">y</a>
         <a id="56079" class="Symbol">→</a> <a id="56081" href="Agda.Builtin.Cubical.Path.html#197" data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" class="Postulate">PathP</a> <a id="56087" href="1Lab.Path.html#56006" class="Bound">A</a> <a id="56089" href="1Lab.Path.html#56023" class="Bound">x</a> <a id="56091" href="1Lab.Path.html#56034" class="Bound">y</a>
<a id="56093" href="1Lab.Path.html#55988" data-type="coe0→1 A x ≡ y → PathP A x y" class="Function">to-pathp</a> <a id="56102" class="Symbol">{</a><a id="56103" class="Argument">A</a> <a id="56105" class="Symbol">=</a> <a id="56107" href="1Lab.Path.html#56107" class="Bound">A</a><a id="56108" class="Symbol">}</a> <a id="56110" class="Symbol">{</a><a id="56111" href="1Lab.Path.html#56111" class="Bound">x</a><a id="56112" class="Symbol">}</a> <a id="56114" href="1Lab.Path.html#56114" class="Bound">p</a> <a id="56116" href="1Lab.Path.html#56116" class="Bound">i</a> <a id="56118" class="Symbol">=</a>
  <a id="56122" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="56128" class="Symbol">(λ</a> <a id="56131" href="1Lab.Path.html#56131" class="Bound">j</a> <a id="56133" class="Symbol">→</a> <a id="56135" class="Symbol">λ</a> <a id="56137" class="Symbol">{</a> <a id="56139" class="Symbol">(</a><a id="56140" href="1Lab.Path.html#56116" class="Bound">i</a> <a id="56142" class="Symbol">=</a> <a id="56144" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a><a id="56146" class="Symbol">)</a> <a id="56148" class="Symbol">→</a> <a id="56150" href="1Lab.Path.html#56111" class="Bound">x</a>
                 <a id="56169" class="Symbol">;</a> <a id="56171" class="Symbol">(</a><a id="56172" href="1Lab.Path.html#56116" class="Bound">i</a> <a id="56174" class="Symbol">=</a> <a id="56176" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a><a id="56178" class="Symbol">)</a> <a id="56180" class="Symbol">→</a> <a id="56182" href="1Lab.Path.html#56114" class="Bound">p</a> <a id="56184" href="1Lab.Path.html#56131" class="Bound">j</a> <a id="56186" class="Symbol">})</a>
        <a id="56197" class="Symbol">(</a><a id="56198" href="1Lab.Path.html#51690" data-type="(A : (i : I) → Type (ℓ i)) (i : I) → A i0 → A i" class="Function">coe0→i</a> <a id="56205" href="1Lab.Path.html#56107" class="Bound">A</a> <a id="56207" href="1Lab.Path.html#56116" class="Bound">i</a> <a id="56209" href="1Lab.Path.html#56111" class="Bound">x</a><a id="56210" class="Symbol">)</a>

<a id="from-pathp"></a><a id="56213" href="1Lab.Path.html#56213" data-type="PathP A x y → coe0→1 A x ≡ y" class="Function">from-pathp</a> <a id="56224" class="Symbol">:</a> <a id="56226" class="Symbol">∀</a> <a id="56228" class="Symbol">{</a><a id="56229" href="1Lab.Path.html#56229" class="Bound">ℓ</a><a id="56230" class="Symbol">}</a> <a id="56232" class="Symbol">{</a><a id="56233" href="1Lab.Path.html#56233" class="Bound">A</a> <a id="56235" class="Symbol">:</a> <a id="56237" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a> <a id="56239" class="Symbol">→</a> <a id="56241" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="56246" href="1Lab.Path.html#56229" class="Bound">ℓ</a><a id="56247" class="Symbol">}</a> <a id="56249" class="Symbol">{</a><a id="56250" href="1Lab.Path.html#56250" class="Bound">x</a> <a id="56252" class="Symbol">:</a> <a id="56254" href="1Lab.Path.html#56233" class="Bound">A</a> <a id="56256" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a><a id="56258" class="Symbol">}</a> <a id="56260" class="Symbol">{</a><a id="56261" href="1Lab.Path.html#56261" class="Bound">y</a> <a id="56263" class="Symbol">:</a> <a id="56265" href="1Lab.Path.html#56233" class="Bound">A</a> <a id="56267" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a><a id="56269" class="Symbol">}</a>
           <a id="56282" class="Symbol">→</a> <a id="56284" href="Agda.Builtin.Cubical.Path.html#197" data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" class="Postulate">PathP</a> <a id="56290" href="1Lab.Path.html#56233" class="Bound">A</a> <a id="56292" href="1Lab.Path.html#56250" class="Bound">x</a> <a id="56294" href="1Lab.Path.html#56261" class="Bound">y</a>
           <a id="56307" class="Symbol">→</a> <a id="56309" href="1Lab.Path.html#51235" data-type="(A : I → Type ℓ) → A i0 → A i1" class="Function">coe0→1</a> <a id="56316" href="1Lab.Path.html#56233" class="Bound">A</a> <a id="56318" href="1Lab.Path.html#56250" class="Bound">x</a> <a id="56320" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="56322" href="1Lab.Path.html#56261" class="Bound">y</a>
<a id="56324" href="1Lab.Path.html#56213" data-type="PathP A x y → coe0→1 A x ≡ y" class="Function">from-pathp</a> <a id="56335" class="Symbol">{</a><a id="56336" class="Argument">A</a> <a id="56338" class="Symbol">=</a> <a id="56340" href="1Lab.Path.html#56340" class="Bound">A</a><a id="56341" class="Symbol">}</a> <a id="56343" href="1Lab.Path.html#56343" class="Bound">p</a> <a id="56345" href="1Lab.Path.html#56345" class="Bound">i</a> <a id="56347" class="Symbol">=</a> <a id="56349" href="1Lab.Path.html#53519" data-type="(A : (i : I) → Type (ℓ i)) (i : I) → A i → A i1" class="Function">coei→1</a> <a id="56356" href="1Lab.Path.html#56340" class="Bound">A</a> <a id="56358" href="1Lab.Path.html#56345" class="Bound">i</a> <a id="56360" class="Symbol">(</a><a id="56361" href="1Lab.Path.html#56343" class="Bound">p</a> <a id="56363" href="1Lab.Path.html#56345" class="Bound">i</a><a id="56364" class="Symbol">)</a>
</pre>
<p>These definitions illustrate how using the named squeezes and spreads
—
<span class="Agda"><a href="1Lab.Path.html#51690" class="Function">coe0→i</a></span>,
<span class="Agda"><a href="1Lab.Path.html#53519" class="Function">coei→1</a></span>
— can be a lot more elegant than trying to work out what composition to
use in a
<span class="Agda"><a href="1Lab.Path.html#2405" class="Primitive">transp</a></span>.</p>
<h1 id="path-spaces"><a href="#path-spaces" class="header-link">Path
Spaces<span class="header-link-emoji">🔗</span></a></h1>
<p>A large part of the study of HoTT is the <em>characterisation of path
spaces</em>. Given a type <code>A</code>, what does
<code>Path A x y</code> look like? <a href="1Lab.HLevel.Sets.html">Hedberg’s theorem</a> says that for types
with decidable equality, it’s boring. For <a href="1Lab.HIT.S1.html">the
circle</a>, we can prove its loop space is the integers — we have
<code>Path S¹ base base ≡ Int</code>.</p>
<p>Most of these characterisations need machinery that is not in this
module to be properly stated. Even then, we can begin to outline a few
simple cases:</p>
<h2 id="σ-types"><a href="#σ-types" class="header-link">Σ
Types<span class="header-link-emoji">🔗</span></a></h2>
<p>For
<span class="Agda"><a href="1Lab.Type.html#1573" class="Function">Σ</a></span>
types, a path between <code>(a , b) ≡ (x , y)</code> consists of a path
<code>p : a ≡ x</code>, and a path between <code>b</code> and
<code>y</code> laying over <code>p</code>.</p>
<pre class="Agda"><a id="Σ-pathp"></a><a id="57288" href="1Lab.Path.html#57288" data-type="(p : x .fst ≡ y .fst) →
PathP (λ i → B₁ (p i)) (x .snd) (y .snd) → x ≡ y" class="Function">Σ-pathp</a> <a id="57296" class="Symbol">:</a> <a id="57298" class="Symbol">∀</a> <a id="57300" class="Symbol">{</a><a id="57301" href="1Lab.Path.html#57301" class="Bound">a</a> <a id="57303" href="1Lab.Path.html#57303" class="Bound">b</a><a id="57304" class="Symbol">}</a> <a id="57306" class="Symbol">{</a><a id="57307" href="1Lab.Path.html#57307" class="Bound">A</a> <a id="57309" class="Symbol">:</a> <a id="57311" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="57316" href="1Lab.Path.html#57301" class="Bound">a</a><a id="57317" class="Symbol">}</a> <a id="57319" class="Symbol">{</a><a id="57320" href="1Lab.Path.html#57320" class="Bound">B</a> <a id="57322" class="Symbol">:</a> <a id="57324" href="1Lab.Path.html#57307" class="Bound">A</a> <a id="57326" class="Symbol">→</a> <a id="57328" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="57333" href="1Lab.Path.html#57303" class="Bound">b</a><a id="57334" class="Symbol">}</a>
        <a id="57344" class="Symbol">→</a> <a id="57346" class="Symbol">{</a><a id="57347" href="1Lab.Path.html#57347" class="Bound">x</a> <a id="57349" href="1Lab.Path.html#57349" class="Bound">y</a> <a id="57351" class="Symbol">:</a> <a id="57353" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">Σ</a> <a id="57355" href="1Lab.Path.html#57320" class="Bound">B</a><a id="57356" class="Symbol">}</a>
        <a id="57366" class="Symbol">→</a> <a id="57368" class="Symbol">(</a><a id="57369" href="1Lab.Path.html#57369" class="Bound">p</a> <a id="57371" class="Symbol">:</a> <a id="57373" href="1Lab.Path.html#57347" class="Bound">x</a> <a id="57375" class="Symbol">.</a><a id="57376" href="Agda.Builtin.Sigma.html#252" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="57380" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="57382" href="1Lab.Path.html#57349" class="Bound">y</a> <a id="57384" class="Symbol">.</a><a id="57385" href="Agda.Builtin.Sigma.html#252" data-type="∑ A B₁ → A" class="Field">fst</a><a id="57388" class="Symbol">)</a>
        <a id="57398" class="Symbol">→</a> <a id="57400" href="Agda.Builtin.Cubical.Path.html#197" data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" class="Postulate">PathP</a> <a id="57406" class="Symbol">(λ</a> <a id="57409" href="1Lab.Path.html#57409" class="Bound">i</a> <a id="57411" class="Symbol">→</a> <a id="57413" href="1Lab.Path.html#57320" class="Bound">B</a> <a id="57415" class="Symbol">(</a><a id="57416" href="1Lab.Path.html#57369" class="Bound">p</a> <a id="57418" href="1Lab.Path.html#57409" class="Bound">i</a><a id="57419" class="Symbol">))</a> <a id="57422" class="Symbol">(</a><a id="57423" href="1Lab.Path.html#57347" class="Bound">x</a> <a id="57425" class="Symbol">.</a><a id="57426" href="Agda.Builtin.Sigma.html#264" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a><a id="57429" class="Symbol">)</a> <a id="57431" class="Symbol">(</a><a id="57432" href="1Lab.Path.html#57349" class="Bound">y</a> <a id="57434" class="Symbol">.</a><a id="57435" href="Agda.Builtin.Sigma.html#264" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a><a id="57438" class="Symbol">)</a>
        <a id="57448" class="Symbol">→</a> <a id="57450" href="1Lab.Path.html#57347" class="Bound">x</a> <a id="57452" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="57454" href="1Lab.Path.html#57349" class="Bound">y</a>
<a id="57456" href="1Lab.Path.html#57288" data-type="(p : x .fst ≡ y .fst) →
PathP (λ i → B₁ (p i)) (x .snd) (y .snd) → x ≡ y" class="Function">Σ-pathp</a> <a id="57464" href="1Lab.Path.html#57464" class="Bound">p</a> <a id="57466" href="1Lab.Path.html#57466" class="Bound">q</a> <a id="57468" href="1Lab.Path.html#57468" class="Bound">i</a> <a id="57470" class="Symbol">=</a> <a id="57472" href="1Lab.Path.html#57464" class="Bound">p</a> <a id="57474" href="1Lab.Path.html#57468" class="Bound">i</a> <a id="57476" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="57478" href="1Lab.Path.html#57466" class="Bound">q</a> <a id="57480" href="1Lab.Path.html#57468" class="Bound">i</a>
</pre>
<p>We can also use the book characterisation of dependent paths, which
is simpler in the case where the
<span class="Agda"><a href="1Lab.Type.html#1573" class="Function">Σ</a></span>
represents a subset — i.e., <code>B</code> is a family of
propositions.</p>
<pre class="Agda"><a id="Σ-path"></a><a id="57671" href="1Lab.Path.html#57671" data-type="(p : x .fst ≡ y .fst) → subst B₁ p (x .snd) ≡ y .snd → x ≡ y" class="Function">Σ-path</a> <a id="57678" class="Symbol">:</a> <a id="57680" class="Symbol">∀</a> <a id="57682" class="Symbol">{</a><a id="57683" href="1Lab.Path.html#57683" class="Bound">a</a> <a id="57685" href="1Lab.Path.html#57685" class="Bound">b</a><a id="57686" class="Symbol">}</a> <a id="57688" class="Symbol">{</a><a id="57689" href="1Lab.Path.html#57689" class="Bound">A</a> <a id="57691" class="Symbol">:</a> <a id="57693" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="57698" href="1Lab.Path.html#57683" class="Bound">a</a><a id="57699" class="Symbol">}</a> <a id="57701" class="Symbol">{</a><a id="57702" href="1Lab.Path.html#57702" class="Bound">B</a> <a id="57704" class="Symbol">:</a> <a id="57706" href="1Lab.Path.html#57689" class="Bound">A</a> <a id="57708" class="Symbol">→</a> <a id="57710" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="57715" href="1Lab.Path.html#57685" class="Bound">b</a><a id="57716" class="Symbol">}</a>
       <a id="57725" class="Symbol">→</a> <a id="57727" class="Symbol">{</a><a id="57728" href="1Lab.Path.html#57728" class="Bound">x</a> <a id="57730" href="1Lab.Path.html#57730" class="Bound">y</a> <a id="57732" class="Symbol">:</a> <a id="57734" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">Σ</a> <a id="57736" href="1Lab.Path.html#57702" class="Bound">B</a><a id="57737" class="Symbol">}</a>
       <a id="57746" class="Symbol">→</a> <a id="57748" class="Symbol">(</a><a id="57749" href="1Lab.Path.html#57749" class="Bound">p</a> <a id="57751" class="Symbol">:</a> <a id="57753" href="1Lab.Path.html#57728" class="Bound">x</a> <a id="57755" class="Symbol">.</a><a id="57756" href="Agda.Builtin.Sigma.html#252" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="57760" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="57762" href="1Lab.Path.html#57730" class="Bound">y</a> <a id="57764" class="Symbol">.</a><a id="57765" href="Agda.Builtin.Sigma.html#252" data-type="∑ A B₁ → A" class="Field">fst</a><a id="57768" class="Symbol">)</a>
       <a id="57777" class="Symbol">→</a> <a id="57779" href="1Lab.Path.html#15309" data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" class="Function">subst</a> <a id="57785" href="1Lab.Path.html#57702" class="Bound">B</a> <a id="57787" href="1Lab.Path.html#57749" class="Bound">p</a> <a id="57789" class="Symbol">(</a><a id="57790" href="1Lab.Path.html#57728" class="Bound">x</a> <a id="57792" class="Symbol">.</a><a id="57793" href="Agda.Builtin.Sigma.html#264" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a><a id="57796" class="Symbol">)</a> <a id="57798" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="57800" class="Symbol">(</a><a id="57801" href="1Lab.Path.html#57730" class="Bound">y</a> <a id="57803" class="Symbol">.</a><a id="57804" href="Agda.Builtin.Sigma.html#264" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a><a id="57807" class="Symbol">)</a>
       <a id="57816" class="Symbol">→</a> <a id="57818" href="1Lab.Path.html#57728" class="Bound">x</a> <a id="57820" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="57822" href="1Lab.Path.html#57730" class="Bound">y</a>
<a id="57824" href="1Lab.Path.html#57671" data-type="(p : x .fst ≡ y .fst) → subst B₁ p (x .snd) ≡ y .snd → x ≡ y" class="Function">Σ-path</a> <a id="57831" class="Symbol">{</a><a id="57832" class="Argument">A</a> <a id="57834" class="Symbol">=</a> <a id="57836" href="1Lab.Path.html#57836" class="Bound">A</a><a id="57837" class="Symbol">}</a> <a id="57839" class="Symbol">{</a><a id="57840" href="1Lab.Path.html#57840" class="Bound">B</a><a id="57841" class="Symbol">}</a> <a id="57843" class="Symbol">{</a><a id="57844" href="1Lab.Path.html#57844" class="Bound">x</a><a id="57845" class="Symbol">}</a> <a id="57847" class="Symbol">{</a><a id="57848" href="1Lab.Path.html#57848" class="Bound">y</a><a id="57849" class="Symbol">}</a> <a id="57851" href="1Lab.Path.html#57851" class="Bound">p</a> <a id="57853" href="1Lab.Path.html#57853" class="Bound">q</a> <a id="57855" class="Symbol">=</a> <a id="57857" href="1Lab.Path.html#57288" data-type="(p : x .fst ≡ y .fst) →
PathP (λ i → B₁ (p i)) (x .snd) (y .snd) → x ≡ y" class="Function">Σ-pathp</a> <a id="57865" href="1Lab.Path.html#57851" class="Bound">p</a> <a id="57867" class="Symbol">(</a><a id="57868" href="1Lab.Path.html#55988" data-type="coe0→1 A x ≡ y → PathP A x y" class="Function">to-pathp</a> <a id="57877" href="1Lab.Path.html#57853" class="Bound">q</a><a id="57878" class="Symbol">)</a>
</pre>
<h2 id="π-types"><a href="#π-types" class="header-link">Π
types<span class="header-link-emoji">🔗</span></a></h2>
<p>For dependent functions, the paths are <em>homotopies</em>, in the
topological sense: <code>Path ((x : A) → B x) f g</code> is the same
thing as a function <code>I → (x : A) → B x</code> — which we could turn
into a product if we really wanted to.</p>
<pre class="Agda"><a id="happly"></a><a id="58127" href="1Lab.Path.html#58127" data-type="f ≡ g → (x : A) → f x ≡ g x" class="Function">happly</a> <a id="58134" class="Symbol">:</a> <a id="58136" class="Symbol">∀</a> <a id="58138" class="Symbol">{</a><a id="58139" href="1Lab.Path.html#58139" class="Bound">a</a> <a id="58141" href="1Lab.Path.html#58141" class="Bound">b</a><a id="58142" class="Symbol">}</a> <a id="58144" class="Symbol">{</a><a id="58145" href="1Lab.Path.html#58145" class="Bound">A</a> <a id="58147" class="Symbol">:</a> <a id="58149" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="58154" href="1Lab.Path.html#58139" class="Bound">a</a><a id="58155" class="Symbol">}</a> <a id="58157" class="Symbol">{</a><a id="58158" href="1Lab.Path.html#58158" class="Bound">B</a> <a id="58160" class="Symbol">:</a> <a id="58162" href="1Lab.Path.html#58145" class="Bound">A</a> <a id="58164" class="Symbol">→</a> <a id="58166" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="58171" href="1Lab.Path.html#58141" class="Bound">b</a><a id="58172" class="Symbol">}</a>
         <a id="58183" class="Symbol">{</a><a id="58184" href="1Lab.Path.html#58184" class="Bound">f</a> <a id="58186" href="1Lab.Path.html#58186" class="Bound">g</a> <a id="58188" class="Symbol">:</a> <a id="58190" class="Symbol">(</a><a id="58191" href="1Lab.Path.html#58191" class="Bound">x</a> <a id="58193" class="Symbol">:</a> <a id="58195" href="1Lab.Path.html#58145" class="Bound">A</a><a id="58196" class="Symbol">)</a> <a id="58198" class="Symbol">→</a> <a id="58200" href="1Lab.Path.html#58158" class="Bound">B</a> <a id="58202" href="1Lab.Path.html#58191" class="Bound">x</a><a id="58203" class="Symbol">}</a>
       <a id="58212" class="Symbol">→</a> <a id="58214" href="1Lab.Path.html#58184" class="Bound">f</a> <a id="58216" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="58218" href="1Lab.Path.html#58186" class="Bound">g</a> <a id="58220" class="Symbol">→</a> <a id="58222" class="Symbol">(</a><a id="58223" href="1Lab.Path.html#58223" class="Bound">x</a> <a id="58225" class="Symbol">:</a> <a id="58227" href="1Lab.Path.html#58145" class="Bound">A</a><a id="58228" class="Symbol">)</a> <a id="58230" class="Symbol">→</a> <a id="58232" href="1Lab.Path.html#58184" class="Bound">f</a> <a id="58234" href="1Lab.Path.html#58223" class="Bound">x</a> <a id="58236" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="58238" href="1Lab.Path.html#58186" class="Bound">g</a> <a id="58240" href="1Lab.Path.html#58223" class="Bound">x</a>
<a id="58242" href="1Lab.Path.html#58127" data-type="f ≡ g → (x : A) → f x ≡ g x" class="Function">happly</a> <a id="58249" href="1Lab.Path.html#58249" class="Bound">p</a> <a id="58251" href="1Lab.Path.html#58251" class="Bound">x</a> <a id="58253" href="1Lab.Path.html#58253" class="Bound">i</a> <a id="58255" class="Symbol">=</a> <a id="58257" href="1Lab.Path.html#58249" class="Bound">p</a> <a id="58259" href="1Lab.Path.html#58253" class="Bound">i</a> <a id="58261" href="1Lab.Path.html#58251" class="Bound">x</a>
</pre>
<p>With this, we have made definitional yet another principle which is
propositional in the HoTT book: <em>function extensionality</em>.
Functions are identical precisely if they assign the same outputs to
every input.</p>
<pre class="Agda"><a id="funext"></a><a id="58486" href="1Lab.Path.html#58486" data-type="((x : A) → f x ≡ g x) → f ≡ g" class="Function">funext</a> <a id="58493" class="Symbol">:</a> <a id="58495" class="Symbol">∀</a> <a id="58497" class="Symbol">{</a><a id="58498" href="1Lab.Path.html#58498" class="Bound">a</a> <a id="58500" href="1Lab.Path.html#58500" class="Bound">b</a><a id="58501" class="Symbol">}</a> <a id="58503" class="Symbol">{</a><a id="58504" href="1Lab.Path.html#58504" class="Bound">A</a> <a id="58506" class="Symbol">:</a> <a id="58508" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="58513" href="1Lab.Path.html#58498" class="Bound">a</a><a id="58514" class="Symbol">}</a> <a id="58516" class="Symbol">{</a><a id="58517" href="1Lab.Path.html#58517" class="Bound">B</a> <a id="58519" class="Symbol">:</a> <a id="58521" href="1Lab.Path.html#58504" class="Bound">A</a> <a id="58523" class="Symbol">→</a> <a id="58525" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="58530" href="1Lab.Path.html#58500" class="Bound">b</a><a id="58531" class="Symbol">}</a>
         <a id="58542" class="Symbol">{</a><a id="58543" href="1Lab.Path.html#58543" class="Bound">f</a> <a id="58545" href="1Lab.Path.html#58545" class="Bound">g</a> <a id="58547" class="Symbol">:</a> <a id="58549" class="Symbol">(</a><a id="58550" href="1Lab.Path.html#58550" class="Bound">x</a> <a id="58552" class="Symbol">:</a> <a id="58554" href="1Lab.Path.html#58504" class="Bound">A</a><a id="58555" class="Symbol">)</a> <a id="58557" class="Symbol">→</a> <a id="58559" href="1Lab.Path.html#58517" class="Bound">B</a> <a id="58561" href="1Lab.Path.html#58550" class="Bound">x</a><a id="58562" class="Symbol">}</a>
       <a id="58571" class="Symbol">→</a> <a id="58573" class="Symbol">((</a><a id="58575" href="1Lab.Path.html#58575" class="Bound">x</a> <a id="58577" class="Symbol">:</a> <a id="58579" href="1Lab.Path.html#58504" class="Bound">A</a><a id="58580" class="Symbol">)</a> <a id="58582" class="Symbol">→</a> <a id="58584" href="1Lab.Path.html#58543" class="Bound">f</a> <a id="58586" href="1Lab.Path.html#58575" class="Bound">x</a> <a id="58588" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="58590" href="1Lab.Path.html#58545" class="Bound">g</a> <a id="58592" href="1Lab.Path.html#58575" class="Bound">x</a><a id="58593" class="Symbol">)</a> <a id="58595" class="Symbol">→</a> <a id="58597" href="1Lab.Path.html#58543" class="Bound">f</a> <a id="58599" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="58601" href="1Lab.Path.html#58545" class="Bound">g</a>
<a id="58603" href="1Lab.Path.html#58486" data-type="((x : A) → f x ≡ g x) → f ≡ g" class="Function">funext</a> <a id="58610" href="1Lab.Path.html#58610" class="Bound">p</a> <a id="58612" href="1Lab.Path.html#58612" class="Bound">i</a> <a id="58614" href="1Lab.Path.html#58614" class="Bound">x</a> <a id="58616" class="Symbol">=</a> <a id="58618" href="1Lab.Path.html#58610" class="Bound">p</a> <a id="58620" href="1Lab.Path.html#58614" class="Bound">x</a> <a id="58622" href="1Lab.Path.html#58612" class="Bound">i</a>
</pre>
<p>Furthermore, we know (since types are groupoids, and functions are
functors) that, by analogy with 1-category theory, paths in a function
type should behave like natural transformations (because they are arrows
in a functor category). This is indeed the case:</p>
<pre class="Agda"><a id="homotopy-natural"></a><a id="58898" href="1Lab.Path.html#58898" data-type="(H : (x : A) → f x ≡ g x) (p : x ≡ y) → H x ∙ ap g p ≡ ap f p ∙ H y" class="Function">homotopy-natural</a> <a id="58915" class="Symbol">:</a> <a id="58917" class="Symbol">∀</a> <a id="58919" class="Symbol">{</a><a id="58920" href="1Lab.Path.html#58920" class="Bound">a</a> <a id="58922" href="1Lab.Path.html#58922" class="Bound">b</a><a id="58923" class="Symbol">}</a> <a id="58925" class="Symbol">{</a><a id="58926" href="1Lab.Path.html#58926" class="Bound">A</a> <a id="58928" class="Symbol">:</a> <a id="58930" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="58935" href="1Lab.Path.html#58920" class="Bound">a</a><a id="58936" class="Symbol">}</a> <a id="58938" class="Symbol">{</a><a id="58939" href="1Lab.Path.html#58939" class="Bound">B</a> <a id="58941" class="Symbol">:</a> <a id="58943" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="58948" href="1Lab.Path.html#58922" class="Bound">b</a><a id="58949" class="Symbol">}</a>
                 <a id="58968" class="Symbol">→</a> <a id="58970" class="Symbol">{</a><a id="58971" href="1Lab.Path.html#58971" class="Bound">f</a> <a id="58973" href="1Lab.Path.html#58973" class="Bound">g</a> <a id="58975" class="Symbol">:</a> <a id="58977" href="1Lab.Path.html#58926" class="Bound">A</a> <a id="58979" class="Symbol">→</a> <a id="58981" href="1Lab.Path.html#58939" class="Bound">B</a><a id="58982" class="Symbol">}</a>
                 <a id="59001" class="Symbol">→</a> <a id="59003" class="Symbol">(</a><a id="59004" href="1Lab.Path.html#59004" class="Bound">H</a> <a id="59006" class="Symbol">:</a> <a id="59008" class="Symbol">(</a><a id="59009" href="1Lab.Path.html#59009" class="Bound">x</a> <a id="59011" class="Symbol">:</a> <a id="59013" href="1Lab.Path.html#58926" class="Bound">A</a><a id="59014" class="Symbol">)</a> <a id="59016" class="Symbol">→</a> <a id="59018" href="1Lab.Path.html#58971" class="Bound">f</a> <a id="59020" href="1Lab.Path.html#59009" class="Bound">x</a> <a id="59022" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="59024" href="1Lab.Path.html#58973" class="Bound">g</a> <a id="59026" href="1Lab.Path.html#59009" class="Bound">x</a><a id="59027" class="Symbol">)</a>
                 <a id="59046" class="Symbol">→</a> <a id="59048" class="Symbol">{</a><a id="59049" href="1Lab.Path.html#59049" class="Bound">x</a> <a id="59051" href="1Lab.Path.html#59051" class="Bound">y</a> <a id="59053" class="Symbol">:</a> <a id="59055" href="1Lab.Path.html#58926" class="Bound">A</a><a id="59056" class="Symbol">}</a> <a id="59058" class="Symbol">(</a><a id="59059" href="1Lab.Path.html#59059" class="Bound">p</a> <a id="59061" class="Symbol">:</a> <a id="59063" href="1Lab.Path.html#59049" class="Bound">x</a> <a id="59065" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="59067" href="1Lab.Path.html#59051" class="Bound">y</a><a id="59068" class="Symbol">)</a>
                 <a id="59087" class="Symbol">→</a> <a id="59089" href="1Lab.Path.html#59004" class="Bound">H</a> <a id="59091" href="1Lab.Path.html#59049" class="Bound">x</a> <a id="59093" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="59095" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="59098" href="1Lab.Path.html#58973" class="Bound">g</a> <a id="59100" href="1Lab.Path.html#59059" class="Bound">p</a> <a id="59102" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="59104" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="59107" href="1Lab.Path.html#58971" class="Bound">f</a> <a id="59109" href="1Lab.Path.html#59059" class="Bound">p</a> <a id="59111" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="59113" href="1Lab.Path.html#59004" class="Bound">H</a> <a id="59115" href="1Lab.Path.html#59051" class="Bound">y</a>
<a id="59117" href="1Lab.Path.html#58898" data-type="(H : (x : A) → f x ≡ g x) (p : x ≡ y) → H x ∙ ap g p ≡ ap f p ∙ H y" class="Function">homotopy-natural</a> <a id="59134" class="Symbol">{</a><a id="59135" class="Argument">f</a> <a id="59137" class="Symbol">=</a> <a id="59139" href="1Lab.Path.html#59139" class="Bound">f</a><a id="59140" class="Symbol">}</a> <a id="59142" class="Symbol">{</a><a id="59143" class="Argument">g</a> <a id="59145" class="Symbol">=</a> <a id="59147" href="1Lab.Path.html#59147" class="Bound">g</a><a id="59148" class="Symbol">}</a> <a id="59150" href="1Lab.Path.html#59150" class="Bound">H</a> <a id="59152" href="1Lab.Path.html#59152" class="Bound">p</a> <a id="59154" class="Symbol">=</a>
  <a id="59158" href="1Lab.Path.html#19544" data-type="(P : (y : A) → x ≡ y → Type ℓ₂) → P x refl → (p : x ≡ y) → P y p" class="Function">J</a> <a id="59160" class="Symbol">(λ</a> <a id="59163" href="1Lab.Path.html#59163" class="Bound">_</a> <a id="59165" href="1Lab.Path.html#59165" class="Bound">p</a> <a id="59167" class="Symbol">→</a> <a id="59169" href="1Lab.Path.html#59150" class="Bound">H</a> <a id="59171" class="Symbol">_</a> <a id="59173" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="59175" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="59178" href="1Lab.Path.html#59147" class="Bound">g</a> <a id="59180" href="1Lab.Path.html#59165" class="Bound">p</a> <a id="59182" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="59184" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="59187" href="1Lab.Path.html#59139" class="Bound">f</a> <a id="59189" href="1Lab.Path.html#59165" class="Bound">p</a> <a id="59191" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="59193" href="1Lab.Path.html#59150" class="Bound">H</a> <a id="59195" class="Symbol">_)</a>
    <a id="59202" class="Symbol">(</a><a id="59203" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="59207" class="Symbol">(</a><a id="59208" href="1Lab.Path.html#39820" data-type="(p : x ≡ y) (q : y ≡ z) → Square refl p (p ∙ q) q" class="Function">∙-filler</a> <a id="59217" class="Symbol">(</a><a id="59218" href="1Lab.Path.html#59150" class="Bound">H</a> <a id="59220" class="Symbol">_)</a> <a id="59223" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a><a id="59227" class="Symbol">)</a> <a id="59229" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="59231" href="1Lab.Path.html#40319" data-type="(p : x ≡ y) (q : y ≡ z) → Square (sym p) q (p ∙ q) refl" class="Function">∙-filler&#39;</a> <a id="59241" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="59246" class="Symbol">(</a><a id="59247" href="1Lab.Path.html#59150" class="Bound">H</a> <a id="59249" class="Symbol">_))</a>
    <a id="59257" href="1Lab.Path.html#59152" class="Bound">p</a>
</pre>
<h2 id="paths-1"><a href="#paths-1" class="header-link">Paths<span class="header-link-emoji">🔗</span></a></h2>
<p>The groupoid structure of <em>paths</em> is also interesting. While
the characterisation of <code>Path (Path A x y) p q</code> is
fundamentally tied to the characterisation of <code>A</code>, there are
general theorems that can be proven about <em>transport</em> in path
spaces. For example, substituting on both endpoints of a path is
equivalent to a ternary composition:</p>
<pre class="Agda"><a id="subst-path-both"></a><a id="59620" href="1Lab.Path.html#59620" data-type="(loop₁ : x ≡ x) (adj : x ≡ y) →
subst (λ x → x ≡ x) adj loop₁ ≡ sym adj ∙ loop₁ ∙ adj" class="Function">subst-path-both</a> <a id="59636" class="Symbol">:</a> <a id="59638" class="Symbol">∀</a> <a id="59640" class="Symbol">{</a><a id="59641" href="1Lab.Path.html#59641" class="Bound">ℓ</a><a id="59642" class="Symbol">}</a> <a id="59644" class="Symbol">{</a><a id="59645" href="1Lab.Path.html#59645" class="Bound">A</a> <a id="59647" class="Symbol">:</a> <a id="59649" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="59654" href="1Lab.Path.html#59641" class="Bound">ℓ</a><a id="59655" class="Symbol">}</a> <a id="59657" class="Symbol">{</a><a id="59658" href="1Lab.Path.html#59658" class="Bound">x</a> <a id="59660" href="1Lab.Path.html#59660" class="Bound">y</a> <a id="59662" class="Symbol">:</a> <a id="59664" href="1Lab.Path.html#59645" class="Bound">A</a><a id="59665" class="Symbol">}</a>
                <a id="59683" class="Symbol">→</a> <a id="59685" class="Symbol">(</a><a id="59686" href="1Lab.Path.html#59686" class="Bound">loop</a> <a id="59691" class="Symbol">:</a> <a id="59693" href="1Lab.Path.html#59658" class="Bound">x</a> <a id="59695" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="59697" href="1Lab.Path.html#59658" class="Bound">x</a><a id="59698" class="Symbol">)</a>
                <a id="59716" class="Symbol">→</a> <a id="59718" class="Symbol">(</a><a id="59719" href="1Lab.Path.html#59719" class="Bound">adj</a> <a id="59723" class="Symbol">:</a> <a id="59725" href="1Lab.Path.html#59658" class="Bound">x</a> <a id="59727" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="59729" href="1Lab.Path.html#59660" class="Bound">y</a><a id="59730" class="Symbol">)</a>
                <a id="59748" class="Symbol">→</a> <a id="59750" href="1Lab.Path.html#15309" data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" class="Function">subst</a> <a id="59756" class="Symbol">(λ</a> <a id="59759" href="1Lab.Path.html#59759" class="Bound">x</a> <a id="59761" class="Symbol">→</a> <a id="59763" href="1Lab.Path.html#59759" class="Bound">x</a> <a id="59765" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="59767" href="1Lab.Path.html#59759" class="Bound">x</a><a id="59768" class="Symbol">)</a> <a id="59770" href="1Lab.Path.html#59719" class="Bound">adj</a> <a id="59774" href="1Lab.Path.html#59686" class="Bound">loop</a> <a id="59779" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="59781" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="59785" href="1Lab.Path.html#59719" class="Bound">adj</a> <a id="59789" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="59791" href="1Lab.Path.html#59686" class="Bound">loop</a> <a id="59796" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="59798" href="1Lab.Path.html#59719" class="Bound">adj</a>
<a id="59802" href="1Lab.Path.html#59620" data-type="(loop₁ : x ≡ x) (adj : x ≡ y) →
subst (λ x → x ≡ x) adj loop₁ ≡ sym adj ∙ loop₁ ∙ adj" class="Function">subst-path-both</a> <a id="59818" href="1Lab.Path.html#59818" class="Bound">loop</a> <a id="59823" href="1Lab.Path.html#59823" class="Bound">adj</a> <a id="59827" class="Symbol">=</a>
  <a id="59831" href="1Lab.Path.html#19544" data-type="(P : (y : A) → x ≡ y → Type ℓ₂) → P x refl → (p : x ≡ y) → P y p" class="Function">J</a> <a id="59833" class="Symbol">(λ</a> <a id="59836" href="1Lab.Path.html#59836" class="Bound">_</a> <a id="59838" href="1Lab.Path.html#59838" class="Bound">adj</a> <a id="59842" class="Symbol">→</a> <a id="59844" href="1Lab.Path.html#15309" data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" class="Function">subst</a> <a id="59850" class="Symbol">(λ</a> <a id="59853" href="1Lab.Path.html#59853" class="Bound">x</a> <a id="59855" class="Symbol">→</a> <a id="59857" href="1Lab.Path.html#59853" class="Bound">x</a> <a id="59859" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="59861" href="1Lab.Path.html#59853" class="Bound">x</a><a id="59862" class="Symbol">)</a> <a id="59864" href="1Lab.Path.html#59838" class="Bound">adj</a> <a id="59868" href="1Lab.Path.html#59818" class="Bound">loop</a> <a id="59873" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="59875" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="59879" href="1Lab.Path.html#59838" class="Bound">adj</a> <a id="59883" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="59885" href="1Lab.Path.html#59818" class="Bound">loop</a> <a id="59890" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="59892" href="1Lab.Path.html#59838" class="Bound">adj</a><a id="59895" class="Symbol">)</a>
    <a id="59901" class="Symbol">(</a><a id="59902" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="59906" href="1Lab.Path.html#60190" data-type="(loop₁ : x ≡ x) (adj : x ≡ y) →
sym refl ∙ loop₁ ∙ refl ≡ subst (λ x → x ≡ x) refl loop₁" class="Function">lemma</a><a id="59911" class="Symbol">)</a>
    <a id="59917" href="1Lab.Path.html#59823" class="Bound">adj</a>
  <a id="59923" class="Keyword">where</a>
</pre>
<p>The proof is by induction on the path <code>adj</code> (for
<code>adjustment</code>): It suffices to consider the case where it is
<code>refl</code>. In that case, it becomes an application of the <a href="1Lab.Path.Groupoid.html">groupoid laws for types</a>.</p>
<pre class="Agda">    <a id="60190" href="1Lab.Path.html#60190" data-type="(loop₁ : x ≡ x) (adj : x ≡ y) →
sym refl ∙ loop₁ ∙ refl ≡ subst (λ x → x ≡ x) refl loop₁" class="Function">lemma</a> <a id="60196" class="Symbol">:</a> <a id="60198" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="60202" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="60207" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="60209" href="1Lab.Path.html#59818" class="Bound">loop</a> <a id="60214" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="60216" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="60221" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="60223" href="1Lab.Path.html#15309" data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" class="Function">subst</a> <a id="60229" class="Symbol">(λ</a> <a id="60232" href="1Lab.Path.html#60232" class="Bound">x</a> <a id="60234" class="Symbol">→</a> <a id="60236" href="1Lab.Path.html#60232" class="Bound">x</a> <a id="60238" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="60240" href="1Lab.Path.html#60232" class="Bound">x</a><a id="60241" class="Symbol">)</a> <a id="60243" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="60248" href="1Lab.Path.html#59818" class="Bound">loop</a>
    <a id="60257" href="1Lab.Path.html#60190" data-type="(loop₁ : x ≡ x) (adj : x ≡ y) →
sym refl ∙ loop₁ ∙ refl ≡ subst (λ x → x ≡ x) refl loop₁" class="Function">lemma</a> <a id="60263" class="Symbol">=</a>
      <a id="60271" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="60275" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="60280" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="60282" href="1Lab.Path.html#59818" class="Bound">loop</a> <a id="60287" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="60289" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>    <a id="60297" href="1Lab.Path.html#46881" data-type="(x : A) → x ≡ y → x ≡ y" class="Function Operator">≡⟨⟩</a>
      <a id="60307" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="60312" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="60314" href="1Lab.Path.html#59818" class="Bound">loop</a> <a id="60319" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="60321" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>        <span class="reasoning-step"><span class="as-written Function"><a id="60333" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="60336" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="60340" class="Symbol">(</a><a id="60341" href="1Lab.Path.html#40319" data-type="(p : x ≡ y) (q : y ≡ z) → Square (sym p) q (p ∙ q) refl" class="Function">∙-filler&#39;</a> <a id="60351" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="60356" class="Symbol">_)</a> <a id="60359" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="60367" href="1Lab.Path.html#59818" class="Bound">loop</a> <a id="60372" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="60374" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>               <span class="reasoning-step"><span class="as-written Function"><a id="60393" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="60396" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="60400" class="Symbol">(</a><a id="60401" href="1Lab.Path.html#39820" data-type="(p : x ≡ y) (q : y ≡ z) → Square refl p (p ∙ q) q" class="Function">∙-filler</a> <a id="60410" class="Symbol">_</a> <a id="60412" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a><a id="60416" class="Symbol">)</a> <a id="60418" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="60426" href="1Lab.Path.html#59818" class="Bound">loop</a>                      <span class="reasoning-step"><span class="as-written Function"><a id="60452" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="60455" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="60459" class="Symbol">(</a><a id="60460" href="1Lab.Path.html#13454" data-type="(x : A) → transport (λ i → A) x ≡ x" class="Function">transport-refl</a> <a id="60475" class="Symbol">_)</a> <a id="60478" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="60486" href="1Lab.Path.html#15309" data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" class="Function">subst</a> <a id="60492" class="Symbol">(λ</a> <a id="60495" href="1Lab.Path.html#60495" class="Bound">x</a> <a id="60497" class="Symbol">→</a> <a id="60499" href="1Lab.Path.html#60495" class="Bound">x</a><a id="60500" class="Symbol">)</a> <a id="60502" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="60507" href="1Lab.Path.html#59818" class="Bound">loop</a> <a id="60512" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
</pre>
<p>Similar statements can be proven about substitution where we hold the
right endpoint constant, in which case we get something homotopic to
composing with the inverse of the adjustment:</p>
<pre class="Agda"><a id="subst-path-left"></a><a id="60713" href="1Lab.Path.html#60713" data-type="(loop₁ : x ≡ z) (adj : x ≡ y) →
subst (λ e → e ≡ z) adj loop₁ ≡ sym adj ∙ loop₁" class="Function">subst-path-left</a> <a id="60729" class="Symbol">:</a> <a id="60731" class="Symbol">∀</a> <a id="60733" class="Symbol">{</a><a id="60734" href="1Lab.Path.html#60734" class="Bound">ℓ</a><a id="60735" class="Symbol">}</a> <a id="60737" class="Symbol">{</a><a id="60738" href="1Lab.Path.html#60738" class="Bound">A</a> <a id="60740" class="Symbol">:</a> <a id="60742" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="60747" href="1Lab.Path.html#60734" class="Bound">ℓ</a><a id="60748" class="Symbol">}</a> <a id="60750" class="Symbol">{</a><a id="60751" href="1Lab.Path.html#60751" class="Bound">x</a> <a id="60753" href="1Lab.Path.html#60753" class="Bound">y</a> <a id="60755" href="1Lab.Path.html#60755" class="Bound">z</a> <a id="60757" class="Symbol">:</a> <a id="60759" href="1Lab.Path.html#60738" class="Bound">A</a><a id="60760" class="Symbol">}</a>
                <a id="60778" class="Symbol">→</a> <a id="60780" class="Symbol">(</a><a id="60781" href="1Lab.Path.html#60781" class="Bound">loop</a> <a id="60786" class="Symbol">:</a> <a id="60788" href="1Lab.Path.html#60751" class="Bound">x</a> <a id="60790" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="60792" href="1Lab.Path.html#60755" class="Bound">z</a><a id="60793" class="Symbol">)</a>
                <a id="60811" class="Symbol">→</a> <a id="60813" class="Symbol">(</a><a id="60814" href="1Lab.Path.html#60814" class="Bound">adj</a> <a id="60818" class="Symbol">:</a> <a id="60820" href="1Lab.Path.html#60751" class="Bound">x</a> <a id="60822" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="60824" href="1Lab.Path.html#60753" class="Bound">y</a><a id="60825" class="Symbol">)</a>
                <a id="60843" class="Symbol">→</a> <a id="60845" href="1Lab.Path.html#15309" data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" class="Function">subst</a> <a id="60851" class="Symbol">(λ</a> <a id="60854" href="1Lab.Path.html#60854" class="Bound">e</a> <a id="60856" class="Symbol">→</a> <a id="60858" href="1Lab.Path.html#60854" class="Bound">e</a> <a id="60860" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="60862" href="1Lab.Path.html#60755" class="Bound">z</a><a id="60863" class="Symbol">)</a> <a id="60865" href="1Lab.Path.html#60814" class="Bound">adj</a> <a id="60869" href="1Lab.Path.html#60781" class="Bound">loop</a> <a id="60874" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="60876" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="60880" href="1Lab.Path.html#60814" class="Bound">adj</a> <a id="60884" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="60886" href="1Lab.Path.html#60781" class="Bound">loop</a>
<a id="60891" href="1Lab.Path.html#60713" data-type="(loop₁ : x ≡ z) (adj : x ≡ y) →
subst (λ e → e ≡ z) adj loop₁ ≡ sym adj ∙ loop₁" class="Function">subst-path-left</a> <a id="60907" class="Symbol">{</a><a id="60908" class="Argument">x</a> <a id="60910" class="Symbol">=</a> <a id="60912" href="1Lab.Path.html#60912" class="Bound">x</a><a id="60913" class="Symbol">}</a> <a id="60915" class="Symbol">{</a><a id="60916" href="1Lab.Path.html#60916" class="Bound">y</a><a id="60917" class="Symbol">}</a> <a id="60919" class="Symbol">{</a><a id="60920" href="1Lab.Path.html#60920" class="Bound">z</a><a id="60921" class="Symbol">}</a> <a id="60923" href="1Lab.Path.html#60923" class="Bound">loop</a> <a id="60928" href="1Lab.Path.html#60928" class="Bound">adj</a> <a id="60932" class="Symbol">=</a>
  <a id="60936" href="1Lab.Path.html#19544" data-type="(P : (y : A) → x ≡ y → Type ℓ₂) → P x refl → (p : x ≡ y) → P y p" class="Function">J</a> <a id="60938" class="Symbol">(λ</a> <a id="60941" href="1Lab.Path.html#60941" class="Bound">_</a> <a id="60943" href="1Lab.Path.html#60943" class="Bound">adj</a> <a id="60947" class="Symbol">→</a> <a id="60949" href="1Lab.Path.html#15309" data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" class="Function">subst</a> <a id="60955" class="Symbol">(λ</a> <a id="60958" href="1Lab.Path.html#60958" class="Bound">e</a> <a id="60960" class="Symbol">→</a> <a id="60962" href="1Lab.Path.html#60958" class="Bound">e</a> <a id="60964" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="60966" href="1Lab.Path.html#60920" class="Bound">z</a><a id="60967" class="Symbol">)</a> <a id="60969" href="1Lab.Path.html#60943" class="Bound">adj</a> <a id="60973" href="1Lab.Path.html#60923" class="Bound">loop</a> <a id="60978" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="60980" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="60984" href="1Lab.Path.html#60943" class="Bound">adj</a> <a id="60988" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="60990" href="1Lab.Path.html#60923" class="Bound">loop</a><a id="60994" class="Symbol">)</a>
    <a id="61000" class="Symbol">(</a><a id="61001" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="61005" href="1Lab.Path.html#61032" data-type="(loop₁ : x ≡ z) (adj : x ≡ y) →
sym refl ∙ loop₁ ≡ subst (λ e → e ≡ z) refl loop₁" class="Function">lemma</a><a id="61010" class="Symbol">)</a>
    <a id="61016" href="1Lab.Path.html#60928" class="Bound">adj</a>
  <a id="61022" class="Keyword">where</a>
    <a id="61032" href="1Lab.Path.html#61032" data-type="(loop₁ : x ≡ z) (adj : x ≡ y) →
sym refl ∙ loop₁ ≡ subst (λ e → e ≡ z) refl loop₁" class="Function">lemma</a> <a id="61038" class="Symbol">:</a> <a id="61040" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="61044" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="61049" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="61051" href="1Lab.Path.html#60923" class="Bound">loop</a> <a id="61056" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="61058" href="1Lab.Path.html#15309" data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" class="Function">subst</a> <a id="61064" class="Symbol">(λ</a> <a id="61067" href="1Lab.Path.html#61067" class="Bound">e</a> <a id="61069" class="Symbol">→</a> <a id="61071" href="1Lab.Path.html#61067" class="Bound">e</a> <a id="61073" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="61075" href="1Lab.Path.html#60920" class="Bound">z</a><a id="61076" class="Symbol">)</a> <a id="61078" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="61083" href="1Lab.Path.html#60923" class="Bound">loop</a>
    <a id="61092" href="1Lab.Path.html#61032" data-type="(loop₁ : x ≡ z) (adj : x ≡ y) →
sym refl ∙ loop₁ ≡ subst (λ e → e ≡ z) refl loop₁" class="Function">lemma</a> <a id="61098" class="Symbol">=</a>
      <a id="61106" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="61110" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="61115" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="61117" href="1Lab.Path.html#60923" class="Bound">loop</a>           <a id="61132" href="1Lab.Path.html#46881" data-type="(x : A) → x ≡ y → x ≡ y" class="Function Operator">≡⟨⟩</a>
      <a id="61142" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="61147" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="61149" href="1Lab.Path.html#60923" class="Bound">loop</a>               <span class="reasoning-step"><span class="as-written Function"><a id="61168" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="61171" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="61175" class="Symbol">(</a><a id="61176" href="1Lab.Path.html#40319" data-type="(p : x ≡ y) (q : y ≡ z) → Square (sym p) q (p ∙ q) refl" class="Function">∙-filler&#39;</a> <a id="61186" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="61191" class="Symbol">_)</a> <a id="61194" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="61202" href="1Lab.Path.html#60923" class="Bound">loop</a>                      <span class="reasoning-step"><span class="as-written Function"><a id="61228" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="61231" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="61235" class="Symbol">(</a><a id="61236" href="1Lab.Path.html#13454" data-type="(x : A) → transport (λ i → A) x ≡ x" class="Function">transport-refl</a> <a id="61251" class="Symbol">_)</a> <a id="61254" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="61262" href="1Lab.Path.html#15309" data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" class="Function">subst</a> <a id="61268" class="Symbol">(λ</a> <a id="61271" href="1Lab.Path.html#61271" class="Bound">x</a> <a id="61273" class="Symbol">→</a> <a id="61275" href="1Lab.Path.html#61271" class="Bound">x</a><a id="61276" class="Symbol">)</a> <a id="61278" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="61283" href="1Lab.Path.html#60923" class="Bound">loop</a> <a id="61288" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
</pre>
<p>And for the case where we hold the left endpoint constant, in which
case we get a respelling of composition:</p>
<pre class="Agda"><a id="subst-path-right"></a><a id="61413" href="1Lab.Path.html#61413" data-type="(loop₁ : x ≡ z) (adj : z ≡ y) →
subst (_≡_ x) adj loop₁ ≡ loop₁ ∙ adj" class="Function">subst-path-right</a> <a id="61430" class="Symbol">:</a> <a id="61432" class="Symbol">∀</a> <a id="61434" class="Symbol">{</a><a id="61435" href="1Lab.Path.html#61435" class="Bound">ℓ</a><a id="61436" class="Symbol">}</a> <a id="61438" class="Symbol">{</a><a id="61439" href="1Lab.Path.html#61439" class="Bound">A</a> <a id="61441" class="Symbol">:</a> <a id="61443" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="61448" href="1Lab.Path.html#61435" class="Bound">ℓ</a><a id="61449" class="Symbol">}</a> <a id="61451" class="Symbol">{</a><a id="61452" href="1Lab.Path.html#61452" class="Bound">x</a> <a id="61454" href="1Lab.Path.html#61454" class="Bound">y</a> <a id="61456" href="1Lab.Path.html#61456" class="Bound">z</a> <a id="61458" class="Symbol">:</a> <a id="61460" href="1Lab.Path.html#61439" class="Bound">A</a><a id="61461" class="Symbol">}</a>
                 <a id="61480" class="Symbol">→</a> <a id="61482" class="Symbol">(</a><a id="61483" href="1Lab.Path.html#61483" class="Bound">loop</a> <a id="61488" class="Symbol">:</a> <a id="61490" href="1Lab.Path.html#61452" class="Bound">x</a> <a id="61492" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="61494" href="1Lab.Path.html#61456" class="Bound">z</a><a id="61495" class="Symbol">)</a>
                 <a id="61514" class="Symbol">→</a> <a id="61516" class="Symbol">(</a><a id="61517" href="1Lab.Path.html#61517" class="Bound">adj</a> <a id="61521" class="Symbol">:</a> <a id="61523" href="1Lab.Path.html#61456" class="Bound">z</a> <a id="61525" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="61527" href="1Lab.Path.html#61454" class="Bound">y</a><a id="61528" class="Symbol">)</a>
                 <a id="61547" class="Symbol">→</a> <a id="61549" href="1Lab.Path.html#15309" data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" class="Function">subst</a> <a id="61555" class="Symbol">(λ</a> <a id="61558" href="1Lab.Path.html#61558" class="Bound">e</a> <a id="61560" class="Symbol">→</a> <a id="61562" href="1Lab.Path.html#61452" class="Bound">x</a> <a id="61564" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="61566" href="1Lab.Path.html#61558" class="Bound">e</a><a id="61567" class="Symbol">)</a> <a id="61569" href="1Lab.Path.html#61517" class="Bound">adj</a> <a id="61573" href="1Lab.Path.html#61483" class="Bound">loop</a> <a id="61578" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="61580" href="1Lab.Path.html#61483" class="Bound">loop</a> <a id="61585" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="61587" href="1Lab.Path.html#61517" class="Bound">adj</a>
<a id="61591" href="1Lab.Path.html#61413" data-type="(loop₁ : x ≡ z) (adj : z ≡ y) →
subst (_≡_ x) adj loop₁ ≡ loop₁ ∙ adj" class="Function">subst-path-right</a> <a id="61608" class="Symbol">{</a><a id="61609" class="Argument">x</a> <a id="61611" class="Symbol">=</a> <a id="61613" href="1Lab.Path.html#61613" class="Bound">x</a><a id="61614" class="Symbol">}</a> <a id="61616" href="1Lab.Path.html#61616" class="Bound">loop</a> <a id="61621" href="1Lab.Path.html#61621" class="Bound">adj</a> <a id="61625" class="Symbol">=</a>
  <a id="61629" href="1Lab.Path.html#19544" data-type="(P : (y : A) → x ≡ y → Type ℓ₂) → P x refl → (p : x ≡ y) → P y p" class="Function">J</a> <a id="61631" class="Symbol">(λ</a> <a id="61634" href="1Lab.Path.html#61634" class="Bound">_</a> <a id="61636" href="1Lab.Path.html#61636" class="Bound">adj</a> <a id="61640" class="Symbol">→</a> <a id="61642" href="1Lab.Path.html#15309" data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" class="Function">subst</a> <a id="61648" class="Symbol">(λ</a> <a id="61651" href="1Lab.Path.html#61651" class="Bound">e</a> <a id="61653" class="Symbol">→</a> <a id="61655" href="1Lab.Path.html#61613" class="Bound">x</a> <a id="61657" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="61659" href="1Lab.Path.html#61651" class="Bound">e</a><a id="61660" class="Symbol">)</a> <a id="61662" href="1Lab.Path.html#61636" class="Bound">adj</a> <a id="61666" href="1Lab.Path.html#61616" class="Bound">loop</a> <a id="61671" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="61673" href="1Lab.Path.html#61616" class="Bound">loop</a> <a id="61678" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="61680" href="1Lab.Path.html#61636" class="Bound">adj</a><a id="61683" class="Symbol">)</a>
    <a id="61689" class="Symbol">(</a><a id="61690" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="61694" href="1Lab.Path.html#61721" data-type="(loop₁ : x ≡ z) (adj : z ≡ y) →
loop₁ ∙ refl ≡ subst (_≡_ x) refl loop₁" class="Function">lemma</a><a id="61699" class="Symbol">)</a>
    <a id="61705" href="1Lab.Path.html#61621" class="Bound">adj</a>
  <a id="61711" class="Keyword">where</a>
    <a id="61721" href="1Lab.Path.html#61721" data-type="(loop₁ : x ≡ z) (adj : z ≡ y) →
loop₁ ∙ refl ≡ subst (_≡_ x) refl loop₁" class="Function">lemma</a> <a id="61727" class="Symbol">:</a> <a id="61729" href="1Lab.Path.html#61616" class="Bound">loop</a> <a id="61734" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="61736" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="61741" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="61743" href="1Lab.Path.html#15309" data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" class="Function">subst</a> <a id="61749" class="Symbol">(λ</a> <a id="61752" href="1Lab.Path.html#61752" class="Bound">e</a> <a id="61754" class="Symbol">→</a> <a id="61756" href="1Lab.Path.html#61613" class="Bound">x</a> <a id="61758" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="61760" href="1Lab.Path.html#61752" class="Bound">e</a><a id="61761" class="Symbol">)</a> <a id="61763" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="61768" href="1Lab.Path.html#61616" class="Bound">loop</a>
    <a id="61777" href="1Lab.Path.html#61721" data-type="(loop₁ : x ≡ z) (adj : z ≡ y) →
loop₁ ∙ refl ≡ subst (_≡_ x) refl loop₁" class="Function">lemma</a> <a id="61783" class="Symbol">=</a>
      <a id="61791" href="1Lab.Path.html#61616" class="Bound">loop</a> <a id="61796" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="61798" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>               <span class="reasoning-step"><span class="as-written Function"><a id="61817" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="61820" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="61824" class="Symbol">(</a><a id="61825" href="1Lab.Path.html#39820" data-type="(p : x ≡ y) (q : y ≡ z) → Square refl p (p ∙ q) q" class="Function">∙-filler</a> <a id="61834" class="Symbol">_</a> <a id="61836" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a><a id="61840" class="Symbol">)</a> <a id="61842" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="61850" href="1Lab.Path.html#61616" class="Bound">loop</a>                      <span class="reasoning-step"><span class="as-written Function"><a id="61876" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="61879" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="61883" class="Symbol">(</a><a id="61884" href="1Lab.Path.html#13454" data-type="(x : A) → transport (λ i → A) x ≡ x" class="Function">transport-refl</a> <a id="61899" class="Symbol">_)</a> <a id="61902" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="61910" href="1Lab.Path.html#15309" data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" class="Function">subst</a> <a id="61916" class="Symbol">(λ</a> <a id="61919" href="1Lab.Path.html#61919" class="Bound">x</a> <a id="61921" class="Symbol">→</a> <a id="61923" href="1Lab.Path.html#61919" class="Bound">x</a><a id="61924" class="Symbol">)</a> <a id="61926" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="61931" href="1Lab.Path.html#61616" class="Bound">loop</a> <a id="61936" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
</pre>
<!--
TODO: Explain these whiskerings

<pre class="Agda"><a id="_◁_"></a><a id="61989" href="1Lab.Path.html#61989" data-type="a₀ ≡ a₀&#39; → PathP A a₀&#39; a₁ → PathP A a₀ a₁" class="Function Operator">_◁_</a> <a id="61993" class="Symbol">:</a> <a id="61995" class="Symbol">∀</a> <a id="61997" class="Symbol">{</a><a id="61998" href="1Lab.Path.html#61998" class="Bound">ℓ</a><a id="61999" class="Symbol">}</a> <a id="62001" class="Symbol">{</a><a id="62002" href="1Lab.Path.html#62002" class="Bound">A</a> <a id="62004" class="Symbol">:</a> <a id="62006" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a> <a id="62008" class="Symbol">→</a> <a id="62010" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="62015" href="1Lab.Path.html#61998" class="Bound">ℓ</a><a id="62016" class="Symbol">}</a> <a id="62018" class="Symbol">{</a><a id="62019" href="1Lab.Path.html#62019" class="Bound">a₀</a> <a id="62022" href="1Lab.Path.html#62022" class="Bound">a₀&#39;</a> <a id="62026" class="Symbol">:</a> <a id="62028" href="1Lab.Path.html#62002" class="Bound">A</a> <a id="62030" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a><a id="62032" class="Symbol">}</a> <a id="62034" class="Symbol">{</a><a id="62035" href="1Lab.Path.html#62035" class="Bound">a₁</a> <a id="62038" class="Symbol">:</a> <a id="62040" href="1Lab.Path.html#62002" class="Bound">A</a> <a id="62042" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a><a id="62044" class="Symbol">}</a>
  <a id="62048" class="Symbol">→</a> <a id="62050" href="1Lab.Path.html#62019" class="Bound">a₀</a> <a id="62053" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="62055" href="1Lab.Path.html#62022" class="Bound">a₀&#39;</a> <a id="62059" class="Symbol">→</a> <a id="62061" href="Agda.Builtin.Cubical.Path.html#197" data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" class="Postulate">PathP</a> <a id="62067" href="1Lab.Path.html#62002" class="Bound">A</a> <a id="62069" href="1Lab.Path.html#62022" class="Bound">a₀&#39;</a> <a id="62073" href="1Lab.Path.html#62035" class="Bound">a₁</a> <a id="62076" class="Symbol">→</a> <a id="62078" href="Agda.Builtin.Cubical.Path.html#197" data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" class="Postulate">PathP</a> <a id="62084" href="1Lab.Path.html#62002" class="Bound">A</a> <a id="62086" href="1Lab.Path.html#62019" class="Bound">a₀</a> <a id="62089" href="1Lab.Path.html#62035" class="Bound">a₁</a>
<a id="62092" class="Symbol">(</a><a id="62093" href="1Lab.Path.html#62093" class="Bound">p</a> <a id="62095" href="1Lab.Path.html#61989" data-type="a₀ ≡ a₀&#39; → PathP A a₀&#39; a₁ → PathP A a₀ a₁" class="Function Operator">◁</a> <a id="62097" href="1Lab.Path.html#62097" class="Bound">q</a><a id="62098" class="Symbol">)</a> <a id="62100" href="1Lab.Path.html#62100" class="Bound">i</a> <a id="62102" class="Symbol">=</a>
  <a id="62106" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="62112" class="Symbol">(λ</a> <a id="62115" href="1Lab.Path.html#62115" class="Bound">j</a> <a id="62117" class="Symbol">→</a> <a id="62119" class="Symbol">λ</a> <a id="62121" class="Symbol">{(</a><a id="62123" href="1Lab.Path.html#62100" class="Bound">i</a> <a id="62125" class="Symbol">=</a> <a id="62127" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a><a id="62129" class="Symbol">)</a> <a id="62131" class="Symbol">→</a> <a id="62133" href="1Lab.Path.html#62093" class="Bound">p</a> <a id="62135" class="Symbol">(</a><a id="62136" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="62138" href="1Lab.Path.html#62115" class="Bound">j</a><a id="62139" class="Symbol">);</a> <a id="62142" class="Symbol">(</a><a id="62143" href="1Lab.Path.html#62100" class="Bound">i</a> <a id="62145" class="Symbol">=</a> <a id="62147" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a><a id="62149" class="Symbol">)</a> <a id="62151" class="Symbol">→</a> <a id="62153" href="1Lab.Path.html#62097" class="Bound">q</a> <a id="62155" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a><a id="62157" class="Symbol">})</a> <a id="62160" class="Symbol">(</a><a id="62161" href="1Lab.Path.html#62097" class="Bound">q</a> <a id="62163" href="1Lab.Path.html#62100" class="Bound">i</a><a id="62164" class="Symbol">)</a>

<a id="_▷_"></a><a id="62167" href="1Lab.Path.html#62167" data-type="PathP A a₀ a₁ → a₁ ≡ a₁&#39; → PathP A a₀ a₁&#39;" class="Function Operator">_▷_</a> <a id="62171" class="Symbol">:</a> <a id="62173" class="Symbol">∀</a> <a id="62175" class="Symbol">{</a><a id="62176" href="1Lab.Path.html#62176" class="Bound">ℓ</a><a id="62177" class="Symbol">}</a> <a id="62179" class="Symbol">{</a><a id="62180" href="1Lab.Path.html#62180" class="Bound">A</a> <a id="62182" class="Symbol">:</a> <a id="62184" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a> <a id="62186" class="Symbol">→</a> <a id="62188" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="62193" href="1Lab.Path.html#62176" class="Bound">ℓ</a><a id="62194" class="Symbol">}</a> <a id="62196" class="Symbol">{</a><a id="62197" href="1Lab.Path.html#62197" class="Bound">a₀</a> <a id="62200" class="Symbol">:</a> <a id="62202" href="1Lab.Path.html#62180" class="Bound">A</a> <a id="62204" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a><a id="62206" class="Symbol">}</a> <a id="62208" class="Symbol">{</a><a id="62209" href="1Lab.Path.html#62209" class="Bound">a₁</a> <a id="62212" href="1Lab.Path.html#62212" class="Bound">a₁&#39;</a> <a id="62216" class="Symbol">:</a> <a id="62218" href="1Lab.Path.html#62180" class="Bound">A</a> <a id="62220" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a><a id="62222" class="Symbol">}</a>
  <a id="62226" class="Symbol">→</a> <a id="62228" href="Agda.Builtin.Cubical.Path.html#197" data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" class="Postulate">PathP</a> <a id="62234" href="1Lab.Path.html#62180" class="Bound">A</a> <a id="62236" href="1Lab.Path.html#62197" class="Bound">a₀</a> <a id="62239" href="1Lab.Path.html#62209" class="Bound">a₁</a> <a id="62242" class="Symbol">→</a> <a id="62244" href="1Lab.Path.html#62209" class="Bound">a₁</a> <a id="62247" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="62249" href="1Lab.Path.html#62212" class="Bound">a₁&#39;</a> <a id="62253" class="Symbol">→</a> <a id="62255" href="Agda.Builtin.Cubical.Path.html#197" data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" class="Postulate">PathP</a> <a id="62261" href="1Lab.Path.html#62180" class="Bound">A</a> <a id="62263" href="1Lab.Path.html#62197" class="Bound">a₀</a> <a id="62266" href="1Lab.Path.html#62212" class="Bound">a₁&#39;</a>
<a id="62270" class="Symbol">(</a><a id="62271" href="1Lab.Path.html#62271" class="Bound">p</a> <a id="62273" href="1Lab.Path.html#62167" data-type="PathP A a₀ a₁ → a₁ ≡ a₁&#39; → PathP A a₀ a₁&#39;" class="Function Operator">▷</a> <a id="62275" href="1Lab.Path.html#62275" class="Bound">q</a><a id="62276" class="Symbol">)</a> <a id="62278" href="1Lab.Path.html#62278" class="Bound">i</a> <a id="62280" class="Symbol">=</a>
  <a id="62284" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="62290" class="Symbol">(λ</a> <a id="62293" href="1Lab.Path.html#62293" class="Bound">j</a> <a id="62295" class="Symbol">→</a> <a id="62297" class="Symbol">λ</a> <a id="62299" class="Symbol">{(</a><a id="62301" href="1Lab.Path.html#62278" class="Bound">i</a> <a id="62303" class="Symbol">=</a> <a id="62305" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a><a id="62307" class="Symbol">)</a> <a id="62309" class="Symbol">→</a> <a id="62311" href="1Lab.Path.html#62271" class="Bound">p</a> <a id="62313" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a><a id="62315" class="Symbol">;</a> <a id="62317" class="Symbol">(</a><a id="62318" href="1Lab.Path.html#62278" class="Bound">i</a> <a id="62320" class="Symbol">=</a> <a id="62322" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a><a id="62324" class="Symbol">)</a> <a id="62326" class="Symbol">→</a> <a id="62328" href="1Lab.Path.html#62275" class="Bound">q</a> <a id="62330" href="1Lab.Path.html#62293" class="Bound">j</a><a id="62331" class="Symbol">})</a> <a id="62334" class="Symbol">(</a><a id="62335" href="1Lab.Path.html#62271" class="Bound">p</a> <a id="62337" href="1Lab.Path.html#62278" class="Bound">i</a><a id="62338" class="Symbol">)</a>

<a id="Square≡··"></a><a id="62341" href="1Lab.Path.html#62341" data-type="Square p q s r ≡ ((sym p ·· q ·· r) ≡ s)" class="Function">Square≡··</a> <a id="62351" class="Symbol">:</a> <a id="62353" class="Symbol">∀</a> <a id="62355" class="Symbol">{</a><a id="62356" href="1Lab.Path.html#62356" class="Bound">ℓ</a><a id="62357" class="Symbol">}</a> <a id="62359" class="Symbol">{</a><a id="62360" href="1Lab.Path.html#62360" class="Bound">A</a> <a id="62362" class="Symbol">:</a> <a id="62364" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="62369" href="1Lab.Path.html#62356" class="Bound">ℓ</a><a id="62370" class="Symbol">}</a>
          <a id="62382" class="Symbol">→</a> <a id="62384" class="Symbol">{</a><a id="62385" href="1Lab.Path.html#62385" class="Bound">w</a> <a id="62387" href="1Lab.Path.html#62387" class="Bound">x</a> <a id="62389" href="1Lab.Path.html#62389" class="Bound">y</a> <a id="62391" href="1Lab.Path.html#62391" class="Bound">z</a> <a id="62393" class="Symbol">:</a> <a id="62395" href="1Lab.Path.html#62360" class="Bound">A</a><a id="62396" class="Symbol">}</a>
          <a id="62408" class="Symbol">→</a> <a id="62410" class="Symbol">{</a><a id="62411" href="1Lab.Path.html#62411" class="Bound">p</a> <a id="62413" class="Symbol">:</a> <a id="62415" href="1Lab.Path.html#62387" class="Bound">x</a> <a id="62417" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="62419" href="1Lab.Path.html#62385" class="Bound">w</a><a id="62420" class="Symbol">}</a> <a id="62422" class="Symbol">{</a><a id="62423" href="1Lab.Path.html#62423" class="Bound">q</a> <a id="62425" class="Symbol">:</a> <a id="62427" href="1Lab.Path.html#62387" class="Bound">x</a> <a id="62429" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="62431" href="1Lab.Path.html#62389" class="Bound">y</a><a id="62432" class="Symbol">}</a> <a id="62434" class="Symbol">{</a><a id="62435" href="1Lab.Path.html#62435" class="Bound">s</a> <a id="62437" class="Symbol">:</a> <a id="62439" href="1Lab.Path.html#62385" class="Bound">w</a> <a id="62441" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="62443" href="1Lab.Path.html#62391" class="Bound">z</a><a id="62444" class="Symbol">}</a> <a id="62446" class="Symbol">{</a><a id="62447" href="1Lab.Path.html#62447" class="Bound">r</a> <a id="62449" class="Symbol">:</a> <a id="62451" href="1Lab.Path.html#62389" class="Bound">y</a> <a id="62453" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="62455" href="1Lab.Path.html#62391" class="Bound">z</a><a id="62456" class="Symbol">}</a>
          <a id="62468" class="Symbol">→</a> <a id="62470" href="1Lab.Path.html#9409" data-type="a00 ≡ a01 → a00 ≡ a10 → a01 ≡ a11 → a10 ≡ a11 → Type ℓ" class="Function">Square</a> <a id="62477" href="1Lab.Path.html#62411" class="Bound">p</a> <a id="62479" href="1Lab.Path.html#62423" class="Bound">q</a> <a id="62481" href="1Lab.Path.html#62435" class="Bound">s</a> <a id="62483" href="1Lab.Path.html#62447" class="Bound">r</a> <a id="62485" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="62487" class="Symbol">(</a><a id="62488" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="62492" href="1Lab.Path.html#62411" class="Bound">p</a> <a id="62494" href="1Lab.Path.html#38305" data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" class="Function Operator">··</a> <a id="62497" href="1Lab.Path.html#62423" class="Bound">q</a> <a id="62499" href="1Lab.Path.html#38305" data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" class="Function Operator">··</a> <a id="62502" href="1Lab.Path.html#62447" class="Bound">r</a> <a id="62504" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="62506" href="1Lab.Path.html#62435" class="Bound">s</a><a id="62507" class="Symbol">)</a>
<a id="62509" href="1Lab.Path.html#62341" data-type="Square p q s r ≡ ((sym p ·· q ·· r) ≡ s)" class="Function">Square≡··</a> <a id="62519" class="Symbol">{</a><a id="62520" class="Argument">p</a> <a id="62522" class="Symbol">=</a> <a id="62524" href="1Lab.Path.html#62524" class="Bound">p</a><a id="62525" class="Symbol">}</a> <a id="62527" class="Symbol">{</a><a id="62528" href="1Lab.Path.html#62528" class="Bound">q</a><a id="62529" class="Symbol">}</a> <a id="62531" class="Symbol">{</a><a id="62532" href="1Lab.Path.html#62532" class="Bound">s</a><a id="62533" class="Symbol">}</a> <a id="62535" class="Symbol">{</a><a id="62536" href="1Lab.Path.html#62536" class="Bound">r</a><a id="62537" class="Symbol">}</a> <a id="62539" href="1Lab.Path.html#62539" class="Bound">k</a> <a id="62541" class="Symbol">=</a>
  <a id="62545" href="Agda.Builtin.Cubical.Path.html#197" data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" class="Postulate">PathP</a> <a id="62551" class="Symbol">(λ</a> <a id="62554" href="1Lab.Path.html#62554" class="Bound">i</a> <a id="62556" class="Symbol">→</a> <a id="62558" href="1Lab.Path.html#62524" class="Bound">p</a> <a id="62560" class="Symbol">(</a><a id="62561" href="1Lab.Path.html#62554" class="Bound">i</a> <a id="62563" href="1Lab.Path.html#2226" class="Primitive Operator">∨</a> <a id="62565" href="1Lab.Path.html#62539" class="Bound">k</a><a id="62566" class="Symbol">)</a> <a id="62568" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="62570" href="1Lab.Path.html#62536" class="Bound">r</a> <a id="62572" class="Symbol">(</a><a id="62573" href="1Lab.Path.html#62554" class="Bound">i</a> <a id="62575" href="1Lab.Path.html#2226" class="Primitive Operator">∨</a> <a id="62577" href="1Lab.Path.html#62539" class="Bound">k</a><a id="62578" class="Symbol">))</a>
    <a id="62585" class="Symbol">(</a><a id="62586" href="1Lab.Path.html#38623" data-type="(p : w ≡ x) (q : x ≡ y) (r : y ≡ z) →
Square (sym p) q (p ·· q ·· r) r" class="Function">··-filler</a> <a id="62596" class="Symbol">(</a><a id="62597" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="62601" href="1Lab.Path.html#62524" class="Bound">p</a><a id="62602" class="Symbol">)</a> <a id="62604" href="1Lab.Path.html#62528" class="Bound">q</a> <a id="62606" href="1Lab.Path.html#62536" class="Bound">r</a> <a id="62608" href="1Lab.Path.html#62539" class="Bound">k</a><a id="62609" class="Symbol">)</a> <a id="62611" href="1Lab.Path.html#62532" class="Bound">s</a>

<a id="≡⟨⟩⟨⟩-syntax"></a><a id="62614" href="1Lab.Path.html#62614" data-type="(x y : A) → x ≡ y → y ≡ z → z ≡ w → x ≡ w" class="Function">≡⟨⟩⟨⟩-syntax</a> <a id="62627" class="Symbol">:</a> <a id="62629" class="Symbol">∀</a> <a id="62631" class="Symbol">{</a><a id="62632" href="1Lab.Path.html#62632" class="Bound">ℓ</a><a id="62633" class="Symbol">}</a> <a id="62635" class="Symbol">{</a><a id="62636" href="1Lab.Path.html#62636" class="Bound">A</a> <a id="62638" class="Symbol">:</a> <a id="62640" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="62645" href="1Lab.Path.html#62632" class="Bound">ℓ</a><a id="62646" class="Symbol">}</a> <a id="62648" class="Symbol">(</a><a id="62649" href="1Lab.Path.html#62649" class="Bound">x</a> <a id="62651" href="1Lab.Path.html#62651" class="Bound">y</a> <a id="62653" class="Symbol">:</a> <a id="62655" href="1Lab.Path.html#62636" class="Bound">A</a><a id="62656" class="Symbol">)</a> <a id="62658" class="Symbol">{</a><a id="62659" href="1Lab.Path.html#62659" class="Bound">w</a> <a id="62661" href="1Lab.Path.html#62661" class="Bound">z</a> <a id="62663" class="Symbol">:</a> <a id="62665" href="1Lab.Path.html#62636" class="Bound">A</a><a id="62666" class="Symbol">}</a> <a id="62668" class="Symbol">→</a> <a id="62670" href="1Lab.Path.html#62649" class="Bound">x</a> <a id="62672" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="62674" href="1Lab.Path.html#62651" class="Bound">y</a> <a id="62676" class="Symbol">→</a> <a id="62678" href="1Lab.Path.html#62651" class="Bound">y</a> <a id="62680" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="62682" href="1Lab.Path.html#62661" class="Bound">z</a> <a id="62684" class="Symbol">→</a> <a id="62686" href="1Lab.Path.html#62661" class="Bound">z</a> <a id="62688" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="62690" href="1Lab.Path.html#62659" class="Bound">w</a> <a id="62692" class="Symbol">→</a> <a id="62694" href="1Lab.Path.html#62649" class="Bound">x</a> <a id="62696" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="62698" href="1Lab.Path.html#62659" class="Bound">w</a>
<a id="62700" href="1Lab.Path.html#62614" data-type="(x y : A) → x ≡ y → y ≡ z → z ≡ w → x ≡ w" class="Function">≡⟨⟩⟨⟩-syntax</a> <a id="62713" href="1Lab.Path.html#62713" class="Bound">x</a> <a id="62715" href="1Lab.Path.html#62715" class="Bound">y</a> <a id="62717" href="1Lab.Path.html#62717" class="Bound">p</a> <a id="62719" href="1Lab.Path.html#62719" class="Bound">q</a> <a id="62721" href="1Lab.Path.html#62721" class="Bound">r</a> <a id="62723" class="Symbol">=</a> <a id="62725" href="1Lab.Path.html#62717" class="Bound">p</a> <a id="62727" href="1Lab.Path.html#38305" data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" class="Function Operator">··</a> <a id="62730" href="1Lab.Path.html#62719" class="Bound">q</a> <a id="62732" href="1Lab.Path.html#38305" data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" class="Function Operator">··</a> <a id="62735" href="1Lab.Path.html#62721" class="Bound">r</a>
<a id="62737" class="Keyword">infixr</a> <a id="62744" class="Number">2.5</a> <a id="62748" href="1Lab.Path.html#62614" data-type="(x y : A) → x ≡ y → y ≡ z → z ≡ w → x ≡ w" class="Function">≡⟨⟩⟨⟩-syntax</a>
<a id="62761" class="Keyword">syntax</a> <a id="62768" href="1Lab.Path.html#62614" data-type="(x y : A) → x ≡ y → y ≡ z → z ≡ w → x ≡ w" class="Function">≡⟨⟩⟨⟩-syntax</a> <a id="62781" class="Bound">x</a> <a id="62783" class="Bound">y</a> <a id="62785" class="Bound">B</a> <a id="62787" class="Bound">C</a> <a id="62789" class="Symbol">=</a> <a id="62791" class="Bound">x</a> <a id="62793" class="Function">≡⟨</a> <a id="62796" class="Bound">B</a> <a id="62798" class="Function">⟩≡</a> <a id="62801" class="Bound">y</a> <a id="62803" class="Function">≡⟨</a> <a id="62806" class="Bound">C</a> <a id="62808" class="Function">⟩≡</a>

<a id="J′"></a><a id="62812" href="1Lab.Path.html#62812" data-type="(P : (x y : A) → x ≡ y → Type ℓ₂) →
((x : A) → P x x refl) → (p : x ≡ y) → P x y p" class="Function">J′</a> <a id="62815" class="Symbol">:</a> <a id="62817" class="Symbol">∀</a> <a id="62819" class="Symbol">{</a><a id="62820" href="1Lab.Path.html#62820" class="Bound">ℓ₁</a> <a id="62823" href="1Lab.Path.html#62823" class="Bound">ℓ₂</a><a id="62825" class="Symbol">}</a> <a id="62827" class="Symbol">{</a><a id="62828" href="1Lab.Path.html#62828" class="Bound">A</a> <a id="62830" class="Symbol">:</a> <a id="62832" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="62837" href="1Lab.Path.html#62820" class="Bound">ℓ₁</a><a id="62839" class="Symbol">}</a>
     <a id="62846" class="Symbol">(</a><a id="62847" href="1Lab.Path.html#62847" class="Bound">P</a> <a id="62849" class="Symbol">:</a> <a id="62851" class="Symbol">(</a><a id="62852" href="1Lab.Path.html#62852" class="Bound">x</a> <a id="62854" href="1Lab.Path.html#62854" class="Bound">y</a> <a id="62856" class="Symbol">:</a> <a id="62858" href="1Lab.Path.html#62828" class="Bound">A</a><a id="62859" class="Symbol">)</a> <a id="62861" class="Symbol">→</a> <a id="62863" href="1Lab.Path.html#62852" class="Bound">x</a> <a id="62865" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="62867" href="1Lab.Path.html#62854" class="Bound">y</a> <a id="62869" class="Symbol">→</a> <a id="62871" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="62876" href="1Lab.Path.html#62823" class="Bound">ℓ₂</a><a id="62878" class="Symbol">)</a>
   <a id="62883" class="Symbol">→</a> <a id="62885" class="Symbol">(∀</a> <a id="62888" href="1Lab.Path.html#62888" class="Bound">x</a> <a id="62890" class="Symbol">→</a> <a id="62892" href="1Lab.Path.html#62847" class="Bound">P</a> <a id="62894" href="1Lab.Path.html#62888" class="Bound">x</a> <a id="62896" href="1Lab.Path.html#62888" class="Bound">x</a> <a id="62898" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a><a id="62902" class="Symbol">)</a>
   <a id="62907" class="Symbol">→</a> <a id="62909" class="Symbol">{</a><a id="62910" href="1Lab.Path.html#62910" class="Bound">x</a> <a id="62912" href="1Lab.Path.html#62912" class="Bound">y</a> <a id="62914" class="Symbol">:</a> <a id="62916" href="1Lab.Path.html#62828" class="Bound">A</a><a id="62917" class="Symbol">}</a> <a id="62919" class="Symbol">(</a><a id="62920" href="1Lab.Path.html#62920" class="Bound">p</a> <a id="62922" class="Symbol">:</a> <a id="62924" href="1Lab.Path.html#62910" class="Bound">x</a> <a id="62926" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="62928" href="1Lab.Path.html#62912" class="Bound">y</a><a id="62929" class="Symbol">)</a>
   <a id="62934" class="Symbol">→</a> <a id="62936" href="1Lab.Path.html#62847" class="Bound">P</a> <a id="62938" href="1Lab.Path.html#62910" class="Bound">x</a> <a id="62940" href="1Lab.Path.html#62912" class="Bound">y</a> <a id="62942" href="1Lab.Path.html#62920" class="Bound">p</a>
<a id="62944" href="1Lab.Path.html#62812" data-type="(P : (x y : A) → x ≡ y → Type ℓ₂) →
((x : A) → P x x refl) → (p : x ≡ y) → P x y p" class="Function">J′</a> <a id="62947" href="1Lab.Path.html#62947" class="Bound">P</a> <a id="62949" href="1Lab.Path.html#62949" class="Bound">prefl</a> <a id="62955" class="Symbol">{</a><a id="62956" href="1Lab.Path.html#62956" class="Bound">x</a><a id="62957" class="Symbol">}</a> <a id="62959" href="1Lab.Path.html#62959" class="Bound">p</a> <a id="62961" class="Symbol">=</a> <a id="62963" href="1Lab.Path.html#11776" data-type="A ≡ B₁ → A → B₁" class="Function">transport</a> <a id="62973" class="Symbol">(λ</a> <a id="62976" href="1Lab.Path.html#62976" class="Bound">i</a> <a id="62978" class="Symbol">→</a> <a id="62980" href="1Lab.Path.html#62947" class="Bound">P</a> <a id="62982" href="1Lab.Path.html#62956" class="Bound">x</a> <a id="62984" class="Symbol">(</a><a id="62985" href="1Lab.Path.html#62959" class="Bound">p</a> <a id="62987" href="1Lab.Path.html#62976" class="Bound">i</a><a id="62988" class="Symbol">)</a> <a id="62990" class="Symbol">λ</a> <a id="62992" href="1Lab.Path.html#62992" class="Bound">j</a> <a id="62994" class="Symbol">→</a> <a id="62996" href="1Lab.Path.html#62959" class="Bound">p</a> <a id="62998" class="Symbol">(</a><a id="62999" href="1Lab.Path.html#62976" class="Bound">i</a> <a id="63001" href="1Lab.Path.html#2191" class="Primitive Operator">∧</a> <a id="63003" href="1Lab.Path.html#62992" class="Bound">j</a><a id="63004" class="Symbol">))</a> <a id="63007" class="Symbol">(</a><a id="63008" href="1Lab.Path.html#62949" class="Bound">prefl</a> <a id="63014" href="1Lab.Path.html#62956" class="Bound">x</a><a id="63015" class="Symbol">)</a>

<a id="··≡twice∙"></a><a id="63018" href="1Lab.Path.html#63018" data-type="(p : x ≡ y) (q : y ≡ z) (r : z ≡ w) → (p ·· q ·· r) ≡ p ∙ q ∙ r" class="Function">··≡twice∙</a>
  <a id="63030" class="Symbol">:</a> <a id="63032" class="Symbol">∀</a> <a id="63034" class="Symbol">{</a><a id="63035" href="1Lab.Path.html#63035" class="Bound">ℓ</a><a id="63036" class="Symbol">}</a> <a id="63038" class="Symbol">{</a><a id="63039" href="1Lab.Path.html#63039" class="Bound">A</a> <a id="63041" class="Symbol">:</a> <a id="63043" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="63048" href="1Lab.Path.html#63035" class="Bound">ℓ</a><a id="63049" class="Symbol">}</a>
  <a id="63053" class="Symbol">→</a> <a id="63055" class="Symbol">{</a><a id="63056" href="1Lab.Path.html#63056" class="Bound">x</a> <a id="63058" href="1Lab.Path.html#63058" class="Bound">y</a> <a id="63060" href="1Lab.Path.html#63060" class="Bound">z</a> <a id="63062" href="1Lab.Path.html#63062" class="Bound">w</a> <a id="63064" class="Symbol">:</a> <a id="63066" href="1Lab.Path.html#63039" class="Bound">A</a><a id="63067" class="Symbol">}</a>
  <a id="63071" class="Symbol">→</a> <a id="63073" class="Symbol">(</a><a id="63074" href="1Lab.Path.html#63074" class="Bound">p</a> <a id="63076" class="Symbol">:</a> <a id="63078" href="1Lab.Path.html#63056" class="Bound">x</a> <a id="63080" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="63082" href="1Lab.Path.html#63058" class="Bound">y</a><a id="63083" class="Symbol">)</a> <a id="63085" class="Symbol">(</a><a id="63086" href="1Lab.Path.html#63086" class="Bound">q</a> <a id="63088" class="Symbol">:</a> <a id="63090" href="1Lab.Path.html#63058" class="Bound">y</a> <a id="63092" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="63094" href="1Lab.Path.html#63060" class="Bound">z</a><a id="63095" class="Symbol">)</a> <a id="63097" class="Symbol">(</a><a id="63098" href="1Lab.Path.html#63098" class="Bound">r</a> <a id="63100" class="Symbol">:</a> <a id="63102" href="1Lab.Path.html#63060" class="Bound">z</a> <a id="63104" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="63106" href="1Lab.Path.html#63062" class="Bound">w</a><a id="63107" class="Symbol">)</a>
  <a id="63111" class="Symbol">→</a> <a id="63113" href="1Lab.Path.html#63074" class="Bound">p</a> <a id="63115" href="1Lab.Path.html#38305" data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" class="Function Operator">··</a> <a id="63118" href="1Lab.Path.html#63086" class="Bound">q</a> <a id="63120" href="1Lab.Path.html#38305" data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" class="Function Operator">··</a> <a id="63123" href="1Lab.Path.html#63098" class="Bound">r</a> <a id="63125" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="63127" href="1Lab.Path.html#63074" class="Bound">p</a> <a id="63129" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="63131" href="1Lab.Path.html#63086" class="Bound">q</a> <a id="63133" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="63135" href="1Lab.Path.html#63098" class="Bound">r</a>
<a id="63137" href="1Lab.Path.html#63018" data-type="(p : x ≡ y) (q : y ≡ z) (r : z ≡ w) → (p ·· q ·· r) ≡ p ∙ q ∙ r" class="Function">··≡twice∙</a> <a id="63147" href="1Lab.Path.html#63147" class="Bound">p</a> <a id="63149" href="1Lab.Path.html#63149" class="Bound">q</a> <a id="63151" href="1Lab.Path.html#63151" class="Bound">r</a> <a id="63153" href="1Lab.Path.html#63153" class="Bound">i</a> <a id="63155" href="1Lab.Path.html#63155" class="Bound">j</a> <a id="63157" class="Symbol">=</a>
  <a id="63161" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="63167" class="Symbol">(λ</a> <a id="63170" href="1Lab.Path.html#63170" class="Bound">k</a> <a id="63172" class="Symbol">→</a> <a id="63174" class="Symbol">λ</a> <a id="63176" class="Symbol">{</a> <a id="63178" class="Symbol">(</a><a id="63179" href="1Lab.Path.html#63153" class="Bound">i</a> <a id="63181" class="Symbol">=</a> <a id="63183" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a><a id="63185" class="Symbol">)</a> <a id="63187" class="Symbol">→</a> <a id="63189" href="1Lab.Path.html#40319" data-type="(p : x ≡ y) (q : y ≡ z) → Square (sym p) q (p ∙ q) refl" class="Function">∙-filler&#39;</a> <a id="63199" href="1Lab.Path.html#63147" class="Bound">p</a> <a id="63201" class="Symbol">(</a><a id="63202" href="1Lab.Path.html#63149" class="Bound">q</a> <a id="63204" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="63206" href="1Lab.Path.html#63151" class="Bound">r</a><a id="63207" class="Symbol">)</a> <a id="63209" href="1Lab.Path.html#63170" class="Bound">k</a> <a id="63211" href="1Lab.Path.html#63155" class="Bound">j</a>
                 <a id="63230" class="Symbol">;</a> <a id="63232" class="Symbol">(</a><a id="63233" href="1Lab.Path.html#63155" class="Bound">j</a> <a id="63235" class="Symbol">=</a> <a id="63237" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a><a id="63239" class="Symbol">)</a> <a id="63241" class="Symbol">→</a> <a id="63243" href="1Lab.Path.html#63147" class="Bound">p</a> <a id="63245" class="Symbol">(</a><a id="63246" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="63248" href="1Lab.Path.html#63170" class="Bound">k</a><a id="63249" class="Symbol">)</a>
                 <a id="63268" class="Symbol">;</a> <a id="63270" class="Symbol">(</a><a id="63271" href="1Lab.Path.html#63155" class="Bound">j</a> <a id="63273" class="Symbol">=</a> <a id="63275" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a><a id="63277" class="Symbol">)</a> <a id="63279" class="Symbol">→</a> <a id="63281" href="1Lab.Path.html#63151" class="Bound">r</a> <a id="63283" class="Symbol">(</a><a id="63284" href="1Lab.Path.html#63153" class="Bound">i</a> <a id="63286" href="1Lab.Path.html#2226" class="Primitive Operator">∨</a> <a id="63288" href="1Lab.Path.html#63170" class="Bound">k</a><a id="63289" class="Symbol">)})</a>
        <a id="63301" class="Symbol">(</a><a id="63302" href="1Lab.Path.html#39820" data-type="(p : x ≡ y) (q : y ≡ z) → Square refl p (p ∙ q) q" class="Function">∙-filler</a> <a id="63311" href="1Lab.Path.html#63149" class="Bound">q</a> <a id="63313" href="1Lab.Path.html#63151" class="Bound">r</a> <a id="63315" href="1Lab.Path.html#63153" class="Bound">i</a> <a id="63317" href="1Lab.Path.html#63155" class="Bound">j</a><a id="63318" class="Symbol">)</a>

<a id="invert-sides"></a><a id="63321" href="1Lab.Path.html#63321" data-type="(p : x ≡ y) (q : x ≡ z) → Square q p (sym q) (sym p)" class="Function">invert-sides</a> <a id="63334" class="Symbol">:</a> <a id="63336" class="Symbol">∀</a> <a id="63338" class="Symbol">{</a><a id="63339" href="1Lab.Path.html#63339" class="Bound">ℓ</a><a id="63340" class="Symbol">}</a> <a id="63342" class="Symbol">{</a><a id="63343" href="1Lab.Path.html#63343" class="Bound">A</a> <a id="63345" class="Symbol">:</a> <a id="63347" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="63352" href="1Lab.Path.html#63339" class="Bound">ℓ</a><a id="63353" class="Symbol">}</a> <a id="63355" class="Symbol">{</a><a id="63356" href="1Lab.Path.html#63356" class="Bound">x</a> <a id="63358" href="1Lab.Path.html#63358" class="Bound">y</a> <a id="63360" href="1Lab.Path.html#63360" class="Bound">z</a> <a id="63362" class="Symbol">:</a> <a id="63364" href="1Lab.Path.html#63343" class="Bound">A</a><a id="63365" class="Symbol">}</a> <a id="63367" class="Symbol">(</a><a id="63368" href="1Lab.Path.html#63368" class="Bound">p</a> <a id="63370" class="Symbol">:</a> <a id="63372" href="1Lab.Path.html#63356" class="Bound">x</a> <a id="63374" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="63376" href="1Lab.Path.html#63358" class="Bound">y</a><a id="63377" class="Symbol">)</a> <a id="63379" class="Symbol">(</a><a id="63380" href="1Lab.Path.html#63380" class="Bound">q</a> <a id="63382" class="Symbol">:</a> <a id="63384" href="1Lab.Path.html#63356" class="Bound">x</a> <a id="63386" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="63388" href="1Lab.Path.html#63360" class="Bound">z</a><a id="63389" class="Symbol">)</a>
             <a id="63404" class="Symbol">→</a> <a id="63406" href="1Lab.Path.html#9409" data-type="a00 ≡ a01 → a00 ≡ a10 → a01 ≡ a11 → a10 ≡ a11 → Type ℓ" class="Function">Square</a> <a id="63413" href="1Lab.Path.html#63380" class="Bound">q</a> <a id="63415" href="1Lab.Path.html#63368" class="Bound">p</a> <a id="63417" class="Symbol">(</a><a id="63418" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="63422" href="1Lab.Path.html#63380" class="Bound">q</a><a id="63423" class="Symbol">)</a> <a id="63425" class="Symbol">(</a><a id="63426" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="63430" href="1Lab.Path.html#63368" class="Bound">p</a><a id="63431" class="Symbol">)</a>
<a id="63433" href="1Lab.Path.html#63321" data-type="(p : x ≡ y) (q : x ≡ z) → Square q p (sym q) (sym p)" class="Function">invert-sides</a> <a id="63446" class="Symbol">{</a><a id="63447" class="Argument">x</a> <a id="63449" class="Symbol">=</a> <a id="63451" href="1Lab.Path.html#63451" class="Bound">x</a><a id="63452" class="Symbol">}</a> <a id="63454" href="1Lab.Path.html#63454" class="Bound">p</a> <a id="63456" href="1Lab.Path.html#63456" class="Bound">q</a> <a id="63458" href="1Lab.Path.html#63458" class="Bound">i</a> <a id="63460" href="1Lab.Path.html#63460" class="Bound">j</a> <a id="63462" class="Symbol">=</a>
  <a id="63466" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="63472" class="Symbol">(λ</a> <a id="63475" href="1Lab.Path.html#63475" class="Bound">k</a> <a id="63477" class="Symbol">→</a> <a id="63479" class="Symbol">λ</a> <a id="63481" class="Symbol">{</a> <a id="63483" class="Symbol">(</a><a id="63484" href="1Lab.Path.html#63458" class="Bound">i</a> <a id="63486" class="Symbol">=</a> <a id="63488" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a><a id="63490" class="Symbol">)</a> <a id="63492" class="Symbol">→</a> <a id="63494" href="1Lab.Path.html#63454" class="Bound">p</a> <a id="63496" class="Symbol">(</a><a id="63497" href="1Lab.Path.html#63475" class="Bound">k</a> <a id="63499" href="1Lab.Path.html#2191" class="Primitive Operator">∧</a> <a id="63501" href="1Lab.Path.html#63460" class="Bound">j</a><a id="63502" class="Symbol">)</a>
                 <a id="63521" class="Symbol">;</a> <a id="63523" class="Symbol">(</a><a id="63524" href="1Lab.Path.html#63458" class="Bound">i</a> <a id="63526" class="Symbol">=</a> <a id="63528" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a><a id="63530" class="Symbol">)</a> <a id="63532" class="Symbol">→</a> <a id="63534" href="1Lab.Path.html#63456" class="Bound">q</a> <a id="63536" class="Symbol">(</a><a id="63537" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="63539" href="1Lab.Path.html#63460" class="Bound">j</a> <a id="63541" href="1Lab.Path.html#2191" class="Primitive Operator">∧</a> <a id="63543" href="1Lab.Path.html#63475" class="Bound">k</a><a id="63544" class="Symbol">)</a>
                 <a id="63563" class="Symbol">;</a> <a id="63565" class="Symbol">(</a><a id="63566" href="1Lab.Path.html#63460" class="Bound">j</a> <a id="63568" class="Symbol">=</a> <a id="63570" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a><a id="63572" class="Symbol">)</a> <a id="63574" class="Symbol">→</a> <a id="63576" href="1Lab.Path.html#63456" class="Bound">q</a> <a id="63578" class="Symbol">(</a><a id="63579" href="1Lab.Path.html#63458" class="Bound">i</a> <a id="63581" href="1Lab.Path.html#2191" class="Primitive Operator">∧</a> <a id="63583" href="1Lab.Path.html#63475" class="Bound">k</a><a id="63584" class="Symbol">)</a>
                 <a id="63603" class="Symbol">;</a> <a id="63605" class="Symbol">(</a><a id="63606" href="1Lab.Path.html#63460" class="Bound">j</a> <a id="63608" class="Symbol">=</a> <a id="63610" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a><a id="63612" class="Symbol">)</a> <a id="63614" class="Symbol">→</a> <a id="63616" href="1Lab.Path.html#63454" class="Bound">p</a> <a id="63618" class="Symbol">(</a><a id="63619" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="63621" href="1Lab.Path.html#63458" class="Bound">i</a> <a id="63623" href="1Lab.Path.html#2191" class="Primitive Operator">∧</a> <a id="63625" href="1Lab.Path.html#63475" class="Bound">k</a><a id="63626" class="Symbol">)})</a>
        <a id="63638" href="1Lab.Path.html#63451" class="Bound">x</a>

<a id="sym-∙-filler"></a><a id="63641" href="1Lab.Path.html#63641" data-type="x ≡ y → y ≡ z → I → I → I → A" class="Function">sym-∙-filler</a> <a id="63654" class="Symbol">:</a> <a id="63656" class="Symbol">∀</a> <a id="63658" class="Symbol">{</a><a id="63659" href="1Lab.Path.html#63659" class="Bound">ℓ</a><a id="63660" class="Symbol">}</a> <a id="63662" class="Symbol">{</a><a id="63663" href="1Lab.Path.html#63663" class="Bound">A</a> <a id="63665" class="Symbol">:</a> <a id="63667" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="63672" href="1Lab.Path.html#63659" class="Bound">ℓ</a><a id="63673" class="Symbol">}</a> <a id="63675" class="Symbol">{</a><a id="63676" href="1Lab.Path.html#63676" class="Bound">x</a> <a id="63678" href="1Lab.Path.html#63678" class="Bound">y</a> <a id="63680" href="1Lab.Path.html#63680" class="Bound">z</a> <a id="63682" class="Symbol">:</a> <a id="63684" href="1Lab.Path.html#63663" class="Bound">A</a><a id="63685" class="Symbol">}</a> <a id="63687" class="Symbol">(</a><a id="63688" href="1Lab.Path.html#63688" class="Bound">p</a> <a id="63690" class="Symbol">:</a> <a id="63692" href="1Lab.Path.html#63676" class="Bound">x</a> <a id="63694" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="63696" href="1Lab.Path.html#63678" class="Bound">y</a><a id="63697" class="Symbol">)</a> <a id="63699" class="Symbol">(</a><a id="63700" href="1Lab.Path.html#63700" class="Bound">q</a> <a id="63702" class="Symbol">:</a> <a id="63704" href="1Lab.Path.html#63678" class="Bound">y</a> <a id="63706" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="63708" href="1Lab.Path.html#63680" class="Bound">z</a><a id="63709" class="Symbol">)</a> <a id="63711" class="Symbol">→</a> <a id="63713" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a> <a id="63715" class="Symbol">→</a> <a id="63717" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a> <a id="63719" class="Symbol">→</a> <a id="63721" href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a> <a id="63723" class="Symbol">→</a> <a id="63725" href="1Lab.Path.html#63663" class="Bound">A</a>
<a id="63727" href="1Lab.Path.html#63641" data-type="x ≡ y → y ≡ z → I → I → I → A" class="Function">sym-∙-filler</a> <a id="63740" class="Symbol">{</a><a id="63741" class="Argument">A</a> <a id="63743" class="Symbol">=</a> <a id="63745" href="1Lab.Path.html#63745" class="Bound">A</a><a id="63746" class="Symbol">}</a> <a id="63748" class="Symbol">{</a><a id="63749" class="Argument">z</a> <a id="63751" class="Symbol">=</a> <a id="63753" href="1Lab.Path.html#63753" class="Bound">z</a><a id="63754" class="Symbol">}</a> <a id="63756" href="1Lab.Path.html#63756" class="Bound">p</a> <a id="63758" href="1Lab.Path.html#63758" class="Bound">q</a> <a id="63760" href="1Lab.Path.html#63760" class="Bound">i</a> <a id="63762" href="1Lab.Path.html#63762" class="Bound">j</a> <a id="63764" href="1Lab.Path.html#63764" class="Bound">k</a> <a id="63766" class="Symbol">=</a>
  <a id="63770" href="1Lab.Path.html#35493" data-type="(u : I → Partial φ A) (u0 : A [ φ ↦ u i0 ]) →
outS u0 ≡ hcomp u (outS u0)" class="Function">hfill</a> <a id="63776" class="Symbol">(λ</a> <a id="63779" href="1Lab.Path.html#63779" class="Bound">k</a> <a id="63781" class="Symbol">→</a> <a id="63783" class="Symbol">λ</a> <a id="63785" class="Symbol">{</a> <a id="63787" class="Symbol">(</a><a id="63788" href="1Lab.Path.html#63760" class="Bound">i</a> <a id="63790" class="Symbol">=</a> <a id="63792" href="Agda.Primitive.Cubical.html#150" class="InductiveConstructor">i0</a><a id="63794" class="Symbol">)</a> <a id="63796" class="Symbol">→</a> <a id="63798" href="1Lab.Path.html#63758" class="Bound">q</a> <a id="63800" class="Symbol">(</a><a id="63801" href="1Lab.Path.html#63779" class="Bound">k</a> <a id="63803" href="1Lab.Path.html#2226" class="Primitive Operator">∨</a> <a id="63805" href="1Lab.Path.html#63762" class="Bound">j</a><a id="63806" class="Symbol">)</a>
                 <a id="63825" class="Symbol">;</a> <a id="63827" class="Symbol">(</a><a id="63828" href="1Lab.Path.html#63760" class="Bound">i</a> <a id="63830" class="Symbol">=</a> <a id="63832" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a><a id="63834" class="Symbol">)</a> <a id="63836" class="Symbol">→</a> <a id="63838" href="1Lab.Path.html#63756" class="Bound">p</a> <a id="63840" class="Symbol">(</a><a id="63841" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="63843" href="1Lab.Path.html#63779" class="Bound">k</a> <a id="63845" href="1Lab.Path.html#2191" class="Primitive Operator">∧</a> <a id="63847" href="1Lab.Path.html#63762" class="Bound">j</a><a id="63848" class="Symbol">)</a> <a id="63850" class="Symbol">})</a>
       <a id="63860" class="Symbol">(</a><a id="63861" href="1Lab.Path.html#2069" class="Postulate">inS</a> <a id="63865" class="Symbol">(</a><a id="63866" href="1Lab.Path.html#63321" data-type="(p : x ≡ y) (q : x ≡ z) → Square q p (sym q) (sym p)" class="Function">invert-sides</a> <a id="63879" href="1Lab.Path.html#63758" class="Bound">q</a> <a id="63881" class="Symbol">(</a><a id="63882" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="63886" href="1Lab.Path.html#63756" class="Bound">p</a><a id="63887" class="Symbol">)</a> <a id="63889" href="1Lab.Path.html#63760" class="Bound">i</a> <a id="63891" href="1Lab.Path.html#63762" class="Bound">j</a><a id="63892" class="Symbol">))</a>
       <a id="63902" href="1Lab.Path.html#63764" class="Bound">k</a>

<a id="sym-∙"></a><a id="63905" href="1Lab.Path.html#63905" data-type="(p : x ≡ y) (q : y ≡ z) → sym (p ∙ q) ≡ sym q ∙ sym p" class="Function">sym-∙</a> <a id="63911" class="Symbol">:</a> <a id="63913" class="Symbol">∀</a> <a id="63915" class="Symbol">{</a><a id="63916" href="1Lab.Path.html#63916" class="Bound">ℓ</a><a id="63917" class="Symbol">}</a> <a id="63919" class="Symbol">{</a><a id="63920" href="1Lab.Path.html#63920" class="Bound">A</a> <a id="63922" class="Symbol">:</a> <a id="63924" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="63929" href="1Lab.Path.html#63916" class="Bound">ℓ</a><a id="63930" class="Symbol">}</a> <a id="63932" class="Symbol">{</a><a id="63933" href="1Lab.Path.html#63933" class="Bound">x</a> <a id="63935" href="1Lab.Path.html#63935" class="Bound">y</a> <a id="63937" href="1Lab.Path.html#63937" class="Bound">z</a> <a id="63939" class="Symbol">:</a> <a id="63941" href="1Lab.Path.html#63920" class="Bound">A</a><a id="63942" class="Symbol">}</a> <a id="63944" class="Symbol">(</a><a id="63945" href="1Lab.Path.html#63945" class="Bound">p</a> <a id="63947" class="Symbol">:</a> <a id="63949" href="1Lab.Path.html#63933" class="Bound">x</a> <a id="63951" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="63953" href="1Lab.Path.html#63935" class="Bound">y</a><a id="63954" class="Symbol">)</a> <a id="63956" class="Symbol">(</a><a id="63957" href="1Lab.Path.html#63957" class="Bound">q</a> <a id="63959" class="Symbol">:</a> <a id="63961" href="1Lab.Path.html#63935" class="Bound">y</a> <a id="63963" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="63965" href="1Lab.Path.html#63937" class="Bound">z</a><a id="63966" class="Symbol">)</a> <a id="63968" class="Symbol">→</a> <a id="63970" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="63974" class="Symbol">(</a><a id="63975" href="1Lab.Path.html#63945" class="Bound">p</a> <a id="63977" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="63979" href="1Lab.Path.html#63957" class="Bound">q</a><a id="63980" class="Symbol">)</a> <a id="63982" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="63984" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="63988" href="1Lab.Path.html#63957" class="Bound">q</a> <a id="63990" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="63992" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="63996" href="1Lab.Path.html#63945" class="Bound">p</a>
<a id="63998" href="1Lab.Path.html#63905" data-type="(p : x ≡ y) (q : y ≡ z) → sym (p ∙ q) ≡ sym q ∙ sym p" class="Function">sym-∙</a> <a id="64004" href="1Lab.Path.html#64004" class="Bound">p</a> <a id="64006" href="1Lab.Path.html#64006" class="Bound">q</a> <a id="64008" href="1Lab.Path.html#64008" class="Bound">i</a> <a id="64010" href="1Lab.Path.html#64010" class="Bound">j</a> <a id="64012" class="Symbol">=</a> <a id="64014" href="1Lab.Path.html#63641" data-type="x ≡ y → y ≡ z → I → I → I → A" class="Function">sym-∙-filler</a> <a id="64027" href="1Lab.Path.html#64004" class="Bound">p</a> <a id="64029" href="1Lab.Path.html#64006" class="Bound">q</a> <a id="64031" href="1Lab.Path.html#64010" class="Bound">j</a> <a id="64033" href="1Lab.Path.html#64008" class="Bound">i</a> <a id="64035" href="Agda.Primitive.Cubical.html#178" class="InductiveConstructor">i1</a>

</pre>-->
<section class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>The distinction between these two is
elaborated on in the <a href="1Lab.intro.html">Intro to HoTT</a> page.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>For the semantically inclined, these
correspond to face inclusions (including the inclusions of endpoints
into a line) being monomorphisms, and thus <em>cofibrations</em> in the
model structure on cubical sets.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>Since
<span class="Agda"><a href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a></span>
is not Kan (that is — it does not have a <a href="#composition"><em>composition</em></a> structure), it is not an
inhabitant of the “fibrant universe”
<span class="Agda"><a href="1Lab.Type.html#391" class="Primitive">Type</a></span>.
Instead it lives in <code>SSet</code>, or, in Agda 2.6.3, its own
universe – <code>IUniv</code>.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>I (Amélia) wrote <a href="https://amelia.how/posts/cubical-sets.html">a blog post</a>
explaining the semantics of them in a lot of depth.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p><span class="Agda"><a href="Agda.Builtin.Cubical.Sub.html#198" class="Postulate">Sub</a></span>
lives in the universe <code>SSetω</code>, which we do not have a binding
for, so we can not name the type of
<span class="Agda"><a href="1Lab.Path.html#28586" class="Function Operator">_[_↦_]</a></span>.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p>Although it is not proven to be a
contradiction in <em>this</em> module, see <a href="Data.Bool.html">Data.Bool</a> for that construction.<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7" role="doc-endnote"><p>This element has type
<code>(i : I) → I → Partial (~ i ∨ i) A</code> rather than
<code>(i : I) → Partial (~ i ∨ i) (I → A)</code> because of a universe
restriction in Agda: The second argument to
<span class="Agda"><a href="Agda.Primitive.Cubical.html#1072" class="Primitive">Partial</a></span>
must be a
<span class="Agda"><a href="1Lab.Type.html#391" class="Primitive">Type</a></span>,
but
<span class="Agda"><a href="Agda.Primitive.Cubical.html#108" class="Datatype">I</a></span>
is not a
<span class="Agda"><a href="1Lab.Type.html#391" class="Primitive">Type</a></span>.<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8" role="doc-endnote"><p>In Agda 2.6.2, function types
<code>I → A</code> are <em>not</em> fibrant, even though they correspond
to paths with “unmarked” endpoints. In Agda 2.6.3 (in development at the
time of writing), <code>I</code> was moved to its own universe,
<code>IUniv</code>, with a typing rule for functions saying that
<code>A → B</code> is fibrant whenever <code>B : Type</code> and
<code>A : Type</code> <em>or</em> <code>A : IUniv</code> - i.e. function
types <code>I → A</code> were made fibrant whenever <code>A</code> is.<a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
  </article>
</div>
</main>
</body>
</html>
