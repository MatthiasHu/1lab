<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="keywords" content="Agda,categories,topos" />

  <title>1Lab.Equiv - 1Lab</title>

  <link rel="stylesheet" href="/css/default.css" />
  <link rel="stylesheet" href="/css/katex.min.css" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="1Lab.Equiv - 1Lab" />
  <meta name="twitter:image" content="https://1lab.dev/static/cube-128x.png" />

  <meta name="og:title" content="1Lab.Equiv - 1Lab" />
  <meta name="og:image" content="https://1lab.dev/static/cube-128x.png" />
  <meta name="og:site-name" content="1Lab" />
  <meta name="og:type" content="website" />

    <meta name="og:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="twitter:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  
  <script defer src="/main.js"></script>

  <noscript>
    <style>
      body span.reasoning-step .as-written {
        display: inline;
      }

      body span.reasoning-step .alternate {
        display: none;
      }
    </style>
  </noscript>

  <!-- Google font embeds -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;0,800;1,400;1,500;1,600;1,700;1,800&amp;family=Inria+Sans:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&amp;display=swap" rel="stylesheet">
</head>

<body class="text-page">
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <!-- Table of contents (only if the page has a table of contents) -->
    <aside id="toc">
    <div id="toc-container" style="min-width: 10em; font-size: 15pt;">
      <!-- Title for the page -->
      <h3 class="Agda" style="margin-top: 0; margin-bottom: 0; white-space: pre;">
                <a class="Module">1Lab.Equiv</a>
              </h3>

      <!-- Cube logo -->
      <a id="logo" href="/">
        <img alt="1Lab" src="/static/cube-72x.png" style="display: block; margin-bottom: 1em; margin: auto;" width="32px" height="32px" />
      </a>

      <!-- Actual table of contents (separated from the rest by
      horizontal rules) -->
      <hr />
      <ul>
      <li><a href="#equivalences"><a href="#equivalences" class="header-link">Equivalences<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#is-equiv-is-propositional"><a href="#is-equiv-is-propositional" class="header-link">is-equiv
      is
      propositional<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      <li><a href="#isomorphisms-from-equivalences"><a href="#isomorphisms-from-equivalences" class="header-link">Isomorphisms
      from
      equivalences<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#equivalences-from-isomorphisms"><a href="#equivalences-from-isomorphisms" class="header-link">Equivalences
      from
      isomorphisms<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#equivalence-reasoning"><a href="#equivalence-reasoning" class="header-link">Equivalence
      Reasoning<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#propositional-extensionality"><a href="#propositional-extensionality" class="header-link">Propositional
      Extensionality<span class="header-link-emoji">🔗</span></a></a></li>
      </ul>
      <hr />

      <!-- Sidebar controls -->
      <div style="display: flex; gap: 0.25em; flex-flow: row wrap;">
        <!-- Sidebar equations control -->
        <span class="equations" style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-eqns" type="checkbox" class="equations" id="sidebar-eqns">
          <label for="sidebar-eqns">Equations</label>
        </span>

        <!-- Sidebar fonts control -->
        <span style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-font" type="checkbox" id="toggle-fonts">
          <label for="toggle-fonts">Serif Font</label>
        </span>

        <!-- Sidebar footnotes control -->
        <span class="inline-footnotes" style="display: none; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-fns" type="checkbox" class="inline-footnotes" id="sidebar-fns">
          <label for="sidebar-fns">Inline Footnotes</label>
        </span>
      </div>

      <hr />

      <!-- Navbar navigation (lol) -->
      <div id="return" style="white-space: nowrap;">
        <div class="search-form search-form-proxy" role="form">
          <input id="search-box-proxy" type_="text" placeholder="Search..." autocomplete="off" tabindex="0"></input>
        </div>

              <a href="/">back to index</a> <br />
              <a href="all-pages.html">view all pages</a> <br />
        <a href="https://github.com/plt-amy/cubical-1lab/blob/311c6b34788c5c63f0dd125a6cdbb9599f4f159f/src/1Lab/Equiv.lagda.md">link to source</a> <br />
                <hr /> <div class="author-list">Written by Amélia Liao</div> <br />
              </div>
    </div>
  </aside>
  
  <article>
    <!-- Article navigation (narrow screens only) -->
    <div class="narrow-only" id="article-nav">
      <!-- Index return anchor (only if the page is not the index) -->
            <div id="return">
        <a href="/">back to index</a>
      </div>
      
      <!-- Navbar equations control -->
      <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-eqns" type="checkbox" class="equations" id="navbar-eqns">
        <label for="navbar-eqns">Equations</label>
      </span>

      <!-- Navbar footnotes control -->
      <span class="inline-footnotes" style="display: none; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-fns" type="checkbox" class="inline-footnotes" id="navbar-fns">
        <label for="navbar-fns">Inline Footnotes</label>
      </span>
    </div>

<pre class="Agda"><a id="9" class="Keyword">open</a> <a id="14" class="Keyword">import</a> <a id="21" href="1Lab.HLevel.html" class="Module">1Lab.HLevel</a>
<a id="33" class="Keyword">open</a> <a id="38" class="Keyword">import</a> <a id="45" href="1Lab.Path.html" class="Module">1Lab.Path</a>
<a id="55" class="Keyword">open</a> <a id="60" class="Keyword">import</a> <a id="67" href="1Lab.Type.html" class="Module">1Lab.Type</a>

<a id="78" class="Keyword">open</a> <a id="83" href="1Lab.HLevel.html#1328" data-type="(A : Type ℓ) → Type ℓ" class="Module">is-contr</a>

<a id="93" class="Keyword">module</a> <a id="100" href="1Lab.Equiv.html" class="Module">1Lab.Equiv</a> <a id="111" class="Keyword">where</a>
</pre>
<h1 id="equivalences"><a href="#equivalences" class="header-link">Equivalences<span class="header-link-emoji">🔗</span></a></h1>
<p>The big idea of homotopy type theory is that isomorphic types can be
identified: the <a href="1Lab.Univalence.html">univalence axiom</a>.
However, the notion of
<span class="Agda"><a href="1Lab.Equiv.html#6026" class="Record">isomorphism</a></span>,
is, in a sense, not “coherent” enough to be used in the definition. For
that, we need a coherent definition of <em>equivalence</em>, where
“being an equivalence” is <a href="1Lab.HLevel.html#2597">a
proposition</a>.</p>
<p>To be more specific, what we need for a notion of equivalence
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mo>−</mo><mi mathvariant="normal">e</mi><mi mathvariant="normal">q</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">v</mi></mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\id{is-equiv}(f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">is</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathrm" style="margin-right:0.01389em;">equiv</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span>
to be “coherent” is:</p>
<ul>
<li><p>Being an
<span class="Agda"><a href="1Lab.Equiv.html#6026" class="Record">isomorphism</a></span>
implies being an
<span class="Agda"><a href="1Lab.Equiv.html#2286" class="Record">equivalence</a></span>
(<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mo>−</mo><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">o</mi></mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>→</mo><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mo>−</mo><mi mathvariant="normal">e</mi><mi mathvariant="normal">q</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">v</mi></mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\id{is-iso}(f) \to \id{is-equiv}(f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">is</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathrm">iso</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">is</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathrm" style="margin-right:0.01389em;">equiv</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span>)</span></p></li>
<li><p>Being an equivalence implies being an isomorphism
(<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mo>−</mo><mi mathvariant="normal">e</mi><mi mathvariant="normal">q</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">v</mi></mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>→</mo><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mo>−</mo><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">o</mi></mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\id{is-equiv}(f) \to \id{is-iso}(f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">is</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathrm" style="margin-right:0.01389em;">equiv</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">is</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathrm">iso</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span>);</span>
Taken together with the first point we may summarise: “Being an
equivalence and being an isomorphism are logically equivalent.”</p></li>
<li><p>Most importantly, being an equivalence <em>must</em> be a
proposition.</p></li>
</ul>
<p>The notion we adopt is due to Voevodsky: An equivalence is one that
has
<span class="Agda"><a href="1Lab.HLevel.html#1328" class="Module">contractible</a></span>
<span class="Agda"><a href="1Lab.Equiv.html#1873" class="Function">fibres</a></span>.
Other definitions are possible (e.g.: <a href="1Lab.Equiv.Biinv.html">bi-inverible maps</a>) — but contractible
fibres are “privileged” in Cubical Agda because for <a href="1Lab.Univalence.html#Glue">glueing</a> to work, we need a proof
that
<span class="Agda"><a href="1Lab.Equiv.html#3671" class="Function">equivalences have contractible fibres</a></span>
anyway.</p>
<pre class="Agda"><a id="1547" class="Keyword">private</a>
  <a id="1557" class="Keyword">variable</a>
    <a id="1570" href="1Lab.Equiv.html#1570" class="Generalizable">ℓ₁</a> <a id="1573" href="1Lab.Equiv.html#1573" class="Generalizable">ℓ₂</a> <a id="1576" class="Symbol">:</a> <a id="1578" href="Agda.Primitive.html#582" data-type="Type" class="Postulate">Level</a>
    <a id="1588" href="1Lab.Equiv.html#1588" class="Generalizable">A</a> <a id="1590" href="1Lab.Equiv.html#1590" class="Generalizable">B</a> <a id="1592" class="Symbol">:</a> <a id="1594" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="1599" href="1Lab.Equiv.html#1570" class="Generalizable">ℓ₁</a>
</pre>
<p>A <em>homotopy fibre</em>, <em>fibre</em> or <em>preimage</em> of a
function <code>f</code> at a point <code>y : B</code> is the collection
of all elements of <code>A</code> that <code>f</code> maps to
<code>y</code>. Since many choices of name are possible, we settle on
the one that is shortest and most aesthetic:
<span class="Agda"><a href="1Lab.Equiv.html#1873" class="Function">fibre</a></span>.</p>
<pre class="Agda"><a id="fibre"></a><a id="1873" href="1Lab.Equiv.html#1873" data-type="(A → B₁) → B₁ → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Function">fibre</a> <a id="1879" class="Symbol">:</a> <a id="1881" class="Symbol">(</a><a id="1882" href="1Lab.Equiv.html#1588" class="Generalizable">A</a> <a id="1884" class="Symbol">→</a> <a id="1886" href="1Lab.Equiv.html#1590" class="Generalizable">B</a><a id="1887" class="Symbol">)</a> <a id="1889" class="Symbol">→</a> <a id="1891" href="1Lab.Equiv.html#1590" class="Generalizable">B</a> <a id="1893" class="Symbol">→</a> <a id="1895" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="1900" class="Symbol">_</a>
<a id="1902" href="1Lab.Equiv.html#1873" data-type="(A → B₁) → B₁ → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Function">fibre</a> <a id="1908" href="1Lab.Equiv.html#1908" class="Bound">f</a> <a id="1910" href="1Lab.Equiv.html#1910" class="Bound">y</a> <a id="1912" class="Symbol">=</a> <a id="1914" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">Σ</a> <a id="1916" class="Symbol">λ</a> <a id="1918" href="1Lab.Equiv.html#1918" class="Bound">x</a> <a id="1920" class="Symbol">→</a> <a id="1922" href="1Lab.Equiv.html#1908" class="Bound">f</a> <a id="1924" href="1Lab.Equiv.html#1918" class="Bound">x</a> <a id="1926" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="1928" href="1Lab.Equiv.html#1910" class="Bound">y</a>
</pre>
<p>A function <code>f</code> is an equivalence if every one of its
fibres is <a href="1Lab.HLevel.html#1328">contractible</a> - that
is, for any element <code>y</code> in the range, there is exactly one
element in the domain which <code>f</code> maps to <code>y</code>. Using
set-theoretic language, <code>f</code> is an equivalence if the preimage
of every element of the codomain is a singleton.</p>
<pre class="Agda"><a id="2279" class="Keyword">record</a> <a id="is-equiv"></a><a id="2286" href="1Lab.Equiv.html#2286" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-equiv</a> <a id="2295" class="Symbol">(</a><a id="2296" href="1Lab.Equiv.html#2296" class="Bound">f</a> <a id="2298" class="Symbol">:</a> <a id="2300" href="1Lab.Equiv.html#1588" class="Generalizable">A</a> <a id="2302" class="Symbol">→</a> <a id="2304" href="1Lab.Equiv.html#1590" class="Generalizable">B</a><a id="2305" class="Symbol">)</a> <a id="2307" class="Symbol">:</a> <a id="2309" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="2314" class="Symbol">(</a><a id="2315" href="1Lab.Type.html#921" data-type="Type ℓ → Level" class="Function">level-of</a> <a id="2324" href="1Lab.Equiv.html#2300" class="Bound">A</a> <a id="2326" href="Agda.Primitive.html#795" data-type="Level → Level → Level" class="Primitive Operator">⊔</a> <a id="2328" href="1Lab.Type.html#921" data-type="Type ℓ → Level" class="Function">level-of</a> <a id="2337" href="1Lab.Equiv.html#2304" class="Bound">B</a><a id="2338" class="Symbol">)</a> <a id="2340" class="Keyword">where</a>
  <a id="2348" class="Keyword">no-eta-equality</a>
  <a id="2366" class="Keyword">field</a>
    <a id="is-equiv.is-eqv"></a><a id="2376" href="1Lab.Equiv.html#2376" data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" class="Field">is-eqv</a> <a id="2383" class="Symbol">:</a> <a id="2385" class="Symbol">(</a><a id="2386" href="1Lab.Equiv.html#2386" class="Bound">y</a> <a id="2388" class="Symbol">:</a> <a id="2390" href="1Lab.Equiv.html#2304" class="Bound">B</a><a id="2391" class="Symbol">)</a> <a id="2393" class="Symbol">→</a> <a id="2395" href="1Lab.HLevel.html#1328" data-type="(A : Type ℓ) → Type ℓ" class="Record">is-contr</a> <a id="2404" class="Symbol">(</a><a id="2405" href="1Lab.Equiv.html#1873" data-type="(A → B₁) → B₁ → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Function">fibre</a> <a id="2411" href="1Lab.Equiv.html#2296" class="Bound">f</a> <a id="2413" href="1Lab.Equiv.html#2386" class="Bound">y</a><a id="2414" class="Symbol">)</a>

<a id="2417" class="Keyword">open</a> <a id="2422" href="1Lab.Equiv.html#2286" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Module">is-equiv</a> <a id="2431" class="Keyword">public</a>

<a id="_≃_"></a><a id="2439" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">_≃_</a> <a id="2443" class="Symbol">:</a> <a id="2445" class="Symbol">∀</a> <a id="2447" class="Symbol">{</a><a id="2448" href="1Lab.Equiv.html#2448" class="Bound">ℓ₁</a> <a id="2451" href="1Lab.Equiv.html#2451" class="Bound">ℓ₂</a><a id="2453" class="Symbol">}</a> <a id="2455" class="Symbol">→</a> <a id="2457" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="2462" href="1Lab.Equiv.html#2448" class="Bound">ℓ₁</a> <a id="2465" class="Symbol">→</a> <a id="2467" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="2472" href="1Lab.Equiv.html#2451" class="Bound">ℓ₂</a> <a id="2475" class="Symbol">→</a> <a id="2477" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="2482" class="Symbol">_</a>
<a id="2484" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">_≃_</a> <a id="2488" href="1Lab.Equiv.html#2488" class="Bound">A</a> <a id="2490" href="1Lab.Equiv.html#2490" class="Bound">B</a> <a id="2492" class="Symbol">=</a> <a id="2494" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">Σ</a> <a id="2496" class="Symbol">(</a><a id="2497" href="1Lab.Equiv.html#2286" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-equiv</a> <a id="2506" class="Symbol">{</a><a id="2507" class="Argument">A</a> <a id="2509" class="Symbol">=</a> <a id="2511" href="1Lab.Equiv.html#2488" class="Bound">A</a><a id="2512" class="Symbol">}</a> <a id="2514" class="Symbol">{</a><a id="2515" class="Argument">B</a> <a id="2517" class="Symbol">=</a> <a id="2519" href="1Lab.Equiv.html#2490" class="Bound">B</a><a id="2520" class="Symbol">})</a>

<a id="id-equiv"></a><a id="2524" href="1Lab.Equiv.html#2524" data-type="is-equiv (λ x → x)" class="Function">id-equiv</a> <a id="2533" class="Symbol">:</a> <a id="2535" href="1Lab.Equiv.html#2286" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-equiv</a> <a id="2544" class="Symbol">{</a><a id="2545" class="Argument">A</a> <a id="2547" class="Symbol">=</a> <a id="2549" href="1Lab.Equiv.html#1588" class="Generalizable">A</a><a id="2550" class="Symbol">}</a> <a id="2552" class="Symbol">(λ</a> <a id="2555" href="1Lab.Equiv.html#2555" class="Bound">x</a> <a id="2557" class="Symbol">→</a> <a id="2559" href="1Lab.Equiv.html#2555" class="Bound">x</a><a id="2560" class="Symbol">)</a>
<a id="2562" href="1Lab.Equiv.html#2524" data-type="is-equiv (λ x → x)" class="Function">id-equiv</a> <a id="2571" class="Symbol">.</a><a id="2572" href="1Lab.Equiv.html#2376" data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" class="Field">is-eqv</a> <a id="2579" href="1Lab.Equiv.html#2579" class="Bound">y</a> <a id="2581" class="Symbol">=</a>
  <a id="2585" href="1Lab.HLevel.html#1383" data-type="(centre₁ : A) (paths₁ : (x : A) → centre₁ ≡ x) → is-contr A" class="InductiveConstructor">contr</a> <a id="2591" class="Symbol">(</a><a id="2592" href="1Lab.Equiv.html#2579" class="Bound">y</a> <a id="2594" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="2596" class="Symbol">λ</a> <a id="2598" href="1Lab.Equiv.html#2598" class="Bound">i</a> <a id="2600" class="Symbol">→</a> <a id="2602" href="1Lab.Equiv.html#2579" class="Bound">y</a><a id="2603" class="Symbol">)</a>
    <a id="2609" class="Symbol">λ</a> <a id="2611" class="Symbol">{</a> <a id="2613" class="Symbol">(</a><a id="2614" href="1Lab.Equiv.html#2614" class="Bound">y&#39;</a> <a id="2617" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="2619" href="1Lab.Equiv.html#2619" class="Bound">p</a><a id="2620" class="Symbol">)</a> <a id="2622" href="1Lab.Equiv.html#2622" class="Bound">i</a> <a id="2624" class="Symbol">→</a> <a id="2626" href="1Lab.Equiv.html#2619" class="Bound">p</a> <a id="2628" class="Symbol">(</a><a id="2629" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="2631" href="1Lab.Equiv.html#2622" class="Bound">i</a><a id="2632" class="Symbol">)</a> <a id="2634" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="2636" class="Symbol">λ</a> <a id="2638" href="1Lab.Equiv.html#2638" class="Bound">j</a> <a id="2640" class="Symbol">→</a> <a id="2642" href="1Lab.Equiv.html#2619" class="Bound">p</a> <a id="2644" class="Symbol">(</a><a id="2645" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="2647" href="1Lab.Equiv.html#2622" class="Bound">i</a> <a id="2649" href="1Lab.Path.html#2226" class="Primitive Operator">∨</a> <a id="2651" href="1Lab.Equiv.html#2638" class="Bound">j</a><a id="2652" class="Symbol">)</a> <a id="2654" class="Symbol">}</a>
</pre>
<!--
<pre class="Agda"><a id="2670" class="Comment">-- This helper is for functions f, g that cancel eachother, up to</a>
<a id="2736" class="Comment">-- definitional equality, without any case analysis on the argument:</a>

<a id="strict-fibres"></a><a id="2806" href="1Lab.Equiv.html#2806" data-type="(g : B₁ → A) (b : B₁) →
Σ
(λ t →
   (t&#39; : fibre f b) →
   Path (fibre f (f (g b))) t
   (g (f (t&#39; .fst)) , ap (f ⊙ g) (t&#39; .snd)))" class="Function">strict-fibres</a> <a id="2820" class="Symbol">:</a> <a id="2822" class="Symbol">∀</a> <a id="2824" class="Symbol">{</a><a id="2825" href="1Lab.Equiv.html#2825" class="Bound">ℓ</a> <a id="2827" href="1Lab.Equiv.html#2827" class="Bound">ℓ&#39;</a><a id="2829" class="Symbol">}</a> <a id="2831" class="Symbol">{</a><a id="2832" href="1Lab.Equiv.html#2832" class="Bound">A</a> <a id="2834" class="Symbol">:</a> <a id="2836" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="2841" href="1Lab.Equiv.html#2825" class="Bound">ℓ</a><a id="2842" class="Symbol">}</a> <a id="2844" class="Symbol">{</a><a id="2845" href="1Lab.Equiv.html#2845" class="Bound">B</a> <a id="2847" class="Symbol">:</a> <a id="2849" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="2854" href="1Lab.Equiv.html#2827" class="Bound">ℓ&#39;</a><a id="2856" class="Symbol">}</a> <a id="2858" class="Symbol">{</a><a id="2859" href="1Lab.Equiv.html#2859" class="Bound">f</a> <a id="2861" class="Symbol">:</a> <a id="2863" href="1Lab.Equiv.html#2832" class="Bound">A</a> <a id="2865" class="Symbol">→</a> <a id="2867" href="1Lab.Equiv.html#2845" class="Bound">B</a><a id="2868" class="Symbol">}</a> <a id="2870" class="Symbol">(</a><a id="2871" href="1Lab.Equiv.html#2871" class="Bound">g</a> <a id="2873" class="Symbol">:</a> <a id="2875" href="1Lab.Equiv.html#2845" class="Bound">B</a> <a id="2877" class="Symbol">→</a> <a id="2879" href="1Lab.Equiv.html#2832" class="Bound">A</a><a id="2880" class="Symbol">)</a> <a id="2882" class="Symbol">(</a><a id="2883" href="1Lab.Equiv.html#2883" class="Bound">b</a> <a id="2885" class="Symbol">:</a> <a id="2887" href="1Lab.Equiv.html#2845" class="Bound">B</a><a id="2888" class="Symbol">)</a>
  <a id="2892" class="Symbol">→</a> <a id="2894" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">Σ[</a> <a id="2897" href="1Lab.Equiv.html#2897" class="Bound">t</a> <a id="2899" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">∈</a> <a id="2901" href="1Lab.Equiv.html#1873" data-type="(A → B₁) → B₁ → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Function">fibre</a> <a id="2907" href="1Lab.Equiv.html#2859" class="Bound">f</a> <a id="2909" class="Symbol">(</a><a id="2910" href="1Lab.Equiv.html#2859" class="Bound">f</a> <a id="2912" class="Symbol">(</a><a id="2913" href="1Lab.Equiv.html#2871" class="Bound">g</a> <a id="2915" href="1Lab.Equiv.html#2883" class="Bound">b</a><a id="2916" class="Symbol">))</a> <a id="2919" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">]</a>
    <a id="2925" class="Symbol">((</a><a id="2927" href="1Lab.Equiv.html#2927" class="Bound">t&#39;</a> <a id="2930" class="Symbol">:</a> <a id="2932" href="1Lab.Equiv.html#1873" data-type="(A → B₁) → B₁ → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Function">fibre</a> <a id="2938" href="1Lab.Equiv.html#2859" class="Bound">f</a> <a id="2940" href="1Lab.Equiv.html#2883" class="Bound">b</a><a id="2941" class="Symbol">)</a> <a id="2943" class="Symbol">→</a> <a id="2945" href="1Lab.Path.html#2466" data-type="(A : Type ℓ) → A → A → Type ℓ" class="Function">Path</a> <a id="2950" class="Symbol">(</a><a id="2951" href="1Lab.Equiv.html#1873" data-type="(A → B₁) → B₁ → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Function">fibre</a> <a id="2957" href="1Lab.Equiv.html#2859" class="Bound">f</a> <a id="2959" class="Symbol">(</a><a id="2960" href="1Lab.Equiv.html#2859" class="Bound">f</a> <a id="2962" class="Symbol">(</a><a id="2963" href="1Lab.Equiv.html#2871" class="Bound">g</a> <a id="2965" href="1Lab.Equiv.html#2883" class="Bound">b</a><a id="2966" class="Symbol">)))</a> <a id="2970" href="1Lab.Equiv.html#2897" class="Bound">t</a>
                          <a id="2998" class="Symbol">(</a><a id="2999" href="1Lab.Equiv.html#2871" class="Bound">g</a> <a id="3001" class="Symbol">(</a><a id="3002" href="1Lab.Equiv.html#2859" class="Bound">f</a> <a id="3004" class="Symbol">(</a><a id="3005" href="1Lab.Equiv.html#2927" class="Bound">t&#39;</a> <a id="3008" class="Symbol">.</a><a id="3009" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a><a id="3012" class="Symbol">))</a> <a id="3015" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="3017" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="3020" class="Symbol">(</a><a id="3021" href="1Lab.Equiv.html#2859" class="Bound">f</a> <a id="3023" href="1Lab.Type.html#2227" data-type="((y : B₁ x) → C x y) → (f : (x : A) → B₁ x) (x : A) → C x (f x)" class="Function Operator">∘</a> <a id="3025" href="1Lab.Equiv.html#2871" class="Bound">g</a><a id="3026" class="Symbol">)</a> <a id="3028" class="Symbol">(</a><a id="3029" href="1Lab.Equiv.html#2927" class="Bound">t&#39;</a> <a id="3032" class="Symbol">.</a><a id="3033" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a><a id="3036" class="Symbol">)))</a>
<a id="3040" href="1Lab.Equiv.html#2806" data-type="(g : B₁ → A) (b : B₁) →
Σ
(λ t →
   (t&#39; : fibre f b) →
   Path (fibre f (f (g b))) t
   (g (f (t&#39; .fst)) , ap (f ⊙ g) (t&#39; .snd)))" class="Function">strict-fibres</a> <a id="3054" class="Symbol">{</a><a id="3055" class="Argument">f</a> <a id="3057" class="Symbol">=</a> <a id="3059" href="1Lab.Equiv.html#3059" class="Bound">f</a><a id="3060" class="Symbol">}</a> <a id="3062" href="1Lab.Equiv.html#3062" class="Bound">g</a> <a id="3064" href="1Lab.Equiv.html#3064" class="Bound">b</a> <a id="3066" class="Symbol">.</a><a id="3067" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="3071" class="Symbol">=</a> <a id="3073" class="Symbol">(</a><a id="3074" href="1Lab.Equiv.html#3062" class="Bound">g</a> <a id="3076" href="1Lab.Equiv.html#3064" class="Bound">b</a> <a id="3078" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="3080" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a><a id="3084" class="Symbol">)</a>
<a id="3086" href="1Lab.Equiv.html#2806" data-type="(g : B₁ → A) (b : B₁) →
Σ
(λ t →
   (t&#39; : fibre f b) →
   Path (fibre f (f (g b))) t
   (g (f (t&#39; .fst)) , ap (f ⊙ g) (t&#39; .snd)))" class="Function">strict-fibres</a> <a id="3100" class="Symbol">{</a><a id="3101" class="Argument">f</a> <a id="3103" class="Symbol">=</a> <a id="3105" href="1Lab.Equiv.html#3105" class="Bound">f</a><a id="3106" class="Symbol">}</a> <a id="3108" href="1Lab.Equiv.html#3108" class="Bound">g</a> <a id="3110" href="1Lab.Equiv.html#3110" class="Bound">b</a> <a id="3112" class="Symbol">.</a><a id="3113" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="3117" class="Symbol">(</a><a id="3118" href="1Lab.Equiv.html#3118" class="Bound">a</a> <a id="3120" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="3122" href="1Lab.Equiv.html#3122" class="Bound">p</a><a id="3123" class="Symbol">)</a> <a id="3125" href="1Lab.Equiv.html#3125" class="Bound">i</a> <a id="3127" class="Symbol">=</a> <a id="3129" class="Symbol">(</a><a id="3130" href="1Lab.Equiv.html#3108" class="Bound">g</a> <a id="3132" class="Symbol">(</a><a id="3133" href="1Lab.Equiv.html#3122" class="Bound">p</a> <a id="3135" class="Symbol">(</a><a id="3136" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="3138" href="1Lab.Equiv.html#3125" class="Bound">i</a><a id="3139" class="Symbol">))</a> <a id="3142" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="3144" class="Symbol">λ</a> <a id="3146" href="1Lab.Equiv.html#3146" class="Bound">j</a> <a id="3148" class="Symbol">→</a> <a id="3150" href="1Lab.Equiv.html#3105" class="Bound">f</a> <a id="3152" class="Symbol">(</a><a id="3153" href="1Lab.Equiv.html#3108" class="Bound">g</a> <a id="3155" class="Symbol">(</a><a id="3156" href="1Lab.Equiv.html#3122" class="Bound">p</a> <a id="3158" class="Symbol">(</a><a id="3159" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="3161" href="1Lab.Equiv.html#3125" class="Bound">i</a> <a id="3163" href="1Lab.Path.html#2226" class="Primitive Operator">∨</a> <a id="3165" href="1Lab.Equiv.html#3146" class="Bound">j</a><a id="3166" class="Symbol">))))</a>

<a id="3172" class="Comment">-- This is more efficient than using Iso→Equiv. When f (g x) is definitionally x,</a>
<a id="3254" class="Comment">-- the type reduces to essentially is-contr (fibre f b).</a>
</pre>-->
<p>For Cubical Agda, the type of equivalences is distinguished, so we
have to make a small wrapper to match the interface Agda expects. This
is the geometric definition of contractibility, in terms of <a href="1Lab.Path.html#extensibility">partial elements</a> and
extensibility.</p>
<pre class="Agda"><a id="3615" class="Symbol">{-#</a> <a id="3619" class="Keyword">BUILTIN</a> <a id="3627" class="Keyword">EQUIV</a> <a id="3633" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">_≃_</a> <a id="3637" class="Symbol">#-}</a>
<a id="3641" class="Symbol">{-#</a> <a id="3645" class="Keyword">BUILTIN</a> <a id="3653" class="Keyword">EQUIVFUN</a> <a id="3662" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="3666" class="Symbol">#-}</a>

<a id="is-eqv&#39;"></a><a id="3671" href="1Lab.Equiv.html#3671" data-type="(A : Type a) (B₁ : Type b) (w : A ≃ B₁) (a : B₁) (ψ : I) →
Partial ψ (fibre (w .fst) a) → fibre (w .fst) a" class="Function">is-eqv&#39;</a> <a id="3679" class="Symbol">:</a> <a id="3681" class="Symbol">∀</a> <a id="3683" class="Symbol">{</a><a id="3684" href="1Lab.Equiv.html#3684" class="Bound">a</a> <a id="3686" href="1Lab.Equiv.html#3686" class="Bound">b</a><a id="3687" class="Symbol">}</a> <a id="3689" class="Symbol">(</a><a id="3690" href="1Lab.Equiv.html#3690" class="Bound">A</a> <a id="3692" class="Symbol">:</a> <a id="3694" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="3699" href="1Lab.Equiv.html#3684" class="Bound">a</a><a id="3700" class="Symbol">)</a> <a id="3702" class="Symbol">(</a><a id="3703" href="1Lab.Equiv.html#3703" class="Bound">B</a> <a id="3705" class="Symbol">:</a> <a id="3707" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="3712" href="1Lab.Equiv.html#3686" class="Bound">b</a><a id="3713" class="Symbol">)</a>
        <a id="3723" class="Symbol">→</a> <a id="3725" class="Symbol">(</a><a id="3726" href="1Lab.Equiv.html#3726" class="Bound">w</a> <a id="3728" class="Symbol">:</a> <a id="3730" href="1Lab.Equiv.html#3690" class="Bound">A</a> <a id="3732" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="3734" href="1Lab.Equiv.html#3703" class="Bound">B</a><a id="3735" class="Symbol">)</a> <a id="3737" class="Symbol">(</a><a id="3738" href="1Lab.Equiv.html#3738" class="Bound">a</a> <a id="3740" class="Symbol">:</a> <a id="3742" href="1Lab.Equiv.html#3703" class="Bound">B</a><a id="3743" class="Symbol">)</a>
        <a id="3753" class="Symbol">→</a> <a id="3755" class="Symbol">(</a><a id="3756" href="1Lab.Equiv.html#3756" class="Bound">ψ</a> <a id="3758" class="Symbol">:</a> <a id="3760" href="Agda.Primitive.Cubical.html#150" class="Datatype">I</a><a id="3761" class="Symbol">)</a>
        <a id="3771" class="Symbol">→</a> <a id="3773" href="Agda.Primitive.Cubical.html#1115" class="Primitive">Partial</a> <a id="3781" href="1Lab.Equiv.html#3756" class="Bound">ψ</a> <a id="3783" class="Symbol">(</a><a id="3784" href="1Lab.Equiv.html#1873" data-type="(A → B₁) → B₁ → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Function">fibre</a> <a id="3790" class="Symbol">(</a><a id="3791" href="1Lab.Equiv.html#3726" class="Bound">w</a> <a id="3793" class="Symbol">.</a><a id="3794" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a><a id="3797" class="Symbol">)</a> <a id="3799" href="1Lab.Equiv.html#3738" class="Bound">a</a><a id="3800" class="Symbol">)</a>
        <a id="3810" class="Symbol">→</a> <a id="3812" href="1Lab.Equiv.html#1873" data-type="(A → B₁) → B₁ → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Function">fibre</a> <a id="3818" class="Symbol">(</a><a id="3819" href="1Lab.Equiv.html#3726" class="Bound">w</a> <a id="3821" class="Symbol">.</a><a id="3822" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a><a id="3825" class="Symbol">)</a> <a id="3827" href="1Lab.Equiv.html#3738" class="Bound">a</a>
<a id="3829" href="1Lab.Equiv.html#3671" data-type="(A : Type a) (B₁ : Type b) (w : A ≃ B₁) (a : B₁) (ψ : I) →
Partial ψ (fibre (w .fst) a) → fibre (w .fst) a" class="Function">is-eqv&#39;</a> <a id="3837" href="1Lab.Equiv.html#3837" class="Bound">A</a> <a id="3839" href="1Lab.Equiv.html#3839" class="Bound">B</a> <a id="3841" class="Symbol">(</a><a id="3842" href="1Lab.Equiv.html#3842" class="Bound">f</a> <a id="3844" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="3846" href="1Lab.Equiv.html#3846" class="Bound">is-equiv</a><a id="3854" class="Symbol">)</a> <a id="3856" href="1Lab.Equiv.html#3856" class="Bound">a</a> <a id="3858" href="1Lab.Equiv.html#3858" class="Bound">ψ</a> <a id="3860" href="1Lab.Equiv.html#3860" class="Bound">u0</a> <a id="3863" class="Symbol">=</a>
  <a id="3867" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="3873" class="Symbol">(λ</a> <a id="3876" href="1Lab.Equiv.html#3876" class="Bound">i</a> <a id="3878" class="Symbol">→</a> <a id="3880" class="Symbol">λ</a> <a id="3882" class="Symbol">{</a> <a id="3884" class="Symbol">(</a><a id="3885" href="1Lab.Equiv.html#3858" class="Bound">ψ</a> <a id="3887" class="Symbol">=</a> <a id="3889" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="3891" class="Symbol">)</a> <a id="3893" class="Symbol">→</a> <a id="3895" href="1Lab.Equiv.html#4003" data-type="(A : Type a) (B₁ : Type b) (f : A → B₁) (is-equiv₁ : is-equiv f)
(a : B₁) (ψ : I) (u0 : Partial ψ (fibre f a)) →
is-contr (fibre f a)" class="Function">c</a> <a id="3897" class="Symbol">.</a><a id="3898" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a>
                 <a id="3922" class="Symbol">;</a> <a id="3924" class="Symbol">(</a><a id="3925" href="1Lab.Equiv.html#3858" class="Bound">ψ</a> <a id="3927" class="Symbol">=</a> <a id="3929" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="3931" class="Symbol">)</a> <a id="3933" class="Symbol">→</a> <a id="3935" href="1Lab.Equiv.html#4003" data-type="(A : Type a) (B₁ : Type b) (f : A → B₁) (is-equiv₁ : is-equiv f)
(a : B₁) (ψ : I) (u0 : Partial ψ (fibre f a)) →
is-contr (fibre f a)" class="Function">c</a> <a id="3937" class="Symbol">.</a><a id="3938" href="1Lab.HLevel.html#1416" data-type="(r : is-contr A) (x : A) → r .centre ≡ x" class="Field">paths</a> <a id="3944" class="Symbol">(</a><a id="3945" href="1Lab.Equiv.html#3860" class="Bound">u0</a> <a id="3948" href="1Lab.Path.html#2443" class="Postulate">1=1</a><a id="3951" class="Symbol">)</a> <a id="3953" href="1Lab.Equiv.html#3876" class="Bound">i</a>
                 <a id="3972" class="Symbol">})</a>
        <a id="3983" class="Symbol">(</a><a id="3984" href="1Lab.Equiv.html#4003" data-type="(A : Type a) (B₁ : Type b) (f : A → B₁) (is-equiv₁ : is-equiv f)
(a : B₁) (ψ : I) (u0 : Partial ψ (fibre f a)) →
is-contr (fibre f a)" class="Function">c</a> <a id="3986" class="Symbol">.</a><a id="3987" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a><a id="3993" class="Symbol">)</a>
  <a id="3997" class="Keyword">where</a> <a id="4003" href="1Lab.Equiv.html#4003" data-type="(A : Type a) (B₁ : Type b) (f : A → B₁) (is-equiv₁ : is-equiv f)
(a : B₁) (ψ : I) (u0 : Partial ψ (fibre f a)) →
is-contr (fibre f a)" class="Function">c</a> <a id="4005" class="Symbol">=</a> <a id="4007" href="1Lab.Equiv.html#3846" class="Bound">is-equiv</a> <a id="4016" class="Symbol">.</a><a id="4017" href="1Lab.Equiv.html#2376" data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" class="Field">is-eqv</a> <a id="4024" href="1Lab.Equiv.html#3856" class="Bound">a</a>

<a id="4027" class="Symbol">{-#</a> <a id="4031" class="Keyword">BUILTIN</a> <a id="4039" class="Keyword">EQUIVPROOF</a> <a id="4050" href="1Lab.Equiv.html#3671" data-type="(A : Type a) (B₁ : Type b) (w : A ≃ B₁) (a : B₁) (ψ : I) →
Partial ψ (fibre (w .fst) a) → fibre (w .fst) a" class="Function">is-eqv&#39;</a> <a id="4058" class="Symbol">#-}</a>
</pre>
<!--
<pre class="Agda"><a id="equiv-centre"></a><a id="4076" href="1Lab.Equiv.html#4076" data-type="(e : A ≃ B₁) (y : B₁) → fibre (e .fst) y" class="Function">equiv-centre</a> <a id="4089" class="Symbol">:</a> <a id="4091" class="Symbol">(</a><a id="4092" href="1Lab.Equiv.html#4092" class="Bound">e</a> <a id="4094" class="Symbol">:</a> <a id="4096" href="1Lab.Equiv.html#1588" class="Generalizable">A</a> <a id="4098" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="4100" href="1Lab.Equiv.html#1590" class="Generalizable">B</a><a id="4101" class="Symbol">)</a> <a id="4103" class="Symbol">(</a><a id="4104" href="1Lab.Equiv.html#4104" class="Bound">y</a> <a id="4106" class="Symbol">:</a> <a id="4108" href="1Lab.Equiv.html#1590" class="Generalizable">B</a><a id="4109" class="Symbol">)</a> <a id="4111" class="Symbol">→</a> <a id="4113" href="1Lab.Equiv.html#1873" data-type="(A → B₁) → B₁ → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Function">fibre</a> <a id="4119" class="Symbol">(</a><a id="4120" href="1Lab.Equiv.html#4092" class="Bound">e</a> <a id="4122" class="Symbol">.</a><a id="4123" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a><a id="4126" class="Symbol">)</a> <a id="4128" href="1Lab.Equiv.html#4104" class="Bound">y</a>
<a id="4130" href="1Lab.Equiv.html#4076" data-type="(e : A ≃ B₁) (y : B₁) → fibre (e .fst) y" class="Function">equiv-centre</a> <a id="4143" href="1Lab.Equiv.html#4143" class="Bound">e</a> <a id="4145" href="1Lab.Equiv.html#4145" class="Bound">y</a> <a id="4147" class="Symbol">=</a> <a id="4149" href="1Lab.Equiv.html#4143" class="Bound">e</a> <a id="4151" class="Symbol">.</a><a id="4152" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="4156" class="Symbol">.</a><a id="4157" href="1Lab.Equiv.html#2376" data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" class="Field">is-eqv</a> <a id="4164" href="1Lab.Equiv.html#4145" class="Bound">y</a> <a id="4166" class="Symbol">.</a><a id="4167" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a>

<a id="equiv-path"></a><a id="4175" href="1Lab.Equiv.html#4175" data-type="(e : A ≃ B₁) (y : B₁) (v : fibre (e .fst) y) →
Path (∑ A (λ x → e .fst x ≡ y)) (equiv-centre e y) v" class="Function">equiv-path</a> <a id="4186" class="Symbol">:</a> <a id="4188" class="Symbol">(</a><a id="4189" href="1Lab.Equiv.html#4189" class="Bound">e</a> <a id="4191" class="Symbol">:</a> <a id="4193" href="1Lab.Equiv.html#1588" class="Generalizable">A</a> <a id="4195" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="4197" href="1Lab.Equiv.html#1590" class="Generalizable">B</a><a id="4198" class="Symbol">)</a> <a id="4200" class="Symbol">(</a><a id="4201" href="1Lab.Equiv.html#4201" class="Bound">y</a> <a id="4203" class="Symbol">:</a> <a id="4205" href="1Lab.Equiv.html#1590" class="Generalizable">B</a><a id="4206" class="Symbol">)</a> <a id="4208" class="Symbol">→</a>
  <a id="4212" class="Symbol">(</a><a id="4213" href="1Lab.Equiv.html#4213" class="Bound">v</a> <a id="4215" class="Symbol">:</a> <a id="4217" href="1Lab.Equiv.html#1873" data-type="(A → B₁) → B₁ → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Function">fibre</a> <a id="4223" class="Symbol">(</a><a id="4224" href="1Lab.Equiv.html#4189" class="Bound">e</a> <a id="4226" class="Symbol">.</a><a id="4227" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a><a id="4230" class="Symbol">)</a> <a id="4232" href="1Lab.Equiv.html#4201" class="Bound">y</a><a id="4233" class="Symbol">)</a> <a id="4235" class="Symbol">→</a> <a id="4237" href="1Lab.Path.html#2466" data-type="(A : Type ℓ) → A → A → Type ℓ" class="Function">Path</a> <a id="4242" class="Symbol">_</a> <a id="4244" class="Symbol">(</a><a id="4245" href="1Lab.Equiv.html#4076" data-type="(e : A ≃ B₁) (y : B₁) → fibre (e .fst) y" class="Function">equiv-centre</a> <a id="4258" href="1Lab.Equiv.html#4189" class="Bound">e</a> <a id="4260" href="1Lab.Equiv.html#4201" class="Bound">y</a><a id="4261" class="Symbol">)</a> <a id="4263" href="1Lab.Equiv.html#4213" class="Bound">v</a>
<a id="4265" href="1Lab.Equiv.html#4175" data-type="(e : A ≃ B₁) (y : B₁) (v : fibre (e .fst) y) →
Path (∑ A (λ x → e .fst x ≡ y)) (equiv-centre e y) v" class="Function">equiv-path</a> <a id="4276" href="1Lab.Equiv.html#4276" class="Bound">e</a> <a id="4278" href="1Lab.Equiv.html#4278" class="Bound">y</a> <a id="4280" class="Symbol">=</a> <a id="4282" href="1Lab.Equiv.html#4276" class="Bound">e</a> <a id="4284" class="Symbol">.</a><a id="4285" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="4289" class="Symbol">.</a><a id="4290" href="1Lab.Equiv.html#2376" data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" class="Field">is-eqv</a> <a id="4297" href="1Lab.Equiv.html#4278" class="Bound">y</a> <a id="4299" class="Symbol">.</a><a id="4300" href="1Lab.HLevel.html#1416" data-type="(r : is-contr A) (x : A) → r .centre ≡ x" class="Field">paths</a>
</pre>-->
<h2 id="is-equiv-is-propositional"><a href="#is-equiv-is-propositional" class="header-link">is-equiv
is propositional<span class="header-link-emoji">🔗</span></a></h2>
<p>A function can be an equivalence in at most one way. This follows
from propositions being closed under dependent products, and
<span class="Agda"><a href="1Lab.HLevel.html#1328" class="Module">is-contr</a></span>
being a proposition.</p>
<pre class="Agda"><a id="4520" class="Keyword">module</a> <a id="4527" href="1Lab.Equiv.html#4527" class="Module">_</a> <a id="4529" class="Keyword">where</a> <a id="4535" class="Keyword">private</a>
  <a id="4545" href="1Lab.Equiv.html#4545" class="Function">is-equiv-is-prop</a> <a id="4562" class="Symbol">:</a> <a id="4564" class="Symbol">(</a><a id="4565" href="1Lab.Equiv.html#4565" class="Bound">f</a> <a id="4567" class="Symbol">:</a> <a id="4569" href="1Lab.Equiv.html#1588" class="Generalizable">A</a> <a id="4571" class="Symbol">→</a> <a id="4573" href="1Lab.Equiv.html#1590" class="Generalizable">B</a><a id="4574" class="Symbol">)</a> <a id="4576" class="Symbol">→</a> <a id="4578" href="1Lab.HLevel.html#2597" data-type="Type ℓ → Type ℓ" class="Function">is-prop</a> <a id="4586" class="Symbol">(</a><a id="4587" href="1Lab.Equiv.html#2286" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-equiv</a> <a id="4596" href="1Lab.Equiv.html#4565" class="Bound">f</a><a id="4597" class="Symbol">)</a>
  <a id="4601" href="1Lab.Equiv.html#4545" class="Function">is-equiv-is-prop</a> <a id="4618" href="1Lab.Equiv.html#4618" class="Bound">f</a> <a id="4620" href="1Lab.Equiv.html#4620" class="Bound">x</a> <a id="4622" href="1Lab.Equiv.html#4622" class="Bound">y</a> <a id="4624" href="1Lab.Equiv.html#4624" class="Bound">i</a> <a id="4626" class="Symbol">.</a><a id="4627" href="1Lab.Equiv.html#2376" data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" class="Field">is-eqv</a> <a id="4634" href="1Lab.Equiv.html#4634" class="Bound">p</a> <a id="4636" class="Symbol">=</a> <a id="4638" href="1Lab.HLevel.html#11538" data-type="is-prop (is-contr A)" class="Function">is-contr-is-prop</a> <a id="4655" class="Symbol">(</a><a id="4656" href="1Lab.Equiv.html#4620" class="Bound">x</a> <a id="4658" class="Symbol">.</a><a id="4659" href="1Lab.Equiv.html#2376" data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" class="Field">is-eqv</a> <a id="4666" href="1Lab.Equiv.html#4634" class="Bound">p</a><a id="4667" class="Symbol">)</a> <a id="4669" class="Symbol">(</a><a id="4670" href="1Lab.Equiv.html#4622" class="Bound">y</a> <a id="4672" class="Symbol">.</a><a id="4673" href="1Lab.Equiv.html#2376" data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" class="Field">is-eqv</a> <a id="4680" href="1Lab.Equiv.html#4634" class="Bound">p</a><a id="4681" class="Symbol">)</a> <a id="4683" href="1Lab.Equiv.html#4624" class="Bound">i</a>
</pre>
<details>
<summary>
Even though the proof above works, we use the direct cubical proof in
this <code>&lt;details&gt;</code> tag (lifted from the Cubical Agda
library) in the rest of the development for efficiency concerns.
</summary>
<pre class="Agda"><a id="is-equiv-is-prop"></a><a id="4916" href="1Lab.Equiv.html#4916" data-type="(f : A → B₁) → is-prop (is-equiv f)" class="Function">is-equiv-is-prop</a> <a id="4933" class="Symbol">:</a> <a id="4935" class="Symbol">(</a><a id="4936" href="1Lab.Equiv.html#4936" class="Bound">f</a> <a id="4938" class="Symbol">:</a> <a id="4940" href="1Lab.Equiv.html#1588" class="Generalizable">A</a> <a id="4942" class="Symbol">→</a> <a id="4944" href="1Lab.Equiv.html#1590" class="Generalizable">B</a><a id="4945" class="Symbol">)</a> <a id="4947" class="Symbol">→</a> <a id="4949" href="1Lab.HLevel.html#2597" data-type="Type ℓ → Type ℓ" class="Function">is-prop</a> <a id="4957" class="Symbol">(</a><a id="4958" href="1Lab.Equiv.html#2286" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-equiv</a> <a id="4967" href="1Lab.Equiv.html#4936" class="Bound">f</a><a id="4968" class="Symbol">)</a>
<a id="4970" href="1Lab.Equiv.html#4916" data-type="(f : A → B₁) → is-prop (is-equiv f)" class="Function">is-equiv-is-prop</a> <a id="4987" href="1Lab.Equiv.html#4987" class="Bound">f</a> <a id="4989" href="1Lab.Equiv.html#4989" class="Bound">p</a> <a id="4991" href="1Lab.Equiv.html#4991" class="Bound">q</a> <a id="4993" href="1Lab.Equiv.html#4993" class="Bound">i</a> <a id="4995" class="Symbol">.</a><a id="4996" href="1Lab.Equiv.html#2376" data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" class="Field">is-eqv</a> <a id="5003" href="1Lab.Equiv.html#5003" class="Bound">y</a> <a id="5005" class="Symbol">=</a>
  <a id="5009" class="Keyword">let</a> <a id="5013" href="1Lab.Equiv.html#5013" class="Bound">p2</a> <a id="5016" class="Symbol">=</a> <a id="5018" href="1Lab.Equiv.html#4989" class="Bound">p</a> <a id="5020" class="Symbol">.</a><a id="5021" href="1Lab.Equiv.html#2376" data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" class="Field">is-eqv</a> <a id="5028" href="1Lab.Equiv.html#5003" class="Bound">y</a> <a id="5030" class="Symbol">.</a><a id="5031" href="1Lab.HLevel.html#1416" data-type="(r : is-contr A) (x : A) → r .centre ≡ x" class="Field">paths</a>
      <a id="5043" href="1Lab.Equiv.html#5043" class="Bound">q2</a> <a id="5046" class="Symbol">=</a> <a id="5048" href="1Lab.Equiv.html#4991" class="Bound">q</a> <a id="5050" class="Symbol">.</a><a id="5051" href="1Lab.Equiv.html#2376" data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" class="Field">is-eqv</a> <a id="5058" href="1Lab.Equiv.html#5003" class="Bound">y</a> <a id="5060" class="Symbol">.</a><a id="5061" href="1Lab.HLevel.html#1416" data-type="(r : is-contr A) (x : A) → r .centre ≡ x" class="Field">paths</a>
  <a id="5069" class="Keyword">in</a> <a id="5072" href="1Lab.HLevel.html#1383" data-type="(centre₁ : A) (paths₁ : (x : A) → centre₁ ≡ x) → is-contr A" class="InductiveConstructor">contr</a> <a id="5078" class="Symbol">(</a><a id="5079" href="1Lab.Equiv.html#5013" class="Bound">p2</a> <a id="5082" class="Symbol">(</a><a id="5083" href="1Lab.Equiv.html#4991" class="Bound">q</a> <a id="5085" class="Symbol">.</a><a id="5086" href="1Lab.Equiv.html#2376" data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" class="Field">is-eqv</a> <a id="5093" href="1Lab.Equiv.html#5003" class="Bound">y</a> <a id="5095" class="Symbol">.</a><a id="5096" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a><a id="5102" class="Symbol">)</a> <a id="5104" href="1Lab.Equiv.html#4993" class="Bound">i</a><a id="5105" class="Symbol">)</a>
      <a id="5113" class="Symbol">λ</a> <a id="5115" href="1Lab.Equiv.html#5115" class="Bound">w</a> <a id="5117" href="1Lab.Equiv.html#5117" class="Bound">j</a> <a id="5119" class="Symbol">→</a> <a id="5121" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="5127" class="Symbol">(λ</a> <a id="5130" href="1Lab.Equiv.html#5130" class="Bound">k</a> <a id="5132" class="Symbol">→</a> <a id="5134" class="Symbol">λ</a> <a id="5136" class="Symbol">{</a> <a id="5138" class="Symbol">(</a><a id="5139" href="1Lab.Equiv.html#4993" class="Bound">i</a> <a id="5141" class="Symbol">=</a> <a id="5143" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="5145" class="Symbol">)</a> <a id="5147" class="Symbol">→</a> <a id="5149" href="1Lab.Equiv.html#5013" class="Bound">p2</a> <a id="5152" href="1Lab.Equiv.html#5115" class="Bound">w</a> <a id="5154" href="1Lab.Equiv.html#5117" class="Bound">j</a>
                             <a id="5185" class="Symbol">;</a> <a id="5187" class="Symbol">(</a><a id="5188" href="1Lab.Equiv.html#4993" class="Bound">i</a> <a id="5190" class="Symbol">=</a> <a id="5192" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="5194" class="Symbol">)</a> <a id="5196" class="Symbol">→</a> <a id="5198" href="1Lab.Equiv.html#5043" class="Bound">q2</a> <a id="5201" href="1Lab.Equiv.html#5115" class="Bound">w</a> <a id="5203" class="Symbol">(</a><a id="5204" href="1Lab.Equiv.html#5117" class="Bound">j</a> <a id="5206" href="1Lab.Path.html#2226" class="Primitive Operator">∨</a> <a id="5208" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="5210" href="1Lab.Equiv.html#5130" class="Bound">k</a><a id="5211" class="Symbol">)</a>
                             <a id="5242" class="Symbol">;</a> <a id="5244" class="Symbol">(</a><a id="5245" href="1Lab.Equiv.html#5117" class="Bound">j</a> <a id="5247" class="Symbol">=</a> <a id="5249" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="5251" class="Symbol">)</a> <a id="5253" class="Symbol">→</a> <a id="5255" href="1Lab.Equiv.html#5013" class="Bound">p2</a> <a id="5258" class="Symbol">(</a><a id="5259" href="1Lab.Equiv.html#5043" class="Bound">q2</a> <a id="5262" href="1Lab.Equiv.html#5115" class="Bound">w</a> <a id="5264" class="Symbol">(</a><a id="5265" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="5267" href="1Lab.Equiv.html#5130" class="Bound">k</a><a id="5268" class="Symbol">))</a> <a id="5271" href="1Lab.Equiv.html#4993" class="Bound">i</a>
                             <a id="5302" class="Symbol">;</a> <a id="5304" class="Symbol">(</a><a id="5305" href="1Lab.Equiv.html#5117" class="Bound">j</a> <a id="5307" class="Symbol">=</a> <a id="5309" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="5311" class="Symbol">)</a> <a id="5313" class="Symbol">→</a> <a id="5315" href="1Lab.Equiv.html#5115" class="Bound">w</a> <a id="5317" class="Symbol">})</a>
                    <a id="5340" class="Symbol">(</a><a id="5341" href="1Lab.Equiv.html#5013" class="Bound">p2</a> <a id="5344" href="1Lab.Equiv.html#5115" class="Bound">w</a> <a id="5346" class="Symbol">(</a><a id="5347" href="1Lab.Equiv.html#4993" class="Bound">i</a> <a id="5349" href="1Lab.Path.html#2226" class="Primitive Operator">∨</a> <a id="5351" href="1Lab.Equiv.html#5117" class="Bound">j</a><a id="5352" class="Symbol">))</a>
</pre>
</details>
<h1 id="isomorphisms-from-equivalences"><a href="#isomorphisms-from-equivalences" class="header-link">Isomorphisms
from equivalences<span class="header-link-emoji">🔗</span></a></h1>
<p>For this section, we need a definition of <em>isomorphism</em>. This
is the same as ever! An isomorphism is a function that has a two-sided
inverse. We first define what it means for a function to invert another
on the left and on the right:</p>
<pre class="Agda"><a id="is-left-inverse"></a><a id="5649" href="1Lab.Equiv.html#5649" data-type="(B₁ → A) → (A → B₁) → Type A.ℓ₁" class="Function">is-left-inverse</a> <a id="5665" class="Symbol">:</a> <a id="5667" class="Symbol">(</a><a id="5668" href="1Lab.Equiv.html#1590" class="Generalizable">B</a> <a id="5670" class="Symbol">→</a> <a id="5672" href="1Lab.Equiv.html#1588" class="Generalizable">A</a><a id="5673" class="Symbol">)</a> <a id="5675" class="Symbol">→</a> <a id="5677" class="Symbol">(</a><a id="5678" href="1Lab.Equiv.html#1588" class="Generalizable">A</a> <a id="5680" class="Symbol">→</a> <a id="5682" href="1Lab.Equiv.html#1590" class="Generalizable">B</a><a id="5683" class="Symbol">)</a> <a id="5685" class="Symbol">→</a> <a id="5687" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="5692" class="Symbol">_</a>
<a id="5694" href="1Lab.Equiv.html#5649" data-type="(B₁ → A) → (A → B₁) → Type A.ℓ₁" class="Function">is-left-inverse</a> <a id="5710" href="1Lab.Equiv.html#5710" class="Bound">g</a> <a id="5712" href="1Lab.Equiv.html#5712" class="Bound">f</a> <a id="5714" class="Symbol">=</a> <a id="5716" class="Symbol">(</a><a id="5717" href="1Lab.Equiv.html#5717" class="Bound">x</a> <a id="5719" class="Symbol">:</a> <a id="5721" class="Symbol">_)</a> <a id="5724" class="Symbol">→</a> <a id="5726" href="1Lab.Equiv.html#5710" class="Bound">g</a> <a id="5728" class="Symbol">(</a><a id="5729" href="1Lab.Equiv.html#5712" class="Bound">f</a> <a id="5731" href="1Lab.Equiv.html#5717" class="Bound">x</a><a id="5732" class="Symbol">)</a> <a id="5734" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="5736" href="1Lab.Equiv.html#5717" class="Bound">x</a>

<a id="is-right-inverse"></a><a id="5739" href="1Lab.Equiv.html#5739" data-type="(B₁ → A) → (A → B₁) → Type B.ℓ₁" class="Function">is-right-inverse</a> <a id="5756" class="Symbol">:</a> <a id="5758" class="Symbol">(</a><a id="5759" href="1Lab.Equiv.html#1590" class="Generalizable">B</a> <a id="5761" class="Symbol">→</a> <a id="5763" href="1Lab.Equiv.html#1588" class="Generalizable">A</a><a id="5764" class="Symbol">)</a> <a id="5766" class="Symbol">→</a> <a id="5768" class="Symbol">(</a><a id="5769" href="1Lab.Equiv.html#1588" class="Generalizable">A</a> <a id="5771" class="Symbol">→</a> <a id="5773" href="1Lab.Equiv.html#1590" class="Generalizable">B</a><a id="5774" class="Symbol">)</a> <a id="5776" class="Symbol">→</a> <a id="5778" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="5783" class="Symbol">_</a>
<a id="5785" href="1Lab.Equiv.html#5739" data-type="(B₁ → A) → (A → B₁) → Type B.ℓ₁" class="Function">is-right-inverse</a> <a id="5802" href="1Lab.Equiv.html#5802" class="Bound">g</a> <a id="5804" href="1Lab.Equiv.html#5804" class="Bound">f</a> <a id="5806" class="Symbol">=</a> <a id="5808" class="Symbol">(</a><a id="5809" href="1Lab.Equiv.html#5809" class="Bound">x</a> <a id="5811" class="Symbol">:</a> <a id="5813" class="Symbol">_)</a> <a id="5816" class="Symbol">→</a> <a id="5818" href="1Lab.Equiv.html#5804" class="Bound">f</a> <a id="5820" class="Symbol">(</a><a id="5821" href="1Lab.Equiv.html#5802" class="Bound">g</a> <a id="5823" href="1Lab.Equiv.html#5809" class="Bound">x</a><a id="5824" class="Symbol">)</a> <a id="5826" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="5828" href="1Lab.Equiv.html#5809" class="Bound">x</a>
</pre>
<p>A proof that a function
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>
is an isomorphism consists of a function
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span>
in the other direction, together with homotopies exhibiting
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span>
as a left- and right- inverse to
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>.</span></p>
<pre class="Agda"><a id="6019" class="Keyword">record</a> <a id="is-iso"></a><a id="6026" href="1Lab.Equiv.html#6026" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-iso</a> <a id="6033" class="Symbol">(</a><a id="6034" href="1Lab.Equiv.html#6034" class="Bound">f</a> <a id="6036" class="Symbol">:</a> <a id="6038" href="1Lab.Equiv.html#1588" class="Generalizable">A</a> <a id="6040" class="Symbol">→</a> <a id="6042" href="1Lab.Equiv.html#1590" class="Generalizable">B</a><a id="6043" class="Symbol">)</a> <a id="6045" class="Symbol">:</a> <a id="6047" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="6052" class="Symbol">(</a><a id="6053" href="1Lab.Type.html#921" data-type="Type ℓ → Level" class="Function">level-of</a> <a id="6062" href="1Lab.Equiv.html#6038" class="Bound">A</a> <a id="6064" href="Agda.Primitive.html#795" data-type="Level → Level → Level" class="Primitive Operator">⊔</a> <a id="6066" href="1Lab.Type.html#921" data-type="Type ℓ → Level" class="Function">level-of</a> <a id="6075" href="1Lab.Equiv.html#6042" class="Bound">B</a><a id="6076" class="Symbol">)</a> <a id="6078" class="Keyword">where</a>
  <a id="6086" class="Keyword">no-eta-equality</a>
  <a id="6104" class="Keyword">constructor</a> <a id="iso"></a><a id="6116" href="1Lab.Equiv.html#6116" data-type="(inv₁ : B₁ → A) (rinv₁ : is-right-inverse inv₁ f)
(linv₁ : is-left-inverse inv₁ f) →
is-iso f" class="InductiveConstructor">iso</a>
  <a id="6122" class="Keyword">field</a>
    <a id="is-iso.inv"></a><a id="6132" href="1Lab.Equiv.html#6132" data-type="is-iso f → B₁ → A" class="Field">inv</a> <a id="6136" class="Symbol">:</a> <a id="6138" href="1Lab.Equiv.html#6042" class="Bound">B</a> <a id="6140" class="Symbol">→</a> <a id="6142" href="1Lab.Equiv.html#6038" class="Bound">A</a>
    <a id="is-iso.rinv"></a><a id="6148" href="1Lab.Equiv.html#6148" data-type="(r : is-iso f) → is-right-inverse (r .inv) f" class="Field">rinv</a> <a id="6153" class="Symbol">:</a> <a id="6155" href="1Lab.Equiv.html#5739" data-type="(B₁ → A) → (A → B₁) → Type B.ℓ₁" class="Function">is-right-inverse</a> <a id="6172" href="1Lab.Equiv.html#6132" data-type="is-iso f → B₁ → A" class="Field">inv</a> <a id="6176" href="1Lab.Equiv.html#6034" class="Bound">f</a>
    <a id="is-iso.linv"></a><a id="6182" href="1Lab.Equiv.html#6182" data-type="(r : is-iso f) → is-left-inverse (r .inv) f" class="Field">linv</a> <a id="6187" class="Symbol">:</a> <a id="6189" href="1Lab.Equiv.html#5649" data-type="(B₁ → A) → (A → B₁) → Type A.ℓ₁" class="Function">is-left-inverse</a> <a id="6205" href="1Lab.Equiv.html#6132" data-type="is-iso f → B₁ → A" class="Field">inv</a> <a id="6209" href="1Lab.Equiv.html#6034" class="Bound">f</a>

  <a id="is-iso.inverse"></a><a id="6214" href="1Lab.Equiv.html#6214" data-type="(r : is-iso f) → is-iso (inv r)" class="Function">inverse</a> <a id="6222" class="Symbol">:</a> <a id="6224" href="1Lab.Equiv.html#6026" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-iso</a> <a id="6231" href="1Lab.Equiv.html#6132" data-type="is-iso f → B₁ → A" class="Field">inv</a>
  <a id="6237" href="1Lab.Equiv.html#6132" data-type="is-iso f → B₁ → A" class="Field">inv</a> <a id="6241" href="1Lab.Equiv.html#6214" data-type="(r : is-iso f) → is-iso (inv r)" class="Function">inverse</a> <a id="6249" class="Symbol">=</a> <a id="6251" href="1Lab.Equiv.html#6034" class="Bound">f</a>
  <a id="6255" href="1Lab.Equiv.html#6148" data-type="(r : is-iso f) → is-right-inverse (r .inv) f" class="Field">rinv</a> <a id="6260" href="1Lab.Equiv.html#6214" data-type="(r : is-iso f) → is-iso (inv r)" class="Function">inverse</a> <a id="6268" class="Symbol">=</a> <a id="6270" href="1Lab.Equiv.html#6182" data-type="(r : is-iso f) → is-left-inverse (r .inv) f" class="Field">linv</a>
  <a id="6277" href="1Lab.Equiv.html#6182" data-type="(r : is-iso f) → is-left-inverse (r .inv) f" class="Field">linv</a> <a id="6282" href="1Lab.Equiv.html#6214" data-type="(r : is-iso f) → is-iso (inv r)" class="Function">inverse</a> <a id="6290" class="Symbol">=</a> <a id="6292" href="1Lab.Equiv.html#6148" data-type="(r : is-iso f) → is-right-inverse (r .inv) f" class="Field">rinv</a>

<a id="Iso"></a><a id="6298" href="1Lab.Equiv.html#6298" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function">Iso</a> <a id="6302" class="Symbol">:</a> <a id="6304" class="Symbol">∀</a> <a id="6306" class="Symbol">{</a><a id="6307" href="1Lab.Equiv.html#6307" class="Bound">ℓ₁</a> <a id="6310" href="1Lab.Equiv.html#6310" class="Bound">ℓ₂</a><a id="6312" class="Symbol">}</a> <a id="6314" class="Symbol">→</a> <a id="6316" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="6321" href="1Lab.Equiv.html#6307" class="Bound">ℓ₁</a> <a id="6324" class="Symbol">→</a> <a id="6326" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="6331" href="1Lab.Equiv.html#6310" class="Bound">ℓ₂</a> <a id="6334" class="Symbol">→</a> <a id="6336" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="6341" class="Symbol">_</a>
<a id="6343" href="1Lab.Equiv.html#6298" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function">Iso</a> <a id="6347" href="1Lab.Equiv.html#6347" class="Bound">A</a> <a id="6349" href="1Lab.Equiv.html#6349" class="Bound">B</a> <a id="6351" class="Symbol">=</a> <a id="6353" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">Σ</a> <a id="6355" class="Symbol">(</a><a id="6356" href="1Lab.Equiv.html#6026" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-iso</a> <a id="6363" class="Symbol">{</a><a id="6364" class="Argument">A</a> <a id="6366" class="Symbol">=</a> <a id="6368" href="1Lab.Equiv.html#6347" class="Bound">A</a><a id="6369" class="Symbol">}</a> <a id="6371" class="Symbol">{</a><a id="6372" class="Argument">B</a> <a id="6374" class="Symbol">=</a> <a id="6376" href="1Lab.Equiv.html#6349" class="Bound">B</a><a id="6377" class="Symbol">})</a>
</pre>
<p>Any function that is an equivalence is an isomorphism:</p>
<pre class="Agda"><a id="equiv→inverse"></a><a id="6449" href="1Lab.Equiv.html#6449" data-type="is-equiv f → B₁ → A" class="Function">equiv→inverse</a> <a id="6463" class="Symbol">:</a> <a id="6465" class="Symbol">{</a><a id="6466" href="1Lab.Equiv.html#6466" class="Bound">f</a> <a id="6468" class="Symbol">:</a> <a id="6470" href="1Lab.Equiv.html#1588" class="Generalizable">A</a> <a id="6472" class="Symbol">→</a> <a id="6474" href="1Lab.Equiv.html#1590" class="Generalizable">B</a><a id="6475" class="Symbol">}</a> <a id="6477" class="Symbol">→</a> <a id="6479" href="1Lab.Equiv.html#2286" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-equiv</a> <a id="6488" href="1Lab.Equiv.html#6466" class="Bound">f</a> <a id="6490" class="Symbol">→</a> <a id="6492" href="1Lab.Equiv.html#1590" class="Generalizable">B</a> <a id="6494" class="Symbol">→</a> <a id="6496" href="1Lab.Equiv.html#1588" class="Generalizable">A</a>
<a id="6498" href="1Lab.Equiv.html#6449" data-type="is-equiv f → B₁ → A" class="Function">equiv→inverse</a> <a id="6512" href="1Lab.Equiv.html#6512" class="Bound">eqv</a> <a id="6516" href="1Lab.Equiv.html#6516" class="Bound">y</a> <a id="6518" class="Symbol">=</a> <a id="6520" href="1Lab.Equiv.html#6512" class="Bound">eqv</a> <a id="6524" class="Symbol">.</a><a id="6525" href="1Lab.Equiv.html#2376" data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" class="Field">is-eqv</a> <a id="6532" href="1Lab.Equiv.html#6516" class="Bound">y</a> <a id="6534" class="Symbol">.</a><a id="6535" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a> <a id="6542" class="Symbol">.</a><a id="6543" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a>

<a id="equiv→counit"></a><a id="6548" href="1Lab.Equiv.html#6548" data-type="(eqv : is-equiv f) (x : B₁) → f (equiv→inverse eqv x) ≡ x" class="Function">equiv→counit</a>
  <a id="6563" class="Symbol">:</a> <a id="6565" class="Symbol">∀</a> <a id="6567" class="Symbol">{</a><a id="6568" href="1Lab.Equiv.html#6568" class="Bound">f</a> <a id="6570" class="Symbol">:</a> <a id="6572" href="1Lab.Equiv.html#1588" class="Generalizable">A</a> <a id="6574" class="Symbol">→</a> <a id="6576" href="1Lab.Equiv.html#1590" class="Generalizable">B</a><a id="6577" class="Symbol">}</a> <a id="6579" class="Symbol">(</a><a id="6580" href="1Lab.Equiv.html#6580" class="Bound">eqv</a> <a id="6584" class="Symbol">:</a> <a id="6586" href="1Lab.Equiv.html#2286" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-equiv</a> <a id="6595" href="1Lab.Equiv.html#6568" class="Bound">f</a><a id="6596" class="Symbol">)</a> <a id="6598" href="1Lab.Equiv.html#6598" class="Bound">x</a> <a id="6600" class="Symbol">→</a> <a id="6602" href="1Lab.Equiv.html#6568" class="Bound">f</a> <a id="6604" class="Symbol">(</a><a id="6605" href="1Lab.Equiv.html#6449" data-type="is-equiv f → B₁ → A" class="Function">equiv→inverse</a> <a id="6619" href="1Lab.Equiv.html#6580" class="Bound">eqv</a> <a id="6623" href="1Lab.Equiv.html#6598" class="Bound">x</a><a id="6624" class="Symbol">)</a> <a id="6626" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="6628" href="1Lab.Equiv.html#6598" class="Bound">x</a>
<a id="6630" href="1Lab.Equiv.html#6548" data-type="(eqv : is-equiv f) (x : B₁) → f (equiv→inverse eqv x) ≡ x" class="Function">equiv→counit</a> <a id="6643" href="1Lab.Equiv.html#6643" class="Bound">eqv</a> <a id="6647" href="1Lab.Equiv.html#6647" class="Bound">y</a> <a id="6649" class="Symbol">=</a> <a id="6651" href="1Lab.Equiv.html#6643" class="Bound">eqv</a> <a id="6655" class="Symbol">.</a><a id="6656" href="1Lab.Equiv.html#2376" data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" class="Field">is-eqv</a> <a id="6663" href="1Lab.Equiv.html#6647" class="Bound">y</a> <a id="6665" class="Symbol">.</a><a id="6666" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a> <a id="6673" class="Symbol">.</a><a id="6674" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a>

<a id="equiv→unit"></a><a id="6679" href="1Lab.Equiv.html#6679" data-type="(eqv : is-equiv f) (x : A) → equiv→inverse eqv (f x) ≡ x" class="Function">equiv→unit</a>
  <a id="6692" class="Symbol">:</a> <a id="6694" class="Symbol">∀</a> <a id="6696" class="Symbol">{</a><a id="6697" href="1Lab.Equiv.html#6697" class="Bound">f</a> <a id="6699" class="Symbol">:</a> <a id="6701" href="1Lab.Equiv.html#1588" class="Generalizable">A</a> <a id="6703" class="Symbol">→</a> <a id="6705" href="1Lab.Equiv.html#1590" class="Generalizable">B</a><a id="6706" class="Symbol">}</a> <a id="6708" class="Symbol">(</a><a id="6709" href="1Lab.Equiv.html#6709" class="Bound">eqv</a> <a id="6713" class="Symbol">:</a> <a id="6715" href="1Lab.Equiv.html#2286" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-equiv</a> <a id="6724" href="1Lab.Equiv.html#6697" class="Bound">f</a><a id="6725" class="Symbol">)</a> <a id="6727" href="1Lab.Equiv.html#6727" class="Bound">x</a> <a id="6729" class="Symbol">→</a> <a id="6731" href="1Lab.Equiv.html#6449" data-type="is-equiv f → B₁ → A" class="Function">equiv→inverse</a> <a id="6745" href="1Lab.Equiv.html#6709" class="Bound">eqv</a> <a id="6749" class="Symbol">(</a><a id="6750" href="1Lab.Equiv.html#6697" class="Bound">f</a> <a id="6752" href="1Lab.Equiv.html#6727" class="Bound">x</a><a id="6753" class="Symbol">)</a> <a id="6755" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="6757" href="1Lab.Equiv.html#6727" class="Bound">x</a>
<a id="6759" href="1Lab.Equiv.html#6679" data-type="(eqv : is-equiv f) (x : A) → equiv→inverse eqv (f x) ≡ x" class="Function">equiv→unit</a> <a id="6770" class="Symbol">{</a><a id="6771" class="Argument">f</a> <a id="6773" class="Symbol">=</a> <a id="6775" href="1Lab.Equiv.html#6775" class="Bound">f</a><a id="6776" class="Symbol">}</a> <a id="6778" href="1Lab.Equiv.html#6778" class="Bound">eqv</a> <a id="6782" href="1Lab.Equiv.html#6782" class="Bound">x</a> <a id="6784" href="1Lab.Equiv.html#6784" class="Bound">i</a> <a id="6786" class="Symbol">=</a> <a id="6788" href="1Lab.Equiv.html#6778" class="Bound">eqv</a> <a id="6792" class="Symbol">.</a><a id="6793" href="1Lab.Equiv.html#2376" data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" class="Field">is-eqv</a> <a id="6800" class="Symbol">(</a><a id="6801" href="1Lab.Equiv.html#6775" class="Bound">f</a> <a id="6803" href="1Lab.Equiv.html#6782" class="Bound">x</a><a id="6804" class="Symbol">)</a> <a id="6806" class="Symbol">.</a><a id="6807" href="1Lab.HLevel.html#1416" data-type="(r : is-contr A) (x : A) → r .centre ≡ x" class="Field">paths</a> <a id="6813" class="Symbol">(</a><a id="6814" href="1Lab.Equiv.html#6782" class="Bound">x</a> <a id="6816" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="6818" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a><a id="6822" class="Symbol">)</a> <a id="6824" href="1Lab.Equiv.html#6784" class="Bound">i</a> <a id="6826" class="Symbol">.</a><a id="6827" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a>

<a id="equiv→zig"></a><a id="6832" href="1Lab.Equiv.html#6832" data-type="(eqv : is-equiv f) (x : A) →
ap f (equiv→unit eqv x) ≡ equiv→counit eqv (f x)" class="Function">equiv→zig</a>
  <a id="6844" class="Symbol">:</a> <a id="6846" class="Symbol">∀</a> <a id="6848" class="Symbol">{</a><a id="6849" href="1Lab.Equiv.html#6849" class="Bound">f</a> <a id="6851" class="Symbol">:</a> <a id="6853" href="1Lab.Equiv.html#1588" class="Generalizable">A</a> <a id="6855" class="Symbol">→</a> <a id="6857" href="1Lab.Equiv.html#1590" class="Generalizable">B</a><a id="6858" class="Symbol">}</a> <a id="6860" class="Symbol">(</a><a id="6861" href="1Lab.Equiv.html#6861" class="Bound">eqv</a> <a id="6865" class="Symbol">:</a> <a id="6867" href="1Lab.Equiv.html#2286" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-equiv</a> <a id="6876" href="1Lab.Equiv.html#6849" class="Bound">f</a><a id="6877" class="Symbol">)</a> <a id="6879" href="1Lab.Equiv.html#6879" class="Bound">x</a>
  <a id="6883" class="Symbol">→</a> <a id="6885" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="6888" href="1Lab.Equiv.html#6849" class="Bound">f</a> <a id="6890" class="Symbol">(</a><a id="6891" href="1Lab.Equiv.html#6679" data-type="(eqv : is-equiv f) (x : A) → equiv→inverse eqv (f x) ≡ x" class="Function">equiv→unit</a> <a id="6902" href="1Lab.Equiv.html#6861" class="Bound">eqv</a> <a id="6906" href="1Lab.Equiv.html#6879" class="Bound">x</a><a id="6907" class="Symbol">)</a> <a id="6909" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="6911" href="1Lab.Equiv.html#6548" data-type="(eqv : is-equiv f) (x : B₁) → f (equiv→inverse eqv x) ≡ x" class="Function">equiv→counit</a> <a id="6924" href="1Lab.Equiv.html#6861" class="Bound">eqv</a> <a id="6928" class="Symbol">(</a><a id="6929" href="1Lab.Equiv.html#6849" class="Bound">f</a> <a id="6931" href="1Lab.Equiv.html#6879" class="Bound">x</a><a id="6932" class="Symbol">)</a>
<a id="6934" href="1Lab.Equiv.html#6832" data-type="(eqv : is-equiv f) (x : A) →
ap f (equiv→unit eqv x) ≡ equiv→counit eqv (f x)" class="Function">equiv→zig</a> <a id="6944" class="Symbol">{</a><a id="6945" class="Argument">f</a> <a id="6947" class="Symbol">=</a> <a id="6949" href="1Lab.Equiv.html#6949" class="Bound">f</a><a id="6950" class="Symbol">}</a> <a id="6952" href="1Lab.Equiv.html#6952" class="Bound">eqv</a> <a id="6956" href="1Lab.Equiv.html#6956" class="Bound">x</a> <a id="6958" href="1Lab.Equiv.html#6958" class="Bound">i</a> <a id="6960" href="1Lab.Equiv.html#6960" class="Bound">j</a> <a id="6962" class="Symbol">=</a> <a id="6964" href="1Lab.Path.html#2368" class="Primitive">hcomp</a>
  <a id="6972" class="Symbol">(λ</a> <a id="6975" class="Symbol">{</a> <a id="6977" href="1Lab.Equiv.html#6977" class="Bound">k</a> <a id="6979" class="Symbol">(</a><a id="6980" href="1Lab.Equiv.html#6958" class="Bound">i</a> <a id="6982" class="Symbol">=</a> <a id="6984" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="6986" class="Symbol">)</a> <a id="6988" class="Symbol">→</a> <a id="6990" href="1Lab.Equiv.html#6949" class="Bound">f</a> <a id="6992" class="Symbol">(</a><a id="6993" href="1Lab.Equiv.html#6679" data-type="(eqv : is-equiv f) (x : A) → equiv→inverse eqv (f x) ≡ x" class="Function">equiv→unit</a> <a id="7004" href="1Lab.Equiv.html#6952" class="Bound">eqv</a> <a id="7008" href="1Lab.Equiv.html#6956" class="Bound">x</a> <a id="7010" href="1Lab.Equiv.html#6960" class="Bound">j</a><a id="7011" class="Symbol">)</a>
     <a id="7018" class="Symbol">;</a> <a id="7020" href="1Lab.Equiv.html#7020" class="Bound">k</a> <a id="7022" class="Symbol">(</a><a id="7023" href="1Lab.Equiv.html#6958" class="Bound">i</a> <a id="7025" class="Symbol">=</a> <a id="7027" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="7029" class="Symbol">)</a> <a id="7031" class="Symbol">→</a> <a id="7033" href="1Lab.Equiv.html#6548" data-type="(eqv : is-equiv f) (x : B₁) → f (equiv→inverse eqv x) ≡ x" class="Function">equiv→counit</a> <a id="7046" href="1Lab.Equiv.html#6952" class="Bound">eqv</a> <a id="7050" class="Symbol">(</a><a id="7051" href="1Lab.Equiv.html#6949" class="Bound">f</a> <a id="7053" href="1Lab.Equiv.html#6956" class="Bound">x</a><a id="7054" class="Symbol">)</a> <a id="7056" class="Symbol">(</a><a id="7057" href="1Lab.Equiv.html#6960" class="Bound">j</a> <a id="7059" href="1Lab.Path.html#2226" class="Primitive Operator">∨</a> <a id="7061" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="7063" href="1Lab.Equiv.html#7020" class="Bound">k</a><a id="7064" class="Symbol">)</a>
     <a id="7071" class="Symbol">;</a> <a id="7073" href="1Lab.Equiv.html#7073" class="Bound">k</a> <a id="7075" class="Symbol">(</a><a id="7076" href="1Lab.Equiv.html#6960" class="Bound">j</a> <a id="7078" class="Symbol">=</a> <a id="7080" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="7082" class="Symbol">)</a> <a id="7084" class="Symbol">→</a> <a id="7086" href="1Lab.Equiv.html#6548" data-type="(eqv : is-equiv f) (x : B₁) → f (equiv→inverse eqv x) ≡ x" class="Function">equiv→counit</a> <a id="7099" href="1Lab.Equiv.html#6952" class="Bound">eqv</a> <a id="7103" class="Symbol">(</a><a id="7104" href="1Lab.Equiv.html#6949" class="Bound">f</a> <a id="7106" href="1Lab.Equiv.html#6956" class="Bound">x</a><a id="7107" class="Symbol">)</a> <a id="7109" class="Symbol">(</a><a id="7110" href="1Lab.Equiv.html#6958" class="Bound">i</a> <a id="7112" href="1Lab.Path.html#2191" class="Primitive Operator">∧</a> <a id="7114" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="7116" href="1Lab.Equiv.html#7073" class="Bound">k</a><a id="7117" class="Symbol">)</a>
     <a id="7124" class="Symbol">;</a> <a id="7126" href="1Lab.Equiv.html#7126" class="Bound">k</a> <a id="7128" class="Symbol">(</a><a id="7129" href="1Lab.Equiv.html#6960" class="Bound">j</a> <a id="7131" class="Symbol">=</a> <a id="7133" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="7135" class="Symbol">)</a> <a id="7137" class="Symbol">→</a> <a id="7139" href="1Lab.Equiv.html#6949" class="Bound">f</a> <a id="7141" href="1Lab.Equiv.html#6956" class="Bound">x</a>
     <a id="7148" class="Symbol">})</a>
  <a id="7153" class="Symbol">(</a><a id="7154" href="1Lab.Equiv.html#6952" class="Bound">eqv</a> <a id="7158" class="Symbol">.</a><a id="7159" href="1Lab.Equiv.html#2376" data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" class="Field">is-eqv</a> <a id="7166" class="Symbol">(</a><a id="7167" href="1Lab.Equiv.html#6949" class="Bound">f</a> <a id="7169" href="1Lab.Equiv.html#6956" class="Bound">x</a><a id="7170" class="Symbol">)</a> <a id="7172" class="Symbol">.</a><a id="7173" href="1Lab.HLevel.html#1416" data-type="(r : is-contr A) (x : A) → r .centre ≡ x" class="Field">paths</a> <a id="7179" class="Symbol">(</a><a id="7180" href="1Lab.Equiv.html#6956" class="Bound">x</a> <a id="7182" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="7184" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a><a id="7188" class="Symbol">)</a> <a id="7190" href="1Lab.Equiv.html#6960" class="Bound">j</a> <a id="7192" class="Symbol">.</a><a id="7193" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="7197" href="1Lab.Equiv.html#6958" class="Bound">i</a><a id="7198" class="Symbol">)</a>

<a id="is-equiv→is-iso"></a><a id="7201" href="1Lab.Equiv.html#7201" data-type="is-equiv f → is-iso f" class="Function">is-equiv→is-iso</a> <a id="7217" class="Symbol">:</a> <a id="7219" class="Symbol">{</a><a id="7220" href="1Lab.Equiv.html#7220" class="Bound">f</a> <a id="7222" class="Symbol">:</a> <a id="7224" href="1Lab.Equiv.html#1588" class="Generalizable">A</a> <a id="7226" class="Symbol">→</a> <a id="7228" href="1Lab.Equiv.html#1590" class="Generalizable">B</a><a id="7229" class="Symbol">}</a> <a id="7231" class="Symbol">→</a> <a id="7233" href="1Lab.Equiv.html#2286" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-equiv</a> <a id="7242" href="1Lab.Equiv.html#7220" class="Bound">f</a> <a id="7244" class="Symbol">→</a> <a id="7246" href="1Lab.Equiv.html#6026" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-iso</a> <a id="7253" href="1Lab.Equiv.html#7220" class="Bound">f</a>
<a id="7255" href="1Lab.Equiv.html#6132" data-type="is-iso f → B₁ → A" class="Field">is-iso.inv</a> <a id="7266" class="Symbol">(</a><a id="7267" href="1Lab.Equiv.html#7201" data-type="is-equiv f → is-iso f" class="Function">is-equiv→is-iso</a> <a id="7283" href="1Lab.Equiv.html#7283" class="Bound">eqv</a><a id="7286" class="Symbol">)</a> <a id="7288" class="Symbol">=</a> <a id="7290" href="1Lab.Equiv.html#6449" data-type="is-equiv f → B₁ → A" class="Function">equiv→inverse</a> <a id="7304" href="1Lab.Equiv.html#7283" class="Bound">eqv</a>
</pre>
<p>We can get an element of <code>x</code> from the proof that
<code>f</code> is an equivalence - it’s the point of <code>A</code>
mapped to <code>y</code>, which we get from centre of contraction for
the fibres of <code>f</code> over <code>y</code>.</p>
<pre class="Agda"><a id="7504" href="1Lab.Equiv.html#6148" data-type="(r : is-iso f) → is-right-inverse (r .inv) f" class="Field">is-iso.rinv</a> <a id="7516" class="Symbol">(</a><a id="7517" href="1Lab.Equiv.html#7201" data-type="is-equiv f → is-iso f" class="Function">is-equiv→is-iso</a> <a id="7533" href="1Lab.Equiv.html#7533" class="Bound">eqv</a><a id="7536" class="Symbol">)</a> <a id="7538" href="1Lab.Equiv.html#7538" class="Bound">y</a> <a id="7540" class="Symbol">=</a>
  <a id="7544" href="1Lab.Equiv.html#7533" class="Bound">eqv</a> <a id="7548" class="Symbol">.</a><a id="7549" href="1Lab.Equiv.html#2376" data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" class="Field">is-eqv</a> <a id="7556" href="1Lab.Equiv.html#7538" class="Bound">y</a> <a id="7558" class="Symbol">.</a><a id="7559" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a> <a id="7566" class="Symbol">.</a><a id="7567" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a>
</pre>
<p>Similarly, that one fibre gives us a proof that the function above is
a right inverse to <code>f</code>.</p>
<pre class="Agda"><a id="7679" href="1Lab.Equiv.html#6182" data-type="(r : is-iso f) → is-left-inverse (r .inv) f" class="Field">is-iso.linv</a> <a id="7691" class="Symbol">(</a><a id="7692" href="1Lab.Equiv.html#7201" data-type="is-equiv f → is-iso f" class="Function">is-equiv→is-iso</a> <a id="7708" class="Symbol">{</a><a id="7709" class="Argument">f</a> <a id="7711" class="Symbol">=</a> <a id="7713" href="1Lab.Equiv.html#7713" class="Bound">f</a><a id="7714" class="Symbol">}</a> <a id="7716" href="1Lab.Equiv.html#7716" class="Bound">eqv</a><a id="7719" class="Symbol">)</a> <a id="7721" href="1Lab.Equiv.html#7721" class="Bound">x</a> <a id="7723" href="1Lab.Equiv.html#7723" class="Bound">i</a> <a id="7725" class="Symbol">=</a>
  <a id="7729" href="1Lab.Equiv.html#7716" class="Bound">eqv</a> <a id="7733" class="Symbol">.</a><a id="7734" href="1Lab.Equiv.html#2376" data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" class="Field">is-eqv</a> <a id="7741" class="Symbol">(</a><a id="7742" href="1Lab.Equiv.html#7713" class="Bound">f</a> <a id="7744" href="1Lab.Equiv.html#7721" class="Bound">x</a><a id="7745" class="Symbol">)</a> <a id="7747" class="Symbol">.</a><a id="7748" href="1Lab.HLevel.html#1416" data-type="(r : is-contr A) (x : A) → r .centre ≡ x" class="Field">paths</a> <a id="7754" class="Symbol">(</a><a id="7755" href="1Lab.Equiv.html#7721" class="Bound">x</a> <a id="7757" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="7759" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a><a id="7763" class="Symbol">)</a> <a id="7765" href="1Lab.Equiv.html#7723" class="Bound">i</a> <a id="7767" class="Symbol">.</a><a id="7768" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a>
</pre>
<p>The proof that the function is a <em>left</em> inverse comes from the
fibres of <code>f</code> over <code>y</code> being contractible. Since
we have a fibre - namely, <code>f</code> maps <code>x</code> to
<code>f x</code> by
<span class="Agda"><a href="1Lab.Path.html#3593" class="Function">refl</a></span>
- we can get any other we want!</p>
<h1 id="equivalences-from-isomorphisms"><a href="#equivalences-from-isomorphisms" class="header-link">Equivalences
from isomorphisms<span class="header-link-emoji">🔗</span></a></h1>
<p>Any isomorphism can be upgraded into an equivalence, in a way that
preserves the function
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>,</span>
its inverse
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span>,</span>
<em>and</em> the proof
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span>
that
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span>
is a right inverse to
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>.</span>
We can not preserve <em>everything</em>, though, as is usual when making
something “more coherent”. Furthermore, if everything was preserved,
<span class="Agda"><a href="1Lab.Equiv.html#6026" class="Record">is-iso</a></span>
would be a proposition, and this is <a href="1Lab.Counterexamples.IsIso.html">provably not the case</a>.</p>
<p>The argument presented here is done directly in cubical style, but a
less direct proof is also available, by showing that every isomorphism
is a <a href="1Lab.Equiv.HalfAdjoint.html">half-adjoint equivalence</a>,
and that half-adjoint equivalences have contractible fibres.</p>
<pre class="Agda"><a id="8760" class="Keyword">module</a> <a id="8767" href="1Lab.Equiv.html#8767" class="Module">_</a> <a id="8769" class="Symbol">{</a><a id="8770" href="1Lab.Equiv.html#8770" class="Bound">f</a> <a id="8772" class="Symbol">:</a> <a id="8774" href="1Lab.Equiv.html#1588" class="Generalizable">A</a> <a id="8776" class="Symbol">→</a> <a id="8778" href="1Lab.Equiv.html#1590" class="Generalizable">B</a><a id="8779" class="Symbol">}</a> <a id="8781" class="Symbol">(</a><a id="8782" href="1Lab.Equiv.html#8782" class="Bound">i</a> <a id="8784" class="Symbol">:</a> <a id="8786" href="1Lab.Equiv.html#6026" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-iso</a> <a id="8793" href="1Lab.Equiv.html#8770" class="Bound">f</a><a id="8794" class="Symbol">)</a> <a id="8796" class="Keyword">where</a>

  <a id="8805" class="Keyword">open</a> <a id="8810" href="1Lab.Equiv.html#6026" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Module">is-iso</a> <a id="8817" href="1Lab.Equiv.html#8782" class="Bound">i</a> <a id="8819" class="Keyword">renaming</a> <a id="8828" class="Symbol">(</a> <a id="8830" href="1Lab.Equiv.html#6132" data-type="is-iso f → B₁ → A" class="Field">inv</a> <a id="8834" class="Symbol">to</a> <a id="8837" class="Field">g</a>
                         <a id="8864" class="Symbol">;</a> <a id="8866" href="1Lab.Equiv.html#6148" data-type="(r : is-iso f) → is-right-inverse (r .inv) f" class="Field">rinv</a> <a id="8871" class="Symbol">to</a> <a id="8874" class="Field">s</a>
                         <a id="8901" class="Symbol">;</a> <a id="8903" href="1Lab.Equiv.html#6182" data-type="(r : is-iso f) → is-left-inverse (r .inv) f" class="Field">linv</a> <a id="8908" class="Symbol">to</a> <a id="8911" class="Field">t</a>
                         <a id="8938" class="Symbol">)</a>
</pre>
<p>Suppose, then, that
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">f : A \to B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>
and
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>:</mo><mi>B</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">g : B \to A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>,</span>
and we’re given witnesses
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>:</mo><mi>f</mi><mo stretchy="false">(</mo><mi>g</mi><mtext> </mtext><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">s : f (g\ x) = x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>
and
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>:</mo><mi>g</mi><mo stretchy="false">(</mo><mi>f</mi><mtext> </mtext><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">t : g (f\ x) = x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace"> </span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>
(named for <strong>s</strong>ection and re<strong>t</strong>raction)
that
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>
and
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span>
are inverses. We want to show that, for any
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>,</span>
the
<span class="Agda"><a href="1Lab.Equiv.html#1873" class="Function">fibre</a></span>
of
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>
over
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>
is contractible. It suffices to show that the fibre is propositional,
and that it is inhabited.</p>
<p>We begin with showing that the fibre over
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>
is propositional, since that’s the harder of the two arguments. Suppose
that we have
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>,</span>
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">x_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,</span>
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,</span>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">p_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
and
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">p_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
as below; Note that
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>p</mi><mn>0</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x_0, p_0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>
and
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>p</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x_1, p_1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>
are fibres of
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>
over
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>.</span>
What we need to show is that we have some
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo>:</mo><msub><mi>x</mi><mn>0</mn></msub><mo>≡</mo><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\pi : x_0 ≡ x_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6138em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
and
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>0</mn></msub><mo>≡</mo><msub><mi>p</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">p_0 ≡ p_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6582em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
<em><code class="sourceCode agda" data-ident="PathP">over</code></em>
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span>.</span></p>
<pre class="Agda">  <a id="9673" class="Keyword">private</a> <a id="9681" class="Keyword">module</a> <a id="9688" href="1Lab.Equiv.html#9688" class="Module">_</a> <a id="9690" class="Symbol">(</a><a id="9691" href="1Lab.Equiv.html#9691" class="Bound">y</a> <a id="9693" class="Symbol">:</a> <a id="9695" href="1Lab.Equiv.html#8778" class="Bound">B</a><a id="9696" class="Symbol">)</a> <a id="9698" class="Symbol">(</a><a id="9699" href="1Lab.Equiv.html#9699" class="Bound">x0</a> <a id="9702" href="1Lab.Equiv.html#9702" class="Bound">x1</a> <a id="9705" class="Symbol">:</a> <a id="9707" href="1Lab.Equiv.html#8774" class="Bound">A</a><a id="9708" class="Symbol">)</a> <a id="9710" class="Symbol">(</a><a id="9711" href="1Lab.Equiv.html#9711" class="Bound">p0</a> <a id="9714" class="Symbol">:</a> <a id="9716" href="1Lab.Equiv.html#8770" class="Bound">f</a> <a id="9718" href="1Lab.Equiv.html#9699" class="Bound">x0</a> <a id="9721" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="9723" href="1Lab.Equiv.html#9691" class="Bound">y</a><a id="9724" class="Symbol">)</a> <a id="9726" class="Symbol">(</a><a id="9727" href="1Lab.Equiv.html#9727" class="Bound">p1</a> <a id="9730" class="Symbol">:</a> <a id="9732" href="1Lab.Equiv.html#8770" class="Bound">f</a> <a id="9734" href="1Lab.Equiv.html#9702" class="Bound">x1</a> <a id="9737" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="9739" href="1Lab.Equiv.html#9691" class="Bound">y</a><a id="9740" class="Symbol">)</a> <a id="9742" class="Keyword">where</a>
</pre>
<p>As an intermediate step in proving that
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>0</mn></msub><mo>≡</mo><msub><mi>p</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">p_0 ≡ p_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6582em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,</span>
we <em>must</em> show that
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub><mo>≡</mo><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_0 ≡ x_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6138em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
- without this, we can’t even <em>state</em> that
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">p_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
and
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">p_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
are identified, since they live in different types! To this end, we will
build
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo>:</mo><msub><mi>p</mi><mn>0</mn></msub><mo>≡</mo><msub><mi>p</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\pi : p_0 ≡ p_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6582em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,</span>
parts of which will be required to assemble the overall proof that
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>0</mn></msub><mo>≡</mo><msub><mi>p</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">p_0 ≡ p_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6582em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</span></p>
<p>We’ll detail the construction of
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\pi_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>;</span>
for
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\pi_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,</span>
the same method is used. We want to construct a <em>line</em>, which we
can do by exhibiting that line as the missing face in a <em>square</em>.
We have equations
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mtext> </mtext><mi>y</mi><mo>≡</mo><mi>g</mi><mtext> </mtext><mi>y</mi></mrow><annotation encoding="application/x-tex">g\ y ≡ g\ y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6582em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>
(<span class="Agda"><a href="1Lab.Path.html#3593" class="Function">refl</a></span>),
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>f</mi><mtext> </mtext><msub><mi>x</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mo>≡</mo><mi>g</mi><mtext> </mtext><mi>y</mi></mrow><annotation encoding="application/x-tex">g\ (f\ x_0) ≡ g\ y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace"> </span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>
(the action of <code>g</code> on <code>p0</code>), and
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>f</mi><mtext> </mtext><msub><mi>x</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mo>=</mo><msub><mi>x</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">g\ (f\ x_0) = x_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace"> </span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
by the assumption that
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span>
is a right inverse to
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>.</span>
Diagramatically, these fit together into a square:</p>
<div class="diagram-container">
<img src="light-193afca482e4eaf959452d27288a9c224bb0eaf2.svg" title="commutative diagram" class="diagram diagram-light quiver" />
<img src="dark-193afca482e4eaf959452d27288a9c224bb0eaf2.svg" title="commutative diagram" class="diagram diagram-dark quiver" />
</div>
<p>The missing line in this square is
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\pi_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</span>
Since the <em>inside</em> (the
<span class="Agda"><a href="1Lab.Path.html#35481" class="Function">filler</a></span>)
will be useful to us later, we also give it a name:
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span>.</span></p>
<pre class="Agda">    <a id="11096" href="1Lab.Equiv.html#11096" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
inv i y ≡ x0" class="Function">π₀</a> <a id="11099" class="Symbol">:</a> <a id="11101" href="1Lab.Equiv.html#8837" class="Field">g</a> <a id="11103" href="1Lab.Equiv.html#9691" class="Bound">y</a> <a id="11105" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="11107" href="1Lab.Equiv.html#9699" class="Bound">x0</a>
    <a id="11114" href="1Lab.Equiv.html#11096" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
inv i y ≡ x0" class="Function">π₀</a> <a id="11117" href="1Lab.Equiv.html#11117" class="Bound">i</a> <a id="11119" class="Symbol">=</a> <a id="11121" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="11127" class="Symbol">(λ</a> <a id="11130" href="1Lab.Equiv.html#11130" class="Bound">k</a> <a id="11132" class="Symbol">→</a> <a id="11134" class="Symbol">λ</a> <a id="11136" class="Symbol">{</a> <a id="11138" class="Symbol">(</a><a id="11139" href="1Lab.Equiv.html#11117" class="Bound">i</a> <a id="11141" class="Symbol">=</a> <a id="11143" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="11145" class="Symbol">)</a> <a id="11147" class="Symbol">→</a> <a id="11149" href="1Lab.Equiv.html#8837" class="Field">g</a> <a id="11151" href="1Lab.Equiv.html#9691" class="Bound">y</a>
                          <a id="11179" class="Symbol">;</a> <a id="11181" class="Symbol">(</a><a id="11182" href="1Lab.Equiv.html#11117" class="Bound">i</a> <a id="11184" class="Symbol">=</a> <a id="11186" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="11188" class="Symbol">)</a> <a id="11190" class="Symbol">→</a> <a id="11192" href="1Lab.Equiv.html#8911" class="Field">t</a> <a id="11194" href="1Lab.Equiv.html#9699" class="Bound">x0</a> <a id="11197" href="1Lab.Equiv.html#11130" class="Bound">k</a>
                          <a id="11225" class="Symbol">})</a>
                    <a id="11248" class="Symbol">(</a><a id="11249" href="1Lab.Equiv.html#8837" class="Field">g</a> <a id="11251" class="Symbol">(</a><a id="11252" href="1Lab.Equiv.html#9711" class="Bound">p0</a> <a id="11255" class="Symbol">(</a><a id="11256" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="11258" href="1Lab.Equiv.html#11117" class="Bound">i</a><a id="11259" class="Symbol">)))</a>

    <a id="11268" href="1Lab.Equiv.html#11268" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
Square (ap (inv i) (sym p0)) refl (linv i x0) (π₀ i y x0 x1 p0 p1)" class="Function">θ₀</a> <a id="11271" class="Symbol">:</a> <a id="11273" href="1Lab.Path.html#9409" data-type="a00 ≡ a01 → a00 ≡ a10 → a01 ≡ a11 → a10 ≡ a11 → Type ℓ" class="Function">Square</a> <a id="11280" class="Symbol">(</a><a id="11281" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="11284" href="1Lab.Equiv.html#8837" class="Field">g</a> <a id="11286" class="Symbol">(</a><a id="11287" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="11291" href="1Lab.Equiv.html#9711" class="Bound">p0</a><a id="11293" class="Symbol">))</a> <a id="11296" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="11301" class="Symbol">(</a><a id="11302" href="1Lab.Equiv.html#8911" class="Field">t</a> <a id="11304" href="1Lab.Equiv.html#9699" class="Bound">x0</a><a id="11306" class="Symbol">)</a> <a id="11308" href="1Lab.Equiv.html#11096" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
inv i y ≡ x0" class="Function">π₀</a>
    <a id="11315" href="1Lab.Equiv.html#11268" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
Square (ap (inv i) (sym p0)) refl (linv i x0) (π₀ i y x0 x1 p0 p1)" class="Function">θ₀</a> <a id="11318" href="1Lab.Equiv.html#11318" class="Bound">i</a> <a id="11320" href="1Lab.Equiv.html#11320" class="Bound">j</a> <a id="11322" class="Symbol">=</a> <a id="11324" href="1Lab.Path.html#35481" data-type="(u : I → Partial φ A) (u0 : A [ φ ↦ u i0 ]) →
outS u0 ≡ hcomp u (outS u0)" class="Function">hfill</a> <a id="11330" class="Symbol">(λ</a> <a id="11333" href="1Lab.Equiv.html#11333" class="Bound">k</a> <a id="11335" class="Symbol">→</a> <a id="11337" class="Symbol">λ</a> <a id="11339" class="Symbol">{</a> <a id="11341" class="Symbol">(</a><a id="11342" href="1Lab.Equiv.html#11318" class="Bound">i</a> <a id="11344" class="Symbol">=</a> <a id="11346" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="11348" class="Symbol">)</a> <a id="11350" class="Symbol">→</a> <a id="11352" href="1Lab.Equiv.html#8837" class="Field">g</a> <a id="11354" href="1Lab.Equiv.html#9691" class="Bound">y</a>
                            <a id="11384" class="Symbol">;</a> <a id="11386" class="Symbol">(</a><a id="11387" href="1Lab.Equiv.html#11318" class="Bound">i</a> <a id="11389" class="Symbol">=</a> <a id="11391" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="11393" class="Symbol">)</a> <a id="11395" class="Symbol">→</a> <a id="11397" href="1Lab.Equiv.html#8911" class="Field">t</a> <a id="11399" href="1Lab.Equiv.html#9699" class="Bound">x0</a> <a id="11402" href="1Lab.Equiv.html#11333" class="Bound">k</a>
                            <a id="11432" class="Symbol">})</a>
                   <a id="11454" class="Symbol">(</a><a id="11455" href="1Lab.Path.html#2069" class="Postulate">inS</a> <a id="11459" class="Symbol">(</a><a id="11460" href="1Lab.Equiv.html#8837" class="Field">g</a> <a id="11462" class="Symbol">(</a><a id="11463" href="1Lab.Equiv.html#9711" class="Bound">p0</a> <a id="11466" class="Symbol">(</a><a id="11467" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="11469" href="1Lab.Equiv.html#11318" class="Bound">i</a><a id="11470" class="Symbol">))))</a> <a id="11475" href="1Lab.Equiv.html#11320" class="Bound">j</a>
</pre>
<p>Since the construction of
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\pi_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
is analogous, I’ll simply present the square. We correspondingly name
the missing face
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\pi_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
and the filler
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>θ</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\theta_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</span></p>
<div class="mathpar">
<div class="diagram-container">
<img src="light-7b944591e80866a5b04179d5ec65b925a6e46ba7.svg" title="commutative diagram" class="diagram diagram-light quiver" />
<img src="dark-7b944591e80866a5b04179d5ec65b925a6e46ba7.svg" title="commutative diagram" class="diagram diagram-dark quiver" />
</div>
<pre class="Agda">    <a id="12103" href="1Lab.Equiv.html#12103" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
inv i y ≡ x1" class="Function">π₁</a> <a id="12106" class="Symbol">:</a> <a id="12108" href="1Lab.Equiv.html#8837" class="Field">g</a> <a id="12110" href="1Lab.Equiv.html#9691" class="Bound">y</a> <a id="12112" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="12114" href="1Lab.Equiv.html#9702" class="Bound">x1</a>
    <a id="12121" href="1Lab.Equiv.html#12103" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
inv i y ≡ x1" class="Function">π₁</a> <a id="12124" href="1Lab.Equiv.html#12124" class="Bound">i</a> <a id="12126" class="Symbol">=</a> <a id="12128" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="12134" class="Symbol">(λ</a> <a id="12137" href="1Lab.Equiv.html#12137" class="Bound">k</a> <a id="12139" class="Symbol">→</a> <a id="12141" class="Symbol">λ</a> <a id="12143" class="Symbol">{</a> <a id="12145" class="Symbol">(</a><a id="12146" href="1Lab.Equiv.html#12124" class="Bound">i</a> <a id="12148" class="Symbol">=</a> <a id="12150" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="12152" class="Symbol">)</a> <a id="12154" class="Symbol">→</a> <a id="12156" href="1Lab.Equiv.html#8837" class="Field">g</a> <a id="12158" href="1Lab.Equiv.html#9691" class="Bound">y</a>
                          <a id="12186" class="Symbol">;</a> <a id="12188" class="Symbol">(</a><a id="12189" href="1Lab.Equiv.html#12124" class="Bound">i</a> <a id="12191" class="Symbol">=</a> <a id="12193" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="12195" class="Symbol">)</a> <a id="12197" class="Symbol">→</a> <a id="12199" href="1Lab.Equiv.html#8911" class="Field">t</a> <a id="12201" href="1Lab.Equiv.html#9702" class="Bound">x1</a> <a id="12204" href="1Lab.Equiv.html#12137" class="Bound">k</a>
                          <a id="12232" class="Symbol">})</a>
                    <a id="12255" class="Symbol">(</a><a id="12256" href="1Lab.Equiv.html#8837" class="Field">g</a> <a id="12258" class="Symbol">(</a><a id="12259" href="1Lab.Equiv.html#9727" class="Bound">p1</a> <a id="12262" class="Symbol">(</a><a id="12263" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="12265" href="1Lab.Equiv.html#12124" class="Bound">i</a><a id="12266" class="Symbol">)))</a>

    <a id="12275" href="1Lab.Equiv.html#12275" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
Square (ap (inv i) (sym p1)) refl (linv i x1) (π₁ i y x0 x1 p0 p1)" class="Function">θ₁</a> <a id="12278" class="Symbol">:</a> <a id="12280" href="1Lab.Path.html#9409" data-type="a00 ≡ a01 → a00 ≡ a10 → a01 ≡ a11 → a10 ≡ a11 → Type ℓ" class="Function">Square</a> <a id="12287" class="Symbol">(</a><a id="12288" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="12291" href="1Lab.Equiv.html#8837" class="Field">g</a> <a id="12293" class="Symbol">(</a><a id="12294" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="12298" href="1Lab.Equiv.html#9727" class="Bound">p1</a><a id="12300" class="Symbol">))</a> <a id="12303" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="12308" class="Symbol">(</a><a id="12309" href="1Lab.Equiv.html#8911" class="Field">t</a> <a id="12311" href="1Lab.Equiv.html#9702" class="Bound">x1</a><a id="12313" class="Symbol">)</a> <a id="12315" href="1Lab.Equiv.html#12103" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
inv i y ≡ x1" class="Function">π₁</a>
    <a id="12322" href="1Lab.Equiv.html#12275" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
Square (ap (inv i) (sym p1)) refl (linv i x1) (π₁ i y x0 x1 p0 p1)" class="Function">θ₁</a> <a id="12325" href="1Lab.Equiv.html#12325" class="Bound">i</a> <a id="12327" href="1Lab.Equiv.html#12327" class="Bound">j</a> <a id="12329" class="Symbol">=</a> <a id="12331" href="1Lab.Path.html#35481" data-type="(u : I → Partial φ A) (u0 : A [ φ ↦ u i0 ]) →
outS u0 ≡ hcomp u (outS u0)" class="Function">hfill</a> <a id="12337" class="Symbol">(λ</a> <a id="12340" href="1Lab.Equiv.html#12340" class="Bound">k</a> <a id="12342" class="Symbol">→</a> <a id="12344" class="Symbol">λ</a> <a id="12346" class="Symbol">{</a> <a id="12348" class="Symbol">(</a><a id="12349" href="1Lab.Equiv.html#12325" class="Bound">i</a> <a id="12351" class="Symbol">=</a> <a id="12353" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="12355" class="Symbol">)</a> <a id="12357" class="Symbol">→</a> <a id="12359" href="1Lab.Equiv.html#8837" class="Field">g</a> <a id="12361" href="1Lab.Equiv.html#9691" class="Bound">y</a>
                            <a id="12391" class="Symbol">;</a> <a id="12393" class="Symbol">(</a><a id="12394" href="1Lab.Equiv.html#12325" class="Bound">i</a> <a id="12396" class="Symbol">=</a> <a id="12398" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="12400" class="Symbol">)</a> <a id="12402" class="Symbol">→</a> <a id="12404" href="1Lab.Equiv.html#8911" class="Field">t</a> <a id="12406" href="1Lab.Equiv.html#9702" class="Bound">x1</a> <a id="12409" href="1Lab.Equiv.html#12340" class="Bound">k</a>
                            <a id="12439" class="Symbol">})</a>
                      <a id="12464" class="Symbol">(</a><a id="12465" href="1Lab.Path.html#2069" class="Postulate">inS</a> <a id="12469" class="Symbol">(</a><a id="12470" href="1Lab.Equiv.html#8837" class="Field">g</a> <a id="12472" class="Symbol">(</a><a id="12473" href="1Lab.Equiv.html#9727" class="Bound">p1</a> <a id="12476" class="Symbol">(</a><a id="12477" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="12479" href="1Lab.Equiv.html#12325" class="Bound">i</a><a id="12480" class="Symbol">))))</a> <a id="12485" href="1Lab.Equiv.html#12327" class="Bound">j</a>
</pre>
</div>
<p>Joining these paths by their common
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mtext> </mtext><mi>y</mi></mrow><annotation encoding="application/x-tex">g\ y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>
face, we obtain
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo>:</mo><msub><mi>x</mi><mn>0</mn></msub><mo>≡</mo><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\pi : x_0 ≡ x_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6138em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</span>
This square <em>also</em> has a filler, connecting
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\pi_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
and
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\pi_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
over the line
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mtext> </mtext><mi>y</mi><mo>≡</mo><mi>π</mi><mtext> </mtext><mi>i</mi></mrow><annotation encoding="application/x-tex">g\ y ≡ \pi\ i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6582em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mspace"> </span><span class="mord mathnormal">i</span></span></span></span>.</span></p>
<div class="mathpar">
<div class="diagram-container">
<img src="light-696d9aa257c82c2ac2da8bebd91fc997e3206334.svg" title="commutative diagram" class="diagram diagram-light quiver" />
<img src="dark-696d9aa257c82c2ac2da8bebd91fc997e3206334.svg" title="commutative diagram" class="diagram diagram-dark quiver" />
</div>
<pre class="Agda">    <a id="13111" href="1Lab.Equiv.html#13111" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
x0 ≡ x1" class="Function">π</a> <a id="13113" class="Symbol">:</a> <a id="13115" href="1Lab.Equiv.html#9699" class="Bound">x0</a> <a id="13118" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="13120" href="1Lab.Equiv.html#9702" class="Bound">x1</a>
    <a id="13127" href="1Lab.Equiv.html#13111" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
x0 ≡ x1" class="Function">π</a> <a id="13129" href="1Lab.Equiv.html#13129" class="Bound">i</a> <a id="13131" class="Symbol">=</a> <a id="13133" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="13139" class="Symbol">(λ</a> <a id="13142" href="1Lab.Equiv.html#13142" class="Bound">k</a> <a id="13144" class="Symbol">→</a> <a id="13146" class="Symbol">λ</a> <a id="13148" class="Symbol">{</a> <a id="13150" class="Symbol">(</a><a id="13151" href="1Lab.Equiv.html#13129" class="Bound">i</a> <a id="13153" class="Symbol">=</a> <a id="13155" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="13157" class="Symbol">)</a> <a id="13159" class="Symbol">→</a> <a id="13161" href="1Lab.Equiv.html#11096" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
inv i y ≡ x0" class="Function">π₀</a> <a id="13164" href="1Lab.Equiv.html#13142" class="Bound">k</a>
                         <a id="13191" class="Symbol">;</a> <a id="13193" class="Symbol">(</a><a id="13194" href="1Lab.Equiv.html#13129" class="Bound">i</a> <a id="13196" class="Symbol">=</a> <a id="13198" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="13200" class="Symbol">)</a> <a id="13202" class="Symbol">→</a> <a id="13204" href="1Lab.Equiv.html#12103" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
inv i y ≡ x1" class="Function">π₁</a> <a id="13207" href="1Lab.Equiv.html#13142" class="Bound">k</a>
                         <a id="13234" class="Symbol">})</a>
                <a id="13253" class="Symbol">(</a><a id="13254" href="1Lab.Equiv.html#8837" class="Field">g</a> <a id="13256" href="1Lab.Equiv.html#9691" class="Bound">y</a><a id="13257" class="Symbol">)</a>
</pre>
</div>
<p>This concludes the construction of
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span>,</span>
and thus, the 2D part of the proof. Now, we want to show that
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>0</mn></msub><mo>≡</mo><msub><mi>p</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">p_0 ≡ p_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6582em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
over a path induced by
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span>.</span>
This is a <em>square</em> with a specific boundary, which can be built
by constructing an appropriate <em>open cube</em>, where the missing
face is that square. As an intermediate step, we define
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span>
to be the filler for the square above.</p>
<pre class="Agda">    <a id="13660" href="1Lab.Equiv.html#13660" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
Square refl (π₀ i y x0 x1 p0 p1) (π₁ i y x0 x1 p0 p1)
(π i y x0 x1 p0 p1)" class="Function">θ</a> <a id="13662" class="Symbol">:</a> <a id="13664" href="1Lab.Path.html#9409" data-type="a00 ≡ a01 → a00 ≡ a10 → a01 ≡ a11 → a10 ≡ a11 → Type ℓ" class="Function">Square</a> <a id="13671" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="13676" href="1Lab.Equiv.html#11096" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
inv i y ≡ x0" class="Function">π₀</a> <a id="13679" href="1Lab.Equiv.html#12103" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
inv i y ≡ x1" class="Function">π₁</a> <a id="13682" href="1Lab.Equiv.html#13111" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
x0 ≡ x1" class="Function">π</a>
    <a id="13688" href="1Lab.Equiv.html#13660" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
Square refl (π₀ i y x0 x1 p0 p1) (π₁ i y x0 x1 p0 p1)
(π i y x0 x1 p0 p1)" class="Function">θ</a> <a id="13690" href="1Lab.Equiv.html#13690" class="Bound">i</a> <a id="13692" href="1Lab.Equiv.html#13692" class="Bound">j</a> <a id="13694" class="Symbol">=</a> <a id="13696" href="1Lab.Path.html#35481" data-type="(u : I → Partial φ A) (u0 : A [ φ ↦ u i0 ]) →
outS u0 ≡ hcomp u (outS u0)" class="Function">hfill</a> <a id="13702" class="Symbol">(λ</a> <a id="13705" href="1Lab.Equiv.html#13705" class="Bound">k</a> <a id="13707" class="Symbol">→</a> <a id="13709" class="Symbol">λ</a> <a id="13711" class="Symbol">{</a> <a id="13713" class="Symbol">(</a><a id="13714" href="1Lab.Equiv.html#13690" class="Bound">i</a> <a id="13716" class="Symbol">=</a> <a id="13718" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="13720" class="Symbol">)</a> <a id="13722" class="Symbol">→</a> <a id="13724" href="1Lab.Equiv.html#12103" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
inv i y ≡ x1" class="Function">π₁</a> <a id="13727" href="1Lab.Equiv.html#13705" class="Bound">k</a>
                           <a id="13756" class="Symbol">;</a> <a id="13758" class="Symbol">(</a><a id="13759" href="1Lab.Equiv.html#13690" class="Bound">i</a> <a id="13761" class="Symbol">=</a> <a id="13763" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="13765" class="Symbol">)</a> <a id="13767" class="Symbol">→</a> <a id="13769" href="1Lab.Equiv.html#11096" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
inv i y ≡ x0" class="Function">π₀</a> <a id="13772" href="1Lab.Equiv.html#13705" class="Bound">k</a>
                           <a id="13801" class="Symbol">})</a>
                      <a id="13826" class="Symbol">(</a><a id="13827" href="1Lab.Path.html#2069" class="Postulate">inS</a> <a id="13831" class="Symbol">(</a><a id="13832" href="1Lab.Equiv.html#8837" class="Field">g</a> <a id="13834" href="1Lab.Equiv.html#9691" class="Bound">y</a><a id="13835" class="Symbol">))</a> <a id="13838" href="1Lab.Equiv.html#13692" class="Bound">j</a>
</pre>
<p>Observe that we can coherently alter
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span>
to get
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ι</mi></mrow><annotation encoding="application/x-tex">\iota</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ι</span></span></span></span>
below, which expresses that
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">p</mi></mrow><mtext> </mtext><mi>g</mi><mtext> </mtext><msub><mi>p</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\id{ap}\ g\ p_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathrm">ap</span></span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
and
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">p</mi></mrow><mtext> </mtext><mi>g</mi><mtext> </mtext><msub><mi>p</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\id{ap}\ g\ p_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathrm">ap</span></span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
are identified.</p>
<pre class="Agda">    <a id="14003" href="1Lab.Equiv.html#14003" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
Square (ap (inv i ⊙ f) (π i y x0 x1 p0 p1)) (ap (inv i) p0)
(ap (inv i) p1) refl" class="Function">ι</a> <a id="14005" class="Symbol">:</a> <a id="14007" href="1Lab.Path.html#9409" data-type="a00 ≡ a01 → a00 ≡ a10 → a01 ≡ a11 → a10 ≡ a11 → Type ℓ" class="Function">Square</a> <a id="14014" class="Symbol">(</a><a id="14015" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="14018" class="Symbol">(</a><a id="14019" href="1Lab.Equiv.html#8837" class="Field">g</a> <a id="14021" href="1Lab.Type.html#2227" data-type="((y : B₁ x) → C x y) → (f : (x : A) → B₁ x) (x : A) → C x (f x)" class="Function Operator">∘</a> <a id="14023" href="1Lab.Equiv.html#8770" class="Bound">f</a><a id="14024" class="Symbol">)</a> <a id="14026" href="1Lab.Equiv.html#13111" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
x0 ≡ x1" class="Function">π</a><a id="14027" class="Symbol">)</a> <a id="14029" class="Symbol">(</a><a id="14030" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="14033" href="1Lab.Equiv.html#8837" class="Field">g</a> <a id="14035" href="1Lab.Equiv.html#9711" class="Bound">p0</a><a id="14037" class="Symbol">)</a> <a id="14039" class="Symbol">(</a><a id="14040" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="14043" href="1Lab.Equiv.html#8837" class="Field">g</a> <a id="14045" href="1Lab.Equiv.html#9727" class="Bound">p1</a><a id="14047" class="Symbol">)</a> <a id="14049" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
    <a id="14058" href="1Lab.Equiv.html#14003" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
Square (ap (inv i ⊙ f) (π i y x0 x1 p0 p1)) (ap (inv i) p0)
(ap (inv i) p1) refl" class="Function">ι</a> <a id="14060" href="1Lab.Equiv.html#14060" class="Bound">i</a> <a id="14062" href="1Lab.Equiv.html#14062" class="Bound">j</a> <a id="14064" class="Symbol">=</a> <a id="14066" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="14072" class="Symbol">(λ</a> <a id="14075" href="1Lab.Equiv.html#14075" class="Bound">k</a> <a id="14077" class="Symbol">→</a> <a id="14079" class="Symbol">λ</a> <a id="14081" class="Symbol">{</a> <a id="14083" class="Symbol">(</a><a id="14084" href="1Lab.Equiv.html#14060" class="Bound">i</a> <a id="14086" class="Symbol">=</a> <a id="14088" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="14090" class="Symbol">)</a> <a id="14092" class="Symbol">→</a> <a id="14094" href="1Lab.Equiv.html#11268" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
Square (ap (inv i) (sym p0)) refl (linv i x0) (π₀ i y x0 x1 p0 p1)" class="Function">θ₀</a> <a id="14097" class="Symbol">(</a><a id="14098" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="14100" href="1Lab.Equiv.html#14062" class="Bound">j</a><a id="14101" class="Symbol">)</a> <a id="14103" class="Symbol">(</a><a id="14104" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="14106" href="1Lab.Equiv.html#14075" class="Bound">k</a><a id="14107" class="Symbol">)</a>
                           <a id="14136" class="Symbol">;</a> <a id="14138" class="Symbol">(</a><a id="14139" href="1Lab.Equiv.html#14060" class="Bound">i</a> <a id="14141" class="Symbol">=</a> <a id="14143" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="14145" class="Symbol">)</a> <a id="14147" class="Symbol">→</a> <a id="14149" href="1Lab.Equiv.html#12275" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
Square (ap (inv i) (sym p1)) refl (linv i x1) (π₁ i y x0 x1 p0 p1)" class="Function">θ₁</a> <a id="14152" class="Symbol">(</a><a id="14153" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="14155" href="1Lab.Equiv.html#14062" class="Bound">j</a><a id="14156" class="Symbol">)</a> <a id="14158" class="Symbol">(</a><a id="14159" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="14161" href="1Lab.Equiv.html#14075" class="Bound">k</a><a id="14162" class="Symbol">)</a>
                           <a id="14191" class="Symbol">;</a> <a id="14193" class="Symbol">(</a><a id="14194" href="1Lab.Equiv.html#14062" class="Bound">j</a> <a id="14196" class="Symbol">=</a> <a id="14198" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="14200" class="Symbol">)</a> <a id="14202" class="Symbol">→</a> <a id="14204" href="1Lab.Equiv.html#8911" class="Field">t</a> <a id="14206" class="Symbol">(</a><a id="14207" href="1Lab.Equiv.html#13111" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
x0 ≡ x1" class="Function">π</a> <a id="14209" href="1Lab.Equiv.html#14060" class="Bound">i</a><a id="14210" class="Symbol">)</a> <a id="14212" class="Symbol">(</a><a id="14213" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="14215" href="1Lab.Equiv.html#14075" class="Bound">k</a><a id="14216" class="Symbol">)</a>
                           <a id="14245" class="Symbol">;</a> <a id="14247" class="Symbol">(</a><a id="14248" href="1Lab.Equiv.html#14062" class="Bound">j</a> <a id="14250" class="Symbol">=</a> <a id="14252" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="14254" class="Symbol">)</a> <a id="14256" class="Symbol">→</a> <a id="14258" href="1Lab.Equiv.html#8837" class="Field">g</a> <a id="14260" href="1Lab.Equiv.html#9691" class="Bound">y</a>
                           <a id="14289" class="Symbol">})</a>
                  <a id="14310" class="Symbol">(</a><a id="14311" href="1Lab.Equiv.html#13660" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
Square refl (π₀ i y x0 x1 p0 p1) (π₁ i y x0 x1 p0 p1)
(π i y x0 x1 p0 p1)" class="Function">θ</a> <a id="14313" href="1Lab.Equiv.html#14060" class="Bound">i</a> <a id="14315" class="Symbol">(</a><a id="14316" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="14318" href="1Lab.Equiv.html#14062" class="Bound">j</a><a id="14319" class="Symbol">))</a>
</pre>
<p>This composition can be visualised as the <em>red</em> (front) face
in the diagram below. The back face is
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi><mtext> </mtext><mi>i</mi><mtext> </mtext><mo stretchy="false">(</mo><mi mathvariant="normal">¬</mi><mtext> </mtext><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\theta\ i\ (\neg\ j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mspace"> </span><span class="mord mathnormal">i</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord">¬</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>,</span>
i.e. <code>(θ i (~ j))</code> in the code. Similarly, the
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>=</mo><mrow><mi mathvariant="normal">i</mi><mn>1</mn></mrow></mrow><annotation encoding="application/x-tex">j = \id{i1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i1</span></span></span></span></span>
(bottom) face is <code>g y</code>, the
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>=</mo><mrow><mi mathvariant="normal">i</mi><mn>0</mn></mrow></mrow><annotation encoding="application/x-tex">j = \id{i0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i0</span></span></span></span></span>
(top) face is <code>t (π i) (~ k)</code>, and similarly for
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mrow><mi mathvariant="normal">i</mi><mn>0</mn></mrow></mrow><annotation encoding="application/x-tex">i = \id{i0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i0</span></span></span></span></span>
(left) and
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mrow><mi mathvariant="normal">i</mi><mn>1</mn></mrow></mrow><annotation encoding="application/x-tex">i = \id{i1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i1</span></span></span></span></span>
(right).</p>
<div class="diagram-container">
<img src="light-4ca7bf8c3850978af54f0b59ab98cc349f53d49d.svg" title="commutative diagram" class="diagram diagram-light quiver tall-2" />
<img src="dark-4ca7bf8c3850978af54f0b59ab98cc349f53d49d.svg" title="commutative diagram" class="diagram diagram-dark quiver tall-2" />
</div>
<p>The fact that
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>
only appears as
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">¬</mi><mi>j</mi></mrow><annotation encoding="application/x-tex">\neg j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord">¬</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>
can be understood as the diagram above being <em>upside-down</em>.
Indeed,
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\pi_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
and
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\pi_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
in the boundary of
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span>
(the inner, blue face) are inverted when their types are considered.
We’re in the home stretch: Using our assumption
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>:</mo><mi>f</mi><mo stretchy="false">(</mo><mi>g</mi><mtext> </mtext><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">s : f (g\ x) = x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>,</span>
we can cancel all of the
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>∘</mo><mi>g</mi></mrow><annotation encoding="application/x-tex">f \circ g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span>s</span>
in the diagram above to get what we wanted:
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>0</mn></msub><mo>≡</mo><msub><mi>p</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">p_0 ≡ p_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6582em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</span></p>
<pre class="Agda">    <a id="17153" href="1Lab.Equiv.html#17153" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
Square (ap f (π i y x0 x1 p0 p1)) p0 p1 refl" class="Function">sq1</a> <a id="17157" class="Symbol">:</a> <a id="17159" href="1Lab.Path.html#9409" data-type="a00 ≡ a01 → a00 ≡ a10 → a01 ≡ a11 → a10 ≡ a11 → Type ℓ" class="Function">Square</a> <a id="17166" class="Symbol">(</a><a id="17167" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="17170" href="1Lab.Equiv.html#8770" class="Bound">f</a> <a id="17172" href="1Lab.Equiv.html#13111" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
x0 ≡ x1" class="Function">π</a><a id="17173" class="Symbol">)</a> <a id="17175" href="1Lab.Equiv.html#9711" class="Bound">p0</a> <a id="17178" href="1Lab.Equiv.html#9727" class="Bound">p1</a> <a id="17181" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
    <a id="17190" href="1Lab.Equiv.html#17153" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
Square (ap f (π i y x0 x1 p0 p1)) p0 p1 refl" class="Function">sq1</a> <a id="17194" href="1Lab.Equiv.html#17194" class="Bound">i</a> <a id="17196" href="1Lab.Equiv.html#17196" class="Bound">j</a> <a id="17198" class="Symbol">=</a> <a id="17200" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="17206" class="Symbol">(λ</a> <a id="17209" href="1Lab.Equiv.html#17209" class="Bound">k</a> <a id="17211" class="Symbol">→</a> <a id="17213" class="Symbol">λ</a> <a id="17215" class="Symbol">{</a> <a id="17217" class="Symbol">(</a><a id="17218" href="1Lab.Equiv.html#17194" class="Bound">i</a> <a id="17220" class="Symbol">=</a> <a id="17222" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="17224" class="Symbol">)</a> <a id="17226" class="Symbol">→</a> <a id="17228" href="1Lab.Equiv.html#8874" class="Field">s</a> <a id="17230" class="Symbol">(</a><a id="17231" href="1Lab.Equiv.html#9711" class="Bound">p0</a> <a id="17234" href="1Lab.Equiv.html#17196" class="Bound">j</a><a id="17235" class="Symbol">)</a> <a id="17237" href="1Lab.Equiv.html#17209" class="Bound">k</a>
                             <a id="17268" class="Symbol">;</a> <a id="17270" class="Symbol">(</a><a id="17271" href="1Lab.Equiv.html#17194" class="Bound">i</a> <a id="17273" class="Symbol">=</a> <a id="17275" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="17277" class="Symbol">)</a> <a id="17279" class="Symbol">→</a> <a id="17281" href="1Lab.Equiv.html#8874" class="Field">s</a> <a id="17283" class="Symbol">(</a><a id="17284" href="1Lab.Equiv.html#9727" class="Bound">p1</a> <a id="17287" href="1Lab.Equiv.html#17196" class="Bound">j</a><a id="17288" class="Symbol">)</a> <a id="17290" href="1Lab.Equiv.html#17209" class="Bound">k</a>
                             <a id="17321" class="Symbol">;</a> <a id="17323" class="Symbol">(</a><a id="17324" href="1Lab.Equiv.html#17196" class="Bound">j</a> <a id="17326" class="Symbol">=</a> <a id="17328" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="17330" class="Symbol">)</a> <a id="17332" class="Symbol">→</a> <a id="17334" href="1Lab.Equiv.html#8874" class="Field">s</a> <a id="17336" class="Symbol">(</a><a id="17337" href="1Lab.Equiv.html#8770" class="Bound">f</a> <a id="17339" class="Symbol">(</a><a id="17340" href="1Lab.Equiv.html#13111" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
x0 ≡ x1" class="Function">π</a> <a id="17342" href="1Lab.Equiv.html#17194" class="Bound">i</a><a id="17343" class="Symbol">))</a> <a id="17346" href="1Lab.Equiv.html#17209" class="Bound">k</a>
                             <a id="17377" class="Symbol">;</a> <a id="17379" class="Symbol">(</a><a id="17380" href="1Lab.Equiv.html#17196" class="Bound">j</a> <a id="17382" class="Symbol">=</a> <a id="17384" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="17386" class="Symbol">)</a> <a id="17388" class="Symbol">→</a> <a id="17390" href="1Lab.Equiv.html#8874" class="Field">s</a> <a id="17392" href="1Lab.Equiv.html#9691" class="Bound">y</a> <a id="17394" href="1Lab.Equiv.html#17209" class="Bound">k</a>
                             <a id="17425" class="Symbol">})</a>
                    <a id="17448" class="Symbol">(</a><a id="17449" href="1Lab.Equiv.html#8770" class="Bound">f</a> <a id="17451" class="Symbol">(</a><a id="17452" href="1Lab.Equiv.html#14003" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
Square (ap (inv i ⊙ f) (π i y x0 x1 p0 p1)) (ap (inv i) p0)
(ap (inv i) p1) refl" class="Function">ι</a> <a id="17454" href="1Lab.Equiv.html#17194" class="Bound">i</a> <a id="17456" href="1Lab.Equiv.html#17196" class="Bound">j</a><a id="17457" class="Symbol">))</a>
</pre>
<p>The composition above can be visualised as the front (red) face in
the cubical diagram below. Once more, left is
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mrow><mi mathvariant="normal">i</mi><mn>0</mn></mrow></mrow><annotation encoding="application/x-tex">i = \id{i0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i0</span></span></span></span></span>,</span>
right is
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mrow><mi mathvariant="normal">i</mi><mn>1</mn></mrow></mrow><annotation encoding="application/x-tex">i = \id{i1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i1</span></span></span></span></span>,</span>
up is
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>=</mo><mrow><mi mathvariant="normal">i</mi><mn>0</mn></mrow></mrow><annotation encoding="application/x-tex">j = \id{i0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i0</span></span></span></span></span>,</span>
and down is
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>=</mo><mrow><mi mathvariant="normal">i</mi><mn>1</mn></mrow></mrow><annotation encoding="application/x-tex">j = \id{i1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i1</span></span></span></span></span>.</span></p>
<div class="diagram-container">
<img src="light-ed665b137886f06422ef995b304d460c5fbffbb7.svg" title="commutative diagram" class="diagram diagram-light quiver tall-2" />
<img src="dark-ed665b137886f06422ef995b304d460c5fbffbb7.svg" title="commutative diagram" class="diagram diagram-dark quiver tall-2" />
</div>
<p>Putting all of this together, we get that
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>p</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mo>≡</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>p</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x_0, p_0) ≡ (x_1, p_1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>.</span>
Since there were no assumptions on any of the variables under
consideration, this indeed says that the fibre over
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>
is a proposition for any choice of
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>.</span></p>
<pre class="Agda">    <a id="19908" href="1Lab.Equiv.html#19908" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
(x0 , p0) ≡ (x1 , p1)" class="Function">is-iso→fibre-is-prop</a> <a id="19929" class="Symbol">:</a> <a id="19931" class="Symbol">(</a><a id="19932" href="1Lab.Equiv.html#9699" class="Bound">x0</a> <a id="19935" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="19937" href="1Lab.Equiv.html#9711" class="Bound">p0</a><a id="19939" class="Symbol">)</a> <a id="19941" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="19943" class="Symbol">(</a><a id="19944" href="1Lab.Equiv.html#9702" class="Bound">x1</a> <a id="19947" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="19949" href="1Lab.Equiv.html#9727" class="Bound">p1</a><a id="19951" class="Symbol">)</a>
    <a id="19957" href="1Lab.Equiv.html#19908" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
(x0 , p0) ≡ (x1 , p1)" class="Function">is-iso→fibre-is-prop</a> <a id="19978" href="1Lab.Equiv.html#19978" class="Bound">i</a> <a id="19980" class="Symbol">.</a><a id="19981" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="19985" class="Symbol">=</a> <a id="19987" href="1Lab.Equiv.html#13111" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
x0 ≡ x1" class="Function">π</a> <a id="19989" href="1Lab.Equiv.html#19978" class="Bound">i</a>
    <a id="19995" href="1Lab.Equiv.html#19908" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
(x0 , p0) ≡ (x1 , p1)" class="Function">is-iso→fibre-is-prop</a> <a id="20016" href="1Lab.Equiv.html#20016" class="Bound">i</a> <a id="20018" class="Symbol">.</a><a id="20019" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="20023" class="Symbol">=</a> <a id="20025" href="1Lab.Equiv.html#17153" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
Square (ap f (π i y x0 x1 p0 p1)) p0 p1 refl" class="Function">sq1</a> <a id="20029" href="1Lab.Equiv.html#20016" class="Bound">i</a>
</pre>
<p>Since the fibre over
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>
is inhabited by
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>g</mi><mtext> </mtext><mi>y</mi><mo separator="true">,</mo><mi>s</mi><mtext> </mtext><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(g\ y, s\ y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">s</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>,</span>
we get that any isomorphism has contractible fibres:</p>
<pre class="Agda">  <a id="20157" href="1Lab.Equiv.html#20157" data-type="(i : is-iso f) → is-equiv f" class="Function">is-iso→is-equiv</a> <a id="20173" class="Symbol">:</a> <a id="20175" href="1Lab.Equiv.html#2286" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-equiv</a> <a id="20184" href="1Lab.Equiv.html#8770" class="Bound">f</a>
  <a id="20188" href="1Lab.Equiv.html#20157" data-type="(i : is-iso f) → is-equiv f" class="Function">is-iso→is-equiv</a> <a id="20204" class="Symbol">.</a><a id="20205" href="1Lab.Equiv.html#2376" data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" class="Field">is-eqv</a> <a id="20212" href="1Lab.Equiv.html#20212" class="Bound">y</a> <a id="20214" class="Symbol">.</a><a id="20215" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a> <a id="20222" class="Symbol">.</a><a id="20223" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="20227" class="Symbol">=</a> <a id="20229" href="1Lab.Equiv.html#8837" class="Field">g</a> <a id="20231" href="1Lab.Equiv.html#20212" class="Bound">y</a>
  <a id="20235" href="1Lab.Equiv.html#20157" data-type="(i : is-iso f) → is-equiv f" class="Function">is-iso→is-equiv</a> <a id="20251" class="Symbol">.</a><a id="20252" href="1Lab.Equiv.html#2376" data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" class="Field">is-eqv</a> <a id="20259" href="1Lab.Equiv.html#20259" class="Bound">y</a> <a id="20261" class="Symbol">.</a><a id="20262" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a> <a id="20269" class="Symbol">.</a><a id="20270" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="20274" class="Symbol">=</a> <a id="20276" href="1Lab.Equiv.html#8874" class="Field">s</a> <a id="20278" href="1Lab.Equiv.html#20259" class="Bound">y</a>
  <a id="20282" href="1Lab.Equiv.html#20157" data-type="(i : is-iso f) → is-equiv f" class="Function">is-iso→is-equiv</a> <a id="20298" class="Symbol">.</a><a id="20299" href="1Lab.Equiv.html#2376" data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" class="Field">is-eqv</a> <a id="20306" href="1Lab.Equiv.html#20306" class="Bound">y</a> <a id="20308" class="Symbol">.</a><a id="20309" href="1Lab.HLevel.html#1416" data-type="(r : is-contr A) (x : A) → r .centre ≡ x" class="Field">paths</a> <a id="20315" href="1Lab.Equiv.html#20315" class="Bound">z</a> <a id="20317" class="Symbol">=</a>
    <a id="20323" href="1Lab.Equiv.html#19908" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
(x0 , p0) ≡ (x1 , p1)" class="Function">is-iso→fibre-is-prop</a> <a id="20344" href="1Lab.Equiv.html#20306" class="Bound">y</a> <a id="20346" class="Symbol">(</a><a id="20347" href="1Lab.Equiv.html#8837" class="Field">g</a> <a id="20349" href="1Lab.Equiv.html#20306" class="Bound">y</a><a id="20350" class="Symbol">)</a> <a id="20352" class="Symbol">(</a><a id="20353" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="20357" href="1Lab.Equiv.html#20315" class="Bound">z</a><a id="20358" class="Symbol">)</a> <a id="20360" class="Symbol">(</a><a id="20361" href="1Lab.Equiv.html#8874" class="Field">s</a> <a id="20363" href="1Lab.Equiv.html#20306" class="Bound">y</a><a id="20364" class="Symbol">)</a> <a id="20366" class="Symbol">(</a><a id="20367" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="20371" href="1Lab.Equiv.html#20315" class="Bound">z</a><a id="20372" class="Symbol">)</a>
</pre>
<p>Applying this to the
<span class="Agda"><a href="1Lab.Equiv.html#6298" class="Function">Iso</a></span>
and
<span class="Agda"><a href="1Lab.Equiv.html#2439" class="Function Operator">_≃_</a></span>
pairs, we can turn any isomorphism into a coherent equivalence.</p>
<pre class="Agda"><a id="Iso→Equiv"></a><a id="20503" href="1Lab.Equiv.html#20503" data-type="Iso A B₁ → A ≃ B₁" class="Function">Iso→Equiv</a> <a id="20513" class="Symbol">:</a> <a id="20515" class="Symbol">∀</a> <a id="20517" class="Symbol">{</a><a id="20518" href="1Lab.Equiv.html#20518" class="Bound">ℓ₁</a> <a id="20521" href="1Lab.Equiv.html#20521" class="Bound">ℓ₂</a><a id="20523" class="Symbol">}</a> <a id="20525" class="Symbol">{</a><a id="20526" href="1Lab.Equiv.html#20526" class="Bound">A</a> <a id="20528" class="Symbol">:</a> <a id="20530" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="20535" href="1Lab.Equiv.html#20518" class="Bound">ℓ₁</a><a id="20537" class="Symbol">}</a> <a id="20539" class="Symbol">{</a><a id="20540" href="1Lab.Equiv.html#20540" class="Bound">B</a> <a id="20542" class="Symbol">:</a> <a id="20544" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="20549" href="1Lab.Equiv.html#20521" class="Bound">ℓ₂</a><a id="20551" class="Symbol">}</a>
          <a id="20563" class="Symbol">→</a> <a id="20565" href="1Lab.Equiv.html#6298" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function">Iso</a> <a id="20569" href="1Lab.Equiv.html#20526" class="Bound">A</a> <a id="20571" href="1Lab.Equiv.html#20540" class="Bound">B</a>
          <a id="20583" class="Symbol">→</a> <a id="20585" href="1Lab.Equiv.html#20526" class="Bound">A</a> <a id="20587" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="20589" href="1Lab.Equiv.html#20540" class="Bound">B</a>
<a id="20591" href="1Lab.Equiv.html#20503" data-type="Iso A B₁ → A ≃ B₁" class="Function">Iso→Equiv</a> <a id="20601" class="Symbol">(</a><a id="20602" href="1Lab.Equiv.html#20602" class="Bound">f</a> <a id="20604" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="20606" href="1Lab.Equiv.html#20606" class="Bound">is-iso</a><a id="20612" class="Symbol">)</a> <a id="20614" class="Symbol">=</a> <a id="20616" href="1Lab.Equiv.html#20602" class="Bound">f</a> <a id="20618" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="20620" href="1Lab.Equiv.html#20157" data-type="(i : is-iso f) → is-equiv f" class="Function">is-iso→is-equiv</a> <a id="20636" href="1Lab.Equiv.html#20606" class="Bound">is-iso</a>
</pre>
<p>A helpful lemma: Any function between contractible types is an
equivalence:</p>
<pre class="Agda"><a id="is-contr→is-equiv"></a><a id="20733" href="1Lab.Equiv.html#20733" data-type="is-contr A → is-contr B₁ → is-equiv f" class="Function">is-contr→is-equiv</a> <a id="20751" class="Symbol">:</a> <a id="20753" class="Symbol">∀</a> <a id="20755" class="Symbol">{</a><a id="20756" href="1Lab.Equiv.html#20756" class="Bound">ℓ₁</a> <a id="20759" href="1Lab.Equiv.html#20759" class="Bound">ℓ₂</a><a id="20761" class="Symbol">}</a> <a id="20763" class="Symbol">{</a><a id="20764" href="1Lab.Equiv.html#20764" class="Bound">A</a> <a id="20766" class="Symbol">:</a> <a id="20768" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="20773" href="1Lab.Equiv.html#20756" class="Bound">ℓ₁</a><a id="20775" class="Symbol">}</a> <a id="20777" class="Symbol">{</a><a id="20778" href="1Lab.Equiv.html#20778" class="Bound">B</a> <a id="20780" class="Symbol">:</a> <a id="20782" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="20787" href="1Lab.Equiv.html#20759" class="Bound">ℓ₂</a><a id="20789" class="Symbol">}</a>
                  <a id="20809" class="Symbol">→</a> <a id="20811" href="1Lab.HLevel.html#1328" data-type="(A : Type ℓ) → Type ℓ" class="Record">is-contr</a> <a id="20820" href="1Lab.Equiv.html#20764" class="Bound">A</a> <a id="20822" class="Symbol">→</a> <a id="20824" href="1Lab.HLevel.html#1328" data-type="(A : Type ℓ) → Type ℓ" class="Record">is-contr</a> <a id="20833" href="1Lab.Equiv.html#20778" class="Bound">B</a> <a id="20835" class="Symbol">→</a> <a id="20837" class="Symbol">{</a><a id="20838" href="1Lab.Equiv.html#20838" class="Bound">f</a> <a id="20840" class="Symbol">:</a> <a id="20842" href="1Lab.Equiv.html#20764" class="Bound">A</a> <a id="20844" class="Symbol">→</a> <a id="20846" href="1Lab.Equiv.html#20778" class="Bound">B</a><a id="20847" class="Symbol">}</a>
                  <a id="20867" class="Symbol">→</a> <a id="20869" href="1Lab.Equiv.html#2286" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-equiv</a> <a id="20878" href="1Lab.Equiv.html#20838" class="Bound">f</a>
<a id="20880" href="1Lab.Equiv.html#20733" data-type="is-contr A → is-contr B₁ → is-equiv f" class="Function">is-contr→is-equiv</a> <a id="20898" href="1Lab.Equiv.html#20898" class="Bound">cA</a> <a id="20901" href="1Lab.Equiv.html#20901" class="Bound">cB</a> <a id="20904" class="Symbol">=</a> <a id="20906" href="1Lab.Equiv.html#20157" data-type="(i : is-iso f) → is-equiv f" class="Function">is-iso→is-equiv</a> <a id="20922" href="1Lab.Equiv.html#20939" data-type="(cA : is-contr A) (cB : is-contr B₁) → is-iso f" class="Function">f-is-iso</a> <a id="20931" class="Keyword">where</a>
  <a id="20939" href="1Lab.Equiv.html#20939" data-type="(cA : is-contr A) (cB : is-contr B₁) → is-iso f" class="Function">f-is-iso</a> <a id="20948" class="Symbol">:</a> <a id="20950" href="1Lab.Equiv.html#6026" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-iso</a> <a id="20957" class="Symbol">_</a>
  <a id="20961" href="1Lab.Equiv.html#6132" data-type="is-iso f → B₁ → A" class="Field">is-iso.inv</a> <a id="20972" href="1Lab.Equiv.html#20939" data-type="(cA : is-contr A) (cB : is-contr B₁) → is-iso f" class="Function">f-is-iso</a> <a id="20981" class="Symbol">_</a> <a id="20983" class="Symbol">=</a> <a id="20985" href="1Lab.Equiv.html#20898" class="Bound">cA</a> <a id="20988" class="Symbol">.</a><a id="20989" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a>
  <a id="20998" href="1Lab.Equiv.html#6148" data-type="(r : is-iso f) → is-right-inverse (r .inv) f" class="Field">is-iso.rinv</a> <a id="21010" href="1Lab.Equiv.html#20939" data-type="(cA : is-contr A) (cB : is-contr B₁) → is-iso f" class="Function">f-is-iso</a> <a id="21019" class="Symbol">_</a> <a id="21021" class="Symbol">=</a> <a id="21023" href="1Lab.HLevel.html#3818" data-type="is-contr A → is-prop A" class="Function">is-contr→is-prop</a> <a id="21040" href="1Lab.Equiv.html#20901" class="Bound">cB</a> <a id="21043" class="Symbol">_</a> <a id="21045" class="Symbol">_</a>
  <a id="21049" href="1Lab.Equiv.html#6182" data-type="(r : is-iso f) → is-left-inverse (r .inv) f" class="Field">is-iso.linv</a> <a id="21061" href="1Lab.Equiv.html#20939" data-type="(cA : is-contr A) (cB : is-contr B₁) → is-iso f" class="Function">f-is-iso</a> <a id="21070" class="Symbol">_</a> <a id="21072" class="Symbol">=</a> <a id="21074" href="1Lab.HLevel.html#3818" data-type="is-contr A → is-prop A" class="Function">is-contr→is-prop</a> <a id="21091" href="1Lab.Equiv.html#20898" class="Bound">cA</a> <a id="21094" class="Symbol">_</a> <a id="21096" class="Symbol">_</a>

<a id="is-contr→≃"></a><a id="21099" href="1Lab.Equiv.html#21099" data-type="is-contr A → is-contr B₁ → A ≃ B₁" class="Function">is-contr→≃</a> <a id="21110" class="Symbol">:</a> <a id="21112" class="Symbol">∀</a> <a id="21114" class="Symbol">{</a><a id="21115" href="1Lab.Equiv.html#21115" class="Bound">ℓ₁</a> <a id="21118" href="1Lab.Equiv.html#21118" class="Bound">ℓ₂</a><a id="21120" class="Symbol">}</a> <a id="21122" class="Symbol">{</a><a id="21123" href="1Lab.Equiv.html#21123" class="Bound">A</a> <a id="21125" class="Symbol">:</a> <a id="21127" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="21132" href="1Lab.Equiv.html#21115" class="Bound">ℓ₁</a><a id="21134" class="Symbol">}</a> <a id="21136" class="Symbol">{</a><a id="21137" href="1Lab.Equiv.html#21137" class="Bound">B</a> <a id="21139" class="Symbol">:</a> <a id="21141" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="21146" href="1Lab.Equiv.html#21118" class="Bound">ℓ₂</a><a id="21148" class="Symbol">}</a>
           <a id="21161" class="Symbol">→</a> <a id="21163" href="1Lab.HLevel.html#1328" data-type="(A : Type ℓ) → Type ℓ" class="Record">is-contr</a> <a id="21172" href="1Lab.Equiv.html#21123" class="Bound">A</a> <a id="21174" class="Symbol">→</a> <a id="21176" href="1Lab.HLevel.html#1328" data-type="(A : Type ℓ) → Type ℓ" class="Record">is-contr</a> <a id="21185" href="1Lab.Equiv.html#21137" class="Bound">B</a> <a id="21187" class="Symbol">→</a> <a id="21189" href="1Lab.Equiv.html#21123" class="Bound">A</a> <a id="21191" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="21193" href="1Lab.Equiv.html#21137" class="Bound">B</a>
<a id="21195" href="1Lab.Equiv.html#21099" data-type="is-contr A → is-contr B₁ → A ≃ B₁" class="Function">is-contr→≃</a> <a id="21206" href="1Lab.Equiv.html#21206" class="Bound">cA</a> <a id="21209" href="1Lab.Equiv.html#21209" class="Bound">cB</a> <a id="21212" class="Symbol">=</a> <a id="21214" class="Symbol">(λ</a> <a id="21217" href="1Lab.Equiv.html#21217" class="Bound">_</a> <a id="21219" class="Symbol">→</a> <a id="21221" href="1Lab.Equiv.html#21209" class="Bound">cB</a> <a id="21224" class="Symbol">.</a><a id="21225" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a><a id="21231" class="Symbol">)</a> <a id="21233" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="21235" href="1Lab.Equiv.html#20157" data-type="(i : is-iso f) → is-equiv f" class="Function">is-iso→is-equiv</a> <a id="21251" href="1Lab.Equiv.html#21268" data-type="(cA : is-contr A) (cB : is-contr B₁) → is-iso (λ _ → cB .centre)" class="Function">f-is-iso</a> <a id="21260" class="Keyword">where</a>
  <a id="21268" href="1Lab.Equiv.html#21268" data-type="(cA : is-contr A) (cB : is-contr B₁) → is-iso (λ _ → cB .centre)" class="Function">f-is-iso</a> <a id="21277" class="Symbol">:</a> <a id="21279" href="1Lab.Equiv.html#6026" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-iso</a> <a id="21286" class="Symbol">_</a>
  <a id="21290" href="1Lab.Equiv.html#6132" data-type="is-iso f → B₁ → A" class="Field">is-iso.inv</a> <a id="21301" href="1Lab.Equiv.html#21268" data-type="(cA : is-contr A) (cB : is-contr B₁) → is-iso (λ _ → cB .centre)" class="Function">f-is-iso</a> <a id="21310" class="Symbol">_</a> <a id="21312" class="Symbol">=</a> <a id="21314" href="1Lab.Equiv.html#21206" class="Bound">cA</a> <a id="21317" class="Symbol">.</a><a id="21318" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a>
  <a id="21327" href="1Lab.Equiv.html#6148" data-type="(r : is-iso f) → is-right-inverse (r .inv) f" class="Field">is-iso.rinv</a> <a id="21339" href="1Lab.Equiv.html#21268" data-type="(cA : is-contr A) (cB : is-contr B₁) → is-iso (λ _ → cB .centre)" class="Function">f-is-iso</a> <a id="21348" class="Symbol">_</a> <a id="21350" class="Symbol">=</a> <a id="21352" href="1Lab.HLevel.html#3818" data-type="is-contr A → is-prop A" class="Function">is-contr→is-prop</a> <a id="21369" href="1Lab.Equiv.html#21209" class="Bound">cB</a> <a id="21372" class="Symbol">_</a> <a id="21374" class="Symbol">_</a>
  <a id="21378" href="1Lab.Equiv.html#6182" data-type="(r : is-iso f) → is-left-inverse (r .inv) f" class="Field">is-iso.linv</a> <a id="21390" href="1Lab.Equiv.html#21268" data-type="(cA : is-contr A) (cB : is-contr B₁) → is-iso (λ _ → cB .centre)" class="Function">f-is-iso</a> <a id="21399" class="Symbol">_</a> <a id="21401" class="Symbol">=</a> <a id="21403" href="1Lab.HLevel.html#3818" data-type="is-contr A → is-prop A" class="Function">is-contr→is-prop</a> <a id="21420" href="1Lab.Equiv.html#21206" class="Bound">cA</a> <a id="21423" class="Symbol">_</a> <a id="21425" class="Symbol">_</a>
</pre>
<h1 id="equivalence-reasoning"><a href="#equivalence-reasoning" class="header-link">Equivalence
Reasoning<span class="header-link-emoji">🔗</span></a></h1>
<p>To make composing equivalences more intuitive, we implement operators
to do equivalence reasoning in the same style as equational
reasoning.</p>
<pre class="Agda"><a id="_∙e_"></a><a id="21607" href="1Lab.Equiv.html#21607" data-type="A ≃ B₁ → B₁ ≃ C → A ≃ C" class="Function Operator">_∙e_</a> <a id="21612" class="Symbol">:</a> <a id="21614" class="Symbol">∀</a> <a id="21616" class="Symbol">{</a><a id="21617" href="1Lab.Equiv.html#21617" class="Bound">ℓ</a> <a id="21619" href="1Lab.Equiv.html#21619" class="Bound">ℓ₁</a> <a id="21622" href="1Lab.Equiv.html#21622" class="Bound">ℓ₂</a><a id="21624" class="Symbol">}</a> <a id="21626" class="Symbol">{</a><a id="21627" href="1Lab.Equiv.html#21627" class="Bound">A</a> <a id="21629" class="Symbol">:</a> <a id="21631" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="21636" href="1Lab.Equiv.html#21617" class="Bound">ℓ</a><a id="21637" class="Symbol">}</a> <a id="21639" class="Symbol">{</a><a id="21640" href="1Lab.Equiv.html#21640" class="Bound">B</a> <a id="21642" class="Symbol">:</a> <a id="21644" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="21649" href="1Lab.Equiv.html#21619" class="Bound">ℓ₁</a><a id="21651" class="Symbol">}</a> <a id="21653" class="Symbol">{</a><a id="21654" href="1Lab.Equiv.html#21654" class="Bound">C</a> <a id="21656" class="Symbol">:</a> <a id="21658" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="21663" href="1Lab.Equiv.html#21622" class="Bound">ℓ₂</a><a id="21665" class="Symbol">}</a>
     <a id="21672" class="Symbol">→</a> <a id="21674" href="1Lab.Equiv.html#21627" class="Bound">A</a> <a id="21676" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="21678" href="1Lab.Equiv.html#21640" class="Bound">B</a> <a id="21680" class="Symbol">→</a> <a id="21682" href="1Lab.Equiv.html#21640" class="Bound">B</a> <a id="21684" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="21686" href="1Lab.Equiv.html#21654" class="Bound">C</a> <a id="21688" class="Symbol">→</a> <a id="21690" href="1Lab.Equiv.html#21627" class="Bound">A</a> <a id="21692" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="21694" href="1Lab.Equiv.html#21654" class="Bound">C</a>

<a id="_e⁻¹"></a><a id="21697" href="1Lab.Equiv.html#21697" data-type="A ≃ B₁ → B₁ ≃ A" class="Function Operator">_e⁻¹</a> <a id="21702" class="Symbol">:</a> <a id="21704" class="Symbol">∀</a> <a id="21706" class="Symbol">{</a><a id="21707" href="1Lab.Equiv.html#21707" class="Bound">ℓ</a> <a id="21709" href="1Lab.Equiv.html#21709" class="Bound">ℓ₁</a><a id="21711" class="Symbol">}</a> <a id="21713" class="Symbol">{</a><a id="21714" href="1Lab.Equiv.html#21714" class="Bound">A</a> <a id="21716" class="Symbol">:</a> <a id="21718" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="21723" href="1Lab.Equiv.html#21707" class="Bound">ℓ</a><a id="21724" class="Symbol">}</a> <a id="21726" class="Symbol">{</a><a id="21727" href="1Lab.Equiv.html#21727" class="Bound">B</a> <a id="21729" class="Symbol">:</a> <a id="21731" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="21736" href="1Lab.Equiv.html#21709" class="Bound">ℓ₁</a><a id="21738" class="Symbol">}</a>
     <a id="21745" class="Symbol">→</a> <a id="21747" href="1Lab.Equiv.html#21714" class="Bound">A</a> <a id="21749" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="21751" href="1Lab.Equiv.html#21727" class="Bound">B</a> <a id="21753" class="Symbol">→</a> <a id="21755" href="1Lab.Equiv.html#21727" class="Bound">B</a> <a id="21757" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="21759" href="1Lab.Equiv.html#21714" class="Bound">A</a>
<a id="21761" href="1Lab.Equiv.html#21697" data-type="A ≃ B₁ → B₁ ≃ A" class="Function Operator">_e⁻¹</a> <a id="21766" href="1Lab.Equiv.html#21766" class="Bound">eqv</a> <a id="21770" class="Symbol">=</a> <a id="21772" href="1Lab.Equiv.html#20503" data-type="Iso A B₁ → A ≃ B₁" class="Function">Iso→Equiv</a> <a id="21782" class="Symbol">(</a> <a id="21784" href="1Lab.Equiv.html#6449" data-type="is-equiv f → B₁ → A" class="Function">equiv→inverse</a> <a id="21798" class="Symbol">(</a><a id="21799" href="1Lab.Equiv.html#21766" class="Bound">eqv</a> <a id="21803" class="Symbol">.</a><a id="21804" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a><a id="21807" class="Symbol">)</a>
                     <a id="21830" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="21832" class="Keyword">record</a> <a id="21839" class="Symbol">{</a> <a id="21841" href="1Lab.Equiv.html#6132" data-type="is-iso f → B₁ → A" class="Field">inv</a>  <a id="21846" class="Symbol">=</a> <a id="21848" href="1Lab.Equiv.html#21766" class="Bound">eqv</a> <a id="21852" class="Symbol">.</a><a id="21853" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a>
                              <a id="21887" class="Symbol">;</a> <a id="21889" href="1Lab.Equiv.html#6148" data-type="(r : is-iso f) → is-right-inverse (r .inv) f" class="Field">rinv</a> <a id="21894" class="Symbol">=</a> <a id="21896" href="1Lab.Equiv.html#6679" data-type="(eqv : is-equiv f) (x : A) → equiv→inverse eqv (f x) ≡ x" class="Function">equiv→unit</a> <a id="21907" class="Symbol">(</a><a id="21908" href="1Lab.Equiv.html#21766" class="Bound">eqv</a> <a id="21912" class="Symbol">.</a><a id="21913" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a><a id="21916" class="Symbol">)</a>
                              <a id="21948" class="Symbol">;</a> <a id="21950" href="1Lab.Equiv.html#6182" data-type="(r : is-iso f) → is-left-inverse (r .inv) f" class="Field">linv</a> <a id="21955" class="Symbol">=</a> <a id="21957" href="1Lab.Equiv.html#6548" data-type="(eqv : is-equiv f) (x : B₁) → f (equiv→inverse eqv x) ≡ x" class="Function">equiv→counit</a> <a id="21970" class="Symbol">(</a><a id="21971" href="1Lab.Equiv.html#21766" class="Bound">eqv</a> <a id="21975" class="Symbol">.</a><a id="21976" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a><a id="21979" class="Symbol">)</a>
                              <a id="22011" class="Symbol">})</a>
</pre>
<!--
<pre class="Agda"><a id="22027" href="1Lab.Equiv.html#21607" data-type="A ≃ B₁ → B₁ ≃ C → A ≃ C" class="Function Operator">_∙e_</a> <a id="22032" class="Symbol">(</a><a id="22033" href="1Lab.Equiv.html#22033" class="Bound">f</a> <a id="22035" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="22037" href="1Lab.Equiv.html#22037" class="Bound">e</a><a id="22038" class="Symbol">)</a> <a id="22040" class="Symbol">(</a><a id="22041" href="1Lab.Equiv.html#22041" class="Bound">g</a> <a id="22043" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="22045" href="1Lab.Equiv.html#22045" class="Bound">e&#39;</a><a id="22047" class="Symbol">)</a> <a id="22049" class="Symbol">=</a> <a id="22051" class="Symbol">(λ</a> <a id="22054" href="1Lab.Equiv.html#22054" class="Bound">x</a> <a id="22056" class="Symbol">→</a> <a id="22058" href="1Lab.Equiv.html#22041" class="Bound">g</a> <a id="22060" class="Symbol">(</a><a id="22061" href="1Lab.Equiv.html#22033" class="Bound">f</a> <a id="22063" href="1Lab.Equiv.html#22054" class="Bound">x</a><a id="22064" class="Symbol">))</a> <a id="22067" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="22069" href="1Lab.Equiv.html#22796" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
is-equiv (λ x → g (f x))" class="Function">eqv</a> <a id="22073" class="Keyword">where</a>
  <a id="22081" href="1Lab.Equiv.html#22081" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
is-iso g" class="Function">g⁻¹</a> <a id="22085" class="Symbol">:</a> <a id="22087" href="1Lab.Equiv.html#6026" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-iso</a> <a id="22094" href="1Lab.Equiv.html#22041" class="Bound">g</a>
  <a id="22098" href="1Lab.Equiv.html#22081" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
is-iso g" class="Function">g⁻¹</a> <a id="22102" class="Symbol">=</a> <a id="22104" href="1Lab.Equiv.html#7201" data-type="is-equiv f → is-iso f" class="Function">is-equiv→is-iso</a> <a id="22120" href="1Lab.Equiv.html#22045" class="Bound">e&#39;</a>

  <a id="22126" href="1Lab.Equiv.html#22126" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
is-iso f" class="Function">f⁻¹</a> <a id="22130" class="Symbol">:</a> <a id="22132" href="1Lab.Equiv.html#6026" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-iso</a> <a id="22139" href="1Lab.Equiv.html#22033" class="Bound">f</a>
  <a id="22143" href="1Lab.Equiv.html#22126" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
is-iso f" class="Function">f⁻¹</a> <a id="22147" class="Symbol">=</a> <a id="22149" href="1Lab.Equiv.html#7201" data-type="is-equiv f → is-iso f" class="Function">is-equiv→is-iso</a> <a id="22165" href="1Lab.Equiv.html#22037" class="Bound">e</a>

  <a id="22170" href="1Lab.Equiv.html#22170" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
C → A" class="Function">inv</a> <a id="22174" class="Symbol">:</a> <a id="22176" class="Symbol">_</a> <a id="22178" class="Symbol">→</a> <a id="22180" class="Symbol">_</a>
  <a id="22184" href="1Lab.Equiv.html#22170" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
C → A" class="Function">inv</a> <a id="22188" href="1Lab.Equiv.html#22188" class="Bound">x</a> <a id="22190" class="Symbol">=</a> <a id="22192" href="1Lab.Equiv.html#22126" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
is-iso f" class="Function">f⁻¹</a> <a id="22196" class="Symbol">.</a><a id="22197" href="1Lab.Equiv.html#6132" data-type="is-iso f → B₁ → A" class="Field">is-iso.inv</a> <a id="22208" class="Symbol">(</a><a id="22209" href="1Lab.Equiv.html#22081" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
is-iso g" class="Function">g⁻¹</a> <a id="22213" class="Symbol">.</a><a id="22214" href="1Lab.Equiv.html#6132" data-type="is-iso f → B₁ → A" class="Field">is-iso.inv</a> <a id="22225" href="1Lab.Equiv.html#22188" class="Bound">x</a><a id="22226" class="Symbol">)</a>

  <a id="22231" class="Keyword">abstract</a>
    <a id="22244" href="1Lab.Equiv.html#22244" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
is-right-inverse (inv f e g e&#39;) (λ x → g (f x))" class="Function">right</a> <a id="22250" class="Symbol">:</a> <a id="22252" href="1Lab.Equiv.html#5739" data-type="(B₁ → A) → (A → B₁) → Type B.ℓ₁" class="Function">is-right-inverse</a> <a id="22269" href="1Lab.Equiv.html#22170" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
C → A" class="Function">inv</a> <a id="22273" class="Symbol">(λ</a> <a id="22276" href="1Lab.Equiv.html#22276" class="Bound">x</a> <a id="22278" class="Symbol">→</a> <a id="22280" href="1Lab.Equiv.html#22041" class="Bound">g</a> <a id="22282" class="Symbol">(</a><a id="22283" href="1Lab.Equiv.html#22033" class="Bound">f</a> <a id="22285" href="1Lab.Equiv.html#22276" class="Bound">x</a><a id="22286" class="Symbol">))</a>
    <a id="22293" href="1Lab.Equiv.html#22244" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
is-right-inverse (inv f e g e&#39;) (λ x → g (f x))" class="Function">right</a> <a id="22299" href="1Lab.Equiv.html#22299" class="Bound">z</a> <a id="22301" class="Symbol">=</a>
      <a id="22309" href="1Lab.Equiv.html#22041" class="Bound">g</a> <a id="22311" class="Symbol">(</a><a id="22312" href="1Lab.Equiv.html#22033" class="Bound">f</a> <a id="22314" class="Symbol">(</a><a id="22315" href="1Lab.Equiv.html#22126" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
is-iso f" class="Function">f⁻¹</a> <a id="22319" class="Symbol">.</a><a id="22320" href="1Lab.Equiv.html#6132" data-type="is-iso f → B₁ → A" class="Field">is-iso.inv</a> <a id="22331" class="Symbol">(</a><a id="22332" href="1Lab.Equiv.html#22081" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
is-iso g" class="Function">g⁻¹</a> <a id="22336" class="Symbol">.</a><a id="22337" href="1Lab.Equiv.html#6132" data-type="is-iso f → B₁ → A" class="Field">is-iso.inv</a> <a id="22348" href="1Lab.Equiv.html#22299" class="Bound">z</a><a id="22349" class="Symbol">)))</a> <a id="22353" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="22356" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="22359" href="1Lab.Equiv.html#22041" class="Bound">g</a> <a id="22361" class="Symbol">(</a><a id="22362" href="1Lab.Equiv.html#22126" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
is-iso f" class="Function">f⁻¹</a> <a id="22366" class="Symbol">.</a><a id="22367" href="1Lab.Equiv.html#6148" data-type="(r : is-iso f) → is-right-inverse (r .inv) f" class="Field">is-iso.rinv</a> <a id="22379" class="Symbol">_)</a> <a id="22382" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
      <a id="22390" href="1Lab.Equiv.html#22041" class="Bound">g</a> <a id="22392" class="Symbol">(</a><a id="22393" href="1Lab.Equiv.html#22081" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
is-iso g" class="Function">g⁻¹</a> <a id="22397" class="Symbol">.</a><a id="22398" href="1Lab.Equiv.html#6132" data-type="is-iso f → B₁ → A" class="Field">is-iso.inv</a> <a id="22409" href="1Lab.Equiv.html#22299" class="Bound">z</a><a id="22410" class="Symbol">)</a>                       <a id="22434" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="22437" href="1Lab.Equiv.html#22081" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
is-iso g" class="Function">g⁻¹</a> <a id="22441" class="Symbol">.</a><a id="22442" href="1Lab.Equiv.html#6148" data-type="(r : is-iso f) → is-right-inverse (r .inv) f" class="Field">is-iso.rinv</a> <a id="22454" class="Symbol">_</a> <a id="22456" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
      <a id="22464" href="1Lab.Equiv.html#22299" class="Bound">z</a>                                           <a id="22508" href="1Lab.Path.html#46945" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>

    <a id="22515" href="1Lab.Equiv.html#22515" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
is-left-inverse (inv f e g e&#39;) (λ x → g (f x))" class="Function">left</a> <a id="22520" class="Symbol">:</a> <a id="22522" href="1Lab.Equiv.html#5649" data-type="(B₁ → A) → (A → B₁) → Type A.ℓ₁" class="Function">is-left-inverse</a> <a id="22538" href="1Lab.Equiv.html#22170" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
C → A" class="Function">inv</a> <a id="22542" class="Symbol">(λ</a> <a id="22545" href="1Lab.Equiv.html#22545" class="Bound">x</a> <a id="22547" class="Symbol">→</a> <a id="22549" href="1Lab.Equiv.html#22041" class="Bound">g</a> <a id="22551" class="Symbol">(</a><a id="22552" href="1Lab.Equiv.html#22033" class="Bound">f</a> <a id="22554" href="1Lab.Equiv.html#22545" class="Bound">x</a><a id="22555" class="Symbol">))</a>
    <a id="22562" href="1Lab.Equiv.html#22515" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
is-left-inverse (inv f e g e&#39;) (λ x → g (f x))" class="Function">left</a> <a id="22567" href="1Lab.Equiv.html#22567" class="Bound">z</a> <a id="22569" class="Symbol">=</a>
      <a id="22577" href="1Lab.Equiv.html#22126" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
is-iso f" class="Function">f⁻¹</a> <a id="22581" class="Symbol">.</a><a id="22582" href="1Lab.Equiv.html#6132" data-type="is-iso f → B₁ → A" class="Field">is-iso.inv</a> <a id="22593" class="Symbol">(</a><a id="22594" href="1Lab.Equiv.html#22081" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
is-iso g" class="Function">g⁻¹</a> <a id="22598" class="Symbol">.</a><a id="22599" href="1Lab.Equiv.html#6132" data-type="is-iso f → B₁ → A" class="Field">is-iso.inv</a> <a id="22610" class="Symbol">(</a><a id="22611" href="1Lab.Equiv.html#22041" class="Bound">g</a> <a id="22613" class="Symbol">(</a><a id="22614" href="1Lab.Equiv.html#22033" class="Bound">f</a> <a id="22616" href="1Lab.Equiv.html#22567" class="Bound">z</a><a id="22617" class="Symbol">)))</a> <a id="22621" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="22624" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="22627" class="Symbol">(</a><a id="22628" href="1Lab.Equiv.html#22126" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
is-iso f" class="Function">f⁻¹</a> <a id="22632" class="Symbol">.</a><a id="22633" href="1Lab.Equiv.html#6132" data-type="is-iso f → B₁ → A" class="Field">is-iso.inv</a><a id="22643" class="Symbol">)</a> <a id="22645" class="Symbol">(</a><a id="22646" href="1Lab.Equiv.html#22081" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
is-iso g" class="Function">g⁻¹</a> <a id="22650" class="Symbol">.</a><a id="22651" href="1Lab.Equiv.html#6182" data-type="(r : is-iso f) → is-left-inverse (r .inv) f" class="Field">is-iso.linv</a> <a id="22663" class="Symbol">_)</a> <a id="22666" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
      <a id="22674" href="1Lab.Equiv.html#22126" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
is-iso f" class="Function">f⁻¹</a> <a id="22678" class="Symbol">.</a><a id="22679" href="1Lab.Equiv.html#6132" data-type="is-iso f → B₁ → A" class="Field">is-iso.inv</a> <a id="22690" class="Symbol">(</a><a id="22691" href="1Lab.Equiv.html#22033" class="Bound">f</a> <a id="22693" href="1Lab.Equiv.html#22567" class="Bound">z</a><a id="22694" class="Symbol">)</a>                       <a id="22718" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="22721" href="1Lab.Equiv.html#22126" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
is-iso f" class="Function">f⁻¹</a> <a id="22725" class="Symbol">.</a><a id="22726" href="1Lab.Equiv.html#6182" data-type="(r : is-iso f) → is-left-inverse (r .inv) f" class="Field">is-iso.linv</a> <a id="22738" class="Symbol">_</a> <a id="22740" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
      <a id="22748" href="1Lab.Equiv.html#22567" class="Bound">z</a>                                           <a id="22792" href="1Lab.Path.html#46945" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
  <a id="22796" href="1Lab.Equiv.html#22796" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
is-equiv (λ x → g (f x))" class="Function">eqv</a> <a id="22800" class="Symbol">:</a> <a id="22802" href="1Lab.Equiv.html#2286" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-equiv</a> <a id="22811" class="Symbol">(λ</a> <a id="22814" href="1Lab.Equiv.html#22814" class="Bound">x</a> <a id="22816" class="Symbol">→</a> <a id="22818" href="1Lab.Equiv.html#22041" class="Bound">g</a> <a id="22820" class="Symbol">(</a><a id="22821" href="1Lab.Equiv.html#22033" class="Bound">f</a> <a id="22823" href="1Lab.Equiv.html#22814" class="Bound">x</a><a id="22824" class="Symbol">))</a>
  <a id="22829" href="1Lab.Equiv.html#22796" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
is-equiv (λ x → g (f x))" class="Function">eqv</a> <a id="22833" class="Symbol">=</a> <a id="22835" href="1Lab.Equiv.html#20157" data-type="(i : is-iso f) → is-equiv f" class="Function">is-iso→is-equiv</a> <a id="22851" class="Symbol">(</a><a id="22852" href="1Lab.Equiv.html#6116" data-type="(inv₁ : B₁ → A) (rinv₁ : is-right-inverse inv₁ f)
(linv₁ : is-left-inverse inv₁ f) →
is-iso f" class="InductiveConstructor">iso</a> <a id="22856" class="Symbol">(λ</a> <a id="22859" href="1Lab.Equiv.html#22859" class="Bound">x</a> <a id="22861" class="Symbol">→</a> <a id="22863" href="1Lab.Equiv.html#22126" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
is-iso f" class="Function">f⁻¹</a> <a id="22867" class="Symbol">.</a><a id="22868" href="1Lab.Equiv.html#6132" data-type="is-iso f → B₁ → A" class="Field">is-iso.inv</a> <a id="22879" class="Symbol">(</a><a id="22880" href="1Lab.Equiv.html#22081" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
is-iso g" class="Function">g⁻¹</a> <a id="22884" class="Symbol">.</a><a id="22885" href="1Lab.Equiv.html#6132" data-type="is-iso f → B₁ → A" class="Field">is-iso.inv</a> <a id="22896" href="1Lab.Equiv.html#22859" class="Bound">x</a><a id="22897" class="Symbol">))</a> <a id="22900" href="1Lab.Equiv.html#22244" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
is-right-inverse (inv f e g e&#39;) (λ x → g (f x))" class="Function">right</a> <a id="22906" href="1Lab.Equiv.html#22515" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
is-left-inverse (inv f e g e&#39;) (λ x → g (f x))" class="Function">left</a><a id="22910" class="Symbol">)</a>

<a id="∙-is-equiv"></a><a id="22913" href="1Lab.Equiv.html#22913" data-type="is-equiv f → is-equiv g → is-equiv (λ x → g (f x))" class="Function">∙-is-equiv</a> <a id="22924" class="Symbol">:</a> <a id="22926" class="Symbol">∀</a> <a id="22928" class="Symbol">{</a><a id="22929" href="1Lab.Equiv.html#22929" class="Bound">ℓ</a> <a id="22931" href="1Lab.Equiv.html#22931" class="Bound">ℓ₁</a> <a id="22934" href="1Lab.Equiv.html#22934" class="Bound">ℓ₂</a><a id="22936" class="Symbol">}</a> <a id="22938" class="Symbol">{</a><a id="22939" href="1Lab.Equiv.html#22939" class="Bound">A</a> <a id="22941" class="Symbol">:</a> <a id="22943" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="22948" href="1Lab.Equiv.html#22929" class="Bound">ℓ</a><a id="22949" class="Symbol">}</a> <a id="22951" class="Symbol">{</a><a id="22952" href="1Lab.Equiv.html#22952" class="Bound">B</a> <a id="22954" class="Symbol">:</a> <a id="22956" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="22961" href="1Lab.Equiv.html#22931" class="Bound">ℓ₁</a><a id="22963" class="Symbol">}</a> <a id="22965" class="Symbol">{</a><a id="22966" href="1Lab.Equiv.html#22966" class="Bound">C</a> <a id="22968" class="Symbol">:</a> <a id="22970" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="22975" href="1Lab.Equiv.html#22934" class="Bound">ℓ₂</a><a id="22977" class="Symbol">}</a>
           <a id="22990" class="Symbol">→</a> <a id="22992" class="Symbol">{</a><a id="22993" href="1Lab.Equiv.html#22993" class="Bound">f</a> <a id="22995" class="Symbol">:</a> <a id="22997" href="1Lab.Equiv.html#22939" class="Bound">A</a> <a id="22999" class="Symbol">→</a> <a id="23001" href="1Lab.Equiv.html#22952" class="Bound">B</a><a id="23002" class="Symbol">}</a> <a id="23004" class="Symbol">{</a><a id="23005" href="1Lab.Equiv.html#23005" class="Bound">g</a> <a id="23007" class="Symbol">:</a> <a id="23009" href="1Lab.Equiv.html#22952" class="Bound">B</a> <a id="23011" class="Symbol">→</a> <a id="23013" href="1Lab.Equiv.html#22966" class="Bound">C</a><a id="23014" class="Symbol">}</a>
           <a id="23027" class="Symbol">→</a> <a id="23029" href="1Lab.Equiv.html#2286" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-equiv</a> <a id="23038" href="1Lab.Equiv.html#22993" class="Bound">f</a>
           <a id="23051" class="Symbol">→</a> <a id="23053" href="1Lab.Equiv.html#2286" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-equiv</a> <a id="23062" href="1Lab.Equiv.html#23005" class="Bound">g</a>
           <a id="23075" class="Symbol">→</a> <a id="23077" href="1Lab.Equiv.html#2286" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-equiv</a> <a id="23086" class="Symbol">(λ</a> <a id="23089" href="1Lab.Equiv.html#23089" class="Bound">x</a> <a id="23091" class="Symbol">→</a> <a id="23093" href="1Lab.Equiv.html#23005" class="Bound">g</a> <a id="23095" class="Symbol">(</a><a id="23096" href="1Lab.Equiv.html#22993" class="Bound">f</a> <a id="23098" href="1Lab.Equiv.html#23089" class="Bound">x</a><a id="23099" class="Symbol">))</a>
<a id="23102" href="1Lab.Equiv.html#22913" data-type="is-equiv f → is-equiv g → is-equiv (λ x → g (f x))" class="Function">∙-is-equiv</a> <a id="23113" class="Symbol">{</a><a id="23114" class="Argument">f</a> <a id="23116" class="Symbol">=</a> <a id="23118" href="1Lab.Equiv.html#23118" class="Bound">f</a><a id="23119" class="Symbol">}</a> <a id="23121" class="Symbol">{</a><a id="23122" class="Argument">g</a> <a id="23124" class="Symbol">=</a> <a id="23126" href="1Lab.Equiv.html#23126" class="Bound">g</a><a id="23127" class="Symbol">}</a> <a id="23129" href="1Lab.Equiv.html#23129" class="Bound">e</a> <a id="23131" href="1Lab.Equiv.html#23131" class="Bound">e&#39;</a> <a id="23134" class="Symbol">=</a> <a id="23136" class="Symbol">((</a><a id="23138" href="1Lab.Equiv.html#23118" class="Bound">f</a> <a id="23140" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="23142" href="1Lab.Equiv.html#23129" class="Bound">e</a><a id="23143" class="Symbol">)</a> <a id="23145" href="1Lab.Equiv.html#21607" data-type="A ≃ B₁ → B₁ ≃ C → A ≃ C" class="Function Operator">∙e</a> <a id="23148" class="Symbol">(</a><a id="23149" href="1Lab.Equiv.html#23126" class="Bound">g</a> <a id="23151" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="23153" href="1Lab.Equiv.html#23131" class="Bound">e&#39;</a><a id="23155" class="Symbol">))</a> <a id="23158" class="Symbol">.</a><a id="23159" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a>
</pre>-->
<p>The proofs that equivalences are closed under composition assemble
nicely into transitivity operators resembling equational reasoning:</p>
<pre class="Agda"><a id="_≃⟨_⟩_"></a><a id="23316" href="1Lab.Equiv.html#23316" data-type="(A : Type ℓ) → A ≃ B₁ → B₁ ≃ C → A ≃ C" class="Function Operator">_≃⟨_⟩_</a> <a id="23323" class="Symbol">:</a> <a id="23325" class="Symbol">∀</a> <a id="23327" class="Symbol">{</a><a id="23328" href="1Lab.Equiv.html#23328" class="Bound">ℓ</a> <a id="23330" href="1Lab.Equiv.html#23330" class="Bound">ℓ₁</a> <a id="23333" href="1Lab.Equiv.html#23333" class="Bound">ℓ₂</a><a id="23335" class="Symbol">}</a> <a id="23337" class="Symbol">(</a><a id="23338" href="1Lab.Equiv.html#23338" class="Bound">A</a> <a id="23340" class="Symbol">:</a> <a id="23342" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="23347" href="1Lab.Equiv.html#23328" class="Bound">ℓ</a><a id="23348" class="Symbol">)</a> <a id="23350" class="Symbol">{</a><a id="23351" href="1Lab.Equiv.html#23351" class="Bound">B</a> <a id="23353" class="Symbol">:</a> <a id="23355" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="23360" href="1Lab.Equiv.html#23330" class="Bound">ℓ₁</a><a id="23362" class="Symbol">}</a> <a id="23364" class="Symbol">{</a><a id="23365" href="1Lab.Equiv.html#23365" class="Bound">C</a> <a id="23367" class="Symbol">:</a> <a id="23369" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="23374" href="1Lab.Equiv.html#23333" class="Bound">ℓ₂</a><a id="23376" class="Symbol">}</a>
       <a id="23385" class="Symbol">→</a> <a id="23387" href="1Lab.Equiv.html#23338" class="Bound">A</a> <a id="23389" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="23391" href="1Lab.Equiv.html#23351" class="Bound">B</a> <a id="23393" class="Symbol">→</a> <a id="23395" href="1Lab.Equiv.html#23351" class="Bound">B</a> <a id="23397" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="23399" href="1Lab.Equiv.html#23365" class="Bound">C</a> <a id="23401" class="Symbol">→</a> <a id="23403" href="1Lab.Equiv.html#23338" class="Bound">A</a> <a id="23405" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="23407" href="1Lab.Equiv.html#23365" class="Bound">C</a>
<a id="23409" href="1Lab.Equiv.html#23409" class="Bound">A</a> <span class="reasoning-step"><span class="as-written Function Operator"><a id="23411" href="1Lab.Equiv.html#23316" data-type="(A : Type ℓ) → A ≃ B₁ → B₁ ≃ C → A ≃ C" class="Function Operator">≃⟨</a> <a id="23414" href="1Lab.Equiv.html#23414" class="Bound">f</a> <a id="23416" href="1Lab.Equiv.html#23316" data-type="(A : Type ℓ) → A ≃ B₁ → B₁ ≃ C → A ≃ C" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span> <a id="23418" href="1Lab.Equiv.html#23418" class="Bound">g</a> <a id="23420" class="Symbol">=</a> <a id="23422" href="1Lab.Equiv.html#23414" class="Bound">f</a> <a id="23424" href="1Lab.Equiv.html#21607" data-type="A ≃ B₁ → B₁ ≃ C → A ≃ C" class="Function Operator">∙e</a> <a id="23427" href="1Lab.Equiv.html#23418" class="Bound">g</a>

<a id="_≃⟨⟩_"></a><a id="23430" href="1Lab.Equiv.html#23430" data-type="(A : Type ℓ) → A ≃ B₁ → A ≃ B₁" class="Function Operator">_≃⟨⟩_</a> <a id="23436" class="Symbol">:</a> <a id="23438" class="Symbol">∀</a> <a id="23440" class="Symbol">{</a><a id="23441" href="1Lab.Equiv.html#23441" class="Bound">ℓ</a> <a id="23443" href="1Lab.Equiv.html#23443" class="Bound">ℓ₁</a><a id="23445" class="Symbol">}</a> <a id="23447" class="Symbol">(</a><a id="23448" href="1Lab.Equiv.html#23448" class="Bound">A</a> <a id="23450" class="Symbol">:</a> <a id="23452" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="23457" href="1Lab.Equiv.html#23441" class="Bound">ℓ</a><a id="23458" class="Symbol">)</a> <a id="23460" class="Symbol">{</a><a id="23461" href="1Lab.Equiv.html#23461" class="Bound">B</a> <a id="23463" class="Symbol">:</a> <a id="23465" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="23470" href="1Lab.Equiv.html#23443" class="Bound">ℓ₁</a><a id="23472" class="Symbol">}</a> <a id="23474" class="Symbol">→</a> <a id="23476" href="1Lab.Equiv.html#23448" class="Bound">A</a> <a id="23478" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="23480" href="1Lab.Equiv.html#23461" class="Bound">B</a> <a id="23482" class="Symbol">→</a> <a id="23484" href="1Lab.Equiv.html#23448" class="Bound">A</a> <a id="23486" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="23488" href="1Lab.Equiv.html#23461" class="Bound">B</a>
<a id="23490" href="1Lab.Equiv.html#23490" class="Bound">x</a> <a id="23492" href="1Lab.Equiv.html#23430" data-type="(A : Type ℓ) → A ≃ B₁ → A ≃ B₁" class="Function Operator">≃⟨⟩</a> <a id="23496" href="1Lab.Equiv.html#23496" class="Bound">x≡y</a> <a id="23500" class="Symbol">=</a> <a id="23502" href="1Lab.Equiv.html#23496" class="Bound">x≡y</a>

<a id="_≃∎"></a><a id="23507" href="1Lab.Equiv.html#23507" data-type="(A : Type ℓ) → A ≃ A" class="Function Operator">_≃∎</a> <a id="23511" class="Symbol">:</a> <a id="23513" class="Symbol">∀</a> <a id="23515" class="Symbol">{</a><a id="23516" href="1Lab.Equiv.html#23516" class="Bound">ℓ</a><a id="23517" class="Symbol">}</a> <a id="23519" class="Symbol">(</a><a id="23520" href="1Lab.Equiv.html#23520" class="Bound">A</a> <a id="23522" class="Symbol">:</a> <a id="23524" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="23529" href="1Lab.Equiv.html#23516" class="Bound">ℓ</a><a id="23530" class="Symbol">)</a> <a id="23532" class="Symbol">→</a> <a id="23534" href="1Lab.Equiv.html#23520" class="Bound">A</a> <a id="23536" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="23538" href="1Lab.Equiv.html#23520" class="Bound">A</a>
<a id="23540" href="1Lab.Equiv.html#23540" class="Bound">x</a> <a id="23542" href="1Lab.Equiv.html#23507" data-type="(A : Type ℓ) → A ≃ A" class="Function Operator">≃∎</a> <a id="23545" class="Symbol">=</a> <a id="23547" class="Symbol">_</a> <a id="23549" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="23551" href="1Lab.Equiv.html#2524" data-type="is-equiv (λ x → x)" class="Function">id-equiv</a>

<a id="23561" class="Keyword">infixr</a> <a id="23568" class="Number">30</a> <a id="23571" href="1Lab.Equiv.html#21607" data-type="A ≃ B₁ → B₁ ≃ C → A ≃ C" class="Function Operator">_∙e_</a>
<a id="23576" class="Keyword">infixr</a> <a id="23583" class="Number">2</a> <a id="23585" href="1Lab.Equiv.html#23430" data-type="(A : Type ℓ) → A ≃ B₁ → A ≃ B₁" class="Function Operator">_≃⟨⟩_</a> <a id="23591" href="1Lab.Equiv.html#23316" data-type="(A : Type ℓ) → A ≃ B₁ → B₁ ≃ C → A ≃ C" class="Function Operator">_≃⟨_⟩_</a>
<a id="23598" class="Keyword">infix</a>  <a id="23605" class="Number">3</a> <a id="23607" href="1Lab.Equiv.html#23507" data-type="(A : Type ℓ) → A ≃ A" class="Function Operator">_≃∎</a>
</pre>
<h1 id="propositional-extensionality"><a href="#propositional-extensionality" class="header-link">Propositional
Extensionality<span class="header-link-emoji">🔗</span></a></h1>
<p>The following observation is not very complex, but it is incredibly
useful: Equivalence of propositions is the same as biimplication.</p>
<pre class="Agda"><a id="prop-ext"></a><a id="23791" href="1Lab.Equiv.html#23791" data-type="is-prop P → is-prop Q → (P → Q) → (Q → P) → P ≃ Q" class="Function">prop-ext</a> <a id="23800" class="Symbol">:</a> <a id="23802" class="Symbol">∀</a> <a id="23804" class="Symbol">{</a><a id="23805" href="1Lab.Equiv.html#23805" class="Bound">ℓ</a> <a id="23807" href="1Lab.Equiv.html#23807" class="Bound">ℓ&#39;</a><a id="23809" class="Symbol">}</a> <a id="23811" class="Symbol">{</a><a id="23812" href="1Lab.Equiv.html#23812" class="Bound">P</a> <a id="23814" class="Symbol">:</a> <a id="23816" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="23821" href="1Lab.Equiv.html#23805" class="Bound">ℓ</a><a id="23822" class="Symbol">}</a> <a id="23824" class="Symbol">{</a><a id="23825" href="1Lab.Equiv.html#23825" class="Bound">Q</a> <a id="23827" class="Symbol">:</a> <a id="23829" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="23834" href="1Lab.Equiv.html#23807" class="Bound">ℓ&#39;</a><a id="23836" class="Symbol">}</a>
         <a id="23847" class="Symbol">→</a> <a id="23849" href="1Lab.HLevel.html#2597" data-type="Type ℓ → Type ℓ" class="Function">is-prop</a> <a id="23857" href="1Lab.Equiv.html#23812" class="Bound">P</a> <a id="23859" class="Symbol">→</a> <a id="23861" href="1Lab.HLevel.html#2597" data-type="Type ℓ → Type ℓ" class="Function">is-prop</a> <a id="23869" href="1Lab.Equiv.html#23825" class="Bound">Q</a>
         <a id="23880" class="Symbol">→</a> <a id="23882" class="Symbol">(</a><a id="23883" href="1Lab.Equiv.html#23812" class="Bound">P</a> <a id="23885" class="Symbol">→</a> <a id="23887" href="1Lab.Equiv.html#23825" class="Bound">Q</a><a id="23888" class="Symbol">)</a> <a id="23890" class="Symbol">→</a> <a id="23892" class="Symbol">(</a><a id="23893" href="1Lab.Equiv.html#23825" class="Bound">Q</a> <a id="23895" class="Symbol">→</a> <a id="23897" href="1Lab.Equiv.html#23812" class="Bound">P</a><a id="23898" class="Symbol">)</a>
         <a id="23909" class="Symbol">→</a> <a id="23911" href="1Lab.Equiv.html#23812" class="Bound">P</a> <a id="23913" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="23915" href="1Lab.Equiv.html#23825" class="Bound">Q</a>
<a id="23917" href="1Lab.Equiv.html#23791" data-type="is-prop P → is-prop Q → (P → Q) → (Q → P) → P ≃ Q" class="Function">prop-ext</a> <a id="23926" href="1Lab.Equiv.html#23926" class="Bound">pprop</a> <a id="23932" href="1Lab.Equiv.html#23932" class="Bound">qprop</a> <a id="23938" href="1Lab.Equiv.html#23938" class="Bound">p→q</a> <a id="23942" href="1Lab.Equiv.html#23942" class="Bound">q→p</a> <a id="23946" class="Symbol">.</a><a id="23947" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="23951" class="Symbol">=</a> <a id="23953" href="1Lab.Equiv.html#23938" class="Bound">p→q</a>
<a id="23957" href="1Lab.Equiv.html#23791" data-type="is-prop P → is-prop Q → (P → Q) → (Q → P) → P ≃ Q" class="Function">prop-ext</a> <a id="23966" href="1Lab.Equiv.html#23966" class="Bound">pprop</a> <a id="23972" href="1Lab.Equiv.html#23972" class="Bound">qprop</a> <a id="23978" href="1Lab.Equiv.html#23978" class="Bound">p→q</a> <a id="23982" href="1Lab.Equiv.html#23982" class="Bound">q→p</a> <a id="23986" class="Symbol">.</a><a id="23987" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="23991" class="Symbol">.</a><a id="23992" href="1Lab.Equiv.html#2376" data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" class="Field">is-eqv</a> <a id="23999" href="1Lab.Equiv.html#23999" class="Bound">y</a> <a id="24001" class="Symbol">.</a><a id="24002" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a> <a id="24009" class="Symbol">=</a> <a id="24011" href="1Lab.Equiv.html#23982" class="Bound">q→p</a> <a id="24015" href="1Lab.Equiv.html#23999" class="Bound">y</a> <a id="24017" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="24019" href="1Lab.Equiv.html#23972" class="Bound">qprop</a> <a id="24025" class="Symbol">_</a> <a id="24027" class="Symbol">_</a>
<a id="24029" href="1Lab.Equiv.html#23791" data-type="is-prop P → is-prop Q → (P → Q) → (Q → P) → P ≃ Q" class="Function">prop-ext</a> <a id="24038" href="1Lab.Equiv.html#24038" class="Bound">pprop</a> <a id="24044" href="1Lab.Equiv.html#24044" class="Bound">qprop</a> <a id="24050" href="1Lab.Equiv.html#24050" class="Bound">p→q</a> <a id="24054" href="1Lab.Equiv.html#24054" class="Bound">q→p</a> <a id="24058" class="Symbol">.</a><a id="24059" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="24063" class="Symbol">.</a><a id="24064" href="1Lab.Equiv.html#2376" data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" class="Field">is-eqv</a> <a id="24071" href="1Lab.Equiv.html#24071" class="Bound">y</a> <a id="24073" class="Symbol">.</a><a id="24074" href="1Lab.HLevel.html#1416" data-type="(r : is-contr A) (x : A) → r .centre ≡ x" class="Field">paths</a> <a id="24080" class="Symbol">(</a><a id="24081" href="1Lab.Equiv.html#24081" class="Bound">p&#39;</a> <a id="24084" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="24086" href="1Lab.Equiv.html#24086" class="Bound">path</a><a id="24090" class="Symbol">)</a> <a id="24092" class="Symbol">=</a>
  <a id="24096" href="1Lab.Path.html#57659" data-type="(p : x .fst ≡ y .fst) → subst B₁ p (x .snd) ≡ y .snd → x ≡ y" class="Function">Σ-path</a> <a id="24103" class="Symbol">(</a><a id="24104" href="1Lab.Equiv.html#24038" class="Bound">pprop</a> <a id="24110" class="Symbol">_</a> <a id="24112" class="Symbol">_)</a> <a id="24115" class="Symbol">(</a><a id="24116" href="1Lab.HLevel.html#5554" data-type="is-prop A → is-set A" class="Function">is-prop→is-set</a> <a id="24131" href="1Lab.Equiv.html#24044" class="Bound">qprop</a> <a id="24137" class="Symbol">_</a> <a id="24139" class="Symbol">_</a> <a id="24141" class="Symbol">_</a> <a id="24143" class="Symbol">_)</a>
</pre>
  </article>
</div>
</main>
</body>
</html>
