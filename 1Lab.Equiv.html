<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="keywords" content="Agda,categories,topos" />

  <title>1Lab.Equiv - 1Lab</title>

  <link rel="stylesheet" href="/css/default.css" />
  <link rel="stylesheet" href="/css/katex.min.css" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="1Lab.Equiv - 1Lab" />
  <meta name="twitter:image" content="https://1lab.dev/static/cube-128x.png" />

  <meta name="og:title" content="1Lab.Equiv - 1Lab" />
  <meta name="og:image" content="https://1lab.dev/static/cube-128x.png" />
  <meta name="og:site-name" content="1Lab" />
  <meta name="og:type" content="website" />

    <meta name="og:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="twitter:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  
  <script defer src="/main.js"></script>

  <noscript>
    <style>
      body span.reasoning-step .as-written {
        display: inline;
      }

      body span.reasoning-step .alternate {
        display: none;
      }
    </style>
  </noscript>

  <!-- Google font embeds -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;0,800;1,400;1,500;1,600;1,700;1,800&amp;family=Inria+Sans:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&amp;display=swap" rel="stylesheet">
</head>

<body class="text-page">
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <!-- Table of contents (only if the page has a table of contents) -->
    <aside id="toc">
    <div id="toc-container" style="min-width: 10em; font-size: 15pt;">
      <!-- Title for the page -->
      <h3 class="Agda" style="margin-top: 0; margin-bottom: 0; white-space: pre;">
                <a class="Module">1Lab.Equiv</a>
              </h3>

      <!-- Cube logo -->
      <a id="logo" href="/">
        <img alt="1Lab" src="/static/cube-72x.png" style="display: block; margin-bottom: 1em; margin: auto;" width="32px" height="32px" />
      </a>

      <!-- Actual table of contents (separated from the rest by
      horizontal rules) -->
      <hr />
      <ul>
      <li><a href="#equivalences"><a href="#equivalences" class="header-link">Equivalences<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#is-equiv-is-propositional"><a href="#is-equiv-is-propositional" class="header-link">is-equiv
      is
      propositional<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      <li><a href="#isomorphisms-from-equivalences"><a href="#isomorphisms-from-equivalences" class="header-link">Isomorphisms
      from
      equivalences<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#equivalences-from-isomorphisms"><a href="#equivalences-from-isomorphisms" class="header-link">Equivalences
      from
      isomorphisms<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#equivalence-reasoning"><a href="#equivalence-reasoning" class="header-link">Equivalence
      Reasoning<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#propositional-extensionality"><a href="#propositional-extensionality" class="header-link">Propositional
      Extensionality<span class="header-link-emoji">🔗</span></a></a></li>
      </ul>
      <hr />

      <!-- Sidebar controls -->
      <div style="display: flex; gap: 0.25em; flex-flow: row wrap;">
        <!-- Sidebar equations control -->
        <span class="equations" style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-eqns" type="checkbox" class="equations" id="sidebar-eqns">
          <label for="sidebar-eqns">Equations</label>
        </span>

        <!-- Sidebar fonts control -->
        <span style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-font" type="checkbox" id="toggle-fonts">
          <label for="toggle-fonts">Serif Font</label>
        </span>

        <!-- Sidebar footnotes control -->
        <span class="inline-footnotes" style="display: none; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-fns" type="checkbox" class="inline-footnotes" id="sidebar-fns">
          <label for="sidebar-fns">Inline Footnotes</label>
        </span>
      </div>

      <hr />

      <!-- Navbar navigation (lol) -->
      <div id="return" style="white-space: nowrap;">
        <div class="search-form search-form-proxy" role="form">
          <input id="search-box-proxy" type_="text" placeholder="Search..." autocomplete="off" tabindex="0"></input>
        </div>

              <a href="/">back to index</a> <br />
              <a href="all-pages.html">view all pages</a> <br />
        <a href="https://github.com/plt-amy/cubical-1lab/blob/bc3d169a3fa15f30160966c53f8335592dd0187c/src/1Lab/Equiv.lagda.md">link to source</a> <br />
                <hr /> <div class="author-list">Written by Amélia Liao</div> <br />
              </div>
    </div>
  </aside>
  
  <article>
    <!-- Article navigation (narrow screens only) -->
    <div class="narrow-only" id="article-nav">
      <!-- Index return anchor (only if the page is not the index) -->
            <div id="return">
        <a href="/">back to index</a>
      </div>
      
      <!-- Navbar equations control -->
      <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-eqns" type="checkbox" class="equations" id="navbar-eqns">
        <label for="navbar-eqns">Equations</label>
      </span>

      <!-- Navbar footnotes control -->
      <span class="inline-footnotes" style="display: none; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-fns" type="checkbox" class="inline-footnotes" id="navbar-fns">
        <label for="navbar-fns">Inline Footnotes</label>
      </span>
    </div>

<pre class="Agda"><a id="9" class="Keyword">open</a> <a id="14" class="Keyword">import</a> <a id="21" href="1Lab.HLevel.html" class="Module">1Lab.HLevel</a>
<a id="33" class="Keyword">open</a> <a id="38" class="Keyword">import</a> <a id="45" href="1Lab.Path.html" class="Module">1Lab.Path</a>
<a id="55" class="Keyword">open</a> <a id="60" class="Keyword">import</a> <a id="67" href="1Lab.Type.html" class="Module">1Lab.Type</a>

<a id="78" class="Keyword">open</a> <a id="83" href="1Lab.HLevel.html#1328" data-type="(A : Type ℓ) → Type ℓ" class="Module">is-contr</a>

<a id="93" class="Keyword">module</a> <a id="100" href="1Lab.Equiv.html" class="Module">1Lab.Equiv</a> <a id="111" class="Keyword">where</a>
</pre>
<h1 id="equivalences"><a href="#equivalences" class="header-link">Equivalences<span class="header-link-emoji">🔗</span></a></h1>
<p>The big idea of homotopy type theory is that isomorphic types can be
identified: the <a href="1Lab.Univalence.html">univalence axiom</a>.
However, the notion of
<span class="Agda"><a href="1Lab.Equiv.html#6026" class="Record">isomorphism</a></span>,
is, in a sense, not “coherent” enough to be used in the definition. For
that, we need a coherent definition of <em>equivalence</em>, where
“being an equivalence” is <a href="1Lab.HLevel.html#2597">a
proposition</a>.</p>
<p>To be more specific, what we need for a notion of equivalence
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mo>−</mo><mi mathvariant="normal">e</mi><mi mathvariant="normal">q</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">v</mi></mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\id{is-equiv}(f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">is</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathrm" style="margin-right:0.01389em;">equiv</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span>
to be “coherent” is:</p>
<ul>
<li><p>Being an
<span class="Agda"><a href="1Lab.Equiv.html#6026" class="Record">isomorphism</a></span>
implies being an
<span class="Agda"><a href="1Lab.Equiv.html#2286" class="Record">equivalence</a></span>
(<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mo>−</mo><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">o</mi></mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>→</mo><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mo>−</mo><mi mathvariant="normal">e</mi><mi mathvariant="normal">q</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">v</mi></mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\id{is-iso}(f) \to \id{is-equiv}(f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">is</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathrm">iso</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">is</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathrm" style="margin-right:0.01389em;">equiv</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span>)</span></p></li>
<li><p>Being an equivalence implies being an isomorphism
(<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mo>−</mo><mi mathvariant="normal">e</mi><mi mathvariant="normal">q</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">v</mi></mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>→</mo><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mo>−</mo><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">o</mi></mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\id{is-equiv}(f) \to \id{is-iso}(f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">is</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathrm" style="margin-right:0.01389em;">equiv</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">is</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathrm">iso</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span>);</span>
Taken together with the first point we may summarise: “Being an
equivalence and being an isomorphism are logically equivalent.”</p></li>
<li><p>Most importantly, being an equivalence <em>must</em> be a
proposition.</p></li>
</ul>
<p>The notion we adopt is due to Voevodsky: An equivalence is one that
has
<span class="Agda"><a href="1Lab.HLevel.html#1328" class="Module">contractible</a></span>
<span class="Agda"><a href="1Lab.Equiv.html#1873" class="Function">fibres</a></span>.
Other definitions are possible (e.g.: <a href="1Lab.Equiv.Biinv.html">bi-inverible maps</a>) — but contractible
fibres are “privileged” in Cubical Agda because for <a href="1Lab.Univalence.html#Glue">glueing</a> to work, we need a proof
that
<span class="Agda"><a href="1Lab.Equiv.html#3671" class="Function">equivalences have contractible fibres</a></span>
anyway.</p>
<pre class="Agda"><a id="1547" class="Keyword">private</a>
  <a id="1557" class="Keyword">variable</a>
    <a id="1570" href="1Lab.Equiv.html#1570" class="Generalizable">ℓ₁</a> <a id="1573" href="1Lab.Equiv.html#1573" class="Generalizable">ℓ₂</a> <a id="1576" class="Symbol">:</a> <a id="1578" href="Agda.Primitive.html#582" data-type="Type" class="Postulate">Level</a>
    <a id="1588" href="1Lab.Equiv.html#1588" class="Generalizable">A</a> <a id="1590" href="1Lab.Equiv.html#1590" class="Generalizable">B</a> <a id="1592" class="Symbol">:</a> <a id="1594" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="1599" href="1Lab.Equiv.html#1570" class="Generalizable">ℓ₁</a>
</pre>
<p>A <em>homotopy fibre</em>, <em>fibre</em> or <em>preimage</em> of a
function <code>f</code> at a point <code>y : B</code> is the collection
of all elements of <code>A</code> that <code>f</code> maps to
<code>y</code>. Since many choices of name are possible, we settle on
the one that is shortest and most aesthetic:
<span class="Agda"><a href="1Lab.Equiv.html#1873" class="Function">fibre</a></span>.</p>
<pre class="Agda"><a id="fibre"></a><a id="1873" href="1Lab.Equiv.html#1873" data-type="(A → B₁) → B₁ → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Function">fibre</a> <a id="1879" class="Symbol">:</a> <a id="1881" class="Symbol">(</a><a id="1882" href="1Lab.Equiv.html#1588" class="Generalizable">A</a> <a id="1884" class="Symbol">→</a> <a id="1886" href="1Lab.Equiv.html#1590" class="Generalizable">B</a><a id="1887" class="Symbol">)</a> <a id="1889" class="Symbol">→</a> <a id="1891" href="1Lab.Equiv.html#1590" class="Generalizable">B</a> <a id="1893" class="Symbol">→</a> <a id="1895" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="1900" class="Symbol">_</a>
<a id="1902" href="1Lab.Equiv.html#1873" data-type="(A → B₁) → B₁ → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Function">fibre</a> <a id="1908" href="1Lab.Equiv.html#1908" class="Bound">f</a> <a id="1910" href="1Lab.Equiv.html#1910" class="Bound">y</a> <a id="1912" class="Symbol">=</a> <a id="1914" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">Σ</a> <a id="1916" class="Symbol">λ</a> <a id="1918" href="1Lab.Equiv.html#1918" class="Bound">x</a> <a id="1920" class="Symbol">→</a> <a id="1922" href="1Lab.Equiv.html#1908" class="Bound">f</a> <a id="1924" href="1Lab.Equiv.html#1918" class="Bound">x</a> <a id="1926" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="1928" href="1Lab.Equiv.html#1910" class="Bound">y</a>
</pre>
<p>A function <code>f</code> is an equivalence if every one of its
fibres is <a href="1Lab.HLevel.html#1328">contractible</a> - that
is, for any element <code>y</code> in the range, there is exactly one
element in the domain which <code>f</code> maps to <code>y</code>. Using
set-theoretic language, <code>f</code> is an equivalence if the preimage
of every element of the codomain is a singleton.</p>
<pre class="Agda"><a id="2279" class="Keyword">record</a> <a id="is-equiv"></a><a id="2286" href="1Lab.Equiv.html#2286" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-equiv</a> <a id="2295" class="Symbol">(</a><a id="2296" href="1Lab.Equiv.html#2296" class="Bound">f</a> <a id="2298" class="Symbol">:</a> <a id="2300" href="1Lab.Equiv.html#1588" class="Generalizable">A</a> <a id="2302" class="Symbol">→</a> <a id="2304" href="1Lab.Equiv.html#1590" class="Generalizable">B</a><a id="2305" class="Symbol">)</a> <a id="2307" class="Symbol">:</a> <a id="2309" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="2314" class="Symbol">(</a><a id="2315" href="1Lab.Type.html#921" data-type="Type ℓ → Level" class="Function">level-of</a> <a id="2324" href="1Lab.Equiv.html#2300" class="Bound">A</a> <a id="2326" href="Agda.Primitive.html#795" data-type="Level → Level → Level" class="Primitive Operator">⊔</a> <a id="2328" href="1Lab.Type.html#921" data-type="Type ℓ → Level" class="Function">level-of</a> <a id="2337" href="1Lab.Equiv.html#2304" class="Bound">B</a><a id="2338" class="Symbol">)</a> <a id="2340" class="Keyword">where</a>
  <a id="2348" class="Keyword">no-eta-equality</a>
  <a id="2366" class="Keyword">field</a>
    <a id="is-equiv.is-eqv"></a><a id="2376" href="1Lab.Equiv.html#2376" data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" class="Field">is-eqv</a> <a id="2383" class="Symbol">:</a> <a id="2385" class="Symbol">(</a><a id="2386" href="1Lab.Equiv.html#2386" class="Bound">y</a> <a id="2388" class="Symbol">:</a> <a id="2390" href="1Lab.Equiv.html#2304" class="Bound">B</a><a id="2391" class="Symbol">)</a> <a id="2393" class="Symbol">→</a> <a id="2395" href="1Lab.HLevel.html#1328" data-type="(A : Type ℓ) → Type ℓ" class="Record">is-contr</a> <a id="2404" class="Symbol">(</a><a id="2405" href="1Lab.Equiv.html#1873" data-type="(A → B₁) → B₁ → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Function">fibre</a> <a id="2411" href="1Lab.Equiv.html#2296" class="Bound">f</a> <a id="2413" href="1Lab.Equiv.html#2386" class="Bound">y</a><a id="2414" class="Symbol">)</a>

<a id="2417" class="Keyword">open</a> <a id="2422" href="1Lab.Equiv.html#2286" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Module">is-equiv</a> <a id="2431" class="Keyword">public</a>

<a id="_≃_"></a><a id="2439" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">_≃_</a> <a id="2443" class="Symbol">:</a> <a id="2445" class="Symbol">∀</a> <a id="2447" class="Symbol">{</a><a id="2448" href="1Lab.Equiv.html#2448" class="Bound">ℓ₁</a> <a id="2451" href="1Lab.Equiv.html#2451" class="Bound">ℓ₂</a><a id="2453" class="Symbol">}</a> <a id="2455" class="Symbol">→</a> <a id="2457" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="2462" href="1Lab.Equiv.html#2448" class="Bound">ℓ₁</a> <a id="2465" class="Symbol">→</a> <a id="2467" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="2472" href="1Lab.Equiv.html#2451" class="Bound">ℓ₂</a> <a id="2475" class="Symbol">→</a> <a id="2477" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="2482" class="Symbol">_</a>
<a id="2484" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">_≃_</a> <a id="2488" href="1Lab.Equiv.html#2488" class="Bound">A</a> <a id="2490" href="1Lab.Equiv.html#2490" class="Bound">B</a> <a id="2492" class="Symbol">=</a> <a id="2494" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">Σ</a> <a id="2496" class="Symbol">(</a><a id="2497" href="1Lab.Equiv.html#2286" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-equiv</a> <a id="2506" class="Symbol">{</a><a id="2507" class="Argument">A</a> <a id="2509" class="Symbol">=</a> <a id="2511" href="1Lab.Equiv.html#2488" class="Bound">A</a><a id="2512" class="Symbol">}</a> <a id="2514" class="Symbol">{</a><a id="2515" class="Argument">B</a> <a id="2517" class="Symbol">=</a> <a id="2519" href="1Lab.Equiv.html#2490" class="Bound">B</a><a id="2520" class="Symbol">})</a>

<a id="id-equiv"></a><a id="2524" href="1Lab.Equiv.html#2524" data-type="is-equiv (λ x → x)" class="Function">id-equiv</a> <a id="2533" class="Symbol">:</a> <a id="2535" href="1Lab.Equiv.html#2286" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-equiv</a> <a id="2544" class="Symbol">{</a><a id="2545" class="Argument">A</a> <a id="2547" class="Symbol">=</a> <a id="2549" href="1Lab.Equiv.html#1588" class="Generalizable">A</a><a id="2550" class="Symbol">}</a> <a id="2552" class="Symbol">(λ</a> <a id="2555" href="1Lab.Equiv.html#2555" class="Bound">x</a> <a id="2557" class="Symbol">→</a> <a id="2559" href="1Lab.Equiv.html#2555" class="Bound">x</a><a id="2560" class="Symbol">)</a>
<a id="2562" href="1Lab.Equiv.html#2524" data-type="is-equiv (λ x → x)" class="Function">id-equiv</a> <a id="2571" class="Symbol">.</a><a id="2572" href="1Lab.Equiv.html#2376" data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" class="Field">is-eqv</a> <a id="2579" href="1Lab.Equiv.html#2579" class="Bound">y</a> <a id="2581" class="Symbol">=</a>
  <a id="2585" href="1Lab.HLevel.html#1383" data-type="(centre₁ : A) (paths₁ : (x : A) → centre₁ ≡ x) → is-contr A" class="InductiveConstructor">contr</a> <a id="2591" class="Symbol">(</a><a id="2592" href="1Lab.Equiv.html#2579" class="Bound">y</a> <a id="2594" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="2596" class="Symbol">λ</a> <a id="2598" href="1Lab.Equiv.html#2598" class="Bound">i</a> <a id="2600" class="Symbol">→</a> <a id="2602" href="1Lab.Equiv.html#2579" class="Bound">y</a><a id="2603" class="Symbol">)</a>
    <a id="2609" class="Symbol">λ</a> <a id="2611" class="Symbol">{</a> <a id="2613" class="Symbol">(</a><a id="2614" href="1Lab.Equiv.html#2614" class="Bound">y&#39;</a> <a id="2617" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="2619" href="1Lab.Equiv.html#2619" class="Bound">p</a><a id="2620" class="Symbol">)</a> <a id="2622" href="1Lab.Equiv.html#2622" class="Bound">i</a> <a id="2624" class="Symbol">→</a> <a id="2626" href="1Lab.Equiv.html#2619" class="Bound">p</a> <a id="2628" class="Symbol">(</a><a id="2629" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="2631" href="1Lab.Equiv.html#2622" class="Bound">i</a><a id="2632" class="Symbol">)</a> <a id="2634" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="2636" class="Symbol">λ</a> <a id="2638" href="1Lab.Equiv.html#2638" class="Bound">j</a> <a id="2640" class="Symbol">→</a> <a id="2642" href="1Lab.Equiv.html#2619" class="Bound">p</a> <a id="2644" class="Symbol">(</a><a id="2645" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="2647" href="1Lab.Equiv.html#2622" class="Bound">i</a> <a id="2649" href="1Lab.Path.html#2226" class="Primitive Operator">∨</a> <a id="2651" href="1Lab.Equiv.html#2638" class="Bound">j</a><a id="2652" class="Symbol">)</a> <a id="2654" class="Symbol">}</a>
</pre>
<!--
<pre class="Agda"><a id="2670" class="Comment">-- This helper is for functions f, g that cancel eachother, up to</a>
<a id="2736" class="Comment">-- definitional equality, without any case analysis on the argument:</a>

<a id="strict-fibres"></a><a id="2806" href="1Lab.Equiv.html#2806" data-type="(g : B₁ → A) (b : B₁) →
Σ
(λ t →
   (t&#39; : fibre f b) →
   Path (fibre f (f (g b))) t
   (g (f (t&#39; .fst)) , ap (f ⊙ g) (t&#39; .snd)))" class="Function">strict-fibres</a> <a id="2820" class="Symbol">:</a> <a id="2822" class="Symbol">∀</a> <a id="2824" class="Symbol">{</a><a id="2825" href="1Lab.Equiv.html#2825" class="Bound">ℓ</a> <a id="2827" href="1Lab.Equiv.html#2827" class="Bound">ℓ&#39;</a><a id="2829" class="Symbol">}</a> <a id="2831" class="Symbol">{</a><a id="2832" href="1Lab.Equiv.html#2832" class="Bound">A</a> <a id="2834" class="Symbol">:</a> <a id="2836" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="2841" href="1Lab.Equiv.html#2825" class="Bound">ℓ</a><a id="2842" class="Symbol">}</a> <a id="2844" class="Symbol">{</a><a id="2845" href="1Lab.Equiv.html#2845" class="Bound">B</a> <a id="2847" class="Symbol">:</a> <a id="2849" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="2854" href="1Lab.Equiv.html#2827" class="Bound">ℓ&#39;</a><a id="2856" class="Symbol">}</a> <a id="2858" class="Symbol">{</a><a id="2859" href="1Lab.Equiv.html#2859" class="Bound">f</a> <a id="2861" class="Symbol">:</a> <a id="2863" href="1Lab.Equiv.html#2832" class="Bound">A</a> <a id="2865" class="Symbol">→</a> <a id="2867" href="1Lab.Equiv.html#2845" class="Bound">B</a><a id="2868" class="Symbol">}</a> <a id="2870" class="Symbol">(</a><a id="2871" href="1Lab.Equiv.html#2871" class="Bound">g</a> <a id="2873" class="Symbol">:</a> <a id="2875" href="1Lab.Equiv.html#2845" class="Bound">B</a> <a id="2877" class="Symbol">→</a> <a id="2879" href="1Lab.Equiv.html#2832" class="Bound">A</a><a id="2880" class="Symbol">)</a> <a id="2882" class="Symbol">(</a><a id="2883" href="1Lab.Equiv.html#2883" class="Bound">b</a> <a id="2885" class="Symbol">:</a> <a id="2887" href="1Lab.Equiv.html#2845" class="Bound">B</a><a id="2888" class="Symbol">)</a>
  <a id="2892" class="Symbol">→</a> <a id="2894" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">Σ[</a> <a id="2897" href="1Lab.Equiv.html#2897" class="Bound">t</a> <a id="2899" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">∈</a> <a id="2901" href="1Lab.Equiv.html#1873" data-type="(A → B₁) → B₁ → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Function">fibre</a> <a id="2907" href="1Lab.Equiv.html#2859" class="Bound">f</a> <a id="2909" class="Symbol">(</a><a id="2910" href="1Lab.Equiv.html#2859" class="Bound">f</a> <a id="2912" class="Symbol">(</a><a id="2913" href="1Lab.Equiv.html#2871" class="Bound">g</a> <a id="2915" href="1Lab.Equiv.html#2883" class="Bound">b</a><a id="2916" class="Symbol">))</a> <a id="2919" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">]</a>
    <a id="2925" class="Symbol">((</a><a id="2927" href="1Lab.Equiv.html#2927" class="Bound">t&#39;</a> <a id="2930" class="Symbol">:</a> <a id="2932" href="1Lab.Equiv.html#1873" data-type="(A → B₁) → B₁ → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Function">fibre</a> <a id="2938" href="1Lab.Equiv.html#2859" class="Bound">f</a> <a id="2940" href="1Lab.Equiv.html#2883" class="Bound">b</a><a id="2941" class="Symbol">)</a> <a id="2943" class="Symbol">→</a> <a id="2945" href="1Lab.Path.html#2466" data-type="(A : Type ℓ) → A → A → Type ℓ" class="Function">Path</a> <a id="2950" class="Symbol">(</a><a id="2951" href="1Lab.Equiv.html#1873" data-type="(A → B₁) → B₁ → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Function">fibre</a> <a id="2957" href="1Lab.Equiv.html#2859" class="Bound">f</a> <a id="2959" class="Symbol">(</a><a id="2960" href="1Lab.Equiv.html#2859" class="Bound">f</a> <a id="2962" class="Symbol">(</a><a id="2963" href="1Lab.Equiv.html#2871" class="Bound">g</a> <a id="2965" href="1Lab.Equiv.html#2883" class="Bound">b</a><a id="2966" class="Symbol">)))</a> <a id="2970" href="1Lab.Equiv.html#2897" class="Bound">t</a>
                          <a id="2998" class="Symbol">(</a><a id="2999" href="1Lab.Equiv.html#2871" class="Bound">g</a> <a id="3001" class="Symbol">(</a><a id="3002" href="1Lab.Equiv.html#2859" class="Bound">f</a> <a id="3004" class="Symbol">(</a><a id="3005" href="1Lab.Equiv.html#2927" class="Bound">t&#39;</a> <a id="3008" class="Symbol">.</a><a id="3009" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a><a id="3012" class="Symbol">))</a> <a id="3015" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="3017" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="3020" class="Symbol">(</a><a id="3021" href="1Lab.Equiv.html#2859" class="Bound">f</a> <a id="3023" href="1Lab.Type.html#2227" data-type="((y : B₁ x) → C x y) → (f : (x : A) → B₁ x) (x : A) → C x (f x)" class="Function Operator">∘</a> <a id="3025" href="1Lab.Equiv.html#2871" class="Bound">g</a><a id="3026" class="Symbol">)</a> <a id="3028" class="Symbol">(</a><a id="3029" href="1Lab.Equiv.html#2927" class="Bound">t&#39;</a> <a id="3032" class="Symbol">.</a><a id="3033" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a><a id="3036" class="Symbol">)))</a>
<a id="3040" href="1Lab.Equiv.html#2806" data-type="(g : B₁ → A) (b : B₁) →
Σ
(λ t →
   (t&#39; : fibre f b) →
   Path (fibre f (f (g b))) t
   (g (f (t&#39; .fst)) , ap (f ⊙ g) (t&#39; .snd)))" class="Function">strict-fibres</a> <a id="3054" class="Symbol">{</a><a id="3055" class="Argument">f</a> <a id="3057" class="Symbol">=</a> <a id="3059" href="1Lab.Equiv.html#3059" class="Bound">f</a><a id="3060" class="Symbol">}</a> <a id="3062" href="1Lab.Equiv.html#3062" class="Bound">g</a> <a id="3064" href="1Lab.Equiv.html#3064" class="Bound">b</a> <a id="3066" class="Symbol">.</a><a id="3067" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="3071" class="Symbol">=</a> <a id="3073" class="Symbol">(</a><a id="3074" href="1Lab.Equiv.html#3062" class="Bound">g</a> <a id="3076" href="1Lab.Equiv.html#3064" class="Bound">b</a> <a id="3078" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="3080" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a><a id="3084" class="Symbol">)</a>
<a id="3086" href="1Lab.Equiv.html#2806" data-type="(g : B₁ → A) (b : B₁) →
Σ
(λ t →
   (t&#39; : fibre f b) →
   Path (fibre f (f (g b))) t
   (g (f (t&#39; .fst)) , ap (f ⊙ g) (t&#39; .snd)))" class="Function">strict-fibres</a> <a id="3100" class="Symbol">{</a><a id="3101" class="Argument">f</a> <a id="3103" class="Symbol">=</a> <a id="3105" href="1Lab.Equiv.html#3105" class="Bound">f</a><a id="3106" class="Symbol">}</a> <a id="3108" href="1Lab.Equiv.html#3108" class="Bound">g</a> <a id="3110" href="1Lab.Equiv.html#3110" class="Bound">b</a> <a id="3112" class="Symbol">.</a><a id="3113" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="3117" class="Symbol">(</a><a id="3118" href="1Lab.Equiv.html#3118" class="Bound">a</a> <a id="3120" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="3122" href="1Lab.Equiv.html#3122" class="Bound">p</a><a id="3123" class="Symbol">)</a> <a id="3125" href="1Lab.Equiv.html#3125" class="Bound">i</a> <a id="3127" class="Symbol">=</a> <a id="3129" class="Symbol">(</a><a id="3130" href="1Lab.Equiv.html#3108" class="Bound">g</a> <a id="3132" class="Symbol">(</a><a id="3133" href="1Lab.Equiv.html#3122" class="Bound">p</a> <a id="3135" class="Symbol">(</a><a id="3136" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="3138" href="1Lab.Equiv.html#3125" class="Bound">i</a><a id="3139" class="Symbol">))</a> <a id="3142" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="3144" class="Symbol">λ</a> <a id="3146" href="1Lab.Equiv.html#3146" class="Bound">j</a> <a id="3148" class="Symbol">→</a> <a id="3150" href="1Lab.Equiv.html#3105" class="Bound">f</a> <a id="3152" class="Symbol">(</a><a id="3153" href="1Lab.Equiv.html#3108" class="Bound">g</a> <a id="3155" class="Symbol">(</a><a id="3156" href="1Lab.Equiv.html#3122" class="Bound">p</a> <a id="3158" class="Symbol">(</a><a id="3159" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="3161" href="1Lab.Equiv.html#3125" class="Bound">i</a> <a id="3163" href="1Lab.Path.html#2226" class="Primitive Operator">∨</a> <a id="3165" href="1Lab.Equiv.html#3146" class="Bound">j</a><a id="3166" class="Symbol">))))</a>

<a id="3172" class="Comment">-- This is more efficient than using Iso→Equiv. When f (g x) is definitionally x,</a>
<a id="3254" class="Comment">-- the type reduces to essentially is-contr (fibre f b).</a>
</pre>-->
<p>For Cubical Agda, the type of equivalences is distinguished, so we
have to make a small wrapper to match the interface Agda expects. This
is the geometric definition of contractibility, in terms of <a href="1Lab.Path.html#extensibility">partial elements</a> and
extensibility.</p>
<pre class="Agda"><a id="3615" class="Symbol">{-#</a> <a id="3619" class="Keyword">BUILTIN</a> <a id="3627" class="Keyword">EQUIV</a> <a id="3633" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">_≃_</a> <a id="3637" class="Symbol">#-}</a>
<a id="3641" class="Symbol">{-#</a> <a id="3645" class="Keyword">BUILTIN</a> <a id="3653" class="Keyword">EQUIVFUN</a> <a id="3662" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="3666" class="Symbol">#-}</a>

<a id="is-eqv&#39;"></a><a id="3671" href="1Lab.Equiv.html#3671" data-type="(A : Type a) (B₁ : Type b) (w : A ≃ B₁) (a : B₁) (ψ : I) →
Partial ψ (fibre (w .fst) a) → fibre (w .fst) a" class="Function">is-eqv&#39;</a> <a id="3679" class="Symbol">:</a> <a id="3681" class="Symbol">∀</a> <a id="3683" class="Symbol">{</a><a id="3684" href="1Lab.Equiv.html#3684" class="Bound">a</a> <a id="3686" href="1Lab.Equiv.html#3686" class="Bound">b</a><a id="3687" class="Symbol">}</a> <a id="3689" class="Symbol">(</a><a id="3690" href="1Lab.Equiv.html#3690" class="Bound">A</a> <a id="3692" class="Symbol">:</a> <a id="3694" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="3699" href="1Lab.Equiv.html#3684" class="Bound">a</a><a id="3700" class="Symbol">)</a> <a id="3702" class="Symbol">(</a><a id="3703" href="1Lab.Equiv.html#3703" class="Bound">B</a> <a id="3705" class="Symbol">:</a> <a id="3707" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="3712" href="1Lab.Equiv.html#3686" class="Bound">b</a><a id="3713" class="Symbol">)</a>
        <a id="3723" class="Symbol">→</a> <a id="3725" class="Symbol">(</a><a id="3726" href="1Lab.Equiv.html#3726" class="Bound">w</a> <a id="3728" class="Symbol">:</a> <a id="3730" href="1Lab.Equiv.html#3690" class="Bound">A</a> <a id="3732" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="3734" href="1Lab.Equiv.html#3703" class="Bound">B</a><a id="3735" class="Symbol">)</a> <a id="3737" class="Symbol">(</a><a id="3738" href="1Lab.Equiv.html#3738" class="Bound">a</a> <a id="3740" class="Symbol">:</a> <a id="3742" href="1Lab.Equiv.html#3703" class="Bound">B</a><a id="3743" class="Symbol">)</a>
        <a id="3753" class="Symbol">→</a> <a id="3755" class="Symbol">(</a><a id="3756" href="1Lab.Equiv.html#3756" class="Bound">ψ</a> <a id="3758" class="Symbol">:</a> <a id="3760" href="Agda.Primitive.Cubical.html#150" class="Datatype">I</a><a id="3761" class="Symbol">)</a>
        <a id="3771" class="Symbol">→</a> <a id="3773" href="Agda.Primitive.Cubical.html#1115" class="Primitive">Partial</a> <a id="3781" href="1Lab.Equiv.html#3756" class="Bound">ψ</a> <a id="3783" class="Symbol">(</a><a id="3784" href="1Lab.Equiv.html#1873" data-type="(A → B₁) → B₁ → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Function">fibre</a> <a id="3790" class="Symbol">(</a><a id="3791" href="1Lab.Equiv.html#3726" class="Bound">w</a> <a id="3793" class="Symbol">.</a><a id="3794" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a><a id="3797" class="Symbol">)</a> <a id="3799" href="1Lab.Equiv.html#3738" class="Bound">a</a><a id="3800" class="Symbol">)</a>
        <a id="3810" class="Symbol">→</a> <a id="3812" href="1Lab.Equiv.html#1873" data-type="(A → B₁) → B₁ → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Function">fibre</a> <a id="3818" class="Symbol">(</a><a id="3819" href="1Lab.Equiv.html#3726" class="Bound">w</a> <a id="3821" class="Symbol">.</a><a id="3822" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a><a id="3825" class="Symbol">)</a> <a id="3827" href="1Lab.Equiv.html#3738" class="Bound">a</a>
<a id="3829" href="1Lab.Equiv.html#3671" data-type="(A : Type a) (B₁ : Type b) (w : A ≃ B₁) (a : B₁) (ψ : I) →
Partial ψ (fibre (w .fst) a) → fibre (w .fst) a" class="Function">is-eqv&#39;</a> <a id="3837" href="1Lab.Equiv.html#3837" class="Bound">A</a> <a id="3839" href="1Lab.Equiv.html#3839" class="Bound">B</a> <a id="3841" class="Symbol">(</a><a id="3842" href="1Lab.Equiv.html#3842" class="Bound">f</a> <a id="3844" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="3846" href="1Lab.Equiv.html#3846" class="Bound">is-equiv</a><a id="3854" class="Symbol">)</a> <a id="3856" href="1Lab.Equiv.html#3856" class="Bound">a</a> <a id="3858" href="1Lab.Equiv.html#3858" class="Bound">ψ</a> <a id="3860" href="1Lab.Equiv.html#3860" class="Bound">u0</a> <a id="3863" class="Symbol">=</a>
  <a id="3867" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="3873" class="Symbol">(λ</a> <a id="3876" href="1Lab.Equiv.html#3876" class="Bound">i</a> <a id="3878" class="Symbol">→</a> <a id="3880" class="Symbol">λ</a> <a id="3882" class="Symbol">{</a> <a id="3884" class="Symbol">(</a><a id="3885" href="1Lab.Equiv.html#3858" class="Bound">ψ</a> <a id="3887" class="Symbol">=</a> <a id="3889" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="3891" class="Symbol">)</a> <a id="3893" class="Symbol">→</a> <a id="3895" href="1Lab.Equiv.html#4003" data-type="(A : Type a) (B₁ : Type b) (f : A → B₁) (is-equiv₁ : is-equiv f)
(a : B₁) (ψ : I) (u0 : Partial ψ (fibre f a)) →
is-contr (fibre f a)" class="Function">c</a> <a id="3897" class="Symbol">.</a><a id="3898" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a>
                 <a id="3922" class="Symbol">;</a> <a id="3924" class="Symbol">(</a><a id="3925" href="1Lab.Equiv.html#3858" class="Bound">ψ</a> <a id="3927" class="Symbol">=</a> <a id="3929" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="3931" class="Symbol">)</a> <a id="3933" class="Symbol">→</a> <a id="3935" href="1Lab.Equiv.html#4003" data-type="(A : Type a) (B₁ : Type b) (f : A → B₁) (is-equiv₁ : is-equiv f)
(a : B₁) (ψ : I) (u0 : Partial ψ (fibre f a)) →
is-contr (fibre f a)" class="Function">c</a> <a id="3937" class="Symbol">.</a><a id="3938" href="1Lab.HLevel.html#1416" data-type="(r : is-contr A) (x : A) → r .centre ≡ x" class="Field">paths</a> <a id="3944" class="Symbol">(</a><a id="3945" href="1Lab.Equiv.html#3860" class="Bound">u0</a> <a id="3948" href="1Lab.Path.html#2443" class="Postulate">1=1</a><a id="3951" class="Symbol">)</a> <a id="3953" href="1Lab.Equiv.html#3876" class="Bound">i</a>
                 <a id="3972" class="Symbol">})</a>
        <a id="3983" class="Symbol">(</a><a id="3984" href="1Lab.Equiv.html#4003" data-type="(A : Type a) (B₁ : Type b) (f : A → B₁) (is-equiv₁ : is-equiv f)
(a : B₁) (ψ : I) (u0 : Partial ψ (fibre f a)) →
is-contr (fibre f a)" class="Function">c</a> <a id="3986" class="Symbol">.</a><a id="3987" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a><a id="3993" class="Symbol">)</a>
  <a id="3997" class="Keyword">where</a> <a id="4003" href="1Lab.Equiv.html#4003" data-type="(A : Type a) (B₁ : Type b) (f : A → B₁) (is-equiv₁ : is-equiv f)
(a : B₁) (ψ : I) (u0 : Partial ψ (fibre f a)) →
is-contr (fibre f a)" class="Function">c</a> <a id="4005" class="Symbol">=</a> <a id="4007" href="1Lab.Equiv.html#3846" class="Bound">is-equiv</a> <a id="4016" class="Symbol">.</a><a id="4017" href="1Lab.Equiv.html#2376" data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" class="Field">is-eqv</a> <a id="4024" href="1Lab.Equiv.html#3856" class="Bound">a</a>

<a id="4027" class="Symbol">{-#</a> <a id="4031" class="Keyword">BUILTIN</a> <a id="4039" class="Keyword">EQUIVPROOF</a> <a id="4050" href="1Lab.Equiv.html#3671" data-type="(A : Type a) (B₁ : Type b) (w : A ≃ B₁) (a : B₁) (ψ : I) →
Partial ψ (fibre (w .fst) a) → fibre (w .fst) a" class="Function">is-eqv&#39;</a> <a id="4058" class="Symbol">#-}</a>
</pre>
<!--
<pre class="Agda"><a id="equiv-centre"></a><a id="4076" href="1Lab.Equiv.html#4076" data-type="(e : A ≃ B₁) (y : B₁) → fibre (e .fst) y" class="Function">equiv-centre</a> <a id="4089" class="Symbol">:</a> <a id="4091" class="Symbol">(</a><a id="4092" href="1Lab.Equiv.html#4092" class="Bound">e</a> <a id="4094" class="Symbol">:</a> <a id="4096" href="1Lab.Equiv.html#1588" class="Generalizable">A</a> <a id="4098" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="4100" href="1Lab.Equiv.html#1590" class="Generalizable">B</a><a id="4101" class="Symbol">)</a> <a id="4103" class="Symbol">(</a><a id="4104" href="1Lab.Equiv.html#4104" class="Bound">y</a> <a id="4106" class="Symbol">:</a> <a id="4108" href="1Lab.Equiv.html#1590" class="Generalizable">B</a><a id="4109" class="Symbol">)</a> <a id="4111" class="Symbol">→</a> <a id="4113" href="1Lab.Equiv.html#1873" data-type="(A → B₁) → B₁ → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Function">fibre</a> <a id="4119" class="Symbol">(</a><a id="4120" href="1Lab.Equiv.html#4092" class="Bound">e</a> <a id="4122" class="Symbol">.</a><a id="4123" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a><a id="4126" class="Symbol">)</a> <a id="4128" href="1Lab.Equiv.html#4104" class="Bound">y</a>
<a id="4130" href="1Lab.Equiv.html#4076" data-type="(e : A ≃ B₁) (y : B₁) → fibre (e .fst) y" class="Function">equiv-centre</a> <a id="4143" href="1Lab.Equiv.html#4143" class="Bound">e</a> <a id="4145" href="1Lab.Equiv.html#4145" class="Bound">y</a> <a id="4147" class="Symbol">=</a> <a id="4149" href="1Lab.Equiv.html#4143" class="Bound">e</a> <a id="4151" class="Symbol">.</a><a id="4152" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="4156" class="Symbol">.</a><a id="4157" href="1Lab.Equiv.html#2376" data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" class="Field">is-eqv</a> <a id="4164" href="1Lab.Equiv.html#4145" class="Bound">y</a> <a id="4166" class="Symbol">.</a><a id="4167" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a>

<a id="equiv-path"></a><a id="4175" href="1Lab.Equiv.html#4175" data-type="(e : A ≃ B₁) (y : B₁) (v : fibre (e .fst) y) →
Path (∑ A (λ x → e .fst x ≡ y)) (equiv-centre e y) v" class="Function">equiv-path</a> <a id="4186" class="Symbol">:</a> <a id="4188" class="Symbol">(</a><a id="4189" href="1Lab.Equiv.html#4189" class="Bound">e</a> <a id="4191" class="Symbol">:</a> <a id="4193" href="1Lab.Equiv.html#1588" class="Generalizable">A</a> <a id="4195" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="4197" href="1Lab.Equiv.html#1590" class="Generalizable">B</a><a id="4198" class="Symbol">)</a> <a id="4200" class="Symbol">(</a><a id="4201" href="1Lab.Equiv.html#4201" class="Bound">y</a> <a id="4203" class="Symbol">:</a> <a id="4205" href="1Lab.Equiv.html#1590" class="Generalizable">B</a><a id="4206" class="Symbol">)</a> <a id="4208" class="Symbol">→</a>
  <a id="4212" class="Symbol">(</a><a id="4213" href="1Lab.Equiv.html#4213" class="Bound">v</a> <a id="4215" class="Symbol">:</a> <a id="4217" href="1Lab.Equiv.html#1873" data-type="(A → B₁) → B₁ → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Function">fibre</a> <a id="4223" class="Symbol">(</a><a id="4224" href="1Lab.Equiv.html#4189" class="Bound">e</a> <a id="4226" class="Symbol">.</a><a id="4227" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a><a id="4230" class="Symbol">)</a> <a id="4232" href="1Lab.Equiv.html#4201" class="Bound">y</a><a id="4233" class="Symbol">)</a> <a id="4235" class="Symbol">→</a> <a id="4237" href="1Lab.Path.html#2466" data-type="(A : Type ℓ) → A → A → Type ℓ" class="Function">Path</a> <a id="4242" class="Symbol">_</a> <a id="4244" class="Symbol">(</a><a id="4245" href="1Lab.Equiv.html#4076" data-type="(e : A ≃ B₁) (y : B₁) → fibre (e .fst) y" class="Function">equiv-centre</a> <a id="4258" href="1Lab.Equiv.html#4189" class="Bound">e</a> <a id="4260" href="1Lab.Equiv.html#4201" class="Bound">y</a><a id="4261" class="Symbol">)</a> <a id="4263" href="1Lab.Equiv.html#4213" class="Bound">v</a>
<a id="4265" href="1Lab.Equiv.html#4175" data-type="(e : A ≃ B₁) (y : B₁) (v : fibre (e .fst) y) →
Path (∑ A (λ x → e .fst x ≡ y)) (equiv-centre e y) v" class="Function">equiv-path</a> <a id="4276" href="1Lab.Equiv.html#4276" class="Bound">e</a> <a id="4278" href="1Lab.Equiv.html#4278" class="Bound">y</a> <a id="4280" class="Symbol">=</a> <a id="4282" href="1Lab.Equiv.html#4276" class="Bound">e</a> <a id="4284" class="Symbol">.</a><a id="4285" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="4289" class="Symbol">.</a><a id="4290" href="1Lab.Equiv.html#2376" data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" class="Field">is-eqv</a> <a id="4297" href="1Lab.Equiv.html#4278" class="Bound">y</a> <a id="4299" class="Symbol">.</a><a id="4300" href="1Lab.HLevel.html#1416" data-type="(r : is-contr A) (x : A) → r .centre ≡ x" class="Field">paths</a>
</pre>-->
<h2 id="is-equiv-is-propositional"><a href="#is-equiv-is-propositional" class="header-link">is-equiv
is propositional<span class="header-link-emoji">🔗</span></a></h2>
<p>A function can be an equivalence in at most one way. This follows
from propositions being closed under dependent products, and
<span class="Agda"><a href="1Lab.HLevel.html#1328" class="Module">is-contr</a></span>
being a proposition.</p>
<pre class="Agda"><a id="4520" class="Keyword">module</a> <a id="4527" href="1Lab.Equiv.html#4527" class="Module">_</a> <a id="4529" class="Keyword">where</a> <a id="4535" class="Keyword">private</a>
  <a id="4545" href="1Lab.Equiv.html#4545" class="Function">is-equiv-is-prop</a> <a id="4562" class="Symbol">:</a> <a id="4564" class="Symbol">(</a><a id="4565" href="1Lab.Equiv.html#4565" class="Bound">f</a> <a id="4567" class="Symbol">:</a> <a id="4569" href="1Lab.Equiv.html#1588" class="Generalizable">A</a> <a id="4571" class="Symbol">→</a> <a id="4573" href="1Lab.Equiv.html#1590" class="Generalizable">B</a><a id="4574" class="Symbol">)</a> <a id="4576" class="Symbol">→</a> <a id="4578" href="1Lab.HLevel.html#2597" data-type="Type ℓ → Type ℓ" class="Function">is-prop</a> <a id="4586" class="Symbol">(</a><a id="4587" href="1Lab.Equiv.html#2286" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-equiv</a> <a id="4596" href="1Lab.Equiv.html#4565" class="Bound">f</a><a id="4597" class="Symbol">)</a>
  <a id="4601" href="1Lab.Equiv.html#4545" class="Function">is-equiv-is-prop</a> <a id="4618" href="1Lab.Equiv.html#4618" class="Bound">f</a> <a id="4620" href="1Lab.Equiv.html#4620" class="Bound">x</a> <a id="4622" href="1Lab.Equiv.html#4622" class="Bound">y</a> <a id="4624" href="1Lab.Equiv.html#4624" class="Bound">i</a> <a id="4626" class="Symbol">.</a><a id="4627" href="1Lab.Equiv.html#2376" data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" class="Field">is-eqv</a> <a id="4634" href="1Lab.Equiv.html#4634" class="Bound">p</a> <a id="4636" class="Symbol">=</a> <a id="4638" href="1Lab.HLevel.html#11538" data-type="is-prop (is-contr A)" class="Function">is-contr-is-prop</a> <a id="4655" class="Symbol">(</a><a id="4656" href="1Lab.Equiv.html#4620" class="Bound">x</a> <a id="4658" class="Symbol">.</a><a id="4659" href="1Lab.Equiv.html#2376" data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" class="Field">is-eqv</a> <a id="4666" href="1Lab.Equiv.html#4634" class="Bound">p</a><a id="4667" class="Symbol">)</a> <a id="4669" class="Symbol">(</a><a id="4670" href="1Lab.Equiv.html#4622" class="Bound">y</a> <a id="4672" class="Symbol">.</a><a id="4673" href="1Lab.Equiv.html#2376" data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" class="Field">is-eqv</a> <a id="4680" href="1Lab.Equiv.html#4634" class="Bound">p</a><a id="4681" class="Symbol">)</a> <a id="4683" href="1Lab.Equiv.html#4624" class="Bound">i</a>
</pre>
<details>
<summary>
Even though the proof above works, we use the direct cubical proof in
this <code>&lt;details&gt;</code> tag (lifted from the Cubical Agda
library) in the rest of the development for efficiency concerns.
</summary>
<pre class="Agda"><a id="is-equiv-is-prop"></a><a id="4916" href="1Lab.Equiv.html#4916" data-type="(f : A → B₁) → is-prop (is-equiv f)" class="Function">is-equiv-is-prop</a> <a id="4933" class="Symbol">:</a> <a id="4935" class="Symbol">(</a><a id="4936" href="1Lab.Equiv.html#4936" class="Bound">f</a> <a id="4938" class="Symbol">:</a> <a id="4940" href="1Lab.Equiv.html#1588" class="Generalizable">A</a> <a id="4942" class="Symbol">→</a> <a id="4944" href="1Lab.Equiv.html#1590" class="Generalizable">B</a><a id="4945" class="Symbol">)</a> <a id="4947" class="Symbol">→</a> <a id="4949" href="1Lab.HLevel.html#2597" data-type="Type ℓ → Type ℓ" class="Function">is-prop</a> <a id="4957" class="Symbol">(</a><a id="4958" href="1Lab.Equiv.html#2286" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-equiv</a> <a id="4967" href="1Lab.Equiv.html#4936" class="Bound">f</a><a id="4968" class="Symbol">)</a>
<a id="4970" href="1Lab.Equiv.html#4916" data-type="(f : A → B₁) → is-prop (is-equiv f)" class="Function">is-equiv-is-prop</a> <a id="4987" href="1Lab.Equiv.html#4987" class="Bound">f</a> <a id="4989" href="1Lab.Equiv.html#4989" class="Bound">p</a> <a id="4991" href="1Lab.Equiv.html#4991" class="Bound">q</a> <a id="4993" href="1Lab.Equiv.html#4993" class="Bound">i</a> <a id="4995" class="Symbol">.</a><a id="4996" href="1Lab.Equiv.html#2376" data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" class="Field">is-eqv</a> <a id="5003" href="1Lab.Equiv.html#5003" class="Bound">y</a> <a id="5005" class="Symbol">=</a>
  <a id="5009" class="Keyword">let</a> <a id="5013" href="1Lab.Equiv.html#5013" class="Bound">p2</a> <a id="5016" class="Symbol">=</a> <a id="5018" href="1Lab.Equiv.html#4989" class="Bound">p</a> <a id="5020" class="Symbol">.</a><a id="5021" href="1Lab.Equiv.html#2376" data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" class="Field">is-eqv</a> <a id="5028" href="1Lab.Equiv.html#5003" class="Bound">y</a> <a id="5030" class="Symbol">.</a><a id="5031" href="1Lab.HLevel.html#1416" data-type="(r : is-contr A) (x : A) → r .centre ≡ x" class="Field">paths</a>
      <a id="5043" href="1Lab.Equiv.html#5043" class="Bound">q2</a> <a id="5046" class="Symbol">=</a> <a id="5048" href="1Lab.Equiv.html#4991" class="Bound">q</a> <a id="5050" class="Symbol">.</a><a id="5051" href="1Lab.Equiv.html#2376" data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" class="Field">is-eqv</a> <a id="5058" href="1Lab.Equiv.html#5003" class="Bound">y</a> <a id="5060" class="Symbol">.</a><a id="5061" href="1Lab.HLevel.html#1416" data-type="(r : is-contr A) (x : A) → r .centre ≡ x" class="Field">paths</a>
  <a id="5069" class="Keyword">in</a> <a id="5072" href="1Lab.HLevel.html#1383" data-type="(centre₁ : A) (paths₁ : (x : A) → centre₁ ≡ x) → is-contr A" class="InductiveConstructor">contr</a> <a id="5078" class="Symbol">(</a><a id="5079" href="1Lab.Equiv.html#5013" class="Bound">p2</a> <a id="5082" class="Symbol">(</a><a id="5083" href="1Lab.Equiv.html#4991" class="Bound">q</a> <a id="5085" class="Symbol">.</a><a id="5086" href="1Lab.Equiv.html#2376" data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" class="Field">is-eqv</a> <a id="5093" href="1Lab.Equiv.html#5003" class="Bound">y</a> <a id="5095" class="Symbol">.</a><a id="5096" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a><a id="5102" class="Symbol">)</a> <a id="5104" href="1Lab.Equiv.html#4993" class="Bound">i</a><a id="5105" class="Symbol">)</a>
      <a id="5113" class="Symbol">λ</a> <a id="5115" href="1Lab.Equiv.html#5115" class="Bound">w</a> <a id="5117" href="1Lab.Equiv.html#5117" class="Bound">j</a> <a id="5119" class="Symbol">→</a> <a id="5121" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="5127" class="Symbol">(λ</a> <a id="5130" href="1Lab.Equiv.html#5130" class="Bound">k</a> <a id="5132" class="Symbol">→</a> <a id="5134" class="Symbol">λ</a> <a id="5136" class="Symbol">{</a> <a id="5138" class="Symbol">(</a><a id="5139" href="1Lab.Equiv.html#4993" class="Bound">i</a> <a id="5141" class="Symbol">=</a> <a id="5143" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="5145" class="Symbol">)</a> <a id="5147" class="Symbol">→</a> <a id="5149" href="1Lab.Equiv.html#5013" class="Bound">p2</a> <a id="5152" href="1Lab.Equiv.html#5115" class="Bound">w</a> <a id="5154" href="1Lab.Equiv.html#5117" class="Bound">j</a>
                             <a id="5185" class="Symbol">;</a> <a id="5187" class="Symbol">(</a><a id="5188" href="1Lab.Equiv.html#4993" class="Bound">i</a> <a id="5190" class="Symbol">=</a> <a id="5192" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="5194" class="Symbol">)</a> <a id="5196" class="Symbol">→</a> <a id="5198" href="1Lab.Equiv.html#5043" class="Bound">q2</a> <a id="5201" href="1Lab.Equiv.html#5115" class="Bound">w</a> <a id="5203" class="Symbol">(</a><a id="5204" href="1Lab.Equiv.html#5117" class="Bound">j</a> <a id="5206" href="1Lab.Path.html#2226" class="Primitive Operator">∨</a> <a id="5208" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="5210" href="1Lab.Equiv.html#5130" class="Bound">k</a><a id="5211" class="Symbol">)</a>
                             <a id="5242" class="Symbol">;</a> <a id="5244" class="Symbol">(</a><a id="5245" href="1Lab.Equiv.html#5117" class="Bound">j</a> <a id="5247" class="Symbol">=</a> <a id="5249" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="5251" class="Symbol">)</a> <a id="5253" class="Symbol">→</a> <a id="5255" href="1Lab.Equiv.html#5013" class="Bound">p2</a> <a id="5258" class="Symbol">(</a><a id="5259" href="1Lab.Equiv.html#5043" class="Bound">q2</a> <a id="5262" href="1Lab.Equiv.html#5115" class="Bound">w</a> <a id="5264" class="Symbol">(</a><a id="5265" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="5267" href="1Lab.Equiv.html#5130" class="Bound">k</a><a id="5268" class="Symbol">))</a> <a id="5271" href="1Lab.Equiv.html#4993" class="Bound">i</a>
                             <a id="5302" class="Symbol">;</a> <a id="5304" class="Symbol">(</a><a id="5305" href="1Lab.Equiv.html#5117" class="Bound">j</a> <a id="5307" class="Symbol">=</a> <a id="5309" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="5311" class="Symbol">)</a> <a id="5313" class="Symbol">→</a> <a id="5315" href="1Lab.Equiv.html#5115" class="Bound">w</a> <a id="5317" class="Symbol">})</a>
                    <a id="5340" class="Symbol">(</a><a id="5341" href="1Lab.Equiv.html#5013" class="Bound">p2</a> <a id="5344" href="1Lab.Equiv.html#5115" class="Bound">w</a> <a id="5346" class="Symbol">(</a><a id="5347" href="1Lab.Equiv.html#4993" class="Bound">i</a> <a id="5349" href="1Lab.Path.html#2226" class="Primitive Operator">∨</a> <a id="5351" href="1Lab.Equiv.html#5117" class="Bound">j</a><a id="5352" class="Symbol">))</a>
</pre>
</details>
<h1 id="isomorphisms-from-equivalences"><a href="#isomorphisms-from-equivalences" class="header-link">Isomorphisms
from equivalences<span class="header-link-emoji">🔗</span></a></h1>
<p>For this section, we need a definition of <em>isomorphism</em>. This
is the same as ever! An isomorphism is a function that has a two-sided
inverse. We first define what it means for a function to invert another
on the left and on the right:</p>
<pre class="Agda"><a id="is-left-inverse"></a><a id="5649" href="1Lab.Equiv.html#5649" data-type="(B₁ → A) → (A → B₁) → Type A.ℓ₁" class="Function">is-left-inverse</a> <a id="5665" class="Symbol">:</a> <a id="5667" class="Symbol">(</a><a id="5668" href="1Lab.Equiv.html#1590" class="Generalizable">B</a> <a id="5670" class="Symbol">→</a> <a id="5672" href="1Lab.Equiv.html#1588" class="Generalizable">A</a><a id="5673" class="Symbol">)</a> <a id="5675" class="Symbol">→</a> <a id="5677" class="Symbol">(</a><a id="5678" href="1Lab.Equiv.html#1588" class="Generalizable">A</a> <a id="5680" class="Symbol">→</a> <a id="5682" href="1Lab.Equiv.html#1590" class="Generalizable">B</a><a id="5683" class="Symbol">)</a> <a id="5685" class="Symbol">→</a> <a id="5687" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="5692" class="Symbol">_</a>
<a id="5694" href="1Lab.Equiv.html#5649" data-type="(B₁ → A) → (A → B₁) → Type A.ℓ₁" class="Function">is-left-inverse</a> <a id="5710" href="1Lab.Equiv.html#5710" class="Bound">g</a> <a id="5712" href="1Lab.Equiv.html#5712" class="Bound">f</a> <a id="5714" class="Symbol">=</a> <a id="5716" class="Symbol">(</a><a id="5717" href="1Lab.Equiv.html#5717" class="Bound">x</a> <a id="5719" class="Symbol">:</a> <a id="5721" class="Symbol">_)</a> <a id="5724" class="Symbol">→</a> <a id="5726" href="1Lab.Equiv.html#5710" class="Bound">g</a> <a id="5728" class="Symbol">(</a><a id="5729" href="1Lab.Equiv.html#5712" class="Bound">f</a> <a id="5731" href="1Lab.Equiv.html#5717" class="Bound">x</a><a id="5732" class="Symbol">)</a> <a id="5734" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="5736" href="1Lab.Equiv.html#5717" class="Bound">x</a>

<a id="is-right-inverse"></a><a id="5739" href="1Lab.Equiv.html#5739" data-type="(B₁ → A) → (A → B₁) → Type B.ℓ₁" class="Function">is-right-inverse</a> <a id="5756" class="Symbol">:</a> <a id="5758" class="Symbol">(</a><a id="5759" href="1Lab.Equiv.html#1590" class="Generalizable">B</a> <a id="5761" class="Symbol">→</a> <a id="5763" href="1Lab.Equiv.html#1588" class="Generalizable">A</a><a id="5764" class="Symbol">)</a> <a id="5766" class="Symbol">→</a> <a id="5768" class="Symbol">(</a><a id="5769" href="1Lab.Equiv.html#1588" class="Generalizable">A</a> <a id="5771" class="Symbol">→</a> <a id="5773" href="1Lab.Equiv.html#1590" class="Generalizable">B</a><a id="5774" class="Symbol">)</a> <a id="5776" class="Symbol">→</a> <a id="5778" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="5783" class="Symbol">_</a>
<a id="5785" href="1Lab.Equiv.html#5739" data-type="(B₁ → A) → (A → B₁) → Type B.ℓ₁" class="Function">is-right-inverse</a> <a id="5802" href="1Lab.Equiv.html#5802" class="Bound">g</a> <a id="5804" href="1Lab.Equiv.html#5804" class="Bound">f</a> <a id="5806" class="Symbol">=</a> <a id="5808" class="Symbol">(</a><a id="5809" href="1Lab.Equiv.html#5809" class="Bound">x</a> <a id="5811" class="Symbol">:</a> <a id="5813" class="Symbol">_)</a> <a id="5816" class="Symbol">→</a> <a id="5818" href="1Lab.Equiv.html#5804" class="Bound">f</a> <a id="5820" class="Symbol">(</a><a id="5821" href="1Lab.Equiv.html#5802" class="Bound">g</a> <a id="5823" href="1Lab.Equiv.html#5809" class="Bound">x</a><a id="5824" class="Symbol">)</a> <a id="5826" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="5828" href="1Lab.Equiv.html#5809" class="Bound">x</a>
</pre>
<p>A proof that a function
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>
is an isomorphism consists of a function
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span>
in the other direction, together with homotopies exhibiting
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span>
as a left- and right- inverse to
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>.</span></p>
<pre class="Agda"><a id="6019" class="Keyword">record</a> <a id="is-iso"></a><a id="6026" href="1Lab.Equiv.html#6026" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-iso</a> <a id="6033" class="Symbol">(</a><a id="6034" href="1Lab.Equiv.html#6034" class="Bound">f</a> <a id="6036" class="Symbol">:</a> <a id="6038" href="1Lab.Equiv.html#1588" class="Generalizable">A</a> <a id="6040" class="Symbol">→</a> <a id="6042" href="1Lab.Equiv.html#1590" class="Generalizable">B</a><a id="6043" class="Symbol">)</a> <a id="6045" class="Symbol">:</a> <a id="6047" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="6052" class="Symbol">(</a><a id="6053" href="1Lab.Type.html#921" data-type="Type ℓ → Level" class="Function">level-of</a> <a id="6062" href="1Lab.Equiv.html#6038" class="Bound">A</a> <a id="6064" href="Agda.Primitive.html#795" data-type="Level → Level → Level" class="Primitive Operator">⊔</a> <a id="6066" href="1Lab.Type.html#921" data-type="Type ℓ → Level" class="Function">level-of</a> <a id="6075" href="1Lab.Equiv.html#6042" class="Bound">B</a><a id="6076" class="Symbol">)</a> <a id="6078" class="Keyword">where</a>
  <a id="6086" class="Keyword">no-eta-equality</a>
  <a id="6104" class="Keyword">constructor</a> <a id="iso"></a><a id="6116" href="1Lab.Equiv.html#6116" data-type="(inv₁ : B₁ → A) (rinv₁ : is-right-inverse inv₁ f)
(linv₁ : is-left-inverse inv₁ f) →
is-iso f" class="InductiveConstructor">iso</a>
  <a id="6122" class="Keyword">field</a>
    <a id="is-iso.inv"></a><a id="6132" href="1Lab.Equiv.html#6132" data-type="is-iso f → B₁ → A" class="Field">inv</a> <a id="6136" class="Symbol">:</a> <a id="6138" href="1Lab.Equiv.html#6042" class="Bound">B</a> <a id="6140" class="Symbol">→</a> <a id="6142" href="1Lab.Equiv.html#6038" class="Bound">A</a>
    <a id="is-iso.rinv"></a><a id="6148" href="1Lab.Equiv.html#6148" data-type="(r : is-iso f) → is-right-inverse (r .inv) f" class="Field">rinv</a> <a id="6153" class="Symbol">:</a> <a id="6155" href="1Lab.Equiv.html#5739" data-type="(B₁ → A) → (A → B₁) → Type B.ℓ₁" class="Function">is-right-inverse</a> <a id="6172" href="1Lab.Equiv.html#6132" data-type="is-iso f → B₁ → A" class="Field">inv</a> <a id="6176" href="1Lab.Equiv.html#6034" class="Bound">f</a>
    <a id="is-iso.linv"></a><a id="6182" href="1Lab.Equiv.html#6182" data-type="(r : is-iso f) → is-left-inverse (r .inv) f" class="Field">linv</a> <a id="6187" class="Symbol">:</a> <a id="6189" href="1Lab.Equiv.html#5649" data-type="(B₁ → A) → (A → B₁) → Type A.ℓ₁" class="Function">is-left-inverse</a> <a id="6205" href="1Lab.Equiv.html#6132" data-type="is-iso f → B₁ → A" class="Field">inv</a> <a id="6209" href="1Lab.Equiv.html#6034" class="Bound">f</a>

  <a id="is-iso.inverse"></a><a id="6214" href="1Lab.Equiv.html#6214" data-type="(r : is-iso f) → is-iso (inv r)" class="Function">inverse</a> <a id="6222" class="Symbol">:</a> <a id="6224" href="1Lab.Equiv.html#6026" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-iso</a> <a id="6231" href="1Lab.Equiv.html#6132" data-type="is-iso f → B₁ → A" class="Field">inv</a>
  <a id="6237" href="1Lab.Equiv.html#6132" data-type="is-iso f → B₁ → A" class="Field">inv</a> <a id="6241" href="1Lab.Equiv.html#6214" data-type="(r : is-iso f) → is-iso (inv r)" class="Function">inverse</a> <a id="6249" class="Symbol">=</a> <a id="6251" href="1Lab.Equiv.html#6034" class="Bound">f</a>
  <a id="6255" href="1Lab.Equiv.html#6148" data-type="(r : is-iso f) → is-right-inverse (r .inv) f" class="Field">rinv</a> <a id="6260" href="1Lab.Equiv.html#6214" data-type="(r : is-iso f) → is-iso (inv r)" class="Function">inverse</a> <a id="6268" class="Symbol">=</a> <a id="6270" href="1Lab.Equiv.html#6182" data-type="(r : is-iso f) → is-left-inverse (r .inv) f" class="Field">linv</a>
  <a id="6277" href="1Lab.Equiv.html#6182" data-type="(r : is-iso f) → is-left-inverse (r .inv) f" class="Field">linv</a> <a id="6282" href="1Lab.Equiv.html#6214" data-type="(r : is-iso f) → is-iso (inv r)" class="Function">inverse</a> <a id="6290" class="Symbol">=</a> <a id="6292" href="1Lab.Equiv.html#6148" data-type="(r : is-iso f) → is-right-inverse (r .inv) f" class="Field">rinv</a>

<a id="Iso"></a><a id="6298" href="1Lab.Equiv.html#6298" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function">Iso</a> <a id="6302" class="Symbol">:</a> <a id="6304" class="Symbol">∀</a> <a id="6306" class="Symbol">{</a><a id="6307" href="1Lab.Equiv.html#6307" class="Bound">ℓ₁</a> <a id="6310" href="1Lab.Equiv.html#6310" class="Bound">ℓ₂</a><a id="6312" class="Symbol">}</a> <a id="6314" class="Symbol">→</a> <a id="6316" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="6321" href="1Lab.Equiv.html#6307" class="Bound">ℓ₁</a> <a id="6324" class="Symbol">→</a> <a id="6326" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="6331" href="1Lab.Equiv.html#6310" class="Bound">ℓ₂</a> <a id="6334" class="Symbol">→</a> <a id="6336" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="6341" class="Symbol">_</a>
<a id="6343" href="1Lab.Equiv.html#6298" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function">Iso</a> <a id="6347" href="1Lab.Equiv.html#6347" class="Bound">A</a> <a id="6349" href="1Lab.Equiv.html#6349" class="Bound">B</a> <a id="6351" class="Symbol">=</a> <a id="6353" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">Σ</a> <a id="6355" class="Symbol">(</a><a id="6356" href="1Lab.Equiv.html#6026" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-iso</a> <a id="6363" class="Symbol">{</a><a id="6364" class="Argument">A</a> <a id="6366" class="Symbol">=</a> <a id="6368" href="1Lab.Equiv.html#6347" class="Bound">A</a><a id="6369" class="Symbol">}</a> <a id="6371" class="Symbol">{</a><a id="6372" class="Argument">B</a> <a id="6374" class="Symbol">=</a> <a id="6376" href="1Lab.Equiv.html#6349" class="Bound">B</a><a id="6377" class="Symbol">})</a>
</pre>
<p>Any function that is an equivalence is an isomorphism:</p>
<pre class="Agda"><a id="equiv→inverse"></a><a id="6449" href="1Lab.Equiv.html#6449" data-type="is-equiv f → B₁ → A" class="Function">equiv→inverse</a> <a id="6463" class="Symbol">:</a> <a id="6465" class="Symbol">{</a><a id="6466" href="1Lab.Equiv.html#6466" class="Bound">f</a> <a id="6468" class="Symbol">:</a> <a id="6470" href="1Lab.Equiv.html#1588" class="Generalizable">A</a> <a id="6472" class="Symbol">→</a> <a id="6474" href="1Lab.Equiv.html#1590" class="Generalizable">B</a><a id="6475" class="Symbol">}</a> <a id="6477" class="Symbol">→</a> <a id="6479" href="1Lab.Equiv.html#2286" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-equiv</a> <a id="6488" href="1Lab.Equiv.html#6466" class="Bound">f</a> <a id="6490" class="Symbol">→</a> <a id="6492" href="1Lab.Equiv.html#1590" class="Generalizable">B</a> <a id="6494" class="Symbol">→</a> <a id="6496" href="1Lab.Equiv.html#1588" class="Generalizable">A</a>
<a id="6498" href="1Lab.Equiv.html#6449" data-type="is-equiv f → B₁ → A" class="Function">equiv→inverse</a> <a id="6512" href="1Lab.Equiv.html#6512" class="Bound">eqv</a> <a id="6516" href="1Lab.Equiv.html#6516" class="Bound">y</a> <a id="6518" class="Symbol">=</a> <a id="6520" href="1Lab.Equiv.html#6512" class="Bound">eqv</a> <a id="6524" class="Symbol">.</a><a id="6525" href="1Lab.Equiv.html#2376" data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" class="Field">is-eqv</a> <a id="6532" href="1Lab.Equiv.html#6516" class="Bound">y</a> <a id="6534" class="Symbol">.</a><a id="6535" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a> <a id="6542" class="Symbol">.</a><a id="6543" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a>

<a id="equiv→section"></a><a id="6548" href="1Lab.Equiv.html#6548" data-type="(eqv : is-equiv f) → is-right-inverse (equiv→inverse eqv) f" class="Function">equiv→section</a>
  <a id="6564" class="Symbol">:</a> <a id="6566" class="Symbol">{</a><a id="6567" href="1Lab.Equiv.html#6567" class="Bound">f</a> <a id="6569" class="Symbol">:</a> <a id="6571" href="1Lab.Equiv.html#1588" class="Generalizable">A</a> <a id="6573" class="Symbol">→</a> <a id="6575" href="1Lab.Equiv.html#1590" class="Generalizable">B</a><a id="6576" class="Symbol">}</a> <a id="6578" class="Symbol">(</a><a id="6579" href="1Lab.Equiv.html#6579" class="Bound">eqv</a> <a id="6583" class="Symbol">:</a> <a id="6585" href="1Lab.Equiv.html#2286" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-equiv</a> <a id="6594" href="1Lab.Equiv.html#6567" class="Bound">f</a><a id="6595" class="Symbol">)</a> <a id="6597" class="Symbol">→</a> <a id="6599" href="1Lab.Equiv.html#5739" data-type="(B₁ → A) → (A → B₁) → Type B.ℓ₁" class="Function">is-right-inverse</a> <a id="6616" class="Symbol">(</a><a id="6617" href="1Lab.Equiv.html#6449" data-type="is-equiv f → B₁ → A" class="Function">equiv→inverse</a> <a id="6631" href="1Lab.Equiv.html#6579" class="Bound">eqv</a><a id="6634" class="Symbol">)</a> <a id="6636" href="1Lab.Equiv.html#6567" class="Bound">f</a>
<a id="6638" href="1Lab.Equiv.html#6548" data-type="(eqv : is-equiv f) → is-right-inverse (equiv→inverse eqv) f" class="Function">equiv→section</a> <a id="6652" href="1Lab.Equiv.html#6652" class="Bound">eqv</a> <a id="6656" href="1Lab.Equiv.html#6656" class="Bound">y</a> <a id="6658" class="Symbol">=</a> <a id="6660" href="1Lab.Equiv.html#6652" class="Bound">eqv</a> <a id="6664" class="Symbol">.</a><a id="6665" href="1Lab.Equiv.html#2376" data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" class="Field">is-eqv</a> <a id="6672" href="1Lab.Equiv.html#6656" class="Bound">y</a> <a id="6674" class="Symbol">.</a><a id="6675" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a> <a id="6682" class="Symbol">.</a><a id="6683" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a>

<a id="equiv→retraction"></a><a id="6688" href="1Lab.Equiv.html#6688" data-type="(eqv : is-equiv f) → is-left-inverse (equiv→inverse eqv) f" class="Function">equiv→retraction</a>
  <a id="6707" class="Symbol">:</a> <a id="6709" class="Symbol">{</a><a id="6710" href="1Lab.Equiv.html#6710" class="Bound">f</a> <a id="6712" class="Symbol">:</a> <a id="6714" href="1Lab.Equiv.html#1588" class="Generalizable">A</a> <a id="6716" class="Symbol">→</a> <a id="6718" href="1Lab.Equiv.html#1590" class="Generalizable">B</a><a id="6719" class="Symbol">}</a> <a id="6721" class="Symbol">(</a><a id="6722" href="1Lab.Equiv.html#6722" class="Bound">eqv</a> <a id="6726" class="Symbol">:</a> <a id="6728" href="1Lab.Equiv.html#2286" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-equiv</a> <a id="6737" href="1Lab.Equiv.html#6710" class="Bound">f</a><a id="6738" class="Symbol">)</a> <a id="6740" class="Symbol">→</a> <a id="6742" href="1Lab.Equiv.html#5649" data-type="(B₁ → A) → (A → B₁) → Type A.ℓ₁" class="Function">is-left-inverse</a> <a id="6758" class="Symbol">(</a><a id="6759" href="1Lab.Equiv.html#6449" data-type="is-equiv f → B₁ → A" class="Function">equiv→inverse</a> <a id="6773" href="1Lab.Equiv.html#6722" class="Bound">eqv</a><a id="6776" class="Symbol">)</a> <a id="6778" href="1Lab.Equiv.html#6710" class="Bound">f</a>
<a id="6780" href="1Lab.Equiv.html#6688" data-type="(eqv : is-equiv f) → is-left-inverse (equiv→inverse eqv) f" class="Function">equiv→retraction</a> <a id="6797" class="Symbol">{</a><a id="6798" class="Argument">f</a> <a id="6800" class="Symbol">=</a> <a id="6802" href="1Lab.Equiv.html#6802" class="Bound">f</a><a id="6803" class="Symbol">}</a> <a id="6805" href="1Lab.Equiv.html#6805" class="Bound">eqv</a> <a id="6809" href="1Lab.Equiv.html#6809" class="Bound">x</a> <a id="6811" href="1Lab.Equiv.html#6811" class="Bound">i</a> <a id="6813" class="Symbol">=</a> <a id="6815" href="1Lab.Equiv.html#6805" class="Bound">eqv</a> <a id="6819" class="Symbol">.</a><a id="6820" href="1Lab.Equiv.html#2376" data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" class="Field">is-eqv</a> <a id="6827" class="Symbol">(</a><a id="6828" href="1Lab.Equiv.html#6802" class="Bound">f</a> <a id="6830" href="1Lab.Equiv.html#6809" class="Bound">x</a><a id="6831" class="Symbol">)</a> <a id="6833" class="Symbol">.</a><a id="6834" href="1Lab.HLevel.html#1416" data-type="(r : is-contr A) (x : A) → r .centre ≡ x" class="Field">paths</a> <a id="6840" class="Symbol">(</a><a id="6841" href="1Lab.Equiv.html#6809" class="Bound">x</a> <a id="6843" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="6845" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a><a id="6849" class="Symbol">)</a> <a id="6851" href="1Lab.Equiv.html#6811" class="Bound">i</a> <a id="6853" class="Symbol">.</a><a id="6854" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a>

<a id="is-equiv→is-iso"></a><a id="6859" href="1Lab.Equiv.html#6859" data-type="is-equiv f → is-iso f" class="Function">is-equiv→is-iso</a> <a id="6875" class="Symbol">:</a> <a id="6877" class="Symbol">{</a><a id="6878" href="1Lab.Equiv.html#6878" class="Bound">f</a> <a id="6880" class="Symbol">:</a> <a id="6882" href="1Lab.Equiv.html#1588" class="Generalizable">A</a> <a id="6884" class="Symbol">→</a> <a id="6886" href="1Lab.Equiv.html#1590" class="Generalizable">B</a><a id="6887" class="Symbol">}</a> <a id="6889" class="Symbol">→</a> <a id="6891" href="1Lab.Equiv.html#2286" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-equiv</a> <a id="6900" href="1Lab.Equiv.html#6878" class="Bound">f</a> <a id="6902" class="Symbol">→</a> <a id="6904" href="1Lab.Equiv.html#6026" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-iso</a> <a id="6911" href="1Lab.Equiv.html#6878" class="Bound">f</a>
<a id="6913" href="1Lab.Equiv.html#6132" data-type="is-iso f → B₁ → A" class="Field">is-iso.inv</a> <a id="6924" class="Symbol">(</a><a id="6925" href="1Lab.Equiv.html#6859" data-type="is-equiv f → is-iso f" class="Function">is-equiv→is-iso</a> <a id="6941" href="1Lab.Equiv.html#6941" class="Bound">eqv</a><a id="6944" class="Symbol">)</a> <a id="6946" class="Symbol">=</a> <a id="6948" href="1Lab.Equiv.html#6449" data-type="is-equiv f → B₁ → A" class="Function">equiv→inverse</a> <a id="6962" href="1Lab.Equiv.html#6941" class="Bound">eqv</a>
</pre>
<p>We can get an element of <code>x</code> from the proof that
<code>f</code> is an equivalence - it’s the point of <code>A</code>
mapped to <code>y</code>, which we get from centre of contraction for
the fibres of <code>f</code> over <code>y</code>.</p>
<pre class="Agda"><a id="7162" href="1Lab.Equiv.html#6148" data-type="(r : is-iso f) → is-right-inverse (r .inv) f" class="Field">is-iso.rinv</a> <a id="7174" class="Symbol">(</a><a id="7175" href="1Lab.Equiv.html#6859" data-type="is-equiv f → is-iso f" class="Function">is-equiv→is-iso</a> <a id="7191" href="1Lab.Equiv.html#7191" class="Bound">eqv</a><a id="7194" class="Symbol">)</a> <a id="7196" href="1Lab.Equiv.html#7196" class="Bound">y</a> <a id="7198" class="Symbol">=</a>
  <a id="7202" href="1Lab.Equiv.html#7191" class="Bound">eqv</a> <a id="7206" class="Symbol">.</a><a id="7207" href="1Lab.Equiv.html#2376" data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" class="Field">is-eqv</a> <a id="7214" href="1Lab.Equiv.html#7196" class="Bound">y</a> <a id="7216" class="Symbol">.</a><a id="7217" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a> <a id="7224" class="Symbol">.</a><a id="7225" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a>
</pre>
<p>Similarly, that one fibre gives us a proof that the function above is
a right inverse to <code>f</code>.</p>
<pre class="Agda"><a id="7337" href="1Lab.Equiv.html#6182" data-type="(r : is-iso f) → is-left-inverse (r .inv) f" class="Field">is-iso.linv</a> <a id="7349" class="Symbol">(</a><a id="7350" href="1Lab.Equiv.html#6859" data-type="is-equiv f → is-iso f" class="Function">is-equiv→is-iso</a> <a id="7366" class="Symbol">{</a><a id="7367" class="Argument">f</a> <a id="7369" class="Symbol">=</a> <a id="7371" href="1Lab.Equiv.html#7371" class="Bound">f</a><a id="7372" class="Symbol">}</a> <a id="7374" href="1Lab.Equiv.html#7374" class="Bound">eqv</a><a id="7377" class="Symbol">)</a> <a id="7379" href="1Lab.Equiv.html#7379" class="Bound">x</a> <a id="7381" href="1Lab.Equiv.html#7381" class="Bound">i</a> <a id="7383" class="Symbol">=</a>
  <a id="7387" href="1Lab.Equiv.html#7374" class="Bound">eqv</a> <a id="7391" class="Symbol">.</a><a id="7392" href="1Lab.Equiv.html#2376" data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" class="Field">is-eqv</a> <a id="7399" class="Symbol">(</a><a id="7400" href="1Lab.Equiv.html#7371" class="Bound">f</a> <a id="7402" href="1Lab.Equiv.html#7379" class="Bound">x</a><a id="7403" class="Symbol">)</a> <a id="7405" class="Symbol">.</a><a id="7406" href="1Lab.HLevel.html#1416" data-type="(r : is-contr A) (x : A) → r .centre ≡ x" class="Field">paths</a> <a id="7412" class="Symbol">(</a><a id="7413" href="1Lab.Equiv.html#7379" class="Bound">x</a> <a id="7415" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="7417" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a><a id="7421" class="Symbol">)</a> <a id="7423" href="1Lab.Equiv.html#7381" class="Bound">i</a> <a id="7425" class="Symbol">.</a><a id="7426" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a>
</pre>
<p>The proof that the function is a <em>left</em> inverse comes from the
fibres of <code>f</code> over <code>y</code> being contractible. Since
we have a fibre - namely, <code>f</code> maps <code>x</code> to
<code>f x</code> by
<span class="Agda"><a href="1Lab.Path.html#3593" class="Function">refl</a></span>
- we can get any other we want!</p>
<h1 id="equivalences-from-isomorphisms"><a href="#equivalences-from-isomorphisms" class="header-link">Equivalences
from isomorphisms<span class="header-link-emoji">🔗</span></a></h1>
<p>Any isomorphism can be upgraded into an equivalence, in a way that
preserves the function
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>,</span>
its inverse
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span>,</span>
<em>and</em> the proof
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span>
that
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span>
is a right inverse to
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>.</span>
We can not preserve <em>everything</em>, though, as is usual when making
something “more coherent”. Furthermore, if everything was preserved,
<span class="Agda"><a href="1Lab.Equiv.html#6026" class="Record">is-iso</a></span>
would be a proposition, and this is <a href="1Lab.Counterexamples.IsIso.html">provably not the case</a>.</p>
<p>The argument presented here is done directly in cubical style, but a
less direct proof is also available, by showing that every isomorphism
is a <a href="1Lab.Equiv.HalfAdjoint.html">half-adjoint equivalence</a>,
and that half-adjoint equivalences have contractible fibres.</p>
<pre class="Agda"><a id="8418" class="Keyword">module</a> <a id="8425" href="1Lab.Equiv.html#8425" class="Module">_</a> <a id="8427" class="Symbol">{</a><a id="8428" href="1Lab.Equiv.html#8428" class="Bound">f</a> <a id="8430" class="Symbol">:</a> <a id="8432" href="1Lab.Equiv.html#1588" class="Generalizable">A</a> <a id="8434" class="Symbol">→</a> <a id="8436" href="1Lab.Equiv.html#1590" class="Generalizable">B</a><a id="8437" class="Symbol">}</a> <a id="8439" class="Symbol">(</a><a id="8440" href="1Lab.Equiv.html#8440" class="Bound">i</a> <a id="8442" class="Symbol">:</a> <a id="8444" href="1Lab.Equiv.html#6026" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-iso</a> <a id="8451" href="1Lab.Equiv.html#8428" class="Bound">f</a><a id="8452" class="Symbol">)</a> <a id="8454" class="Keyword">where</a>

  <a id="8463" class="Keyword">open</a> <a id="8468" href="1Lab.Equiv.html#6026" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Module">is-iso</a> <a id="8475" href="1Lab.Equiv.html#8440" class="Bound">i</a> <a id="8477" class="Keyword">renaming</a> <a id="8486" class="Symbol">(</a> <a id="8488" href="1Lab.Equiv.html#6132" data-type="is-iso f → B₁ → A" class="Field">inv</a> <a id="8492" class="Symbol">to</a> <a id="8495" class="Field">g</a>
                         <a id="8522" class="Symbol">;</a> <a id="8524" href="1Lab.Equiv.html#6148" data-type="(r : is-iso f) → is-right-inverse (r .inv) f" class="Field">rinv</a> <a id="8529" class="Symbol">to</a> <a id="8532" class="Field">s</a>
                         <a id="8559" class="Symbol">;</a> <a id="8561" href="1Lab.Equiv.html#6182" data-type="(r : is-iso f) → is-left-inverse (r .inv) f" class="Field">linv</a> <a id="8566" class="Symbol">to</a> <a id="8569" class="Field">t</a>
                         <a id="8596" class="Symbol">)</a>
</pre>
<p>Suppose, then, that
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">f : A \to B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>
and
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>:</mo><mi>B</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">g : B \to A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>,</span>
and we’re given witnesses
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>:</mo><mi>f</mi><mo stretchy="false">(</mo><mi>g</mi><mtext> </mtext><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">s : f (g\ x) = x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>
and
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>:</mo><mi>g</mi><mo stretchy="false">(</mo><mi>f</mi><mtext> </mtext><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">t : g (f\ x) = x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace"> </span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>
(named for <strong>s</strong>ection and re<strong>t</strong>raction)
that
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>
and
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span>
are inverses. We want to show that, for any
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>,</span>
the
<span class="Agda"><a href="1Lab.Equiv.html#1873" class="Function">fibre</a></span>
of
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>
over
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>
is contractible. It suffices to show that the fibre is propositional,
and that it is inhabited.</p>
<p>We begin with showing that the fibre over
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>
is propositional, since that’s the harder of the two arguments. Suppose
that we have
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>,</span>
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">x_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,</span>
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,</span>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">p_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
and
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">p_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
as below; Note that
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>p</mi><mn>0</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x_0, p_0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>
and
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>p</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x_1, p_1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>
are fibres of
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>
over
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>.</span>
What we need to show is that we have some
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo>:</mo><msub><mi>x</mi><mn>0</mn></msub><mo>≡</mo><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\pi : x_0 ≡ x_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6138em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
and
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>0</mn></msub><mo>≡</mo><msub><mi>p</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">p_0 ≡ p_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6582em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
<em><code class="sourceCode agda" data-ident="PathP">over</code></em>
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span>.</span></p>
<pre class="Agda">  <a id="9331" class="Keyword">private</a> <a id="9339" class="Keyword">module</a> <a id="9346" href="1Lab.Equiv.html#9346" class="Module">_</a> <a id="9348" class="Symbol">(</a><a id="9349" href="1Lab.Equiv.html#9349" class="Bound">y</a> <a id="9351" class="Symbol">:</a> <a id="9353" href="1Lab.Equiv.html#8436" class="Bound">B</a><a id="9354" class="Symbol">)</a> <a id="9356" class="Symbol">(</a><a id="9357" href="1Lab.Equiv.html#9357" class="Bound">x0</a> <a id="9360" href="1Lab.Equiv.html#9360" class="Bound">x1</a> <a id="9363" class="Symbol">:</a> <a id="9365" href="1Lab.Equiv.html#8432" class="Bound">A</a><a id="9366" class="Symbol">)</a> <a id="9368" class="Symbol">(</a><a id="9369" href="1Lab.Equiv.html#9369" class="Bound">p0</a> <a id="9372" class="Symbol">:</a> <a id="9374" href="1Lab.Equiv.html#8428" class="Bound">f</a> <a id="9376" href="1Lab.Equiv.html#9357" class="Bound">x0</a> <a id="9379" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="9381" href="1Lab.Equiv.html#9349" class="Bound">y</a><a id="9382" class="Symbol">)</a> <a id="9384" class="Symbol">(</a><a id="9385" href="1Lab.Equiv.html#9385" class="Bound">p1</a> <a id="9388" class="Symbol">:</a> <a id="9390" href="1Lab.Equiv.html#8428" class="Bound">f</a> <a id="9392" href="1Lab.Equiv.html#9360" class="Bound">x1</a> <a id="9395" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="9397" href="1Lab.Equiv.html#9349" class="Bound">y</a><a id="9398" class="Symbol">)</a> <a id="9400" class="Keyword">where</a>
</pre>
<p>As an intermediate step in proving that
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>0</mn></msub><mo>≡</mo><msub><mi>p</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">p_0 ≡ p_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6582em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,</span>
we <em>must</em> show that
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub><mo>≡</mo><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_0 ≡ x_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6138em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
- without this, we can’t even <em>state</em> that
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">p_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
and
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">p_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
are identified, since they live in different types! To this end, we will
build
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo>:</mo><msub><mi>p</mi><mn>0</mn></msub><mo>≡</mo><msub><mi>p</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\pi : p_0 ≡ p_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6582em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,</span>
parts of which will be required to assemble the overall proof that
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>0</mn></msub><mo>≡</mo><msub><mi>p</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">p_0 ≡ p_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6582em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</span></p>
<p>We’ll detail the construction of
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\pi_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>;</span>
for
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\pi_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,</span>
the same method is used. We want to construct a <em>line</em>, which we
can do by exhibiting that line as the missing face in a <em>square</em>.
We have equations
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mtext> </mtext><mi>y</mi><mo>≡</mo><mi>g</mi><mtext> </mtext><mi>y</mi></mrow><annotation encoding="application/x-tex">g\ y ≡ g\ y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6582em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>
(<span class="Agda"><a href="1Lab.Path.html#3593" class="Function">refl</a></span>),
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>f</mi><mtext> </mtext><msub><mi>x</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mo>≡</mo><mi>g</mi><mtext> </mtext><mi>y</mi></mrow><annotation encoding="application/x-tex">g\ (f\ x_0) ≡ g\ y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace"> </span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>
(the action of <code>g</code> on <code>p0</code>), and
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>f</mi><mtext> </mtext><msub><mi>x</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mo>=</mo><msub><mi>x</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">g\ (f\ x_0) = x_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace"> </span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
by the assumption that
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span>
is a right inverse to
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>.</span>
Diagramatically, these fit together into a square:</p>
<div class="diagram-container">
<img src="light-193afca482e4eaf959452d27288a9c224bb0eaf2.svg" title="commutative diagram" class="diagram diagram-light quiver" />
<img src="dark-193afca482e4eaf959452d27288a9c224bb0eaf2.svg" title="commutative diagram" class="diagram diagram-dark quiver" />
</div>
<p>The missing line in this square is
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\pi_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</span>
Since the <em>inside</em> (the
<span class="Agda"><a href="1Lab.Path.html#35493" class="Function">filler</a></span>)
will be useful to us later, we also give it a name:
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span>.</span></p>
<pre class="Agda">    <a id="10754" href="1Lab.Equiv.html#10754" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
inv i y ≡ x0" class="Function">π₀</a> <a id="10757" class="Symbol">:</a> <a id="10759" href="1Lab.Equiv.html#8495" class="Field">g</a> <a id="10761" href="1Lab.Equiv.html#9349" class="Bound">y</a> <a id="10763" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="10765" href="1Lab.Equiv.html#9357" class="Bound">x0</a>
    <a id="10772" href="1Lab.Equiv.html#10754" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
inv i y ≡ x0" class="Function">π₀</a> <a id="10775" href="1Lab.Equiv.html#10775" class="Bound">i</a> <a id="10777" class="Symbol">=</a> <a id="10779" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="10785" class="Symbol">(λ</a> <a id="10788" href="1Lab.Equiv.html#10788" class="Bound">k</a> <a id="10790" class="Symbol">→</a> <a id="10792" class="Symbol">λ</a> <a id="10794" class="Symbol">{</a> <a id="10796" class="Symbol">(</a><a id="10797" href="1Lab.Equiv.html#10775" class="Bound">i</a> <a id="10799" class="Symbol">=</a> <a id="10801" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="10803" class="Symbol">)</a> <a id="10805" class="Symbol">→</a> <a id="10807" href="1Lab.Equiv.html#8495" class="Field">g</a> <a id="10809" href="1Lab.Equiv.html#9349" class="Bound">y</a>
                          <a id="10837" class="Symbol">;</a> <a id="10839" class="Symbol">(</a><a id="10840" href="1Lab.Equiv.html#10775" class="Bound">i</a> <a id="10842" class="Symbol">=</a> <a id="10844" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="10846" class="Symbol">)</a> <a id="10848" class="Symbol">→</a> <a id="10850" href="1Lab.Equiv.html#8569" class="Field">t</a> <a id="10852" href="1Lab.Equiv.html#9357" class="Bound">x0</a> <a id="10855" href="1Lab.Equiv.html#10788" class="Bound">k</a>
                          <a id="10883" class="Symbol">})</a>
                    <a id="10906" class="Symbol">(</a><a id="10907" href="1Lab.Equiv.html#8495" class="Field">g</a> <a id="10909" class="Symbol">(</a><a id="10910" href="1Lab.Equiv.html#9369" class="Bound">p0</a> <a id="10913" class="Symbol">(</a><a id="10914" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="10916" href="1Lab.Equiv.html#10775" class="Bound">i</a><a id="10917" class="Symbol">)))</a>

    <a id="10926" href="1Lab.Equiv.html#10926" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
Square (ap (inv i) (sym p0)) refl (linv i x0) (π₀ i y x0 x1 p0 p1)" class="Function">θ₀</a> <a id="10929" class="Symbol">:</a> <a id="10931" href="1Lab.Path.html#9409" data-type="a00 ≡ a01 → a00 ≡ a10 → a01 ≡ a11 → a10 ≡ a11 → Type ℓ" class="Function">Square</a> <a id="10938" class="Symbol">(</a><a id="10939" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="10942" href="1Lab.Equiv.html#8495" class="Field">g</a> <a id="10944" class="Symbol">(</a><a id="10945" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="10949" href="1Lab.Equiv.html#9369" class="Bound">p0</a><a id="10951" class="Symbol">))</a> <a id="10954" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="10959" class="Symbol">(</a><a id="10960" href="1Lab.Equiv.html#8569" class="Field">t</a> <a id="10962" href="1Lab.Equiv.html#9357" class="Bound">x0</a><a id="10964" class="Symbol">)</a> <a id="10966" href="1Lab.Equiv.html#10754" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
inv i y ≡ x0" class="Function">π₀</a>
    <a id="10973" href="1Lab.Equiv.html#10926" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
Square (ap (inv i) (sym p0)) refl (linv i x0) (π₀ i y x0 x1 p0 p1)" class="Function">θ₀</a> <a id="10976" href="1Lab.Equiv.html#10976" class="Bound">i</a> <a id="10978" href="1Lab.Equiv.html#10978" class="Bound">j</a> <a id="10980" class="Symbol">=</a> <a id="10982" href="1Lab.Path.html#35493" data-type="(u : I → Partial φ A) (u0 : A [ φ ↦ u i0 ]) →
outS u0 ≡ hcomp u (outS u0)" class="Function">hfill</a> <a id="10988" class="Symbol">(λ</a> <a id="10991" href="1Lab.Equiv.html#10991" class="Bound">k</a> <a id="10993" class="Symbol">→</a> <a id="10995" class="Symbol">λ</a> <a id="10997" class="Symbol">{</a> <a id="10999" class="Symbol">(</a><a id="11000" href="1Lab.Equiv.html#10976" class="Bound">i</a> <a id="11002" class="Symbol">=</a> <a id="11004" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="11006" class="Symbol">)</a> <a id="11008" class="Symbol">→</a> <a id="11010" href="1Lab.Equiv.html#8495" class="Field">g</a> <a id="11012" href="1Lab.Equiv.html#9349" class="Bound">y</a>
                            <a id="11042" class="Symbol">;</a> <a id="11044" class="Symbol">(</a><a id="11045" href="1Lab.Equiv.html#10976" class="Bound">i</a> <a id="11047" class="Symbol">=</a> <a id="11049" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="11051" class="Symbol">)</a> <a id="11053" class="Symbol">→</a> <a id="11055" href="1Lab.Equiv.html#8569" class="Field">t</a> <a id="11057" href="1Lab.Equiv.html#9357" class="Bound">x0</a> <a id="11060" href="1Lab.Equiv.html#10991" class="Bound">k</a>
                            <a id="11090" class="Symbol">})</a>
                   <a id="11112" class="Symbol">(</a><a id="11113" href="1Lab.Path.html#2069" class="Postulate">inS</a> <a id="11117" class="Symbol">(</a><a id="11118" href="1Lab.Equiv.html#8495" class="Field">g</a> <a id="11120" class="Symbol">(</a><a id="11121" href="1Lab.Equiv.html#9369" class="Bound">p0</a> <a id="11124" class="Symbol">(</a><a id="11125" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="11127" href="1Lab.Equiv.html#10976" class="Bound">i</a><a id="11128" class="Symbol">))))</a> <a id="11133" href="1Lab.Equiv.html#10978" class="Bound">j</a>
</pre>
<p>Since the construction of
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\pi_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
is analogous, I’ll simply present the square. We correspondingly name
the missing face
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\pi_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
and the filler
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>θ</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\theta_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</span></p>
<div class="mathpar">
<div class="diagram-container">
<img src="light-7b944591e80866a5b04179d5ec65b925a6e46ba7.svg" title="commutative diagram" class="diagram diagram-light quiver" />
<img src="dark-7b944591e80866a5b04179d5ec65b925a6e46ba7.svg" title="commutative diagram" class="diagram diagram-dark quiver" />
</div>
<pre class="Agda">    <a id="11761" href="1Lab.Equiv.html#11761" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
inv i y ≡ x1" class="Function">π₁</a> <a id="11764" class="Symbol">:</a> <a id="11766" href="1Lab.Equiv.html#8495" class="Field">g</a> <a id="11768" href="1Lab.Equiv.html#9349" class="Bound">y</a> <a id="11770" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="11772" href="1Lab.Equiv.html#9360" class="Bound">x1</a>
    <a id="11779" href="1Lab.Equiv.html#11761" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
inv i y ≡ x1" class="Function">π₁</a> <a id="11782" href="1Lab.Equiv.html#11782" class="Bound">i</a> <a id="11784" class="Symbol">=</a> <a id="11786" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="11792" class="Symbol">(λ</a> <a id="11795" href="1Lab.Equiv.html#11795" class="Bound">k</a> <a id="11797" class="Symbol">→</a> <a id="11799" class="Symbol">λ</a> <a id="11801" class="Symbol">{</a> <a id="11803" class="Symbol">(</a><a id="11804" href="1Lab.Equiv.html#11782" class="Bound">i</a> <a id="11806" class="Symbol">=</a> <a id="11808" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="11810" class="Symbol">)</a> <a id="11812" class="Symbol">→</a> <a id="11814" href="1Lab.Equiv.html#8495" class="Field">g</a> <a id="11816" href="1Lab.Equiv.html#9349" class="Bound">y</a>
                          <a id="11844" class="Symbol">;</a> <a id="11846" class="Symbol">(</a><a id="11847" href="1Lab.Equiv.html#11782" class="Bound">i</a> <a id="11849" class="Symbol">=</a> <a id="11851" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="11853" class="Symbol">)</a> <a id="11855" class="Symbol">→</a> <a id="11857" href="1Lab.Equiv.html#8569" class="Field">t</a> <a id="11859" href="1Lab.Equiv.html#9360" class="Bound">x1</a> <a id="11862" href="1Lab.Equiv.html#11795" class="Bound">k</a>
                          <a id="11890" class="Symbol">})</a>
                    <a id="11913" class="Symbol">(</a><a id="11914" href="1Lab.Equiv.html#8495" class="Field">g</a> <a id="11916" class="Symbol">(</a><a id="11917" href="1Lab.Equiv.html#9385" class="Bound">p1</a> <a id="11920" class="Symbol">(</a><a id="11921" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="11923" href="1Lab.Equiv.html#11782" class="Bound">i</a><a id="11924" class="Symbol">)))</a>

    <a id="11933" href="1Lab.Equiv.html#11933" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
Square (ap (inv i) (sym p1)) refl (linv i x1) (π₁ i y x0 x1 p0 p1)" class="Function">θ₁</a> <a id="11936" class="Symbol">:</a> <a id="11938" href="1Lab.Path.html#9409" data-type="a00 ≡ a01 → a00 ≡ a10 → a01 ≡ a11 → a10 ≡ a11 → Type ℓ" class="Function">Square</a> <a id="11945" class="Symbol">(</a><a id="11946" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="11949" href="1Lab.Equiv.html#8495" class="Field">g</a> <a id="11951" class="Symbol">(</a><a id="11952" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="11956" href="1Lab.Equiv.html#9385" class="Bound">p1</a><a id="11958" class="Symbol">))</a> <a id="11961" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="11966" class="Symbol">(</a><a id="11967" href="1Lab.Equiv.html#8569" class="Field">t</a> <a id="11969" href="1Lab.Equiv.html#9360" class="Bound">x1</a><a id="11971" class="Symbol">)</a> <a id="11973" href="1Lab.Equiv.html#11761" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
inv i y ≡ x1" class="Function">π₁</a>
    <a id="11980" href="1Lab.Equiv.html#11933" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
Square (ap (inv i) (sym p1)) refl (linv i x1) (π₁ i y x0 x1 p0 p1)" class="Function">θ₁</a> <a id="11983" href="1Lab.Equiv.html#11983" class="Bound">i</a> <a id="11985" href="1Lab.Equiv.html#11985" class="Bound">j</a> <a id="11987" class="Symbol">=</a> <a id="11989" href="1Lab.Path.html#35493" data-type="(u : I → Partial φ A) (u0 : A [ φ ↦ u i0 ]) →
outS u0 ≡ hcomp u (outS u0)" class="Function">hfill</a> <a id="11995" class="Symbol">(λ</a> <a id="11998" href="1Lab.Equiv.html#11998" class="Bound">k</a> <a id="12000" class="Symbol">→</a> <a id="12002" class="Symbol">λ</a> <a id="12004" class="Symbol">{</a> <a id="12006" class="Symbol">(</a><a id="12007" href="1Lab.Equiv.html#11983" class="Bound">i</a> <a id="12009" class="Symbol">=</a> <a id="12011" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="12013" class="Symbol">)</a> <a id="12015" class="Symbol">→</a> <a id="12017" href="1Lab.Equiv.html#8495" class="Field">g</a> <a id="12019" href="1Lab.Equiv.html#9349" class="Bound">y</a>
                            <a id="12049" class="Symbol">;</a> <a id="12051" class="Symbol">(</a><a id="12052" href="1Lab.Equiv.html#11983" class="Bound">i</a> <a id="12054" class="Symbol">=</a> <a id="12056" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="12058" class="Symbol">)</a> <a id="12060" class="Symbol">→</a> <a id="12062" href="1Lab.Equiv.html#8569" class="Field">t</a> <a id="12064" href="1Lab.Equiv.html#9360" class="Bound">x1</a> <a id="12067" href="1Lab.Equiv.html#11998" class="Bound">k</a>
                            <a id="12097" class="Symbol">})</a>
                      <a id="12122" class="Symbol">(</a><a id="12123" href="1Lab.Path.html#2069" class="Postulate">inS</a> <a id="12127" class="Symbol">(</a><a id="12128" href="1Lab.Equiv.html#8495" class="Field">g</a> <a id="12130" class="Symbol">(</a><a id="12131" href="1Lab.Equiv.html#9385" class="Bound">p1</a> <a id="12134" class="Symbol">(</a><a id="12135" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="12137" href="1Lab.Equiv.html#11983" class="Bound">i</a><a id="12138" class="Symbol">))))</a> <a id="12143" href="1Lab.Equiv.html#11985" class="Bound">j</a>
</pre>
</div>
<p>Joining these paths by their common
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mtext> </mtext><mi>y</mi></mrow><annotation encoding="application/x-tex">g\ y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>
face, we obtain
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo>:</mo><msub><mi>x</mi><mn>0</mn></msub><mo>≡</mo><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\pi : x_0 ≡ x_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6138em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</span>
This square <em>also</em> has a filler, connecting
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\pi_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
and
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\pi_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
over the line
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mtext> </mtext><mi>y</mi><mo>≡</mo><mi>π</mi><mtext> </mtext><mi>i</mi></mrow><annotation encoding="application/x-tex">g\ y ≡ \pi\ i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6582em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mspace"> </span><span class="mord mathnormal">i</span></span></span></span>.</span></p>
<div class="mathpar">
<div class="diagram-container">
<img src="light-696d9aa257c82c2ac2da8bebd91fc997e3206334.svg" title="commutative diagram" class="diagram diagram-light quiver" />
<img src="dark-696d9aa257c82c2ac2da8bebd91fc997e3206334.svg" title="commutative diagram" class="diagram diagram-dark quiver" />
</div>
<pre class="Agda">    <a id="12769" href="1Lab.Equiv.html#12769" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
x0 ≡ x1" class="Function">π</a> <a id="12771" class="Symbol">:</a> <a id="12773" href="1Lab.Equiv.html#9357" class="Bound">x0</a> <a id="12776" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="12778" href="1Lab.Equiv.html#9360" class="Bound">x1</a>
    <a id="12785" href="1Lab.Equiv.html#12769" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
x0 ≡ x1" class="Function">π</a> <a id="12787" href="1Lab.Equiv.html#12787" class="Bound">i</a> <a id="12789" class="Symbol">=</a> <a id="12791" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="12797" class="Symbol">(λ</a> <a id="12800" href="1Lab.Equiv.html#12800" class="Bound">k</a> <a id="12802" class="Symbol">→</a> <a id="12804" class="Symbol">λ</a> <a id="12806" class="Symbol">{</a> <a id="12808" class="Symbol">(</a><a id="12809" href="1Lab.Equiv.html#12787" class="Bound">i</a> <a id="12811" class="Symbol">=</a> <a id="12813" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="12815" class="Symbol">)</a> <a id="12817" class="Symbol">→</a> <a id="12819" href="1Lab.Equiv.html#10754" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
inv i y ≡ x0" class="Function">π₀</a> <a id="12822" href="1Lab.Equiv.html#12800" class="Bound">k</a>
                         <a id="12849" class="Symbol">;</a> <a id="12851" class="Symbol">(</a><a id="12852" href="1Lab.Equiv.html#12787" class="Bound">i</a> <a id="12854" class="Symbol">=</a> <a id="12856" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="12858" class="Symbol">)</a> <a id="12860" class="Symbol">→</a> <a id="12862" href="1Lab.Equiv.html#11761" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
inv i y ≡ x1" class="Function">π₁</a> <a id="12865" href="1Lab.Equiv.html#12800" class="Bound">k</a>
                         <a id="12892" class="Symbol">})</a>
                <a id="12911" class="Symbol">(</a><a id="12912" href="1Lab.Equiv.html#8495" class="Field">g</a> <a id="12914" href="1Lab.Equiv.html#9349" class="Bound">y</a><a id="12915" class="Symbol">)</a>
</pre>
</div>
<p>This concludes the construction of
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span>,</span>
and thus, the 2D part of the proof. Now, we want to show that
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>0</mn></msub><mo>≡</mo><msub><mi>p</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">p_0 ≡ p_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6582em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
over a path induced by
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span>.</span>
This is a <em>square</em> with a specific boundary, which can be built
by constructing an appropriate <em>open cube</em>, where the missing
face is that square. As an intermediate step, we define
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span>
to be the filler for the square above.</p>
<pre class="Agda">    <a id="13318" href="1Lab.Equiv.html#13318" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
Square refl (π₀ i y x0 x1 p0 p1) (π₁ i y x0 x1 p0 p1)
(π i y x0 x1 p0 p1)" class="Function">θ</a> <a id="13320" class="Symbol">:</a> <a id="13322" href="1Lab.Path.html#9409" data-type="a00 ≡ a01 → a00 ≡ a10 → a01 ≡ a11 → a10 ≡ a11 → Type ℓ" class="Function">Square</a> <a id="13329" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="13334" href="1Lab.Equiv.html#10754" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
inv i y ≡ x0" class="Function">π₀</a> <a id="13337" href="1Lab.Equiv.html#11761" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
inv i y ≡ x1" class="Function">π₁</a> <a id="13340" href="1Lab.Equiv.html#12769" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
x0 ≡ x1" class="Function">π</a>
    <a id="13346" href="1Lab.Equiv.html#13318" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
Square refl (π₀ i y x0 x1 p0 p1) (π₁ i y x0 x1 p0 p1)
(π i y x0 x1 p0 p1)" class="Function">θ</a> <a id="13348" href="1Lab.Equiv.html#13348" class="Bound">i</a> <a id="13350" href="1Lab.Equiv.html#13350" class="Bound">j</a> <a id="13352" class="Symbol">=</a> <a id="13354" href="1Lab.Path.html#35493" data-type="(u : I → Partial φ A) (u0 : A [ φ ↦ u i0 ]) →
outS u0 ≡ hcomp u (outS u0)" class="Function">hfill</a> <a id="13360" class="Symbol">(λ</a> <a id="13363" href="1Lab.Equiv.html#13363" class="Bound">k</a> <a id="13365" class="Symbol">→</a> <a id="13367" class="Symbol">λ</a> <a id="13369" class="Symbol">{</a> <a id="13371" class="Symbol">(</a><a id="13372" href="1Lab.Equiv.html#13348" class="Bound">i</a> <a id="13374" class="Symbol">=</a> <a id="13376" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="13378" class="Symbol">)</a> <a id="13380" class="Symbol">→</a> <a id="13382" href="1Lab.Equiv.html#11761" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
inv i y ≡ x1" class="Function">π₁</a> <a id="13385" href="1Lab.Equiv.html#13363" class="Bound">k</a>
                           <a id="13414" class="Symbol">;</a> <a id="13416" class="Symbol">(</a><a id="13417" href="1Lab.Equiv.html#13348" class="Bound">i</a> <a id="13419" class="Symbol">=</a> <a id="13421" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="13423" class="Symbol">)</a> <a id="13425" class="Symbol">→</a> <a id="13427" href="1Lab.Equiv.html#10754" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
inv i y ≡ x0" class="Function">π₀</a> <a id="13430" href="1Lab.Equiv.html#13363" class="Bound">k</a>
                           <a id="13459" class="Symbol">})</a>
                      <a id="13484" class="Symbol">(</a><a id="13485" href="1Lab.Path.html#2069" class="Postulate">inS</a> <a id="13489" class="Symbol">(</a><a id="13490" href="1Lab.Equiv.html#8495" class="Field">g</a> <a id="13492" href="1Lab.Equiv.html#9349" class="Bound">y</a><a id="13493" class="Symbol">))</a> <a id="13496" href="1Lab.Equiv.html#13350" class="Bound">j</a>
</pre>
<p>Observe that we can coherently alter
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span>
to get
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ι</mi></mrow><annotation encoding="application/x-tex">\iota</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ι</span></span></span></span>
below, which expresses that
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">p</mi></mrow><mtext> </mtext><mi>g</mi><mtext> </mtext><msub><mi>p</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\id{ap}\ g\ p_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathrm">ap</span></span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
and
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">p</mi></mrow><mtext> </mtext><mi>g</mi><mtext> </mtext><msub><mi>p</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\id{ap}\ g\ p_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathrm">ap</span></span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
are identified.</p>
<pre class="Agda">    <a id="13661" href="1Lab.Equiv.html#13661" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
Square (ap (inv i ⊙ f) (π i y x0 x1 p0 p1)) (ap (inv i) p0)
(ap (inv i) p1) refl" class="Function">ι</a> <a id="13663" class="Symbol">:</a> <a id="13665" href="1Lab.Path.html#9409" data-type="a00 ≡ a01 → a00 ≡ a10 → a01 ≡ a11 → a10 ≡ a11 → Type ℓ" class="Function">Square</a> <a id="13672" class="Symbol">(</a><a id="13673" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="13676" class="Symbol">(</a><a id="13677" href="1Lab.Equiv.html#8495" class="Field">g</a> <a id="13679" href="1Lab.Type.html#2227" data-type="((y : B₁ x) → C x y) → (f : (x : A) → B₁ x) (x : A) → C x (f x)" class="Function Operator">∘</a> <a id="13681" href="1Lab.Equiv.html#8428" class="Bound">f</a><a id="13682" class="Symbol">)</a> <a id="13684" href="1Lab.Equiv.html#12769" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
x0 ≡ x1" class="Function">π</a><a id="13685" class="Symbol">)</a> <a id="13687" class="Symbol">(</a><a id="13688" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="13691" href="1Lab.Equiv.html#8495" class="Field">g</a> <a id="13693" href="1Lab.Equiv.html#9369" class="Bound">p0</a><a id="13695" class="Symbol">)</a> <a id="13697" class="Symbol">(</a><a id="13698" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="13701" href="1Lab.Equiv.html#8495" class="Field">g</a> <a id="13703" href="1Lab.Equiv.html#9385" class="Bound">p1</a><a id="13705" class="Symbol">)</a> <a id="13707" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
    <a id="13716" href="1Lab.Equiv.html#13661" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
Square (ap (inv i ⊙ f) (π i y x0 x1 p0 p1)) (ap (inv i) p0)
(ap (inv i) p1) refl" class="Function">ι</a> <a id="13718" href="1Lab.Equiv.html#13718" class="Bound">i</a> <a id="13720" href="1Lab.Equiv.html#13720" class="Bound">j</a> <a id="13722" class="Symbol">=</a> <a id="13724" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="13730" class="Symbol">(λ</a> <a id="13733" href="1Lab.Equiv.html#13733" class="Bound">k</a> <a id="13735" class="Symbol">→</a> <a id="13737" class="Symbol">λ</a> <a id="13739" class="Symbol">{</a> <a id="13741" class="Symbol">(</a><a id="13742" href="1Lab.Equiv.html#13718" class="Bound">i</a> <a id="13744" class="Symbol">=</a> <a id="13746" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="13748" class="Symbol">)</a> <a id="13750" class="Symbol">→</a> <a id="13752" href="1Lab.Equiv.html#10926" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
Square (ap (inv i) (sym p0)) refl (linv i x0) (π₀ i y x0 x1 p0 p1)" class="Function">θ₀</a> <a id="13755" class="Symbol">(</a><a id="13756" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="13758" href="1Lab.Equiv.html#13720" class="Bound">j</a><a id="13759" class="Symbol">)</a> <a id="13761" class="Symbol">(</a><a id="13762" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="13764" href="1Lab.Equiv.html#13733" class="Bound">k</a><a id="13765" class="Symbol">)</a>
                           <a id="13794" class="Symbol">;</a> <a id="13796" class="Symbol">(</a><a id="13797" href="1Lab.Equiv.html#13718" class="Bound">i</a> <a id="13799" class="Symbol">=</a> <a id="13801" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="13803" class="Symbol">)</a> <a id="13805" class="Symbol">→</a> <a id="13807" href="1Lab.Equiv.html#11933" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
Square (ap (inv i) (sym p1)) refl (linv i x1) (π₁ i y x0 x1 p0 p1)" class="Function">θ₁</a> <a id="13810" class="Symbol">(</a><a id="13811" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="13813" href="1Lab.Equiv.html#13720" class="Bound">j</a><a id="13814" class="Symbol">)</a> <a id="13816" class="Symbol">(</a><a id="13817" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="13819" href="1Lab.Equiv.html#13733" class="Bound">k</a><a id="13820" class="Symbol">)</a>
                           <a id="13849" class="Symbol">;</a> <a id="13851" class="Symbol">(</a><a id="13852" href="1Lab.Equiv.html#13720" class="Bound">j</a> <a id="13854" class="Symbol">=</a> <a id="13856" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="13858" class="Symbol">)</a> <a id="13860" class="Symbol">→</a> <a id="13862" href="1Lab.Equiv.html#8569" class="Field">t</a> <a id="13864" class="Symbol">(</a><a id="13865" href="1Lab.Equiv.html#12769" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
x0 ≡ x1" class="Function">π</a> <a id="13867" href="1Lab.Equiv.html#13718" class="Bound">i</a><a id="13868" class="Symbol">)</a> <a id="13870" class="Symbol">(</a><a id="13871" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="13873" href="1Lab.Equiv.html#13733" class="Bound">k</a><a id="13874" class="Symbol">)</a>
                           <a id="13903" class="Symbol">;</a> <a id="13905" class="Symbol">(</a><a id="13906" href="1Lab.Equiv.html#13720" class="Bound">j</a> <a id="13908" class="Symbol">=</a> <a id="13910" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="13912" class="Symbol">)</a> <a id="13914" class="Symbol">→</a> <a id="13916" href="1Lab.Equiv.html#8495" class="Field">g</a> <a id="13918" href="1Lab.Equiv.html#9349" class="Bound">y</a>
                           <a id="13947" class="Symbol">})</a>
                  <a id="13968" class="Symbol">(</a><a id="13969" href="1Lab.Equiv.html#13318" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
Square refl (π₀ i y x0 x1 p0 p1) (π₁ i y x0 x1 p0 p1)
(π i y x0 x1 p0 p1)" class="Function">θ</a> <a id="13971" href="1Lab.Equiv.html#13718" class="Bound">i</a> <a id="13973" class="Symbol">(</a><a id="13974" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="13976" href="1Lab.Equiv.html#13720" class="Bound">j</a><a id="13977" class="Symbol">))</a>
</pre>
<p>This composition can be visualised as the <em>red</em> (front) face
in the diagram below. The back face is
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi><mtext> </mtext><mi>i</mi><mtext> </mtext><mo stretchy="false">(</mo><mi mathvariant="normal">¬</mi><mtext> </mtext><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\theta\ i\ (\neg\ j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mspace"> </span><span class="mord mathnormal">i</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord">¬</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>,</span>
i.e. <code>(θ i (~ j))</code> in the code. Similarly, the
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>=</mo><mrow><mi mathvariant="normal">i</mi><mn>1</mn></mrow></mrow><annotation encoding="application/x-tex">j = \id{i1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i1</span></span></span></span></span>
(bottom) face is <code>g y</code>, the
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>=</mo><mrow><mi mathvariant="normal">i</mi><mn>0</mn></mrow></mrow><annotation encoding="application/x-tex">j = \id{i0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i0</span></span></span></span></span>
(top) face is <code>t (π i) (~ k)</code>, and similarly for
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mrow><mi mathvariant="normal">i</mi><mn>0</mn></mrow></mrow><annotation encoding="application/x-tex">i = \id{i0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i0</span></span></span></span></span>
(left) and
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mrow><mi mathvariant="normal">i</mi><mn>1</mn></mrow></mrow><annotation encoding="application/x-tex">i = \id{i1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i1</span></span></span></span></span>
(right).</p>
<div class="diagram-container">
<img src="light-4ca7bf8c3850978af54f0b59ab98cc349f53d49d.svg" title="commutative diagram" class="diagram diagram-light quiver tall-2" />
<img src="dark-4ca7bf8c3850978af54f0b59ab98cc349f53d49d.svg" title="commutative diagram" class="diagram diagram-dark quiver tall-2" />
</div>
<p>The fact that
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>
only appears as
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">¬</mi><mi>j</mi></mrow><annotation encoding="application/x-tex">\neg j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord">¬</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>
can be understood as the diagram above being <em>upside-down</em>.
Indeed,
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\pi_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
and
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\pi_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
in the boundary of
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span>
(the inner, blue face) are inverted when their types are considered.
We’re in the home stretch: Using our assumption
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>:</mo><mi>f</mi><mo stretchy="false">(</mo><mi>g</mi><mtext> </mtext><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">s : f (g\ x) = x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>,</span>
we can cancel all of the
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>∘</mo><mi>g</mi></mrow><annotation encoding="application/x-tex">f \circ g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span>s</span>
in the diagram above to get what we wanted:
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>0</mn></msub><mo>≡</mo><msub><mi>p</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">p_0 ≡ p_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6582em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</span></p>
<pre class="Agda">    <a id="16811" href="1Lab.Equiv.html#16811" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
Square (ap f (π i y x0 x1 p0 p1)) p0 p1 refl" class="Function">sq1</a> <a id="16815" class="Symbol">:</a> <a id="16817" href="1Lab.Path.html#9409" data-type="a00 ≡ a01 → a00 ≡ a10 → a01 ≡ a11 → a10 ≡ a11 → Type ℓ" class="Function">Square</a> <a id="16824" class="Symbol">(</a><a id="16825" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="16828" href="1Lab.Equiv.html#8428" class="Bound">f</a> <a id="16830" href="1Lab.Equiv.html#12769" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
x0 ≡ x1" class="Function">π</a><a id="16831" class="Symbol">)</a> <a id="16833" href="1Lab.Equiv.html#9369" class="Bound">p0</a> <a id="16836" href="1Lab.Equiv.html#9385" class="Bound">p1</a> <a id="16839" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
    <a id="16848" href="1Lab.Equiv.html#16811" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
Square (ap f (π i y x0 x1 p0 p1)) p0 p1 refl" class="Function">sq1</a> <a id="16852" href="1Lab.Equiv.html#16852" class="Bound">i</a> <a id="16854" href="1Lab.Equiv.html#16854" class="Bound">j</a> <a id="16856" class="Symbol">=</a> <a id="16858" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="16864" class="Symbol">(λ</a> <a id="16867" href="1Lab.Equiv.html#16867" class="Bound">k</a> <a id="16869" class="Symbol">→</a> <a id="16871" class="Symbol">λ</a> <a id="16873" class="Symbol">{</a> <a id="16875" class="Symbol">(</a><a id="16876" href="1Lab.Equiv.html#16852" class="Bound">i</a> <a id="16878" class="Symbol">=</a> <a id="16880" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="16882" class="Symbol">)</a> <a id="16884" class="Symbol">→</a> <a id="16886" href="1Lab.Equiv.html#8532" class="Field">s</a> <a id="16888" class="Symbol">(</a><a id="16889" href="1Lab.Equiv.html#9369" class="Bound">p0</a> <a id="16892" href="1Lab.Equiv.html#16854" class="Bound">j</a><a id="16893" class="Symbol">)</a> <a id="16895" href="1Lab.Equiv.html#16867" class="Bound">k</a>
                             <a id="16926" class="Symbol">;</a> <a id="16928" class="Symbol">(</a><a id="16929" href="1Lab.Equiv.html#16852" class="Bound">i</a> <a id="16931" class="Symbol">=</a> <a id="16933" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="16935" class="Symbol">)</a> <a id="16937" class="Symbol">→</a> <a id="16939" href="1Lab.Equiv.html#8532" class="Field">s</a> <a id="16941" class="Symbol">(</a><a id="16942" href="1Lab.Equiv.html#9385" class="Bound">p1</a> <a id="16945" href="1Lab.Equiv.html#16854" class="Bound">j</a><a id="16946" class="Symbol">)</a> <a id="16948" href="1Lab.Equiv.html#16867" class="Bound">k</a>
                             <a id="16979" class="Symbol">;</a> <a id="16981" class="Symbol">(</a><a id="16982" href="1Lab.Equiv.html#16854" class="Bound">j</a> <a id="16984" class="Symbol">=</a> <a id="16986" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="16988" class="Symbol">)</a> <a id="16990" class="Symbol">→</a> <a id="16992" href="1Lab.Equiv.html#8532" class="Field">s</a> <a id="16994" class="Symbol">(</a><a id="16995" href="1Lab.Equiv.html#8428" class="Bound">f</a> <a id="16997" class="Symbol">(</a><a id="16998" href="1Lab.Equiv.html#12769" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
x0 ≡ x1" class="Function">π</a> <a id="17000" href="1Lab.Equiv.html#16852" class="Bound">i</a><a id="17001" class="Symbol">))</a> <a id="17004" href="1Lab.Equiv.html#16867" class="Bound">k</a>
                             <a id="17035" class="Symbol">;</a> <a id="17037" class="Symbol">(</a><a id="17038" href="1Lab.Equiv.html#16854" class="Bound">j</a> <a id="17040" class="Symbol">=</a> <a id="17042" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="17044" class="Symbol">)</a> <a id="17046" class="Symbol">→</a> <a id="17048" href="1Lab.Equiv.html#8532" class="Field">s</a> <a id="17050" href="1Lab.Equiv.html#9349" class="Bound">y</a> <a id="17052" href="1Lab.Equiv.html#16867" class="Bound">k</a>
                             <a id="17083" class="Symbol">})</a>
                    <a id="17106" class="Symbol">(</a><a id="17107" href="1Lab.Equiv.html#8428" class="Bound">f</a> <a id="17109" class="Symbol">(</a><a id="17110" href="1Lab.Equiv.html#13661" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
Square (ap (inv i ⊙ f) (π i y x0 x1 p0 p1)) (ap (inv i) p0)
(ap (inv i) p1) refl" class="Function">ι</a> <a id="17112" href="1Lab.Equiv.html#16852" class="Bound">i</a> <a id="17114" href="1Lab.Equiv.html#16854" class="Bound">j</a><a id="17115" class="Symbol">))</a>
</pre>
<p>The composition above can be visualised as the front (red) face in
the cubical diagram below. Once more, left is
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mrow><mi mathvariant="normal">i</mi><mn>0</mn></mrow></mrow><annotation encoding="application/x-tex">i = \id{i0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i0</span></span></span></span></span>,</span>
right is
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mrow><mi mathvariant="normal">i</mi><mn>1</mn></mrow></mrow><annotation encoding="application/x-tex">i = \id{i1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i1</span></span></span></span></span>,</span>
up is
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>=</mo><mrow><mi mathvariant="normal">i</mi><mn>0</mn></mrow></mrow><annotation encoding="application/x-tex">j = \id{i0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i0</span></span></span></span></span>,</span>
and down is
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>=</mo><mrow><mi mathvariant="normal">i</mi><mn>1</mn></mrow></mrow><annotation encoding="application/x-tex">j = \id{i1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i1</span></span></span></span></span>.</span></p>
<div class="diagram-container">
<img src="light-ed665b137886f06422ef995b304d460c5fbffbb7.svg" title="commutative diagram" class="diagram diagram-light quiver tall-2" />
<img src="dark-ed665b137886f06422ef995b304d460c5fbffbb7.svg" title="commutative diagram" class="diagram diagram-dark quiver tall-2" />
</div>
<p>Putting all of this together, we get that
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>p</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mo>≡</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>p</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x_0, p_0) ≡ (x_1, p_1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>.</span>
Since there were no assumptions on any of the variables under
consideration, this indeed says that the fibre over
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>
is a proposition for any choice of
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>.</span></p>
<pre class="Agda">    <a id="19566" href="1Lab.Equiv.html#19566" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
(x0 , p0) ≡ (x1 , p1)" class="Function">is-iso→fibre-is-prop</a> <a id="19587" class="Symbol">:</a> <a id="19589" class="Symbol">(</a><a id="19590" href="1Lab.Equiv.html#9357" class="Bound">x0</a> <a id="19593" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="19595" href="1Lab.Equiv.html#9369" class="Bound">p0</a><a id="19597" class="Symbol">)</a> <a id="19599" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="19601" class="Symbol">(</a><a id="19602" href="1Lab.Equiv.html#9360" class="Bound">x1</a> <a id="19605" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="19607" href="1Lab.Equiv.html#9385" class="Bound">p1</a><a id="19609" class="Symbol">)</a>
    <a id="19615" href="1Lab.Equiv.html#19566" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
(x0 , p0) ≡ (x1 , p1)" class="Function">is-iso→fibre-is-prop</a> <a id="19636" href="1Lab.Equiv.html#19636" class="Bound">i</a> <a id="19638" class="Symbol">.</a><a id="19639" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="19643" class="Symbol">=</a> <a id="19645" href="1Lab.Equiv.html#12769" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
x0 ≡ x1" class="Function">π</a> <a id="19647" href="1Lab.Equiv.html#19636" class="Bound">i</a>
    <a id="19653" href="1Lab.Equiv.html#19566" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
(x0 , p0) ≡ (x1 , p1)" class="Function">is-iso→fibre-is-prop</a> <a id="19674" href="1Lab.Equiv.html#19674" class="Bound">i</a> <a id="19676" class="Symbol">.</a><a id="19677" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="19681" class="Symbol">=</a> <a id="19683" href="1Lab.Equiv.html#16811" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
Square (ap f (π i y x0 x1 p0 p1)) p0 p1 refl" class="Function">sq1</a> <a id="19687" href="1Lab.Equiv.html#19674" class="Bound">i</a>
</pre>
<p>Since the fibre over
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>
is inhabited by
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>g</mi><mtext> </mtext><mi>y</mi><mo separator="true">,</mo><mi>s</mi><mtext> </mtext><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(g\ y, s\ y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">s</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>,</span>
we get that any isomorphism has contractible fibres:</p>
<pre class="Agda">  <a id="19815" href="1Lab.Equiv.html#19815" data-type="(i : is-iso f) → is-equiv f" class="Function">is-iso→is-equiv</a> <a id="19831" class="Symbol">:</a> <a id="19833" href="1Lab.Equiv.html#2286" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-equiv</a> <a id="19842" href="1Lab.Equiv.html#8428" class="Bound">f</a>
  <a id="19846" href="1Lab.Equiv.html#19815" data-type="(i : is-iso f) → is-equiv f" class="Function">is-iso→is-equiv</a> <a id="19862" class="Symbol">.</a><a id="19863" href="1Lab.Equiv.html#2376" data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" class="Field">is-eqv</a> <a id="19870" href="1Lab.Equiv.html#19870" class="Bound">y</a> <a id="19872" class="Symbol">.</a><a id="19873" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a> <a id="19880" class="Symbol">.</a><a id="19881" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="19885" class="Symbol">=</a> <a id="19887" href="1Lab.Equiv.html#8495" class="Field">g</a> <a id="19889" href="1Lab.Equiv.html#19870" class="Bound">y</a>
  <a id="19893" href="1Lab.Equiv.html#19815" data-type="(i : is-iso f) → is-equiv f" class="Function">is-iso→is-equiv</a> <a id="19909" class="Symbol">.</a><a id="19910" href="1Lab.Equiv.html#2376" data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" class="Field">is-eqv</a> <a id="19917" href="1Lab.Equiv.html#19917" class="Bound">y</a> <a id="19919" class="Symbol">.</a><a id="19920" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a> <a id="19927" class="Symbol">.</a><a id="19928" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="19932" class="Symbol">=</a> <a id="19934" href="1Lab.Equiv.html#8532" class="Field">s</a> <a id="19936" href="1Lab.Equiv.html#19917" class="Bound">y</a>
  <a id="19940" href="1Lab.Equiv.html#19815" data-type="(i : is-iso f) → is-equiv f" class="Function">is-iso→is-equiv</a> <a id="19956" class="Symbol">.</a><a id="19957" href="1Lab.Equiv.html#2376" data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" class="Field">is-eqv</a> <a id="19964" href="1Lab.Equiv.html#19964" class="Bound">y</a> <a id="19966" class="Symbol">.</a><a id="19967" href="1Lab.HLevel.html#1416" data-type="(r : is-contr A) (x : A) → r .centre ≡ x" class="Field">paths</a> <a id="19973" href="1Lab.Equiv.html#19973" class="Bound">z</a> <a id="19975" class="Symbol">=</a>
    <a id="19981" href="1Lab.Equiv.html#19566" data-type="(i : is-iso f) (y : B₁) (x0 x1 : A) (p0 : f x0 ≡ y)
(p1 : f x1 ≡ y) →
(x0 , p0) ≡ (x1 , p1)" class="Function">is-iso→fibre-is-prop</a> <a id="20002" href="1Lab.Equiv.html#19964" class="Bound">y</a> <a id="20004" class="Symbol">(</a><a id="20005" href="1Lab.Equiv.html#8495" class="Field">g</a> <a id="20007" href="1Lab.Equiv.html#19964" class="Bound">y</a><a id="20008" class="Symbol">)</a> <a id="20010" class="Symbol">(</a><a id="20011" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="20015" href="1Lab.Equiv.html#19973" class="Bound">z</a><a id="20016" class="Symbol">)</a> <a id="20018" class="Symbol">(</a><a id="20019" href="1Lab.Equiv.html#8532" class="Field">s</a> <a id="20021" href="1Lab.Equiv.html#19964" class="Bound">y</a><a id="20022" class="Symbol">)</a> <a id="20024" class="Symbol">(</a><a id="20025" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="20029" href="1Lab.Equiv.html#19973" class="Bound">z</a><a id="20030" class="Symbol">)</a>
</pre>
<p>Applying this to the
<span class="Agda"><a href="1Lab.Equiv.html#6298" class="Function">Iso</a></span>
and
<span class="Agda"><a href="1Lab.Equiv.html#2439" class="Function Operator">_≃_</a></span>
pairs, we can turn any isomorphism into a coherent equivalence.</p>
<pre class="Agda"><a id="Iso→Equiv"></a><a id="20161" href="1Lab.Equiv.html#20161" data-type="Iso A B₁ → A ≃ B₁" class="Function">Iso→Equiv</a> <a id="20171" class="Symbol">:</a> <a id="20173" class="Symbol">∀</a> <a id="20175" class="Symbol">{</a><a id="20176" href="1Lab.Equiv.html#20176" class="Bound">ℓ₁</a> <a id="20179" href="1Lab.Equiv.html#20179" class="Bound">ℓ₂</a><a id="20181" class="Symbol">}</a> <a id="20183" class="Symbol">{</a><a id="20184" href="1Lab.Equiv.html#20184" class="Bound">A</a> <a id="20186" class="Symbol">:</a> <a id="20188" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="20193" href="1Lab.Equiv.html#20176" class="Bound">ℓ₁</a><a id="20195" class="Symbol">}</a> <a id="20197" class="Symbol">{</a><a id="20198" href="1Lab.Equiv.html#20198" class="Bound">B</a> <a id="20200" class="Symbol">:</a> <a id="20202" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="20207" href="1Lab.Equiv.html#20179" class="Bound">ℓ₂</a><a id="20209" class="Symbol">}</a>
          <a id="20221" class="Symbol">→</a> <a id="20223" href="1Lab.Equiv.html#6298" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function">Iso</a> <a id="20227" href="1Lab.Equiv.html#20184" class="Bound">A</a> <a id="20229" href="1Lab.Equiv.html#20198" class="Bound">B</a>
          <a id="20241" class="Symbol">→</a> <a id="20243" href="1Lab.Equiv.html#20184" class="Bound">A</a> <a id="20245" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="20247" href="1Lab.Equiv.html#20198" class="Bound">B</a>
<a id="20249" href="1Lab.Equiv.html#20161" data-type="Iso A B₁ → A ≃ B₁" class="Function">Iso→Equiv</a> <a id="20259" class="Symbol">(</a><a id="20260" href="1Lab.Equiv.html#20260" class="Bound">f</a> <a id="20262" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="20264" href="1Lab.Equiv.html#20264" class="Bound">is-iso</a><a id="20270" class="Symbol">)</a> <a id="20272" class="Symbol">=</a> <a id="20274" href="1Lab.Equiv.html#20260" class="Bound">f</a> <a id="20276" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="20278" href="1Lab.Equiv.html#19815" data-type="(i : is-iso f) → is-equiv f" class="Function">is-iso→is-equiv</a> <a id="20294" href="1Lab.Equiv.html#20264" class="Bound">is-iso</a>
</pre>
<p>A helpful lemma: Any function between contractible types is an
equivalence:</p>
<pre class="Agda"><a id="is-contr→is-equiv"></a><a id="20391" href="1Lab.Equiv.html#20391" data-type="is-contr A → is-contr B₁ → is-equiv f" class="Function">is-contr→is-equiv</a> <a id="20409" class="Symbol">:</a> <a id="20411" class="Symbol">∀</a> <a id="20413" class="Symbol">{</a><a id="20414" href="1Lab.Equiv.html#20414" class="Bound">ℓ₁</a> <a id="20417" href="1Lab.Equiv.html#20417" class="Bound">ℓ₂</a><a id="20419" class="Symbol">}</a> <a id="20421" class="Symbol">{</a><a id="20422" href="1Lab.Equiv.html#20422" class="Bound">A</a> <a id="20424" class="Symbol">:</a> <a id="20426" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="20431" href="1Lab.Equiv.html#20414" class="Bound">ℓ₁</a><a id="20433" class="Symbol">}</a> <a id="20435" class="Symbol">{</a><a id="20436" href="1Lab.Equiv.html#20436" class="Bound">B</a> <a id="20438" class="Symbol">:</a> <a id="20440" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="20445" href="1Lab.Equiv.html#20417" class="Bound">ℓ₂</a><a id="20447" class="Symbol">}</a>
                  <a id="20467" class="Symbol">→</a> <a id="20469" href="1Lab.HLevel.html#1328" data-type="(A : Type ℓ) → Type ℓ" class="Record">is-contr</a> <a id="20478" href="1Lab.Equiv.html#20422" class="Bound">A</a> <a id="20480" class="Symbol">→</a> <a id="20482" href="1Lab.HLevel.html#1328" data-type="(A : Type ℓ) → Type ℓ" class="Record">is-contr</a> <a id="20491" href="1Lab.Equiv.html#20436" class="Bound">B</a> <a id="20493" class="Symbol">→</a> <a id="20495" class="Symbol">{</a><a id="20496" href="1Lab.Equiv.html#20496" class="Bound">f</a> <a id="20498" class="Symbol">:</a> <a id="20500" href="1Lab.Equiv.html#20422" class="Bound">A</a> <a id="20502" class="Symbol">→</a> <a id="20504" href="1Lab.Equiv.html#20436" class="Bound">B</a><a id="20505" class="Symbol">}</a>
                  <a id="20525" class="Symbol">→</a> <a id="20527" href="1Lab.Equiv.html#2286" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-equiv</a> <a id="20536" href="1Lab.Equiv.html#20496" class="Bound">f</a>
<a id="20538" href="1Lab.Equiv.html#20391" data-type="is-contr A → is-contr B₁ → is-equiv f" class="Function">is-contr→is-equiv</a> <a id="20556" href="1Lab.Equiv.html#20556" class="Bound">cA</a> <a id="20559" href="1Lab.Equiv.html#20559" class="Bound">cB</a> <a id="20562" class="Symbol">=</a> <a id="20564" href="1Lab.Equiv.html#19815" data-type="(i : is-iso f) → is-equiv f" class="Function">is-iso→is-equiv</a> <a id="20580" href="1Lab.Equiv.html#20597" data-type="(cA : is-contr A) (cB : is-contr B₁) → is-iso f" class="Function">f-is-iso</a> <a id="20589" class="Keyword">where</a>
  <a id="20597" href="1Lab.Equiv.html#20597" data-type="(cA : is-contr A) (cB : is-contr B₁) → is-iso f" class="Function">f-is-iso</a> <a id="20606" class="Symbol">:</a> <a id="20608" href="1Lab.Equiv.html#6026" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-iso</a> <a id="20615" class="Symbol">_</a>
  <a id="20619" href="1Lab.Equiv.html#6132" data-type="is-iso f → B₁ → A" class="Field">is-iso.inv</a> <a id="20630" href="1Lab.Equiv.html#20597" data-type="(cA : is-contr A) (cB : is-contr B₁) → is-iso f" class="Function">f-is-iso</a> <a id="20639" class="Symbol">_</a> <a id="20641" class="Symbol">=</a> <a id="20643" href="1Lab.Equiv.html#20556" class="Bound">cA</a> <a id="20646" class="Symbol">.</a><a id="20647" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a>
  <a id="20656" href="1Lab.Equiv.html#6148" data-type="(r : is-iso f) → is-right-inverse (r .inv) f" class="Field">is-iso.rinv</a> <a id="20668" href="1Lab.Equiv.html#20597" data-type="(cA : is-contr A) (cB : is-contr B₁) → is-iso f" class="Function">f-is-iso</a> <a id="20677" class="Symbol">_</a> <a id="20679" class="Symbol">=</a> <a id="20681" href="1Lab.HLevel.html#3818" data-type="is-contr A → is-prop A" class="Function">is-contr→is-prop</a> <a id="20698" href="1Lab.Equiv.html#20559" class="Bound">cB</a> <a id="20701" class="Symbol">_</a> <a id="20703" class="Symbol">_</a>
  <a id="20707" href="1Lab.Equiv.html#6182" data-type="(r : is-iso f) → is-left-inverse (r .inv) f" class="Field">is-iso.linv</a> <a id="20719" href="1Lab.Equiv.html#20597" data-type="(cA : is-contr A) (cB : is-contr B₁) → is-iso f" class="Function">f-is-iso</a> <a id="20728" class="Symbol">_</a> <a id="20730" class="Symbol">=</a> <a id="20732" href="1Lab.HLevel.html#3818" data-type="is-contr A → is-prop A" class="Function">is-contr→is-prop</a> <a id="20749" href="1Lab.Equiv.html#20556" class="Bound">cA</a> <a id="20752" class="Symbol">_</a> <a id="20754" class="Symbol">_</a>

<a id="is-contr→≃"></a><a id="20757" href="1Lab.Equiv.html#20757" data-type="is-contr A → is-contr B₁ → A ≃ B₁" class="Function">is-contr→≃</a> <a id="20768" class="Symbol">:</a> <a id="20770" class="Symbol">∀</a> <a id="20772" class="Symbol">{</a><a id="20773" href="1Lab.Equiv.html#20773" class="Bound">ℓ₁</a> <a id="20776" href="1Lab.Equiv.html#20776" class="Bound">ℓ₂</a><a id="20778" class="Symbol">}</a> <a id="20780" class="Symbol">{</a><a id="20781" href="1Lab.Equiv.html#20781" class="Bound">A</a> <a id="20783" class="Symbol">:</a> <a id="20785" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="20790" href="1Lab.Equiv.html#20773" class="Bound">ℓ₁</a><a id="20792" class="Symbol">}</a> <a id="20794" class="Symbol">{</a><a id="20795" href="1Lab.Equiv.html#20795" class="Bound">B</a> <a id="20797" class="Symbol">:</a> <a id="20799" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="20804" href="1Lab.Equiv.html#20776" class="Bound">ℓ₂</a><a id="20806" class="Symbol">}</a>
           <a id="20819" class="Symbol">→</a> <a id="20821" href="1Lab.HLevel.html#1328" data-type="(A : Type ℓ) → Type ℓ" class="Record">is-contr</a> <a id="20830" href="1Lab.Equiv.html#20781" class="Bound">A</a> <a id="20832" class="Symbol">→</a> <a id="20834" href="1Lab.HLevel.html#1328" data-type="(A : Type ℓ) → Type ℓ" class="Record">is-contr</a> <a id="20843" href="1Lab.Equiv.html#20795" class="Bound">B</a> <a id="20845" class="Symbol">→</a> <a id="20847" href="1Lab.Equiv.html#20781" class="Bound">A</a> <a id="20849" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="20851" href="1Lab.Equiv.html#20795" class="Bound">B</a>
<a id="20853" href="1Lab.Equiv.html#20757" data-type="is-contr A → is-contr B₁ → A ≃ B₁" class="Function">is-contr→≃</a> <a id="20864" href="1Lab.Equiv.html#20864" class="Bound">cA</a> <a id="20867" href="1Lab.Equiv.html#20867" class="Bound">cB</a> <a id="20870" class="Symbol">=</a> <a id="20872" class="Symbol">(λ</a> <a id="20875" href="1Lab.Equiv.html#20875" class="Bound">_</a> <a id="20877" class="Symbol">→</a> <a id="20879" href="1Lab.Equiv.html#20867" class="Bound">cB</a> <a id="20882" class="Symbol">.</a><a id="20883" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a><a id="20889" class="Symbol">)</a> <a id="20891" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="20893" href="1Lab.Equiv.html#19815" data-type="(i : is-iso f) → is-equiv f" class="Function">is-iso→is-equiv</a> <a id="20909" href="1Lab.Equiv.html#20926" data-type="(cA : is-contr A) (cB : is-contr B₁) → is-iso (λ _ → cB .centre)" class="Function">f-is-iso</a> <a id="20918" class="Keyword">where</a>
  <a id="20926" href="1Lab.Equiv.html#20926" data-type="(cA : is-contr A) (cB : is-contr B₁) → is-iso (λ _ → cB .centre)" class="Function">f-is-iso</a> <a id="20935" class="Symbol">:</a> <a id="20937" href="1Lab.Equiv.html#6026" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-iso</a> <a id="20944" class="Symbol">_</a>
  <a id="20948" href="1Lab.Equiv.html#6132" data-type="is-iso f → B₁ → A" class="Field">is-iso.inv</a> <a id="20959" href="1Lab.Equiv.html#20926" data-type="(cA : is-contr A) (cB : is-contr B₁) → is-iso (λ _ → cB .centre)" class="Function">f-is-iso</a> <a id="20968" class="Symbol">_</a> <a id="20970" class="Symbol">=</a> <a id="20972" href="1Lab.Equiv.html#20864" class="Bound">cA</a> <a id="20975" class="Symbol">.</a><a id="20976" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a>
  <a id="20985" href="1Lab.Equiv.html#6148" data-type="(r : is-iso f) → is-right-inverse (r .inv) f" class="Field">is-iso.rinv</a> <a id="20997" href="1Lab.Equiv.html#20926" data-type="(cA : is-contr A) (cB : is-contr B₁) → is-iso (λ _ → cB .centre)" class="Function">f-is-iso</a> <a id="21006" class="Symbol">_</a> <a id="21008" class="Symbol">=</a> <a id="21010" href="1Lab.HLevel.html#3818" data-type="is-contr A → is-prop A" class="Function">is-contr→is-prop</a> <a id="21027" href="1Lab.Equiv.html#20867" class="Bound">cB</a> <a id="21030" class="Symbol">_</a> <a id="21032" class="Symbol">_</a>
  <a id="21036" href="1Lab.Equiv.html#6182" data-type="(r : is-iso f) → is-left-inverse (r .inv) f" class="Field">is-iso.linv</a> <a id="21048" href="1Lab.Equiv.html#20926" data-type="(cA : is-contr A) (cB : is-contr B₁) → is-iso (λ _ → cB .centre)" class="Function">f-is-iso</a> <a id="21057" class="Symbol">_</a> <a id="21059" class="Symbol">=</a> <a id="21061" href="1Lab.HLevel.html#3818" data-type="is-contr A → is-prop A" class="Function">is-contr→is-prop</a> <a id="21078" href="1Lab.Equiv.html#20864" class="Bound">cA</a> <a id="21081" class="Symbol">_</a> <a id="21083" class="Symbol">_</a>
</pre>
<h1 id="equivalence-reasoning"><a href="#equivalence-reasoning" class="header-link">Equivalence
Reasoning<span class="header-link-emoji">🔗</span></a></h1>
<p>To make composing equivalences more intuitive, we implement operators
to do equivalence reasoning in the same style as equational
reasoning.</p>
<pre class="Agda"><a id="_∙e_"></a><a id="21265" href="1Lab.Equiv.html#21265" data-type="A ≃ B₁ → B₁ ≃ C → A ≃ C" class="Function Operator">_∙e_</a> <a id="21270" class="Symbol">:</a> <a id="21272" class="Symbol">∀</a> <a id="21274" class="Symbol">{</a><a id="21275" href="1Lab.Equiv.html#21275" class="Bound">ℓ</a> <a id="21277" href="1Lab.Equiv.html#21277" class="Bound">ℓ₁</a> <a id="21280" href="1Lab.Equiv.html#21280" class="Bound">ℓ₂</a><a id="21282" class="Symbol">}</a> <a id="21284" class="Symbol">{</a><a id="21285" href="1Lab.Equiv.html#21285" class="Bound">A</a> <a id="21287" class="Symbol">:</a> <a id="21289" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="21294" href="1Lab.Equiv.html#21275" class="Bound">ℓ</a><a id="21295" class="Symbol">}</a> <a id="21297" class="Symbol">{</a><a id="21298" href="1Lab.Equiv.html#21298" class="Bound">B</a> <a id="21300" class="Symbol">:</a> <a id="21302" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="21307" href="1Lab.Equiv.html#21277" class="Bound">ℓ₁</a><a id="21309" class="Symbol">}</a> <a id="21311" class="Symbol">{</a><a id="21312" href="1Lab.Equiv.html#21312" class="Bound">C</a> <a id="21314" class="Symbol">:</a> <a id="21316" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="21321" href="1Lab.Equiv.html#21280" class="Bound">ℓ₂</a><a id="21323" class="Symbol">}</a>
     <a id="21330" class="Symbol">→</a> <a id="21332" href="1Lab.Equiv.html#21285" class="Bound">A</a> <a id="21334" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="21336" href="1Lab.Equiv.html#21298" class="Bound">B</a> <a id="21338" class="Symbol">→</a> <a id="21340" href="1Lab.Equiv.html#21298" class="Bound">B</a> <a id="21342" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="21344" href="1Lab.Equiv.html#21312" class="Bound">C</a> <a id="21346" class="Symbol">→</a> <a id="21348" href="1Lab.Equiv.html#21285" class="Bound">A</a> <a id="21350" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="21352" href="1Lab.Equiv.html#21312" class="Bound">C</a>

<a id="_e⁻¹"></a><a id="21355" href="1Lab.Equiv.html#21355" data-type="A ≃ B₁ → B₁ ≃ A" class="Function Operator">_e⁻¹</a> <a id="21360" class="Symbol">:</a> <a id="21362" class="Symbol">∀</a> <a id="21364" class="Symbol">{</a><a id="21365" href="1Lab.Equiv.html#21365" class="Bound">ℓ</a> <a id="21367" href="1Lab.Equiv.html#21367" class="Bound">ℓ₁</a><a id="21369" class="Symbol">}</a> <a id="21371" class="Symbol">{</a><a id="21372" href="1Lab.Equiv.html#21372" class="Bound">A</a> <a id="21374" class="Symbol">:</a> <a id="21376" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="21381" href="1Lab.Equiv.html#21365" class="Bound">ℓ</a><a id="21382" class="Symbol">}</a> <a id="21384" class="Symbol">{</a><a id="21385" href="1Lab.Equiv.html#21385" class="Bound">B</a> <a id="21387" class="Symbol">:</a> <a id="21389" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="21394" href="1Lab.Equiv.html#21367" class="Bound">ℓ₁</a><a id="21396" class="Symbol">}</a>
     <a id="21403" class="Symbol">→</a> <a id="21405" href="1Lab.Equiv.html#21372" class="Bound">A</a> <a id="21407" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="21409" href="1Lab.Equiv.html#21385" class="Bound">B</a> <a id="21411" class="Symbol">→</a> <a id="21413" href="1Lab.Equiv.html#21385" class="Bound">B</a> <a id="21415" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="21417" href="1Lab.Equiv.html#21372" class="Bound">A</a>
<a id="21419" href="1Lab.Equiv.html#21355" data-type="A ≃ B₁ → B₁ ≃ A" class="Function Operator">_e⁻¹</a> <a id="21424" href="1Lab.Equiv.html#21424" class="Bound">eqv</a> <a id="21428" class="Symbol">=</a> <a id="21430" href="1Lab.Equiv.html#20161" data-type="Iso A B₁ → A ≃ B₁" class="Function">Iso→Equiv</a> <a id="21440" class="Symbol">(</a> <a id="21442" href="1Lab.Equiv.html#6449" data-type="is-equiv f → B₁ → A" class="Function">equiv→inverse</a> <a id="21456" class="Symbol">(</a><a id="21457" href="1Lab.Equiv.html#21424" class="Bound">eqv</a> <a id="21461" class="Symbol">.</a><a id="21462" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a><a id="21465" class="Symbol">)</a>
                     <a id="21488" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="21490" class="Keyword">record</a> <a id="21497" class="Symbol">{</a> <a id="21499" href="1Lab.Equiv.html#6132" data-type="is-iso f → B₁ → A" class="Field">inv</a>  <a id="21504" class="Symbol">=</a> <a id="21506" href="1Lab.Equiv.html#21424" class="Bound">eqv</a> <a id="21510" class="Symbol">.</a><a id="21511" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a>
                              <a id="21545" class="Symbol">;</a> <a id="21547" href="1Lab.Equiv.html#6148" data-type="(r : is-iso f) → is-right-inverse (r .inv) f" class="Field">rinv</a> <a id="21552" class="Symbol">=</a> <a id="21554" href="1Lab.Equiv.html#6688" data-type="(eqv : is-equiv f) → is-left-inverse (equiv→inverse eqv) f" class="Function">equiv→retraction</a> <a id="21571" class="Symbol">(</a><a id="21572" href="1Lab.Equiv.html#21424" class="Bound">eqv</a> <a id="21576" class="Symbol">.</a><a id="21577" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a><a id="21580" class="Symbol">)</a>
                              <a id="21612" class="Symbol">;</a> <a id="21614" href="1Lab.Equiv.html#6182" data-type="(r : is-iso f) → is-left-inverse (r .inv) f" class="Field">linv</a> <a id="21619" class="Symbol">=</a> <a id="21621" href="1Lab.Equiv.html#6548" data-type="(eqv : is-equiv f) → is-right-inverse (equiv→inverse eqv) f" class="Function">equiv→section</a> <a id="21635" class="Symbol">(</a><a id="21636" href="1Lab.Equiv.html#21424" class="Bound">eqv</a> <a id="21640" class="Symbol">.</a><a id="21641" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a><a id="21644" class="Symbol">)</a>
                              <a id="21676" class="Symbol">})</a>
</pre>
<!--
<pre class="Agda"><a id="21692" href="1Lab.Equiv.html#21265" data-type="A ≃ B₁ → B₁ ≃ C → A ≃ C" class="Function Operator">_∙e_</a> <a id="21697" class="Symbol">(</a><a id="21698" href="1Lab.Equiv.html#21698" class="Bound">f</a> <a id="21700" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="21702" href="1Lab.Equiv.html#21702" class="Bound">e</a><a id="21703" class="Symbol">)</a> <a id="21705" class="Symbol">(</a><a id="21706" href="1Lab.Equiv.html#21706" class="Bound">g</a> <a id="21708" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="21710" href="1Lab.Equiv.html#21710" class="Bound">e&#39;</a><a id="21712" class="Symbol">)</a> <a id="21714" class="Symbol">=</a> <a id="21716" class="Symbol">(λ</a> <a id="21719" href="1Lab.Equiv.html#21719" class="Bound">x</a> <a id="21721" class="Symbol">→</a> <a id="21723" href="1Lab.Equiv.html#21706" class="Bound">g</a> <a id="21725" class="Symbol">(</a><a id="21726" href="1Lab.Equiv.html#21698" class="Bound">f</a> <a id="21728" href="1Lab.Equiv.html#21719" class="Bound">x</a><a id="21729" class="Symbol">))</a> <a id="21732" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="21734" href="1Lab.Equiv.html#22461" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
is-equiv (λ x → g (f x))" class="Function">eqv</a> <a id="21738" class="Keyword">where</a>
  <a id="21746" href="1Lab.Equiv.html#21746" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
is-iso g" class="Function">g⁻¹</a> <a id="21750" class="Symbol">:</a> <a id="21752" href="1Lab.Equiv.html#6026" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-iso</a> <a id="21759" href="1Lab.Equiv.html#21706" class="Bound">g</a>
  <a id="21763" href="1Lab.Equiv.html#21746" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
is-iso g" class="Function">g⁻¹</a> <a id="21767" class="Symbol">=</a> <a id="21769" href="1Lab.Equiv.html#6859" data-type="is-equiv f → is-iso f" class="Function">is-equiv→is-iso</a> <a id="21785" href="1Lab.Equiv.html#21710" class="Bound">e&#39;</a>

  <a id="21791" href="1Lab.Equiv.html#21791" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
is-iso f" class="Function">f⁻¹</a> <a id="21795" class="Symbol">:</a> <a id="21797" href="1Lab.Equiv.html#6026" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-iso</a> <a id="21804" href="1Lab.Equiv.html#21698" class="Bound">f</a>
  <a id="21808" href="1Lab.Equiv.html#21791" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
is-iso f" class="Function">f⁻¹</a> <a id="21812" class="Symbol">=</a> <a id="21814" href="1Lab.Equiv.html#6859" data-type="is-equiv f → is-iso f" class="Function">is-equiv→is-iso</a> <a id="21830" href="1Lab.Equiv.html#21702" class="Bound">e</a>

  <a id="21835" href="1Lab.Equiv.html#21835" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
C → A" class="Function">inv</a> <a id="21839" class="Symbol">:</a> <a id="21841" class="Symbol">_</a> <a id="21843" class="Symbol">→</a> <a id="21845" class="Symbol">_</a>
  <a id="21849" href="1Lab.Equiv.html#21835" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
C → A" class="Function">inv</a> <a id="21853" href="1Lab.Equiv.html#21853" class="Bound">x</a> <a id="21855" class="Symbol">=</a> <a id="21857" href="1Lab.Equiv.html#21791" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
is-iso f" class="Function">f⁻¹</a> <a id="21861" class="Symbol">.</a><a id="21862" href="1Lab.Equiv.html#6132" data-type="is-iso f → B₁ → A" class="Field">is-iso.inv</a> <a id="21873" class="Symbol">(</a><a id="21874" href="1Lab.Equiv.html#21746" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
is-iso g" class="Function">g⁻¹</a> <a id="21878" class="Symbol">.</a><a id="21879" href="1Lab.Equiv.html#6132" data-type="is-iso f → B₁ → A" class="Field">is-iso.inv</a> <a id="21890" href="1Lab.Equiv.html#21853" class="Bound">x</a><a id="21891" class="Symbol">)</a>

  <a id="21896" class="Keyword">abstract</a>
    <a id="21909" href="1Lab.Equiv.html#21909" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
is-right-inverse (inv f e g e&#39;) (λ x → g (f x))" class="Function">right</a> <a id="21915" class="Symbol">:</a> <a id="21917" href="1Lab.Equiv.html#5739" data-type="(B₁ → A) → (A → B₁) → Type B.ℓ₁" class="Function">is-right-inverse</a> <a id="21934" href="1Lab.Equiv.html#21835" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
C → A" class="Function">inv</a> <a id="21938" class="Symbol">(λ</a> <a id="21941" href="1Lab.Equiv.html#21941" class="Bound">x</a> <a id="21943" class="Symbol">→</a> <a id="21945" href="1Lab.Equiv.html#21706" class="Bound">g</a> <a id="21947" class="Symbol">(</a><a id="21948" href="1Lab.Equiv.html#21698" class="Bound">f</a> <a id="21950" href="1Lab.Equiv.html#21941" class="Bound">x</a><a id="21951" class="Symbol">))</a>
    <a id="21958" href="1Lab.Equiv.html#21909" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
is-right-inverse (inv f e g e&#39;) (λ x → g (f x))" class="Function">right</a> <a id="21964" href="1Lab.Equiv.html#21964" class="Bound">z</a> <a id="21966" class="Symbol">=</a>
      <a id="21974" href="1Lab.Equiv.html#21706" class="Bound">g</a> <a id="21976" class="Symbol">(</a><a id="21977" href="1Lab.Equiv.html#21698" class="Bound">f</a> <a id="21979" class="Symbol">(</a><a id="21980" href="1Lab.Equiv.html#21791" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
is-iso f" class="Function">f⁻¹</a> <a id="21984" class="Symbol">.</a><a id="21985" href="1Lab.Equiv.html#6132" data-type="is-iso f → B₁ → A" class="Field">is-iso.inv</a> <a id="21996" class="Symbol">(</a><a id="21997" href="1Lab.Equiv.html#21746" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
is-iso g" class="Function">g⁻¹</a> <a id="22001" class="Symbol">.</a><a id="22002" href="1Lab.Equiv.html#6132" data-type="is-iso f → B₁ → A" class="Field">is-iso.inv</a> <a id="22013" href="1Lab.Equiv.html#21964" class="Bound">z</a><a id="22014" class="Symbol">)))</a> <a id="22018" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="22021" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="22024" href="1Lab.Equiv.html#21706" class="Bound">g</a> <a id="22026" class="Symbol">(</a><a id="22027" href="1Lab.Equiv.html#21791" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
is-iso f" class="Function">f⁻¹</a> <a id="22031" class="Symbol">.</a><a id="22032" href="1Lab.Equiv.html#6148" data-type="(r : is-iso f) → is-right-inverse (r .inv) f" class="Field">is-iso.rinv</a> <a id="22044" class="Symbol">_)</a> <a id="22047" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
      <a id="22055" href="1Lab.Equiv.html#21706" class="Bound">g</a> <a id="22057" class="Symbol">(</a><a id="22058" href="1Lab.Equiv.html#21746" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
is-iso g" class="Function">g⁻¹</a> <a id="22062" class="Symbol">.</a><a id="22063" href="1Lab.Equiv.html#6132" data-type="is-iso f → B₁ → A" class="Field">is-iso.inv</a> <a id="22074" href="1Lab.Equiv.html#21964" class="Bound">z</a><a id="22075" class="Symbol">)</a>                       <a id="22099" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="22102" href="1Lab.Equiv.html#21746" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
is-iso g" class="Function">g⁻¹</a> <a id="22106" class="Symbol">.</a><a id="22107" href="1Lab.Equiv.html#6148" data-type="(r : is-iso f) → is-right-inverse (r .inv) f" class="Field">is-iso.rinv</a> <a id="22119" class="Symbol">_</a> <a id="22121" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
      <a id="22129" href="1Lab.Equiv.html#21964" class="Bound">z</a>                                           <a id="22173" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>

    <a id="22180" href="1Lab.Equiv.html#22180" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
is-left-inverse (inv f e g e&#39;) (λ x → g (f x))" class="Function">left</a> <a id="22185" class="Symbol">:</a> <a id="22187" href="1Lab.Equiv.html#5649" data-type="(B₁ → A) → (A → B₁) → Type A.ℓ₁" class="Function">is-left-inverse</a> <a id="22203" href="1Lab.Equiv.html#21835" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
C → A" class="Function">inv</a> <a id="22207" class="Symbol">(λ</a> <a id="22210" href="1Lab.Equiv.html#22210" class="Bound">x</a> <a id="22212" class="Symbol">→</a> <a id="22214" href="1Lab.Equiv.html#21706" class="Bound">g</a> <a id="22216" class="Symbol">(</a><a id="22217" href="1Lab.Equiv.html#21698" class="Bound">f</a> <a id="22219" href="1Lab.Equiv.html#22210" class="Bound">x</a><a id="22220" class="Symbol">))</a>
    <a id="22227" href="1Lab.Equiv.html#22180" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
is-left-inverse (inv f e g e&#39;) (λ x → g (f x))" class="Function">left</a> <a id="22232" href="1Lab.Equiv.html#22232" class="Bound">z</a> <a id="22234" class="Symbol">=</a>
      <a id="22242" href="1Lab.Equiv.html#21791" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
is-iso f" class="Function">f⁻¹</a> <a id="22246" class="Symbol">.</a><a id="22247" href="1Lab.Equiv.html#6132" data-type="is-iso f → B₁ → A" class="Field">is-iso.inv</a> <a id="22258" class="Symbol">(</a><a id="22259" href="1Lab.Equiv.html#21746" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
is-iso g" class="Function">g⁻¹</a> <a id="22263" class="Symbol">.</a><a id="22264" href="1Lab.Equiv.html#6132" data-type="is-iso f → B₁ → A" class="Field">is-iso.inv</a> <a id="22275" class="Symbol">(</a><a id="22276" href="1Lab.Equiv.html#21706" class="Bound">g</a> <a id="22278" class="Symbol">(</a><a id="22279" href="1Lab.Equiv.html#21698" class="Bound">f</a> <a id="22281" href="1Lab.Equiv.html#22232" class="Bound">z</a><a id="22282" class="Symbol">)))</a> <a id="22286" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="22289" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="22292" class="Symbol">(</a><a id="22293" href="1Lab.Equiv.html#21791" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
is-iso f" class="Function">f⁻¹</a> <a id="22297" class="Symbol">.</a><a id="22298" href="1Lab.Equiv.html#6132" data-type="is-iso f → B₁ → A" class="Field">is-iso.inv</a><a id="22308" class="Symbol">)</a> <a id="22310" class="Symbol">(</a><a id="22311" href="1Lab.Equiv.html#21746" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
is-iso g" class="Function">g⁻¹</a> <a id="22315" class="Symbol">.</a><a id="22316" href="1Lab.Equiv.html#6182" data-type="(r : is-iso f) → is-left-inverse (r .inv) f" class="Field">is-iso.linv</a> <a id="22328" class="Symbol">_)</a> <a id="22331" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
      <a id="22339" href="1Lab.Equiv.html#21791" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
is-iso f" class="Function">f⁻¹</a> <a id="22343" class="Symbol">.</a><a id="22344" href="1Lab.Equiv.html#6132" data-type="is-iso f → B₁ → A" class="Field">is-iso.inv</a> <a id="22355" class="Symbol">(</a><a id="22356" href="1Lab.Equiv.html#21698" class="Bound">f</a> <a id="22358" href="1Lab.Equiv.html#22232" class="Bound">z</a><a id="22359" class="Symbol">)</a>                       <a id="22383" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="22386" href="1Lab.Equiv.html#21791" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
is-iso f" class="Function">f⁻¹</a> <a id="22390" class="Symbol">.</a><a id="22391" href="1Lab.Equiv.html#6182" data-type="(r : is-iso f) → is-left-inverse (r .inv) f" class="Field">is-iso.linv</a> <a id="22403" class="Symbol">_</a> <a id="22405" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
      <a id="22413" href="1Lab.Equiv.html#22232" class="Bound">z</a>                                           <a id="22457" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
  <a id="22461" href="1Lab.Equiv.html#22461" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
is-equiv (λ x → g (f x))" class="Function">eqv</a> <a id="22465" class="Symbol">:</a> <a id="22467" href="1Lab.Equiv.html#2286" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-equiv</a> <a id="22476" class="Symbol">(λ</a> <a id="22479" href="1Lab.Equiv.html#22479" class="Bound">x</a> <a id="22481" class="Symbol">→</a> <a id="22483" href="1Lab.Equiv.html#21706" class="Bound">g</a> <a id="22485" class="Symbol">(</a><a id="22486" href="1Lab.Equiv.html#21698" class="Bound">f</a> <a id="22488" href="1Lab.Equiv.html#22479" class="Bound">x</a><a id="22489" class="Symbol">))</a>
  <a id="22494" href="1Lab.Equiv.html#22461" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
is-equiv (λ x → g (f x))" class="Function">eqv</a> <a id="22498" class="Symbol">=</a> <a id="22500" href="1Lab.Equiv.html#19815" data-type="(i : is-iso f) → is-equiv f" class="Function">is-iso→is-equiv</a> <a id="22516" class="Symbol">(</a><a id="22517" href="1Lab.Equiv.html#6116" data-type="(inv₁ : B₁ → A) (rinv₁ : is-right-inverse inv₁ f)
(linv₁ : is-left-inverse inv₁ f) →
is-iso f" class="InductiveConstructor">iso</a> <a id="22521" class="Symbol">(λ</a> <a id="22524" href="1Lab.Equiv.html#22524" class="Bound">x</a> <a id="22526" class="Symbol">→</a> <a id="22528" href="1Lab.Equiv.html#21791" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
is-iso f" class="Function">f⁻¹</a> <a id="22532" class="Symbol">.</a><a id="22533" href="1Lab.Equiv.html#6132" data-type="is-iso f → B₁ → A" class="Field">is-iso.inv</a> <a id="22544" class="Symbol">(</a><a id="22545" href="1Lab.Equiv.html#21746" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
is-iso g" class="Function">g⁻¹</a> <a id="22549" class="Symbol">.</a><a id="22550" href="1Lab.Equiv.html#6132" data-type="is-iso f → B₁ → A" class="Field">is-iso.inv</a> <a id="22561" href="1Lab.Equiv.html#22524" class="Bound">x</a><a id="22562" class="Symbol">))</a> <a id="22565" href="1Lab.Equiv.html#21909" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
is-right-inverse (inv f e g e&#39;) (λ x → g (f x))" class="Function">right</a> <a id="22571" href="1Lab.Equiv.html#22180" data-type="(f : A → B₁) (e : is-equiv f) (g : B₁ → C) (e&#39; : is-equiv g) →
is-left-inverse (inv f e g e&#39;) (λ x → g (f x))" class="Function">left</a><a id="22575" class="Symbol">)</a>

<a id="∙-is-equiv"></a><a id="22578" href="1Lab.Equiv.html#22578" data-type="is-equiv f → is-equiv g → is-equiv (λ x → g (f x))" class="Function">∙-is-equiv</a> <a id="22589" class="Symbol">:</a> <a id="22591" class="Symbol">∀</a> <a id="22593" class="Symbol">{</a><a id="22594" href="1Lab.Equiv.html#22594" class="Bound">ℓ</a> <a id="22596" href="1Lab.Equiv.html#22596" class="Bound">ℓ₁</a> <a id="22599" href="1Lab.Equiv.html#22599" class="Bound">ℓ₂</a><a id="22601" class="Symbol">}</a> <a id="22603" class="Symbol">{</a><a id="22604" href="1Lab.Equiv.html#22604" class="Bound">A</a> <a id="22606" class="Symbol">:</a> <a id="22608" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="22613" href="1Lab.Equiv.html#22594" class="Bound">ℓ</a><a id="22614" class="Symbol">}</a> <a id="22616" class="Symbol">{</a><a id="22617" href="1Lab.Equiv.html#22617" class="Bound">B</a> <a id="22619" class="Symbol">:</a> <a id="22621" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="22626" href="1Lab.Equiv.html#22596" class="Bound">ℓ₁</a><a id="22628" class="Symbol">}</a> <a id="22630" class="Symbol">{</a><a id="22631" href="1Lab.Equiv.html#22631" class="Bound">C</a> <a id="22633" class="Symbol">:</a> <a id="22635" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="22640" href="1Lab.Equiv.html#22599" class="Bound">ℓ₂</a><a id="22642" class="Symbol">}</a>
           <a id="22655" class="Symbol">→</a> <a id="22657" class="Symbol">{</a><a id="22658" href="1Lab.Equiv.html#22658" class="Bound">f</a> <a id="22660" class="Symbol">:</a> <a id="22662" href="1Lab.Equiv.html#22604" class="Bound">A</a> <a id="22664" class="Symbol">→</a> <a id="22666" href="1Lab.Equiv.html#22617" class="Bound">B</a><a id="22667" class="Symbol">}</a> <a id="22669" class="Symbol">{</a><a id="22670" href="1Lab.Equiv.html#22670" class="Bound">g</a> <a id="22672" class="Symbol">:</a> <a id="22674" href="1Lab.Equiv.html#22617" class="Bound">B</a> <a id="22676" class="Symbol">→</a> <a id="22678" href="1Lab.Equiv.html#22631" class="Bound">C</a><a id="22679" class="Symbol">}</a>
           <a id="22692" class="Symbol">→</a> <a id="22694" href="1Lab.Equiv.html#2286" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-equiv</a> <a id="22703" href="1Lab.Equiv.html#22658" class="Bound">f</a>
           <a id="22716" class="Symbol">→</a> <a id="22718" href="1Lab.Equiv.html#2286" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-equiv</a> <a id="22727" href="1Lab.Equiv.html#22670" class="Bound">g</a>
           <a id="22740" class="Symbol">→</a> <a id="22742" href="1Lab.Equiv.html#2286" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-equiv</a> <a id="22751" class="Symbol">(λ</a> <a id="22754" href="1Lab.Equiv.html#22754" class="Bound">x</a> <a id="22756" class="Symbol">→</a> <a id="22758" href="1Lab.Equiv.html#22670" class="Bound">g</a> <a id="22760" class="Symbol">(</a><a id="22761" href="1Lab.Equiv.html#22658" class="Bound">f</a> <a id="22763" href="1Lab.Equiv.html#22754" class="Bound">x</a><a id="22764" class="Symbol">))</a>
<a id="22767" href="1Lab.Equiv.html#22578" data-type="is-equiv f → is-equiv g → is-equiv (λ x → g (f x))" class="Function">∙-is-equiv</a> <a id="22778" class="Symbol">{</a><a id="22779" class="Argument">f</a> <a id="22781" class="Symbol">=</a> <a id="22783" href="1Lab.Equiv.html#22783" class="Bound">f</a><a id="22784" class="Symbol">}</a> <a id="22786" class="Symbol">{</a><a id="22787" class="Argument">g</a> <a id="22789" class="Symbol">=</a> <a id="22791" href="1Lab.Equiv.html#22791" class="Bound">g</a><a id="22792" class="Symbol">}</a> <a id="22794" href="1Lab.Equiv.html#22794" class="Bound">e</a> <a id="22796" href="1Lab.Equiv.html#22796" class="Bound">e&#39;</a> <a id="22799" class="Symbol">=</a> <a id="22801" class="Symbol">((</a><a id="22803" href="1Lab.Equiv.html#22783" class="Bound">f</a> <a id="22805" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="22807" href="1Lab.Equiv.html#22794" class="Bound">e</a><a id="22808" class="Symbol">)</a> <a id="22810" href="1Lab.Equiv.html#21265" data-type="A ≃ B₁ → B₁ ≃ C → A ≃ C" class="Function Operator">∙e</a> <a id="22813" class="Symbol">(</a><a id="22814" href="1Lab.Equiv.html#22791" class="Bound">g</a> <a id="22816" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="22818" href="1Lab.Equiv.html#22796" class="Bound">e&#39;</a><a id="22820" class="Symbol">))</a> <a id="22823" class="Symbol">.</a><a id="22824" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a>
</pre>-->
<p>The proofs that equivalences are closed under composition assemble
nicely into transitivity operators resembling equational reasoning:</p>
<pre class="Agda"><a id="_≃⟨_⟩_"></a><a id="22981" href="1Lab.Equiv.html#22981" data-type="(A : Type ℓ) → A ≃ B₁ → B₁ ≃ C → A ≃ C" class="Function Operator">_≃⟨_⟩_</a> <a id="22988" class="Symbol">:</a> <a id="22990" class="Symbol">∀</a> <a id="22992" class="Symbol">{</a><a id="22993" href="1Lab.Equiv.html#22993" class="Bound">ℓ</a> <a id="22995" href="1Lab.Equiv.html#22995" class="Bound">ℓ₁</a> <a id="22998" href="1Lab.Equiv.html#22998" class="Bound">ℓ₂</a><a id="23000" class="Symbol">}</a> <a id="23002" class="Symbol">(</a><a id="23003" href="1Lab.Equiv.html#23003" class="Bound">A</a> <a id="23005" class="Symbol">:</a> <a id="23007" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="23012" href="1Lab.Equiv.html#22993" class="Bound">ℓ</a><a id="23013" class="Symbol">)</a> <a id="23015" class="Symbol">{</a><a id="23016" href="1Lab.Equiv.html#23016" class="Bound">B</a> <a id="23018" class="Symbol">:</a> <a id="23020" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="23025" href="1Lab.Equiv.html#22995" class="Bound">ℓ₁</a><a id="23027" class="Symbol">}</a> <a id="23029" class="Symbol">{</a><a id="23030" href="1Lab.Equiv.html#23030" class="Bound">C</a> <a id="23032" class="Symbol">:</a> <a id="23034" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="23039" href="1Lab.Equiv.html#22998" class="Bound">ℓ₂</a><a id="23041" class="Symbol">}</a>
       <a id="23050" class="Symbol">→</a> <a id="23052" href="1Lab.Equiv.html#23003" class="Bound">A</a> <a id="23054" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="23056" href="1Lab.Equiv.html#23016" class="Bound">B</a> <a id="23058" class="Symbol">→</a> <a id="23060" href="1Lab.Equiv.html#23016" class="Bound">B</a> <a id="23062" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="23064" href="1Lab.Equiv.html#23030" class="Bound">C</a> <a id="23066" class="Symbol">→</a> <a id="23068" href="1Lab.Equiv.html#23003" class="Bound">A</a> <a id="23070" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="23072" href="1Lab.Equiv.html#23030" class="Bound">C</a>
<a id="23074" href="1Lab.Equiv.html#23074" class="Bound">A</a> <span class="reasoning-step"><span class="as-written Function Operator"><a id="23076" href="1Lab.Equiv.html#22981" data-type="(A : Type ℓ) → A ≃ B₁ → B₁ ≃ C → A ≃ C" class="Function Operator">≃⟨</a> <a id="23079" href="1Lab.Equiv.html#23079" class="Bound">f</a> <a id="23081" href="1Lab.Equiv.html#22981" data-type="(A : Type ℓ) → A ≃ B₁ → B₁ ≃ C → A ≃ C" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span> <a id="23083" href="1Lab.Equiv.html#23083" class="Bound">g</a> <a id="23085" class="Symbol">=</a> <a id="23087" href="1Lab.Equiv.html#23079" class="Bound">f</a> <a id="23089" href="1Lab.Equiv.html#21265" data-type="A ≃ B₁ → B₁ ≃ C → A ≃ C" class="Function Operator">∙e</a> <a id="23092" href="1Lab.Equiv.html#23083" class="Bound">g</a>

<a id="_≃⟨⟩_"></a><a id="23095" href="1Lab.Equiv.html#23095" data-type="(A : Type ℓ) → A ≃ B₁ → A ≃ B₁" class="Function Operator">_≃⟨⟩_</a> <a id="23101" class="Symbol">:</a> <a id="23103" class="Symbol">∀</a> <a id="23105" class="Symbol">{</a><a id="23106" href="1Lab.Equiv.html#23106" class="Bound">ℓ</a> <a id="23108" href="1Lab.Equiv.html#23108" class="Bound">ℓ₁</a><a id="23110" class="Symbol">}</a> <a id="23112" class="Symbol">(</a><a id="23113" href="1Lab.Equiv.html#23113" class="Bound">A</a> <a id="23115" class="Symbol">:</a> <a id="23117" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="23122" href="1Lab.Equiv.html#23106" class="Bound">ℓ</a><a id="23123" class="Symbol">)</a> <a id="23125" class="Symbol">{</a><a id="23126" href="1Lab.Equiv.html#23126" class="Bound">B</a> <a id="23128" class="Symbol">:</a> <a id="23130" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="23135" href="1Lab.Equiv.html#23108" class="Bound">ℓ₁</a><a id="23137" class="Symbol">}</a> <a id="23139" class="Symbol">→</a> <a id="23141" href="1Lab.Equiv.html#23113" class="Bound">A</a> <a id="23143" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="23145" href="1Lab.Equiv.html#23126" class="Bound">B</a> <a id="23147" class="Symbol">→</a> <a id="23149" href="1Lab.Equiv.html#23113" class="Bound">A</a> <a id="23151" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="23153" href="1Lab.Equiv.html#23126" class="Bound">B</a>
<a id="23155" href="1Lab.Equiv.html#23155" class="Bound">x</a> <a id="23157" href="1Lab.Equiv.html#23095" data-type="(A : Type ℓ) → A ≃ B₁ → A ≃ B₁" class="Function Operator">≃⟨⟩</a> <a id="23161" href="1Lab.Equiv.html#23161" class="Bound">x≡y</a> <a id="23165" class="Symbol">=</a> <a id="23167" href="1Lab.Equiv.html#23161" class="Bound">x≡y</a>

<a id="_≃∎"></a><a id="23172" href="1Lab.Equiv.html#23172" data-type="(A : Type ℓ) → A ≃ A" class="Function Operator">_≃∎</a> <a id="23176" class="Symbol">:</a> <a id="23178" class="Symbol">∀</a> <a id="23180" class="Symbol">{</a><a id="23181" href="1Lab.Equiv.html#23181" class="Bound">ℓ</a><a id="23182" class="Symbol">}</a> <a id="23184" class="Symbol">(</a><a id="23185" href="1Lab.Equiv.html#23185" class="Bound">A</a> <a id="23187" class="Symbol">:</a> <a id="23189" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="23194" href="1Lab.Equiv.html#23181" class="Bound">ℓ</a><a id="23195" class="Symbol">)</a> <a id="23197" class="Symbol">→</a> <a id="23199" href="1Lab.Equiv.html#23185" class="Bound">A</a> <a id="23201" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="23203" href="1Lab.Equiv.html#23185" class="Bound">A</a>
<a id="23205" href="1Lab.Equiv.html#23205" class="Bound">x</a> <a id="23207" href="1Lab.Equiv.html#23172" data-type="(A : Type ℓ) → A ≃ A" class="Function Operator">≃∎</a> <a id="23210" class="Symbol">=</a> <a id="23212" class="Symbol">_</a> <a id="23214" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="23216" href="1Lab.Equiv.html#2524" data-type="is-equiv (λ x → x)" class="Function">id-equiv</a>

<a id="23226" class="Keyword">infixr</a> <a id="23233" class="Number">30</a> <a id="23236" href="1Lab.Equiv.html#21265" data-type="A ≃ B₁ → B₁ ≃ C → A ≃ C" class="Function Operator">_∙e_</a>
<a id="23241" class="Keyword">infixr</a> <a id="23248" class="Number">2</a> <a id="23250" href="1Lab.Equiv.html#23095" data-type="(A : Type ℓ) → A ≃ B₁ → A ≃ B₁" class="Function Operator">_≃⟨⟩_</a> <a id="23256" href="1Lab.Equiv.html#22981" data-type="(A : Type ℓ) → A ≃ B₁ → B₁ ≃ C → A ≃ C" class="Function Operator">_≃⟨_⟩_</a>
<a id="23263" class="Keyword">infix</a>  <a id="23270" class="Number">3</a> <a id="23272" href="1Lab.Equiv.html#23172" data-type="(A : Type ℓ) → A ≃ A" class="Function Operator">_≃∎</a>
</pre>
<h1 id="propositional-extensionality"><a href="#propositional-extensionality" class="header-link">Propositional
Extensionality<span class="header-link-emoji">🔗</span></a></h1>
<p>The following observation is not very complex, but it is incredibly
useful: Equivalence of propositions is the same as biimplication.</p>
<pre class="Agda"><a id="prop-ext"></a><a id="23456" href="1Lab.Equiv.html#23456" data-type="is-prop P → is-prop Q → (P → Q) → (Q → P) → P ≃ Q" class="Function">prop-ext</a> <a id="23465" class="Symbol">:</a> <a id="23467" class="Symbol">∀</a> <a id="23469" class="Symbol">{</a><a id="23470" href="1Lab.Equiv.html#23470" class="Bound">ℓ</a> <a id="23472" href="1Lab.Equiv.html#23472" class="Bound">ℓ&#39;</a><a id="23474" class="Symbol">}</a> <a id="23476" class="Symbol">{</a><a id="23477" href="1Lab.Equiv.html#23477" class="Bound">P</a> <a id="23479" class="Symbol">:</a> <a id="23481" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="23486" href="1Lab.Equiv.html#23470" class="Bound">ℓ</a><a id="23487" class="Symbol">}</a> <a id="23489" class="Symbol">{</a><a id="23490" href="1Lab.Equiv.html#23490" class="Bound">Q</a> <a id="23492" class="Symbol">:</a> <a id="23494" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="23499" href="1Lab.Equiv.html#23472" class="Bound">ℓ&#39;</a><a id="23501" class="Symbol">}</a>
         <a id="23512" class="Symbol">→</a> <a id="23514" href="1Lab.HLevel.html#2597" data-type="Type ℓ → Type ℓ" class="Function">is-prop</a> <a id="23522" href="1Lab.Equiv.html#23477" class="Bound">P</a> <a id="23524" class="Symbol">→</a> <a id="23526" href="1Lab.HLevel.html#2597" data-type="Type ℓ → Type ℓ" class="Function">is-prop</a> <a id="23534" href="1Lab.Equiv.html#23490" class="Bound">Q</a>
         <a id="23545" class="Symbol">→</a> <a id="23547" class="Symbol">(</a><a id="23548" href="1Lab.Equiv.html#23477" class="Bound">P</a> <a id="23550" class="Symbol">→</a> <a id="23552" href="1Lab.Equiv.html#23490" class="Bound">Q</a><a id="23553" class="Symbol">)</a> <a id="23555" class="Symbol">→</a> <a id="23557" class="Symbol">(</a><a id="23558" href="1Lab.Equiv.html#23490" class="Bound">Q</a> <a id="23560" class="Symbol">→</a> <a id="23562" href="1Lab.Equiv.html#23477" class="Bound">P</a><a id="23563" class="Symbol">)</a>
         <a id="23574" class="Symbol">→</a> <a id="23576" href="1Lab.Equiv.html#23477" class="Bound">P</a> <a id="23578" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="23580" href="1Lab.Equiv.html#23490" class="Bound">Q</a>
<a id="23582" href="1Lab.Equiv.html#23456" data-type="is-prop P → is-prop Q → (P → Q) → (Q → P) → P ≃ Q" class="Function">prop-ext</a> <a id="23591" href="1Lab.Equiv.html#23591" class="Bound">pprop</a> <a id="23597" href="1Lab.Equiv.html#23597" class="Bound">qprop</a> <a id="23603" href="1Lab.Equiv.html#23603" class="Bound">p→q</a> <a id="23607" href="1Lab.Equiv.html#23607" class="Bound">q→p</a> <a id="23611" class="Symbol">.</a><a id="23612" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="23616" class="Symbol">=</a> <a id="23618" href="1Lab.Equiv.html#23603" class="Bound">p→q</a>
<a id="23622" href="1Lab.Equiv.html#23456" data-type="is-prop P → is-prop Q → (P → Q) → (Q → P) → P ≃ Q" class="Function">prop-ext</a> <a id="23631" href="1Lab.Equiv.html#23631" class="Bound">pprop</a> <a id="23637" href="1Lab.Equiv.html#23637" class="Bound">qprop</a> <a id="23643" href="1Lab.Equiv.html#23643" class="Bound">p→q</a> <a id="23647" href="1Lab.Equiv.html#23647" class="Bound">q→p</a> <a id="23651" class="Symbol">.</a><a id="23652" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="23656" class="Symbol">.</a><a id="23657" href="1Lab.Equiv.html#2376" data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" class="Field">is-eqv</a> <a id="23664" href="1Lab.Equiv.html#23664" class="Bound">y</a> <a id="23666" class="Symbol">.</a><a id="23667" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a> <a id="23674" class="Symbol">=</a> <a id="23676" href="1Lab.Equiv.html#23647" class="Bound">q→p</a> <a id="23680" href="1Lab.Equiv.html#23664" class="Bound">y</a> <a id="23682" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="23684" href="1Lab.Equiv.html#23637" class="Bound">qprop</a> <a id="23690" class="Symbol">_</a> <a id="23692" class="Symbol">_</a>
<a id="23694" href="1Lab.Equiv.html#23456" data-type="is-prop P → is-prop Q → (P → Q) → (Q → P) → P ≃ Q" class="Function">prop-ext</a> <a id="23703" href="1Lab.Equiv.html#23703" class="Bound">pprop</a> <a id="23709" href="1Lab.Equiv.html#23709" class="Bound">qprop</a> <a id="23715" href="1Lab.Equiv.html#23715" class="Bound">p→q</a> <a id="23719" href="1Lab.Equiv.html#23719" class="Bound">q→p</a> <a id="23723" class="Symbol">.</a><a id="23724" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="23728" class="Symbol">.</a><a id="23729" href="1Lab.Equiv.html#2376" data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" class="Field">is-eqv</a> <a id="23736" href="1Lab.Equiv.html#23736" class="Bound">y</a> <a id="23738" class="Symbol">.</a><a id="23739" href="1Lab.HLevel.html#1416" data-type="(r : is-contr A) (x : A) → r .centre ≡ x" class="Field">paths</a> <a id="23745" class="Symbol">(</a><a id="23746" href="1Lab.Equiv.html#23746" class="Bound">p&#39;</a> <a id="23749" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="23751" href="1Lab.Equiv.html#23751" class="Bound">path</a><a id="23755" class="Symbol">)</a> <a id="23757" class="Symbol">=</a>
  <a id="23761" href="1Lab.Path.html#57671" data-type="(p : x .fst ≡ y .fst) → subst B₁ p (x .snd) ≡ y .snd → x ≡ y" class="Function">Σ-path</a> <a id="23768" class="Symbol">(</a><a id="23769" href="1Lab.Equiv.html#23703" class="Bound">pprop</a> <a id="23775" class="Symbol">_</a> <a id="23777" class="Symbol">_)</a> <a id="23780" class="Symbol">(</a><a id="23781" href="1Lab.HLevel.html#5554" data-type="is-prop A → is-set A" class="Function">is-prop→is-set</a> <a id="23796" href="1Lab.Equiv.html#23709" class="Bound">qprop</a> <a id="23802" class="Symbol">_</a> <a id="23804" class="Symbol">_</a> <a id="23806" class="Symbol">_</a> <a id="23808" class="Symbol">_)</a>
</pre>
  </article>
</div>
</main>
</body>
</html>
