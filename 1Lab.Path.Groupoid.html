<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="keywords" content="Agda,categories,topos" />

  <title>1Lab.Path.Groupoid - 1Lab</title>

  <link rel="stylesheet" href="/css/default.css" />
  <link rel="stylesheet" href="/css/katex.min.css" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="1Lab.Path.Groupoid - 1Lab" />
  <meta name="twitter:image" content="https://1lab.dev/static/cube-128x.png" />

  <meta name="og:title" content="1Lab.Path.Groupoid - 1Lab" />
  <meta name="og:image" content="https://1lab.dev/static/cube-128x.png" />
  <meta name="og:site-name" content="1Lab" />
  <meta name="og:type" content="website" />

    <meta name="og:description" content="&lt;p&gt;We make explicit the higher
groupoid structure of type formers, which is derived from their Kan
operations.&lt;/p&gt;" />
  <meta name="twitter:description" content="&lt;p&gt;We make explicit the
higher groupoid structure of type formers, which is derived from their
Kan operations.&lt;/p&gt;" />
  <meta name="description" content="&lt;p&gt;We make explicit the higher
groupoid structure of type formers, which is derived from their Kan
operations.&lt;/p&gt;" />
  
  <script defer src="/main.js"></script>

  <noscript>
    <style>
      body span.reasoning-step .as-written {
        display: inline;
      }

      body span.reasoning-step .alternate {
        display: none;
      }
    </style>
  </noscript>

  <!-- Google font embeds -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;0,800;1,400;1,500;1,600;1,700;1,800&amp;family=Inria+Sans:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&amp;display=swap" rel="stylesheet">
</head>

<body class="text-page">
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <!-- Table of contents (only if the page has a table of contents) -->
    <aside id="toc">
    <div id="toc-container" style="min-width: 10em; font-size: 15pt;">
      <!-- Title for the page -->
      <h3 class="Agda" style="margin-top: 0; margin-bottom: 0; white-space: pre;">
                <a class="Module">1Lab.Path.Groupoid</a>
              </h3>

      <!-- Cube logo -->
      <a id="logo" href="/">
        <img alt="1Lab" src="/static/cube-72x.png" style="display: block; margin-bottom: 1em; margin: auto;" width="32px" height="32px" />
      </a>

      <!-- Actual table of contents (separated from the rest by
      horizontal rules) -->
      <hr />
      <ul>
      <li><a href="#types-are-groupoids"><a href="#types-are-groupoids" class="header-link">Types
      are Groupoids<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#book-style"><a href="#book-style" class="header-link">Book-style<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#cubically"><a href="#cubically" class="header-link">Cubically<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#convenient-helpers"><a href="#convenient-helpers" class="header-link">Convenient
      helpers<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      </ul></li>
      <li><a href="#groupoid-structure-of-types-cont."><a href="#groupoid-structure-of-types-cont." class="header-link">Groupoid
      structure of types
      (cont.)<span class="header-link-emoji">🔗</span></a></a></li>
      </ul>
      <hr />

      <!-- Sidebar controls -->
      <div style="display: flex; gap: 0.25em; flex-flow: row wrap;">
        <!-- Sidebar equations control -->
        <span class="equations" style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-eqns" type="checkbox" class="equations" id="sidebar-eqns">
          <label for="sidebar-eqns">Equations</label>
        </span>

        <!-- Sidebar fonts control -->
        <span style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-font" type="checkbox" id="toggle-fonts">
          <label for="toggle-fonts">Serif Font</label>
        </span>

        <!-- Sidebar footnotes control -->
        <span class="inline-footnotes" style="display: none; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-fns" type="checkbox" class="inline-footnotes" id="sidebar-fns">
          <label for="sidebar-fns">Inline Footnotes</label>
        </span>
      </div>

      <hr />

      <!-- Navbar navigation (lol) -->
      <div id="return" style="white-space: nowrap;">
        <div class="search-form search-form-proxy" role="form">
          <input id="search-box-proxy" type_="text" placeholder="Search..." autocomplete="off" tabindex="0"></input>
        </div>

              <a href="/">back to index</a> <br />
              <a href="all-pages.html">view all pages</a> <br />
        <a href="https://github.com/plt-amy/cubical-1lab/blob/dad48825521bbde86ec397eb9a37485534ed3d5a/src/1Lab/Path/Groupoid.lagda.md">link to source</a> <br />
                <hr /> <div class="author-list">Written by Amélia Liao</div> <br />
              </div>
    </div>
  </aside>
  
  <article>
    <!-- Article navigation (narrow screens only) -->
    <div class="narrow-only" id="article-nav">
      <!-- Index return anchor (only if the page is not the index) -->
            <div id="return">
        <a href="/">back to index</a>
      </div>
      
      <!-- Navbar equations control -->
      <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-eqns" type="checkbox" class="equations" id="navbar-eqns">
        <label for="navbar-eqns">Equations</label>
      </span>

      <!-- Navbar footnotes control -->
      <span class="inline-footnotes" style="display: none; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-fns" type="checkbox" class="inline-footnotes" id="navbar-fns">
        <label for="navbar-fns">Inline Footnotes</label>
      </span>
    </div>

<pre class="Agda"><a id="144" class="Keyword">open</a> <a id="149" class="Keyword">import</a> <a id="156" href="1Lab.Equiv.html" class="Module">1Lab.Equiv</a>
<a id="167" class="Keyword">open</a> <a id="172" class="Keyword">import</a> <a id="179" href="1Lab.Path.html" class="Module">1Lab.Path</a> <a id="189" class="Keyword">hiding</a> <a id="196" class="Symbol">(</a><a id="197" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">_∙_</a><a id="200" class="Symbol">)</a>
<a id="202" class="Keyword">open</a> <a id="207" class="Keyword">import</a> <a id="214" href="1Lab.Type.html" class="Module">1Lab.Type</a>

<a id="225" class="Keyword">module</a> <a id="232" href="1Lab.Path.Groupoid.html" class="Module">1Lab.Path.Groupoid</a> <a id="251" class="Keyword">where</a>
</pre>
<h1 id="types-are-groupoids"><a href="#types-are-groupoids" class="header-link">Types
are Groupoids<span class="header-link-emoji">🔗</span></a></h1>
<p>The <code class="sourceCode agda">Path</code> types equip every
<span class="Agda"><a href="1Lab.Type.html#391" class="Primitive">Type</a></span>
with the structure of an
<em><span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">∞</span></span></span></span>-groupoid</span></em>.
The higher structure of a type begins with its inhabitants (the
0-cells); Then, there are the paths between inhabitants - these are
inhabitants of the type <code>Path A x y</code>, which are the 1-cells
in <code>A</code>. Then, we can consider the inhabitants of
<code>Path (Path A x y) p q</code>, which are <em>homotopies</em>
between paths.</p>
<p>This construction iterates forever - and, at every stage, we have
that the
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>-cells</span>
in <code>A</code> are the 0-cells of some other type (e.g.: The 1-cells
of <code>A</code> are the 0-cells of <code>Path A ...</code>).
Furthermore, this structure is <em>weak</em>: The laws,
e.g. associativity of composition, only hold up to a homotopy. These
laws satisfy their own laws — again using associativity as an example,
the associator satisfies the pentagon identity.</p>
<p>These laws can be proved in two ways: Using path induction, or
directly with a cubical argument. Here, we do both.</p>
<h2 id="book-style"><a href="#book-style" class="header-link">Book-style<span class="header-link-emoji">🔗</span></a></h2>
<p>This is the approach taken in the HoTT book. We fix a type, and some
variables of that type, and some paths between variables of that type,
so that each definition doesn’t start with 12 parameters.</p>
<pre class="Agda"><a id="1451" class="Keyword">module</a> <a id="WithJ"></a><a id="1458" href="1Lab.Path.Groupoid.html#1458" class="Module">WithJ</a> <a id="1464" class="Keyword">where</a>
  <a id="1472" class="Keyword">private</a> <a id="1480" class="Keyword">variable</a>
    <a id="1493" href="1Lab.Path.Groupoid.html#1493" class="Generalizable">ℓ</a> <a id="1495" class="Symbol">:</a> <a id="1497" href="Agda.Primitive.html#582" data-type="Type" class="Postulate">Level</a>
    <a id="1507" href="1Lab.Path.Groupoid.html#1507" class="Generalizable">A</a> <a id="1509" class="Symbol">:</a> <a id="1511" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="1516" href="1Lab.Path.Groupoid.html#1493" class="Generalizable">ℓ</a>
    <a id="1522" href="1Lab.Path.Groupoid.html#1522" class="Generalizable">w</a> <a id="1524" href="1Lab.Path.Groupoid.html#1524" class="Generalizable">x</a> <a id="1526" href="1Lab.Path.Groupoid.html#1526" class="Generalizable">y</a> <a id="1528" href="1Lab.Path.Groupoid.html#1528" class="Generalizable">z</a> <a id="1530" class="Symbol">:</a> <a id="1532" href="1Lab.Path.Groupoid.html#1507" class="Generalizable">A</a>
</pre>
<p>First, we (re)define the operations using J. These will be closer to
the structure given in the book.</p>
<pre class="Agda">  <a id="WithJ._∙_"></a><a id="1652" href="1Lab.Path.Groupoid.html#1652" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">_∙_</a> <a id="1656" class="Symbol">:</a> <a id="1658" href="1Lab.Path.Groupoid.html#1524" class="Generalizable">x</a> <a id="1660" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="1662" href="1Lab.Path.Groupoid.html#1526" class="Generalizable">y</a> <a id="1664" class="Symbol">→</a> <a id="1666" href="1Lab.Path.Groupoid.html#1526" class="Generalizable">y</a> <a id="1668" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="1670" href="1Lab.Path.Groupoid.html#1528" class="Generalizable">z</a> <a id="1672" class="Symbol">→</a> <a id="1674" href="1Lab.Path.Groupoid.html#1524" class="Generalizable">x</a> <a id="1676" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="1678" href="1Lab.Path.Groupoid.html#1528" class="Generalizable">z</a>
  <a id="1682" href="1Lab.Path.Groupoid.html#1652" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">_∙_</a> <a id="1686" class="Symbol">{</a><a id="1687" class="Argument">x</a> <a id="1689" class="Symbol">=</a> <a id="1691" href="1Lab.Path.Groupoid.html#1691" class="Bound">x</a><a id="1692" class="Symbol">}</a> <a id="1694" class="Symbol">{</a><a id="1695" href="1Lab.Path.Groupoid.html#1695" class="Bound">y</a><a id="1696" class="Symbol">}</a> <a id="1698" class="Symbol">{</a><a id="1699" href="1Lab.Path.Groupoid.html#1699" class="Bound">z</a><a id="1700" class="Symbol">}</a> <a id="1702" class="Symbol">=</a> <a id="1704" href="1Lab.Path.html#19544" data-type="(P : (y : A) → x ≡ y → Type ℓ₂) → P x refl → (p : x ≡ y) → P y p" class="Function">J</a> <a id="1706" class="Symbol">(λ</a> <a id="1709" href="1Lab.Path.Groupoid.html#1709" class="Bound">y</a> <a id="1711" href="1Lab.Path.Groupoid.html#1711" class="Bound">_</a> <a id="1713" class="Symbol">→</a> <a id="1715" href="1Lab.Path.Groupoid.html#1709" class="Bound">y</a> <a id="1717" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="1719" href="1Lab.Path.Groupoid.html#1699" class="Bound">z</a> <a id="1721" class="Symbol">→</a> <a id="1723" href="1Lab.Path.Groupoid.html#1691" class="Bound">x</a> <a id="1725" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="1727" href="1Lab.Path.Groupoid.html#1699" class="Bound">z</a><a id="1728" class="Symbol">)</a> <a id="1730" class="Symbol">(λ</a> <a id="1733" href="1Lab.Path.Groupoid.html#1733" class="Bound">x</a> <a id="1735" class="Symbol">→</a> <a id="1737" href="1Lab.Path.Groupoid.html#1733" class="Bound">x</a><a id="1738" class="Symbol">)</a>
</pre>
<p>First we define path composition. Then, we can prove that the
identity path -
<span class="Agda"><a href="1Lab.Path.html#3593" class="Function">refl</a></span>
- acts as an identity for path composition.</p>
<pre class="Agda">  <a id="WithJ.∙-id-r"></a><a id="1892" href="1Lab.Path.Groupoid.html#1892" data-type="(p : x ≡ y) → (p ∙ refl) ≡ p" class="Function">∙-id-r</a> <a id="1899" class="Symbol">:</a> <a id="1901" class="Symbol">(</a><a id="1902" href="1Lab.Path.Groupoid.html#1902" class="Bound">p</a> <a id="1904" class="Symbol">:</a> <a id="1906" href="1Lab.Path.Groupoid.html#1524" class="Generalizable">x</a> <a id="1908" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="1910" href="1Lab.Path.Groupoid.html#1526" class="Generalizable">y</a><a id="1911" class="Symbol">)</a> <a id="1913" class="Symbol">→</a> <a id="1915" href="1Lab.Path.Groupoid.html#1902" class="Bound">p</a> <a id="1917" href="1Lab.Path.Groupoid.html#1652" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="1919" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="1924" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="1926" href="1Lab.Path.Groupoid.html#1902" class="Bound">p</a>
  <a id="1930" href="1Lab.Path.Groupoid.html#1892" data-type="(p : x ≡ y) → (p ∙ refl) ≡ p" class="Function">∙-id-r</a> <a id="1937" class="Symbol">{</a><a id="1938" class="Argument">x</a> <a id="1940" class="Symbol">=</a> <a id="1942" href="1Lab.Path.Groupoid.html#1942" class="Bound">x</a><a id="1943" class="Symbol">}</a> <a id="1945" class="Symbol">{</a><a id="1946" class="Argument">y</a> <a id="1948" class="Symbol">=</a> <a id="1950" href="1Lab.Path.Groupoid.html#1950" class="Bound">y</a><a id="1951" class="Symbol">}</a> <a id="1953" href="1Lab.Path.Groupoid.html#1953" class="Bound">p</a> <a id="1955" class="Symbol">=</a>
    <a id="1961" href="1Lab.Path.html#19544" data-type="(P : (y : A) → x ≡ y → Type ℓ₂) → P x refl → (p : x ≡ y) → P y p" class="Function">J</a> <a id="1963" class="Symbol">(λ</a> <a id="1966" href="1Lab.Path.Groupoid.html#1966" class="Bound">_</a> <a id="1968" href="1Lab.Path.Groupoid.html#1968" class="Bound">p</a> <a id="1970" class="Symbol">→</a> <a id="1972" href="1Lab.Path.Groupoid.html#1968" class="Bound">p</a> <a id="1974" href="1Lab.Path.Groupoid.html#1652" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="1976" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="1981" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="1983" href="1Lab.Path.Groupoid.html#1968" class="Bound">p</a><a id="1984" class="Symbol">)</a>
      <a id="1992" class="Symbol">(</a><a id="1993" href="1Lab.Path.html#58115" data-type="f ≡ g → (x : A) → f x ≡ g x" class="Function">happly</a> <a id="2000" class="Symbol">(</a><a id="2001" href="1Lab.Path.html#20103" data-type="(P : (y : A) → x ≡ y → Type ℓ₂) (pxr : P x refl) →
J P pxr refl ≡ pxr" class="Function">J-refl</a> <a id="2008" class="Symbol">(λ</a> <a id="2011" href="1Lab.Path.Groupoid.html#2011" class="Bound">y</a> <a id="2013" href="1Lab.Path.Groupoid.html#2013" class="Bound">_</a> <a id="2015" class="Symbol">→</a> <a id="2017" href="1Lab.Path.Groupoid.html#2011" class="Bound">y</a> <a id="2019" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="2021" href="1Lab.Path.Groupoid.html#2011" class="Bound">y</a> <a id="2023" class="Symbol">→</a> <a id="2025" href="1Lab.Path.Groupoid.html#1942" class="Bound">x</a> <a id="2027" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="2029" href="1Lab.Path.Groupoid.html#2011" class="Bound">y</a><a id="2030" class="Symbol">)</a> <a id="2032" class="Symbol">(λ</a> <a id="2035" href="1Lab.Path.Groupoid.html#2035" class="Bound">x</a> <a id="2037" class="Symbol">→</a> <a id="2039" href="1Lab.Path.Groupoid.html#2035" class="Bound">x</a><a id="2040" class="Symbol">))</a> <a id="2043" class="Symbol">_)</a>
      <a id="2052" href="1Lab.Path.Groupoid.html#1953" class="Bound">p</a>
</pre>
<p>This isn’t as straightforward as it would be in “Book HoTT” because -
remember - J doesn’t compute definitionally, only up to the path
<span class="Agda"><a href="1Lab.Path.html#20103" class="Function">J-refl</a></span>.
Now the other identity law:</p>
<pre class="Agda">  <a id="WithJ.∙-id-l"></a><a id="2251" href="1Lab.Path.Groupoid.html#2251" data-type="(p : y ≡ z) → (refl ∙ p) ≡ p" class="Function">∙-id-l</a> <a id="2258" class="Symbol">:</a> <a id="2260" class="Symbol">(</a><a id="2261" href="1Lab.Path.Groupoid.html#2261" class="Bound">p</a> <a id="2263" class="Symbol">:</a> <a id="2265" href="1Lab.Path.Groupoid.html#1526" class="Generalizable">y</a> <a id="2267" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="2269" href="1Lab.Path.Groupoid.html#1528" class="Generalizable">z</a><a id="2270" class="Symbol">)</a> <a id="2272" class="Symbol">→</a> <a id="2274" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="2279" href="1Lab.Path.Groupoid.html#1652" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="2281" href="1Lab.Path.Groupoid.html#2261" class="Bound">p</a> <a id="2283" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="2285" href="1Lab.Path.Groupoid.html#2261" class="Bound">p</a>
  <a id="2289" href="1Lab.Path.Groupoid.html#2251" data-type="(p : y ≡ z) → (refl ∙ p) ≡ p" class="Function">∙-id-l</a> <a id="2296" class="Symbol">{</a><a id="2297" class="Argument">y</a> <a id="2299" class="Symbol">=</a> <a id="2301" href="1Lab.Path.Groupoid.html#2301" class="Bound">y</a><a id="2302" class="Symbol">}</a> <a id="2304" class="Symbol">{</a><a id="2305" class="Argument">z</a> <a id="2307" class="Symbol">=</a> <a id="2309" href="1Lab.Path.Groupoid.html#2309" class="Bound">z</a><a id="2310" class="Symbol">}</a> <a id="2312" href="1Lab.Path.Groupoid.html#2312" class="Bound">p</a> <a id="2314" class="Symbol">=</a> <a id="2316" href="1Lab.Path.html#58115" data-type="f ≡ g → (x : A) → f x ≡ g x" class="Function">happly</a> <a id="2323" class="Symbol">(</a><a id="2324" href="1Lab.Path.html#20103" data-type="(P : (y : A) → x ≡ y → Type ℓ₂) (pxr : P x refl) →
J P pxr refl ≡ pxr" class="Function">J-refl</a> <a id="2331" class="Symbol">(λ</a> <a id="2334" href="1Lab.Path.Groupoid.html#2334" class="Bound">y</a> <a id="2336" href="1Lab.Path.Groupoid.html#2336" class="Bound">_</a> <a id="2338" class="Symbol">→</a> <a id="2340" href="1Lab.Path.Groupoid.html#2334" class="Bound">y</a> <a id="2342" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="2344" href="1Lab.Path.Groupoid.html#2309" class="Bound">z</a> <a id="2346" class="Symbol">→</a> <a id="2348" href="1Lab.Path.Groupoid.html#2334" class="Bound">y</a> <a id="2350" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="2352" href="1Lab.Path.Groupoid.html#2309" class="Bound">z</a><a id="2353" class="Symbol">)</a> <a id="2355" class="Symbol">(λ</a> <a id="2358" href="1Lab.Path.Groupoid.html#2358" class="Bound">x</a> <a id="2360" class="Symbol">→</a> <a id="2362" href="1Lab.Path.Groupoid.html#2358" class="Bound">x</a><a id="2363" class="Symbol">))</a> <a id="2366" href="1Lab.Path.Groupoid.html#2312" class="Bound">p</a>
</pre>
<p>This case we get for less since it’s essentially the computation rule
for
<span class="Agda"><a href="1Lab.Path.html#19544" class="Function">J</a></span>.</p>
<pre class="Agda">  <a id="WithJ.∙-assoc"></a><a id="2470" href="1Lab.Path.Groupoid.html#2470" data-type="(p : w ≡ x) (q : x ≡ y) (r : y ≡ z) → (p ∙ (q ∙ r)) ≡ ((p ∙ q) ∙ r)" class="Function">∙-assoc</a> <a id="2478" class="Symbol">:</a> <a id="2480" class="Symbol">(</a><a id="2481" href="1Lab.Path.Groupoid.html#2481" class="Bound">p</a> <a id="2483" class="Symbol">:</a> <a id="2485" href="1Lab.Path.Groupoid.html#1522" class="Generalizable">w</a> <a id="2487" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="2489" href="1Lab.Path.Groupoid.html#1524" class="Generalizable">x</a><a id="2490" class="Symbol">)</a> <a id="2492" class="Symbol">(</a><a id="2493" href="1Lab.Path.Groupoid.html#2493" class="Bound">q</a> <a id="2495" class="Symbol">:</a> <a id="2497" href="1Lab.Path.Groupoid.html#1524" class="Generalizable">x</a> <a id="2499" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="2501" href="1Lab.Path.Groupoid.html#1526" class="Generalizable">y</a><a id="2502" class="Symbol">)</a> <a id="2504" class="Symbol">(</a><a id="2505" href="1Lab.Path.Groupoid.html#2505" class="Bound">r</a> <a id="2507" class="Symbol">:</a> <a id="2509" href="1Lab.Path.Groupoid.html#1526" class="Generalizable">y</a> <a id="2511" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="2513" href="1Lab.Path.Groupoid.html#1528" class="Generalizable">z</a><a id="2514" class="Symbol">)</a>
          <a id="2526" class="Symbol">→</a> <a id="2528" href="1Lab.Path.Groupoid.html#2481" class="Bound">p</a> <a id="2530" href="1Lab.Path.Groupoid.html#1652" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="2532" class="Symbol">(</a><a id="2533" href="1Lab.Path.Groupoid.html#2493" class="Bound">q</a> <a id="2535" href="1Lab.Path.Groupoid.html#1652" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="2537" href="1Lab.Path.Groupoid.html#2505" class="Bound">r</a><a id="2538" class="Symbol">)</a> <a id="2540" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="2542" class="Symbol">(</a><a id="2543" href="1Lab.Path.Groupoid.html#2481" class="Bound">p</a> <a id="2545" href="1Lab.Path.Groupoid.html#1652" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="2547" href="1Lab.Path.Groupoid.html#2493" class="Bound">q</a><a id="2548" class="Symbol">)</a> <a id="2550" href="1Lab.Path.Groupoid.html#1652" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="2552" href="1Lab.Path.Groupoid.html#2505" class="Bound">r</a>
  <a id="2556" href="1Lab.Path.Groupoid.html#2470" data-type="(p : w ≡ x) (q : x ≡ y) (r : y ≡ z) → (p ∙ (q ∙ r)) ≡ ((p ∙ q) ∙ r)" class="Function">∙-assoc</a> <a id="2564" class="Symbol">{</a><a id="2565" class="Argument">w</a> <a id="2567" class="Symbol">=</a> <a id="2569" href="1Lab.Path.Groupoid.html#2569" class="Bound">w</a><a id="2570" class="Symbol">}</a> <a id="2572" class="Symbol">{</a><a id="2573" class="Argument">x</a> <a id="2575" class="Symbol">=</a> <a id="2577" href="1Lab.Path.Groupoid.html#2577" class="Bound">x</a><a id="2578" class="Symbol">}</a> <a id="2580" class="Symbol">{</a><a id="2581" class="Argument">y</a> <a id="2583" class="Symbol">=</a> <a id="2585" href="1Lab.Path.Groupoid.html#2585" class="Bound">y</a><a id="2586" class="Symbol">}</a> <a id="2588" class="Symbol">{</a><a id="2589" class="Argument">z</a> <a id="2591" class="Symbol">=</a> <a id="2593" href="1Lab.Path.Groupoid.html#2593" class="Bound">z</a><a id="2594" class="Symbol">}</a> <a id="2596" href="1Lab.Path.Groupoid.html#2596" class="Bound">p</a> <a id="2598" href="1Lab.Path.Groupoid.html#2598" class="Bound">q</a> <a id="2600" href="1Lab.Path.Groupoid.html#2600" class="Bound">r</a> <a id="2602" class="Symbol">=</a>
    <a id="2608" href="1Lab.Path.html#19544" data-type="(P : (y : A) → x ≡ y → Type ℓ₂) → P x refl → (p : x ≡ y) → P y p" class="Function">J</a> <a id="2610" class="Symbol">(λ</a> <a id="2613" href="1Lab.Path.Groupoid.html#2613" class="Bound">x</a> <a id="2615" href="1Lab.Path.Groupoid.html#2615" class="Bound">p</a> <a id="2617" class="Symbol">→</a> <a id="2619" class="Symbol">(</a><a id="2620" href="1Lab.Path.Groupoid.html#2620" class="Bound">q</a> <a id="2622" class="Symbol">:</a> <a id="2624" href="1Lab.Path.Groupoid.html#2613" class="Bound">x</a> <a id="2626" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="2628" href="1Lab.Path.Groupoid.html#2585" class="Bound">y</a><a id="2629" class="Symbol">)</a> <a id="2631" class="Symbol">(</a><a id="2632" href="1Lab.Path.Groupoid.html#2632" class="Bound">r</a> <a id="2634" class="Symbol">:</a> <a id="2636" href="1Lab.Path.Groupoid.html#2585" class="Bound">y</a> <a id="2638" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="2640" href="1Lab.Path.Groupoid.html#2593" class="Bound">z</a><a id="2641" class="Symbol">)</a> <a id="2643" class="Symbol">→</a> <a id="2645" href="1Lab.Path.Groupoid.html#2615" class="Bound">p</a> <a id="2647" href="1Lab.Path.Groupoid.html#1652" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="2649" class="Symbol">(</a><a id="2650" href="1Lab.Path.Groupoid.html#2620" class="Bound">q</a> <a id="2652" href="1Lab.Path.Groupoid.html#1652" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="2654" href="1Lab.Path.Groupoid.html#2632" class="Bound">r</a><a id="2655" class="Symbol">)</a> <a id="2657" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="2659" class="Symbol">(</a><a id="2660" href="1Lab.Path.Groupoid.html#2615" class="Bound">p</a> <a id="2662" href="1Lab.Path.Groupoid.html#1652" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="2664" href="1Lab.Path.Groupoid.html#2620" class="Bound">q</a><a id="2665" class="Symbol">)</a> <a id="2667" href="1Lab.Path.Groupoid.html#1652" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="2669" href="1Lab.Path.Groupoid.html#2632" class="Bound">r</a><a id="2670" class="Symbol">)</a> <a id="2672" href="1Lab.Path.Groupoid.html#2700" data-type="w ≡ x →
x ≡ y →
y ≡ z →
(q : w ≡ y) (r : y ≡ z) → (refl ∙ (q ∙ r)) ≡ ((refl ∙ q) ∙ r)" class="Function">lemma</a> <a id="2678" href="1Lab.Path.Groupoid.html#2596" class="Bound">p</a> <a id="2680" href="1Lab.Path.Groupoid.html#2598" class="Bound">q</a> <a id="2682" href="1Lab.Path.Groupoid.html#2600" class="Bound">r</a>
    <a id="2688" class="Keyword">where</a>
      <a id="2700" href="1Lab.Path.Groupoid.html#2700" data-type="w ≡ x →
x ≡ y →
y ≡ z →
(q : w ≡ y) (r : y ≡ z) → (refl ∙ (q ∙ r)) ≡ ((refl ∙ q) ∙ r)" class="Function">lemma</a> <a id="2706" class="Symbol">:</a> <a id="2708" class="Symbol">(</a><a id="2709" href="1Lab.Path.Groupoid.html#2709" class="Bound">q</a> <a id="2711" class="Symbol">:</a> <a id="2713" href="1Lab.Path.Groupoid.html#2569" class="Bound">w</a> <a id="2715" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="2717" href="1Lab.Path.Groupoid.html#2585" class="Bound">y</a><a id="2718" class="Symbol">)</a> <a id="2720" class="Symbol">(</a><a id="2721" href="1Lab.Path.Groupoid.html#2721" class="Bound">r</a> <a id="2723" class="Symbol">:</a> <a id="2725" href="1Lab.Path.Groupoid.html#2585" class="Bound">y</a> <a id="2727" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="2729" href="1Lab.Path.Groupoid.html#2593" class="Bound">z</a><a id="2730" class="Symbol">)</a>
            <a id="2744" class="Symbol">→</a> <a id="2746" class="Symbol">(</a><a id="2747" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="2752" href="1Lab.Path.Groupoid.html#1652" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="2754" class="Symbol">(</a><a id="2755" href="1Lab.Path.Groupoid.html#2709" class="Bound">q</a> <a id="2757" href="1Lab.Path.Groupoid.html#1652" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="2759" href="1Lab.Path.Groupoid.html#2721" class="Bound">r</a><a id="2760" class="Symbol">))</a> <a id="2763" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="2765" class="Symbol">((</a><a id="2767" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="2772" href="1Lab.Path.Groupoid.html#1652" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="2774" href="1Lab.Path.Groupoid.html#2709" class="Bound">q</a><a id="2775" class="Symbol">)</a> <a id="2777" href="1Lab.Path.Groupoid.html#1652" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="2779" href="1Lab.Path.Groupoid.html#2721" class="Bound">r</a><a id="2780" class="Symbol">)</a>
      <a id="2788" href="1Lab.Path.Groupoid.html#2700" data-type="w ≡ x →
x ≡ y →
y ≡ z →
(q : w ≡ y) (r : y ≡ z) → (refl ∙ (q ∙ r)) ≡ ((refl ∙ q) ∙ r)" class="Function">lemma</a> <a id="2794" href="1Lab.Path.Groupoid.html#2794" class="Bound">q</a> <a id="2796" href="1Lab.Path.Groupoid.html#2796" class="Bound">r</a> <a id="2798" class="Symbol">=</a>
        <a id="2808" class="Symbol">(</a><a id="2809" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="2814" href="1Lab.Path.Groupoid.html#1652" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="2816" class="Symbol">(</a><a id="2817" href="1Lab.Path.Groupoid.html#2794" class="Bound">q</a> <a id="2819" href="1Lab.Path.Groupoid.html#1652" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="2821" href="1Lab.Path.Groupoid.html#2796" class="Bound">r</a><a id="2822" class="Symbol">))</a> <span class="reasoning-step"><span class="as-written Function"><a id="2825" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="2828" href="1Lab.Path.Groupoid.html#2251" data-type="(p : y ≡ z) → (refl ∙ p) ≡ p" class="Function">∙-id-l</a> <a id="2835" class="Symbol">(</a><a id="2836" href="1Lab.Path.Groupoid.html#2794" class="Bound">q</a> <a id="2838" href="1Lab.Path.Groupoid.html#1652" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="2840" href="1Lab.Path.Groupoid.html#2796" class="Bound">r</a><a id="2841" class="Symbol">)</a> <a id="2843" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
        <a id="2853" href="1Lab.Path.Groupoid.html#2794" class="Bound">q</a> <a id="2855" href="1Lab.Path.Groupoid.html#1652" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="2857" href="1Lab.Path.Groupoid.html#2796" class="Bound">r</a>            <span class="reasoning-step"><span class="as-written Function"><a id="2870" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="2873" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="2877" class="Symbol">(</a><a id="2878" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="2881" class="Symbol">(λ</a> <a id="2884" href="1Lab.Path.Groupoid.html#2884" class="Bound">e</a> <a id="2886" class="Symbol">→</a> <a id="2888" href="1Lab.Path.Groupoid.html#2884" class="Bound">e</a> <a id="2890" href="1Lab.Path.Groupoid.html#1652" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="2892" href="1Lab.Path.Groupoid.html#2796" class="Bound">r</a><a id="2893" class="Symbol">)</a> <a id="2895" class="Symbol">(</a><a id="2896" href="1Lab.Path.Groupoid.html#2251" data-type="(p : y ≡ z) → (refl ∙ p) ≡ p" class="Function">∙-id-l</a> <a id="2903" href="1Lab.Path.Groupoid.html#2794" class="Bound">q</a><a id="2904" class="Symbol">))</a> <a id="2907" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
        <a id="2917" class="Symbol">(</a><a id="2918" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="2923" href="1Lab.Path.Groupoid.html#1652" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="2925" href="1Lab.Path.Groupoid.html#2794" class="Bound">q</a><a id="2926" class="Symbol">)</a> <a id="2928" href="1Lab.Path.Groupoid.html#1652" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="2930" href="1Lab.Path.Groupoid.html#2796" class="Bound">r</a>   <a id="2934" href="1Lab.Path.html#46945" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
</pre>
<p>The associativity rule is trickier to prove, since we do inductive
where the motive is a dependent product. What we’re doing can be
summarised using words: By induction, it suffices to assume
<code>p</code> is refl. Then, what we want to show is
<code>(refl ∙ (q ∙ r)) ≡ ((refl ∙ q) ∙ r)</code>. But both of those
compute to <code>q ∙ r</code>, so we are done. This computation isn’t
automatic - it’s expressed by the
<span class="Agda"><a href="1Lab.Path.Groupoid.html#2700" class="Function">lemma</a></span>.</p>
<p>This expresses that the paths behave like morphisms in a category.
For a groupoid, we also need inverses and cancellation:</p>
<pre class="Agda">  <a id="WithJ.inv"></a><a id="3477" href="1Lab.Path.Groupoid.html#3477" data-type="x ≡ y → y ≡ x" class="Function">inv</a> <a id="3481" class="Symbol">:</a> <a id="3483" href="1Lab.Path.Groupoid.html#1524" class="Generalizable">x</a> <a id="3485" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="3487" href="1Lab.Path.Groupoid.html#1526" class="Generalizable">y</a> <a id="3489" class="Symbol">→</a> <a id="3491" href="1Lab.Path.Groupoid.html#1526" class="Generalizable">y</a> <a id="3493" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="3495" href="1Lab.Path.Groupoid.html#1524" class="Generalizable">x</a>
  <a id="3499" href="1Lab.Path.Groupoid.html#3477" data-type="x ≡ y → y ≡ x" class="Function">inv</a> <a id="3503" class="Symbol">{</a><a id="3504" class="Argument">x</a> <a id="3506" class="Symbol">=</a> <a id="3508" href="1Lab.Path.Groupoid.html#3508" class="Bound">x</a><a id="3509" class="Symbol">}</a> <a id="3511" class="Symbol">=</a> <a id="3513" href="1Lab.Path.html#19544" data-type="(P : (y : A) → x ≡ y → Type ℓ₂) → P x refl → (p : x ≡ y) → P y p" class="Function">J</a> <a id="3515" class="Symbol">(λ</a> <a id="3518" href="1Lab.Path.Groupoid.html#3518" class="Bound">y</a> <a id="3520" href="1Lab.Path.Groupoid.html#3520" class="Bound">_</a> <a id="3522" class="Symbol">→</a> <a id="3524" href="1Lab.Path.Groupoid.html#3518" class="Bound">y</a> <a id="3526" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="3528" href="1Lab.Path.Groupoid.html#3508" class="Bound">x</a><a id="3529" class="Symbol">)</a> <a id="3531" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
</pre>
<p>The operation which assigns inverses has to be involutive, which
follows from two computations.</p>
<pre class="Agda">  <a id="WithJ.inv-inv"></a><a id="3648" href="1Lab.Path.Groupoid.html#3648" data-type="(p : x ≡ y) → inv (inv p) ≡ p" class="Function">inv-inv</a> <a id="3656" class="Symbol">:</a> <a id="3658" class="Symbol">(</a><a id="3659" href="1Lab.Path.Groupoid.html#3659" class="Bound">p</a> <a id="3661" class="Symbol">:</a> <a id="3663" href="1Lab.Path.Groupoid.html#1524" class="Generalizable">x</a> <a id="3665" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="3667" href="1Lab.Path.Groupoid.html#1526" class="Generalizable">y</a><a id="3668" class="Symbol">)</a> <a id="3670" class="Symbol">→</a> <a id="3672" href="1Lab.Path.Groupoid.html#3477" data-type="x ≡ y → y ≡ x" class="Function">inv</a> <a id="3676" class="Symbol">(</a><a id="3677" href="1Lab.Path.Groupoid.html#3477" data-type="x ≡ y → y ≡ x" class="Function">inv</a> <a id="3681" href="1Lab.Path.Groupoid.html#3659" class="Bound">p</a><a id="3682" class="Symbol">)</a> <a id="3684" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="3686" href="1Lab.Path.Groupoid.html#3659" class="Bound">p</a>
  <a id="3690" href="1Lab.Path.Groupoid.html#3648" data-type="(p : x ≡ y) → inv (inv p) ≡ p" class="Function">inv-inv</a> <a id="3698" class="Symbol">{</a><a id="3699" class="Argument">x</a> <a id="3701" class="Symbol">=</a> <a id="3703" href="1Lab.Path.Groupoid.html#3703" class="Bound">x</a><a id="3704" class="Symbol">}</a> <a id="3706" class="Symbol">=</a>
    <a id="3712" href="1Lab.Path.html#19544" data-type="(P : (y : A) → x ≡ y → Type ℓ₂) → P x refl → (p : x ≡ y) → P y p" class="Function">J</a> <a id="3714" class="Symbol">(λ</a> <a id="3717" href="1Lab.Path.Groupoid.html#3717" class="Bound">y</a> <a id="3719" href="1Lab.Path.Groupoid.html#3719" class="Bound">p</a> <a id="3721" class="Symbol">→</a> <a id="3723" href="1Lab.Path.Groupoid.html#3477" data-type="x ≡ y → y ≡ x" class="Function">inv</a> <a id="3727" class="Symbol">(</a><a id="3728" href="1Lab.Path.Groupoid.html#3477" data-type="x ≡ y → y ≡ x" class="Function">inv</a> <a id="3732" href="1Lab.Path.Groupoid.html#3719" class="Bound">p</a><a id="3733" class="Symbol">)</a> <a id="3735" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="3737" href="1Lab.Path.Groupoid.html#3719" class="Bound">p</a><a id="3738" class="Symbol">)</a>
      <a id="3746" class="Symbol">(</a><a id="3747" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="3750" href="1Lab.Path.Groupoid.html#3477" data-type="x ≡ y → y ≡ x" class="Function">inv</a> <a id="3754" class="Symbol">(</a><a id="3755" href="1Lab.Path.html#20103" data-type="(P : (y : A) → x ≡ y → Type ℓ₂) (pxr : P x refl) →
J P pxr refl ≡ pxr" class="Function">J-refl</a> <a id="3762" class="Symbol">(λ</a> <a id="3765" href="1Lab.Path.Groupoid.html#3765" class="Bound">y</a> <a id="3767" href="1Lab.Path.Groupoid.html#3767" class="Bound">_</a> <a id="3769" class="Symbol">→</a> <a id="3771" href="1Lab.Path.Groupoid.html#3765" class="Bound">y</a> <a id="3773" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="3775" href="1Lab.Path.Groupoid.html#3703" class="Bound">x</a><a id="3776" class="Symbol">)</a> <a id="3778" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a><a id="3782" class="Symbol">)</a> <a id="3784" href="1Lab.Path.Groupoid.html#1652" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="3786" href="1Lab.Path.html#20103" data-type="(P : (y : A) → x ≡ y → Type ℓ₂) (pxr : P x refl) →
J P pxr refl ≡ pxr" class="Function">J-refl</a> <a id="3793" class="Symbol">(λ</a> <a id="3796" href="1Lab.Path.Groupoid.html#3796" class="Bound">y</a> <a id="3798" href="1Lab.Path.Groupoid.html#3798" class="Bound">_</a> <a id="3800" class="Symbol">→</a> <a id="3802" href="1Lab.Path.Groupoid.html#3796" class="Bound">y</a> <a id="3804" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="3806" href="1Lab.Path.Groupoid.html#3703" class="Bound">x</a><a id="3807" class="Symbol">)</a> <a id="3809" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a><a id="3813" class="Symbol">)</a>
</pre>
<p>And we have to prove that composing with an inverse gives the
reflexivity path.</p>
<pre class="Agda">  <a id="WithJ.∙-inv-l"></a><a id="3911" href="1Lab.Path.Groupoid.html#3911" data-type="(p : x ≡ y) → (p ∙ inv p) ≡ refl" class="Function">∙-inv-l</a> <a id="3919" class="Symbol">:</a> <a id="3921" class="Symbol">(</a><a id="3922" href="1Lab.Path.Groupoid.html#3922" class="Bound">p</a> <a id="3924" class="Symbol">:</a> <a id="3926" href="1Lab.Path.Groupoid.html#1524" class="Generalizable">x</a> <a id="3928" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="3930" href="1Lab.Path.Groupoid.html#1526" class="Generalizable">y</a><a id="3931" class="Symbol">)</a> <a id="3933" class="Symbol">→</a> <a id="3935" href="1Lab.Path.Groupoid.html#3922" class="Bound">p</a> <a id="3937" href="1Lab.Path.Groupoid.html#1652" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="3939" href="1Lab.Path.Groupoid.html#3477" data-type="x ≡ y → y ≡ x" class="Function">inv</a> <a id="3943" href="1Lab.Path.Groupoid.html#3922" class="Bound">p</a> <a id="3945" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="3947" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
  <a id="3954" href="1Lab.Path.Groupoid.html#3911" data-type="(p : x ≡ y) → (p ∙ inv p) ≡ refl" class="Function">∙-inv-l</a> <a id="3962" class="Symbol">{</a><a id="3963" class="Argument">x</a> <a id="3965" class="Symbol">=</a> <a id="3967" href="1Lab.Path.Groupoid.html#3967" class="Bound">x</a><a id="3968" class="Symbol">}</a> <a id="3970" class="Symbol">=</a> <a id="3972" href="1Lab.Path.html#19544" data-type="(P : (y : A) → x ≡ y → Type ℓ₂) → P x refl → (p : x ≡ y) → P y p" class="Function">J</a> <a id="3974" class="Symbol">(λ</a> <a id="3977" href="1Lab.Path.Groupoid.html#3977" class="Bound">y</a> <a id="3979" href="1Lab.Path.Groupoid.html#3979" class="Bound">p</a> <a id="3981" class="Symbol">→</a> <a id="3983" href="1Lab.Path.Groupoid.html#3979" class="Bound">p</a> <a id="3985" href="1Lab.Path.Groupoid.html#1652" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="3987" href="1Lab.Path.Groupoid.html#3477" data-type="x ≡ y → y ≡ x" class="Function">inv</a> <a id="3991" href="1Lab.Path.Groupoid.html#3979" class="Bound">p</a> <a id="3993" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="3995" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a><a id="3999" class="Symbol">)</a>
                      <a id="4023" class="Symbol">(</a><a id="4024" href="1Lab.Path.Groupoid.html#2251" data-type="(p : y ≡ z) → (refl ∙ p) ≡ p" class="Function">∙-id-l</a> <a id="4031" class="Symbol">(</a><a id="4032" href="1Lab.Path.Groupoid.html#3477" data-type="x ≡ y → y ≡ x" class="Function">inv</a> <a id="4036" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a><a id="4040" class="Symbol">)</a> <a id="4042" href="1Lab.Path.Groupoid.html#1652" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="4044" href="1Lab.Path.html#20103" data-type="(P : (y : A) → x ≡ y → Type ℓ₂) (pxr : P x refl) →
J P pxr refl ≡ pxr" class="Function">J-refl</a> <a id="4051" class="Symbol">(λ</a> <a id="4054" href="1Lab.Path.Groupoid.html#4054" class="Bound">y</a> <a id="4056" href="1Lab.Path.Groupoid.html#4056" class="Bound">_</a> <a id="4058" class="Symbol">→</a> <a id="4060" href="1Lab.Path.Groupoid.html#4054" class="Bound">y</a> <a id="4062" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="4064" href="1Lab.Path.Groupoid.html#3967" class="Bound">x</a><a id="4065" class="Symbol">)</a> <a id="4067" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a><a id="4071" class="Symbol">)</a>

  <a id="WithJ.∙-inv-r"></a><a id="4076" href="1Lab.Path.Groupoid.html#4076" data-type="(p : x ≡ y) → (inv p ∙ p) ≡ refl" class="Function">∙-inv-r</a> <a id="4084" class="Symbol">:</a> <a id="4086" class="Symbol">(</a><a id="4087" href="1Lab.Path.Groupoid.html#4087" class="Bound">p</a> <a id="4089" class="Symbol">:</a> <a id="4091" href="1Lab.Path.Groupoid.html#1524" class="Generalizable">x</a> <a id="4093" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="4095" href="1Lab.Path.Groupoid.html#1526" class="Generalizable">y</a><a id="4096" class="Symbol">)</a> <a id="4098" class="Symbol">→</a> <a id="4100" href="1Lab.Path.Groupoid.html#3477" data-type="x ≡ y → y ≡ x" class="Function">inv</a> <a id="4104" href="1Lab.Path.Groupoid.html#4087" class="Bound">p</a> <a id="4106" href="1Lab.Path.Groupoid.html#1652" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="4108" href="1Lab.Path.Groupoid.html#4087" class="Bound">p</a> <a id="4110" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="4112" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
  <a id="4119" href="1Lab.Path.Groupoid.html#4076" data-type="(p : x ≡ y) → (inv p ∙ p) ≡ refl" class="Function">∙-inv-r</a> <a id="4127" class="Symbol">{</a><a id="4128" class="Argument">x</a> <a id="4130" class="Symbol">=</a> <a id="4132" href="1Lab.Path.Groupoid.html#4132" class="Bound">x</a><a id="4133" class="Symbol">}</a> <a id="4135" class="Symbol">=</a> <a id="4137" href="1Lab.Path.html#19544" data-type="(P : (y : A) → x ≡ y → Type ℓ₂) → P x refl → (p : x ≡ y) → P y p" class="Function">J</a> <a id="4139" class="Symbol">(λ</a> <a id="4142" href="1Lab.Path.Groupoid.html#4142" class="Bound">y</a> <a id="4144" href="1Lab.Path.Groupoid.html#4144" class="Bound">p</a> <a id="4146" class="Symbol">→</a> <a id="4148" href="1Lab.Path.Groupoid.html#3477" data-type="x ≡ y → y ≡ x" class="Function">inv</a> <a id="4152" href="1Lab.Path.Groupoid.html#4144" class="Bound">p</a> <a id="4154" href="1Lab.Path.Groupoid.html#1652" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="4156" href="1Lab.Path.Groupoid.html#4144" class="Bound">p</a> <a id="4158" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="4160" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a><a id="4164" class="Symbol">)</a>
                      <a id="4188" class="Symbol">(</a><a id="4189" href="1Lab.Path.Groupoid.html#1892" data-type="(p : x ≡ y) → (p ∙ refl) ≡ p" class="Function">∙-id-r</a> <a id="4196" class="Symbol">(</a><a id="4197" href="1Lab.Path.Groupoid.html#3477" data-type="x ≡ y → y ≡ x" class="Function">inv</a> <a id="4201" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a><a id="4205" class="Symbol">)</a> <a id="4207" href="1Lab.Path.Groupoid.html#1652" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="4209" href="1Lab.Path.html#20103" data-type="(P : (y : A) → x ≡ y → Type ℓ₂) (pxr : P x refl) →
J P pxr refl ≡ pxr" class="Function">J-refl</a> <a id="4216" class="Symbol">(λ</a> <a id="4219" href="1Lab.Path.Groupoid.html#4219" class="Bound">y</a> <a id="4221" href="1Lab.Path.Groupoid.html#4221" class="Bound">_</a> <a id="4223" class="Symbol">→</a> <a id="4225" href="1Lab.Path.Groupoid.html#4219" class="Bound">y</a> <a id="4227" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="4229" href="1Lab.Path.Groupoid.html#4132" class="Bound">x</a><a id="4230" class="Symbol">)</a> <a id="4232" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a><a id="4236" class="Symbol">)</a>
</pre>
<h2 id="cubically"><a href="#cubically" class="header-link">Cubically<span class="header-link-emoji">🔗</span></a></h2>
<p>Now we do the same using <code class="sourceCode agda">hfill</code>
instead of path induction.</p>
<pre class="Agda"><a id="4333" class="Keyword">module</a> <a id="4340" href="1Lab.Path.Groupoid.html#4340" class="Module">_</a> <a id="4342" class="Keyword">where</a>
  <a id="4350" class="Keyword">private</a> <a id="4358" class="Keyword">variable</a>
    <a id="4371" href="1Lab.Path.Groupoid.html#4371" class="Generalizable">ℓ</a> <a id="4373" class="Symbol">:</a> <a id="4375" href="Agda.Primitive.html#582" data-type="Type" class="Postulate">Level</a>
    <a id="4385" href="1Lab.Path.Groupoid.html#4385" class="Generalizable">A</a> <a id="4387" href="1Lab.Path.Groupoid.html#4387" class="Generalizable">B</a> <a id="4389" class="Symbol">:</a> <a id="4391" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="4396" href="1Lab.Path.Groupoid.html#4371" class="Generalizable">ℓ</a>
    <a id="4402" href="1Lab.Path.Groupoid.html#4402" class="Generalizable">w</a> <a id="4404" href="1Lab.Path.Groupoid.html#4404" class="Generalizable">x</a> <a id="4406" href="1Lab.Path.Groupoid.html#4406" class="Generalizable">y</a> <a id="4408" href="1Lab.Path.Groupoid.html#4408" class="Generalizable">z</a> <a id="4410" class="Symbol">:</a> <a id="4412" href="1Lab.Path.Groupoid.html#4385" class="Generalizable">A</a>

  <a id="4417" class="Keyword">open</a> <a id="4422" href="1Lab.Path.html" class="Module">1Lab.Path</a>
</pre>
<p>The left and right identity laws follow directly from the two fillers
for the composition operation.</p>
<pre class="Agda">  <a id="4549" href="1Lab.Path.Groupoid.html#4549" data-type="(p : x ≡ y) → p ∙ refl ≡ p" class="Function">∙-id-r</a> <a id="4556" class="Symbol">:</a> <a id="4558" class="Symbol">(</a><a id="4559" href="1Lab.Path.Groupoid.html#4559" class="Bound">p</a> <a id="4561" class="Symbol">:</a> <a id="4563" href="1Lab.Path.Groupoid.html#4404" class="Generalizable">x</a> <a id="4565" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="4567" href="1Lab.Path.Groupoid.html#4406" class="Generalizable">y</a><a id="4568" class="Symbol">)</a> <a id="4570" class="Symbol">→</a> <a id="4572" href="1Lab.Path.Groupoid.html#4559" class="Bound">p</a> <a id="4574" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="4576" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="4581" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="4583" href="1Lab.Path.Groupoid.html#4559" class="Bound">p</a>
  <a id="4587" href="1Lab.Path.Groupoid.html#4549" data-type="(p : x ≡ y) → p ∙ refl ≡ p" class="Function">∙-id-r</a> <a id="4594" href="1Lab.Path.Groupoid.html#4594" class="Bound">p</a> <a id="4596" class="Symbol">=</a> <a id="4598" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="4602" class="Symbol">(</a><a id="4603" href="1Lab.Path.html#39808" data-type="(p : x ≡ y) (q : y ≡ z) → Square refl p (p ∙ q) q" class="Function">∙-filler</a> <a id="4612" href="1Lab.Path.Groupoid.html#4594" class="Bound">p</a> <a id="4614" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a><a id="4618" class="Symbol">)</a>

  <a id="4623" href="1Lab.Path.Groupoid.html#4623" data-type="(p : x ≡ y) → refl ∙ p ≡ p" class="Function">∙-id-l</a> <a id="4630" class="Symbol">:</a> <a id="4632" class="Symbol">(</a><a id="4633" href="1Lab.Path.Groupoid.html#4633" class="Bound">p</a> <a id="4635" class="Symbol">:</a> <a id="4637" href="1Lab.Path.Groupoid.html#4404" class="Generalizable">x</a> <a id="4639" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="4641" href="1Lab.Path.Groupoid.html#4406" class="Generalizable">y</a><a id="4642" class="Symbol">)</a> <a id="4644" class="Symbol">→</a> <a id="4646" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="4651" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="4653" href="1Lab.Path.Groupoid.html#4633" class="Bound">p</a> <a id="4655" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="4657" href="1Lab.Path.Groupoid.html#4633" class="Bound">p</a>
  <a id="4661" href="1Lab.Path.Groupoid.html#4623" data-type="(p : x ≡ y) → refl ∙ p ≡ p" class="Function">∙-id-l</a> <a id="4668" href="1Lab.Path.Groupoid.html#4668" class="Bound">p</a> <a id="4670" class="Symbol">=</a> <a id="4672" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="4676" class="Symbol">(</a><a id="4677" href="1Lab.Path.html#40307" data-type="(p : x ≡ y) (q : y ≡ z) → Square (sym p) q (p ∙ q) refl" class="Function">∙-filler&#39;</a> <a id="4687" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="4692" href="1Lab.Path.Groupoid.html#4668" class="Bound">p</a><a id="4693" class="Symbol">)</a>
</pre>
<p>For associativity, we use both:</p>
<pre class="Agda">  <a id="4743" href="1Lab.Path.Groupoid.html#4743" data-type="(p : w ≡ x) (q : x ≡ y) (r : y ≡ z) → p ∙ q ∙ r ≡ (p ∙ q) ∙ r" class="Function">∙-assoc</a> <a id="4751" class="Symbol">:</a> <a id="4753" class="Symbol">(</a><a id="4754" href="1Lab.Path.Groupoid.html#4754" class="Bound">p</a> <a id="4756" class="Symbol">:</a> <a id="4758" href="1Lab.Path.Groupoid.html#4402" class="Generalizable">w</a> <a id="4760" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="4762" href="1Lab.Path.Groupoid.html#4404" class="Generalizable">x</a><a id="4763" class="Symbol">)</a> <a id="4765" class="Symbol">(</a><a id="4766" href="1Lab.Path.Groupoid.html#4766" class="Bound">q</a> <a id="4768" class="Symbol">:</a> <a id="4770" href="1Lab.Path.Groupoid.html#4404" class="Generalizable">x</a> <a id="4772" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="4774" href="1Lab.Path.Groupoid.html#4406" class="Generalizable">y</a><a id="4775" class="Symbol">)</a> <a id="4777" class="Symbol">(</a><a id="4778" href="1Lab.Path.Groupoid.html#4778" class="Bound">r</a> <a id="4780" class="Symbol">:</a> <a id="4782" href="1Lab.Path.Groupoid.html#4406" class="Generalizable">y</a> <a id="4784" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="4786" href="1Lab.Path.Groupoid.html#4408" class="Generalizable">z</a><a id="4787" class="Symbol">)</a>
          <a id="4799" class="Symbol">→</a> <a id="4801" href="1Lab.Path.Groupoid.html#4754" class="Bound">p</a> <a id="4803" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="4805" class="Symbol">(</a><a id="4806" href="1Lab.Path.Groupoid.html#4766" class="Bound">q</a> <a id="4808" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="4810" href="1Lab.Path.Groupoid.html#4778" class="Bound">r</a><a id="4811" class="Symbol">)</a> <a id="4813" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="4815" class="Symbol">(</a><a id="4816" href="1Lab.Path.Groupoid.html#4754" class="Bound">p</a> <a id="4818" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="4820" href="1Lab.Path.Groupoid.html#4766" class="Bound">q</a><a id="4821" class="Symbol">)</a> <a id="4823" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="4825" href="1Lab.Path.Groupoid.html#4778" class="Bound">r</a>
  <a id="4829" href="1Lab.Path.Groupoid.html#4743" data-type="(p : w ≡ x) (q : x ≡ y) (r : y ≡ z) → p ∙ q ∙ r ≡ (p ∙ q) ∙ r" class="Function">∙-assoc</a> <a id="4837" href="1Lab.Path.Groupoid.html#4837" class="Bound">p</a> <a id="4839" href="1Lab.Path.Groupoid.html#4839" class="Bound">q</a> <a id="4841" href="1Lab.Path.Groupoid.html#4841" class="Bound">r</a> <a id="4843" href="1Lab.Path.Groupoid.html#4843" class="Bound">i</a> <a id="4845" class="Symbol">=</a> <a id="4847" href="1Lab.Path.html#39808" data-type="(p : x ≡ y) (q : y ≡ z) → Square refl p (p ∙ q) q" class="Function">∙-filler</a> <a id="4856" href="1Lab.Path.Groupoid.html#4837" class="Bound">p</a> <a id="4858" href="1Lab.Path.Groupoid.html#4839" class="Bound">q</a> <a id="4860" href="1Lab.Path.Groupoid.html#4843" class="Bound">i</a> <a id="4862" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="4864" href="1Lab.Path.html#40307" data-type="(p : x ≡ y) (q : y ≡ z) → Square (sym p) q (p ∙ q) refl" class="Function">∙-filler&#39;</a> <a id="4874" href="1Lab.Path.Groupoid.html#4839" class="Bound">q</a> <a id="4876" href="1Lab.Path.Groupoid.html#4841" class="Bound">r</a> <a id="4878" class="Symbol">(</a><a id="4879" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="4881" href="1Lab.Path.Groupoid.html#4843" class="Bound">i</a><a id="4882" class="Symbol">)</a>
</pre>
<p>For cancellation, we need to sketch an open cube where the missing
square expresses the equation we’re looking for. Thankfully, we only
have to do this once!</p>
<pre class="Agda">  <a id="5058" href="1Lab.Path.Groupoid.html#5058" data-type="(p : x ≡ y) → p ∙ sym p ≡ refl" class="Function">∙-inv-r</a> <a id="5066" class="Symbol">:</a> <a id="5068" class="Symbol">∀</a> <a id="5070" class="Symbol">{</a><a id="5071" href="1Lab.Path.Groupoid.html#5071" class="Bound">x</a> <a id="5073" href="1Lab.Path.Groupoid.html#5073" class="Bound">y</a> <a id="5075" class="Symbol">:</a> <a id="5077" href="1Lab.Path.Groupoid.html#4385" class="Generalizable">A</a><a id="5078" class="Symbol">}</a> <a id="5080" class="Symbol">(</a><a id="5081" href="1Lab.Path.Groupoid.html#5081" class="Bound">p</a> <a id="5083" class="Symbol">:</a> <a id="5085" href="1Lab.Path.Groupoid.html#5071" class="Bound">x</a> <a id="5087" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="5089" href="1Lab.Path.Groupoid.html#5073" class="Bound">y</a><a id="5090" class="Symbol">)</a> <a id="5092" class="Symbol">→</a> <a id="5094" href="1Lab.Path.Groupoid.html#5081" class="Bound">p</a> <a id="5096" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="5098" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="5102" href="1Lab.Path.Groupoid.html#5081" class="Bound">p</a> <a id="5104" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="5106" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
  <a id="5113" href="1Lab.Path.Groupoid.html#5058" data-type="(p : x ≡ y) → p ∙ sym p ≡ refl" class="Function">∙-inv-r</a> <a id="5121" class="Symbol">{</a><a id="5122" class="Argument">x</a> <a id="5124" class="Symbol">=</a> <a id="5126" href="1Lab.Path.Groupoid.html#5126" class="Bound">x</a><a id="5127" class="Symbol">}</a> <a id="5129" href="1Lab.Path.Groupoid.html#5129" class="Bound">p</a> <a id="5131" href="1Lab.Path.Groupoid.html#5131" class="Bound">i</a> <a id="5133" href="1Lab.Path.Groupoid.html#5133" class="Bound">j</a> <a id="5135" class="Symbol">=</a>
    <a id="5141" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="5147" class="Symbol">(λ</a> <a id="5150" href="1Lab.Path.Groupoid.html#5150" class="Bound">l</a> <a id="5152" class="Symbol">→</a> <a id="5154" class="Symbol">λ</a> <a id="5156" class="Symbol">{</a> <a id="5158" class="Symbol">(</a><a id="5159" href="1Lab.Path.Groupoid.html#5133" class="Bound">j</a> <a id="5161" class="Symbol">=</a> <a id="5163" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="5165" class="Symbol">)</a> <a id="5167" class="Symbol">→</a> <a id="5169" href="1Lab.Path.Groupoid.html#5126" class="Bound">x</a>
                   <a id="5190" class="Symbol">;</a> <a id="5192" class="Symbol">(</a><a id="5193" href="1Lab.Path.Groupoid.html#5133" class="Bound">j</a> <a id="5195" class="Symbol">=</a> <a id="5197" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="5199" class="Symbol">)</a> <a id="5201" class="Symbol">→</a> <a id="5203" href="1Lab.Path.Groupoid.html#5129" class="Bound">p</a> <a id="5205" class="Symbol">(</a><a id="5206" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="5208" href="1Lab.Path.Groupoid.html#5150" class="Bound">l</a> <a id="5210" href="1Lab.Path.html#2191" class="Primitive Operator">∧</a> <a id="5212" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="5214" href="1Lab.Path.Groupoid.html#5131" class="Bound">i</a><a id="5215" class="Symbol">)</a>
                   <a id="5236" class="Symbol">;</a> <a id="5238" class="Symbol">(</a><a id="5239" href="1Lab.Path.Groupoid.html#5131" class="Bound">i</a> <a id="5241" class="Symbol">=</a> <a id="5243" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="5245" class="Symbol">)</a> <a id="5247" class="Symbol">→</a> <a id="5249" href="1Lab.Path.Groupoid.html#5126" class="Bound">x</a>
                   <a id="5270" class="Symbol">})</a>
          <a id="5283" class="Symbol">(</a><a id="5284" href="1Lab.Path.Groupoid.html#5129" class="Bound">p</a> <a id="5286" class="Symbol">(</a><a id="5287" href="1Lab.Path.Groupoid.html#5133" class="Bound">j</a> <a id="5289" href="1Lab.Path.html#2191" class="Primitive Operator">∧</a> <a id="5291" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="5293" href="1Lab.Path.Groupoid.html#5131" class="Bound">i</a><a id="5294" class="Symbol">))</a>
</pre>
<p>For the other direction, we use the fact that <code>p</code> is
definitionally equal to <code>sym (sym p)</code>. In that case, we show
that <code>sym p ∙ sym (sym p) ≡ refl</code> - which computes to the
thing we want!</p>
<pre class="Agda">  <a id="5500" href="1Lab.Path.Groupoid.html#5500" data-type="(p : x ≡ y) → sym p ∙ p ≡ refl" class="Function">∙-inv-l</a> <a id="5508" class="Symbol">:</a> <a id="5510" class="Symbol">(</a><a id="5511" href="1Lab.Path.Groupoid.html#5511" class="Bound">p</a> <a id="5513" class="Symbol">:</a> <a id="5515" href="1Lab.Path.Groupoid.html#4404" class="Generalizable">x</a> <a id="5517" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="5519" href="1Lab.Path.Groupoid.html#4406" class="Generalizable">y</a><a id="5520" class="Symbol">)</a> <a id="5522" class="Symbol">→</a> <a id="5524" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="5528" href="1Lab.Path.Groupoid.html#5511" class="Bound">p</a> <a id="5530" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="5532" href="1Lab.Path.Groupoid.html#5511" class="Bound">p</a> <a id="5534" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="5536" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
  <a id="5543" href="1Lab.Path.Groupoid.html#5500" data-type="(p : x ≡ y) → sym p ∙ p ≡ refl" class="Function">∙-inv-l</a> <a id="5551" href="1Lab.Path.Groupoid.html#5551" class="Bound">p</a> <a id="5553" class="Symbol">=</a> <a id="5555" href="1Lab.Path.Groupoid.html#5058" data-type="(p : x ≡ y) → p ∙ sym p ≡ refl" class="Function">∙-inv-r</a> <a id="5563" class="Symbol">(</a><a id="5564" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="5568" href="1Lab.Path.Groupoid.html#5551" class="Bound">p</a><a id="5569" class="Symbol">)</a>
</pre>
<p>In addition to the groupoid identities for paths in a type, it has
been established that functions behave like functors: These are the
lemmas
<span class="Agda"><a href="1Lab.Path.html#21984" class="Function">ap-refl</a></span>
and
<span class="Agda"><a href="1Lab.Path.html#21894" class="Function">ap-sym</a></span>
in the <a href="1Lab.Path.html#the-action-on-paths">1Lab.Path</a>
module.</p>
<p>There, a proof that functions preserve path composition wasn’t
included, because it needs
<span class="Agda"><a href="1Lab.Path.html#2368" class="Primitive">hcomp</a></span>
to be defined. We fill a cube where the left face is defined to be
<code>ap f (p ∙ q)</code> (that’s the <code>(i = i0)</code> face in the
<span class="Agda"><a href="1Lab.Path.html#2368" class="Primitive">hcomp</a></span>
below), and the remaining structure of the proof mimics the definition
of
<span class="Agda"><a href="1Lab.Path.html#39460" class="Function Operator">_∙_</a></span>,
so that we indeed get <code>ap f p ∙ ap f q</code> as the right
face.</p>
<!--
<pre class="Agda">  <a id="6228" href="1Lab.Path.Groupoid.html#6228" class="Function">_</a> <a id="6230" class="Symbol">=</a> <a id="6232" href="1Lab.Path.html#21984" data-type="ap f (λ i → x) ≡ (λ i → f x)" class="Function">ap-refl</a>
  <a id="6242" href="1Lab.Path.Groupoid.html#6242" class="Function">_</a> <a id="6244" class="Symbol">=</a> <a id="6246" href="1Lab.Path.html#21894" data-type="sym (ap f p) ≡ ap f (sym p)" class="Function">ap-sym</a>
</pre>-->
<pre class="Agda">  <a id="6272" href="1Lab.Path.Groupoid.html#6272" data-type="(f : A → B₁) (p : x ≡ y) (q : y ≡ z) →
ap f (p ∙ q) ≡ ap f p ∙ ap f q" class="Function">ap-comp-path</a> <a id="6285" class="Symbol">:</a> <a id="6287" class="Symbol">(</a><a id="6288" href="1Lab.Path.Groupoid.html#6288" class="Bound">f</a> <a id="6290" class="Symbol">:</a> <a id="6292" href="1Lab.Path.Groupoid.html#4385" class="Generalizable">A</a> <a id="6294" class="Symbol">→</a> <a id="6296" href="1Lab.Path.Groupoid.html#4387" class="Generalizable">B</a><a id="6297" class="Symbol">)</a> <a id="6299" class="Symbol">{</a><a id="6300" href="1Lab.Path.Groupoid.html#6300" class="Bound">x</a> <a id="6302" href="1Lab.Path.Groupoid.html#6302" class="Bound">y</a> <a id="6304" href="1Lab.Path.Groupoid.html#6304" class="Bound">z</a> <a id="6306" class="Symbol">:</a> <a id="6308" href="1Lab.Path.Groupoid.html#4385" class="Generalizable">A</a><a id="6309" class="Symbol">}</a> <a id="6311" class="Symbol">(</a><a id="6312" href="1Lab.Path.Groupoid.html#6312" class="Bound">p</a> <a id="6314" class="Symbol">:</a> <a id="6316" href="1Lab.Path.Groupoid.html#6300" class="Bound">x</a> <a id="6318" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="6320" href="1Lab.Path.Groupoid.html#6302" class="Bound">y</a><a id="6321" class="Symbol">)</a> <a id="6323" class="Symbol">(</a><a id="6324" href="1Lab.Path.Groupoid.html#6324" class="Bound">q</a> <a id="6326" class="Symbol">:</a> <a id="6328" href="1Lab.Path.Groupoid.html#6302" class="Bound">y</a> <a id="6330" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="6332" href="1Lab.Path.Groupoid.html#6304" class="Bound">z</a><a id="6333" class="Symbol">)</a>
               <a id="6350" class="Symbol">→</a> <a id="6352" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="6355" href="1Lab.Path.Groupoid.html#6288" class="Bound">f</a> <a id="6357" class="Symbol">(</a><a id="6358" href="1Lab.Path.Groupoid.html#6312" class="Bound">p</a> <a id="6360" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="6362" href="1Lab.Path.Groupoid.html#6324" class="Bound">q</a><a id="6363" class="Symbol">)</a> <a id="6365" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="6367" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="6370" href="1Lab.Path.Groupoid.html#6288" class="Bound">f</a> <a id="6372" href="1Lab.Path.Groupoid.html#6312" class="Bound">p</a> <a id="6374" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="6376" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="6379" href="1Lab.Path.Groupoid.html#6288" class="Bound">f</a> <a id="6381" href="1Lab.Path.Groupoid.html#6324" class="Bound">q</a>
  <a id="6385" href="1Lab.Path.Groupoid.html#6272" data-type="(f : A → B₁) (p : x ≡ y) (q : y ≡ z) →
ap f (p ∙ q) ≡ ap f p ∙ ap f q" class="Function">ap-comp-path</a> <a id="6398" href="1Lab.Path.Groupoid.html#6398" class="Bound">f</a> <a id="6400" class="Symbol">{</a><a id="6401" href="1Lab.Path.Groupoid.html#6401" class="Bound">x</a><a id="6402" class="Symbol">}</a> <a id="6404" href="1Lab.Path.Groupoid.html#6404" class="Bound">p</a> <a id="6406" href="1Lab.Path.Groupoid.html#6406" class="Bound">q</a> <a id="6408" href="1Lab.Path.Groupoid.html#6408" class="Bound">i</a> <a id="6410" href="1Lab.Path.Groupoid.html#6410" class="Bound">j</a> <a id="6412" class="Symbol">=</a>
    <a id="6418" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="6424" class="Symbol">(λ</a> <a id="6427" href="1Lab.Path.Groupoid.html#6427" class="Bound">k</a> <a id="6429" class="Symbol">→</a> <a id="6431" class="Symbol">λ</a> <a id="6433" class="Symbol">{</a> <a id="6435" class="Symbol">(</a><a id="6436" href="1Lab.Path.Groupoid.html#6408" class="Bound">i</a> <a id="6438" class="Symbol">=</a> <a id="6440" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="6442" class="Symbol">)</a> <a id="6444" class="Symbol">→</a> <a id="6446" href="1Lab.Path.Groupoid.html#6398" class="Bound">f</a> <a id="6448" class="Symbol">(</a><a id="6449" href="1Lab.Path.html#39808" data-type="(p : x ≡ y) (q : y ≡ z) → Square refl p (p ∙ q) q" class="Function">∙-filler</a> <a id="6458" href="1Lab.Path.Groupoid.html#6404" class="Bound">p</a> <a id="6460" href="1Lab.Path.Groupoid.html#6406" class="Bound">q</a> <a id="6462" href="1Lab.Path.Groupoid.html#6427" class="Bound">k</a> <a id="6464" href="1Lab.Path.Groupoid.html#6410" class="Bound">j</a><a id="6465" class="Symbol">)</a>
                   <a id="6486" class="Symbol">;</a> <a id="6488" class="Symbol">(</a><a id="6489" href="1Lab.Path.Groupoid.html#6410" class="Bound">j</a> <a id="6491" class="Symbol">=</a> <a id="6493" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="6495" class="Symbol">)</a> <a id="6497" class="Symbol">→</a> <a id="6499" href="1Lab.Path.Groupoid.html#6398" class="Bound">f</a> <a id="6501" href="1Lab.Path.Groupoid.html#6401" class="Bound">x</a>
                   <a id="6522" class="Symbol">;</a> <a id="6524" class="Symbol">(</a><a id="6525" href="1Lab.Path.Groupoid.html#6410" class="Bound">j</a> <a id="6527" class="Symbol">=</a> <a id="6529" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="6531" class="Symbol">)</a> <a id="6533" class="Symbol">→</a> <a id="6535" href="1Lab.Path.Groupoid.html#6398" class="Bound">f</a> <a id="6537" class="Symbol">(</a><a id="6538" href="1Lab.Path.Groupoid.html#6406" class="Bound">q</a> <a id="6540" href="1Lab.Path.Groupoid.html#6427" class="Bound">k</a><a id="6541" class="Symbol">)</a>
                   <a id="6562" class="Symbol">})</a>
          <a id="6575" class="Symbol">(</a><a id="6576" href="1Lab.Path.Groupoid.html#6398" class="Bound">f</a> <a id="6578" class="Symbol">(</a><a id="6579" href="1Lab.Path.Groupoid.html#6404" class="Bound">p</a> <a id="6581" href="1Lab.Path.Groupoid.html#6410" class="Bound">j</a><a id="6582" class="Symbol">))</a>
</pre>
<h3 id="convenient-helpers"><a href="#convenient-helpers" class="header-link">Convenient
helpers<span class="header-link-emoji">🔗</span></a></h3>
<p>Since a <em>lot</em> of Homotopy Type Theory is dealing with paths,
this section introduces useful helpers for dealing with
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>-ary</span>
compositions. For instance, we know that
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>p</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>∙</mo><mi>p</mi><mo>∙</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">p^{-1} ∙ p ∙ q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0085em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∙</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∙</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span>
is
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span>,</span>
but this involves more than a handful of intermediate steps:</p>
<pre class="Agda">  <a id="6877" href="1Lab.Path.Groupoid.html#6877" data-type="(p : x ≡ y) (q : y ≡ z) → sym p ∙ p ∙ q ≡ q" class="Function">∙-cancel-l</a> <a id="6888" class="Symbol">:</a> <a id="6890" class="Symbol">{</a><a id="6891" href="1Lab.Path.Groupoid.html#6891" class="Bound">x</a> <a id="6893" href="1Lab.Path.Groupoid.html#6893" class="Bound">y</a> <a id="6895" href="1Lab.Path.Groupoid.html#6895" class="Bound">z</a> <a id="6897" class="Symbol">:</a> <a id="6899" href="1Lab.Path.Groupoid.html#4385" class="Generalizable">A</a><a id="6900" class="Symbol">}</a> <a id="6902" class="Symbol">(</a><a id="6903" href="1Lab.Path.Groupoid.html#6903" class="Bound">p</a> <a id="6905" class="Symbol">:</a> <a id="6907" href="1Lab.Path.Groupoid.html#6891" class="Bound">x</a> <a id="6909" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="6911" href="1Lab.Path.Groupoid.html#6893" class="Bound">y</a><a id="6912" class="Symbol">)</a> <a id="6914" class="Symbol">(</a><a id="6915" href="1Lab.Path.Groupoid.html#6915" class="Bound">q</a> <a id="6917" class="Symbol">:</a> <a id="6919" href="1Lab.Path.Groupoid.html#6893" class="Bound">y</a> <a id="6921" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="6923" href="1Lab.Path.Groupoid.html#6895" class="Bound">z</a><a id="6924" class="Symbol">)</a>
             <a id="6939" class="Symbol">→</a> <a id="6941" class="Symbol">(</a><a id="6942" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="6946" href="1Lab.Path.Groupoid.html#6903" class="Bound">p</a> <a id="6948" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="6950" href="1Lab.Path.Groupoid.html#6903" class="Bound">p</a> <a id="6952" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="6954" href="1Lab.Path.Groupoid.html#6915" class="Bound">q</a><a id="6955" class="Symbol">)</a> <a id="6957" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="6959" href="1Lab.Path.Groupoid.html#6915" class="Bound">q</a>
  <a id="6963" href="1Lab.Path.Groupoid.html#6877" data-type="(p : x ≡ y) (q : y ≡ z) → sym p ∙ p ∙ q ≡ q" class="Function">∙-cancel-l</a> <a id="6974" href="1Lab.Path.Groupoid.html#6974" class="Bound">p</a> <a id="6976" href="1Lab.Path.Groupoid.html#6976" class="Bound">q</a> <a id="6978" class="Symbol">=</a>
    <a id="6984" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="6988" href="1Lab.Path.Groupoid.html#6974" class="Bound">p</a> <a id="6990" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="6992" href="1Lab.Path.Groupoid.html#6974" class="Bound">p</a> <a id="6994" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="6996" href="1Lab.Path.Groupoid.html#6976" class="Bound">q</a>   <span class="reasoning-step"><span class="as-written Function"><a id="7000" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="7003" href="1Lab.Path.Groupoid.html#4743" data-type="(p : w ≡ x) (q : x ≡ y) (r : y ≡ z) → p ∙ q ∙ r ≡ (p ∙ q) ∙ r" class="Function">∙-assoc</a> <a id="7011" class="Symbol">_</a> <a id="7013" class="Symbol">_</a> <a id="7015" class="Symbol">_</a> <a id="7017" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="7023" class="Symbol">(</a><a id="7024" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="7028" href="1Lab.Path.Groupoid.html#6974" class="Bound">p</a> <a id="7030" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="7032" href="1Lab.Path.Groupoid.html#6974" class="Bound">p</a><a id="7033" class="Symbol">)</a> <a id="7035" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="7037" href="1Lab.Path.Groupoid.html#6976" class="Bound">q</a> <span class="reasoning-step"><span class="as-written Function"><a id="7039" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="7042" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="7046" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">_∙_</a> <a id="7050" class="Symbol">(</a><a id="7051" href="1Lab.Path.Groupoid.html#5500" data-type="(p : x ≡ y) → sym p ∙ p ≡ refl" class="Function">∙-inv-l</a> <a id="7059" href="1Lab.Path.Groupoid.html#6974" class="Bound">p</a><a id="7060" class="Symbol">)</a> <a id="7062" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="7067" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="7073" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="7078" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="7080" href="1Lab.Path.Groupoid.html#6976" class="Bound">q</a>        <span class="reasoning-step"><span class="as-written Function"><a id="7089" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="7092" href="1Lab.Path.Groupoid.html#4623" data-type="(p : x ≡ y) → refl ∙ p ≡ p" class="Function">∙-id-l</a> <a id="7099" href="1Lab.Path.Groupoid.html#6976" class="Bound">q</a> <a id="7101" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="7107" href="1Lab.Path.Groupoid.html#6976" class="Bound">q</a>               <a id="7123" href="1Lab.Path.html#46945" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>

  <a id="7128" href="1Lab.Path.Groupoid.html#7128" data-type="(p : x ≡ y) (q r : y ≡ z) → p ∙ q ≡ p ∙ r → q ≡ r" class="Function">∙-cancel&#39;-l</a> <a id="7140" class="Symbol">:</a> <a id="7142" class="Symbol">{</a><a id="7143" href="1Lab.Path.Groupoid.html#7143" class="Bound">x</a> <a id="7145" href="1Lab.Path.Groupoid.html#7145" class="Bound">y</a> <a id="7147" href="1Lab.Path.Groupoid.html#7147" class="Bound">z</a> <a id="7149" class="Symbol">:</a> <a id="7151" href="1Lab.Path.Groupoid.html#4385" class="Generalizable">A</a><a id="7152" class="Symbol">}</a> <a id="7154" class="Symbol">(</a><a id="7155" href="1Lab.Path.Groupoid.html#7155" class="Bound">p</a> <a id="7157" class="Symbol">:</a> <a id="7159" href="1Lab.Path.Groupoid.html#7143" class="Bound">x</a> <a id="7161" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="7163" href="1Lab.Path.Groupoid.html#7145" class="Bound">y</a><a id="7164" class="Symbol">)</a> <a id="7166" class="Symbol">(</a><a id="7167" href="1Lab.Path.Groupoid.html#7167" class="Bound">q</a> <a id="7169" href="1Lab.Path.Groupoid.html#7169" class="Bound">r</a> <a id="7171" class="Symbol">:</a> <a id="7173" href="1Lab.Path.Groupoid.html#7145" class="Bound">y</a> <a id="7175" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="7177" href="1Lab.Path.Groupoid.html#7147" class="Bound">z</a><a id="7178" class="Symbol">)</a>
              <a id="7194" class="Symbol">→</a> <a id="7196" href="1Lab.Path.Groupoid.html#7155" class="Bound">p</a> <a id="7198" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="7200" href="1Lab.Path.Groupoid.html#7167" class="Bound">q</a> <a id="7202" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="7204" href="1Lab.Path.Groupoid.html#7155" class="Bound">p</a> <a id="7206" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="7208" href="1Lab.Path.Groupoid.html#7169" class="Bound">r</a> <a id="7210" class="Symbol">→</a> <a id="7212" href="1Lab.Path.Groupoid.html#7167" class="Bound">q</a> <a id="7214" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="7216" href="1Lab.Path.Groupoid.html#7169" class="Bound">r</a>
  <a id="7220" href="1Lab.Path.Groupoid.html#7128" data-type="(p : x ≡ y) (q r : y ≡ z) → p ∙ q ≡ p ∙ r → q ≡ r" class="Function">∙-cancel&#39;-l</a> <a id="7232" class="Symbol">=</a> <a id="7234" href="1Lab.Path.html#19544" data-type="(P : (y : A) → x ≡ y → Type ℓ₂) → P x refl → (p : x ≡ y) → P y p" class="Function">J</a> <a id="7236" class="Symbol">(λ</a> <a id="7239" href="1Lab.Path.Groupoid.html#7239" class="Bound">y</a> <a id="7241" href="1Lab.Path.Groupoid.html#7241" class="Bound">p</a> <a id="7243" class="Symbol">→</a> <a id="7245" class="Symbol">(</a><a id="7246" href="1Lab.Path.Groupoid.html#7246" class="Bound">q</a> <a id="7248" href="1Lab.Path.Groupoid.html#7248" class="Bound">r</a> <a id="7250" class="Symbol">:</a> <a id="7252" href="1Lab.Path.Groupoid.html#7239" class="Bound">y</a> <a id="7254" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="7256" class="Symbol">_)</a> <a id="7259" class="Symbol">→</a> <a id="7261" href="1Lab.Path.Groupoid.html#7241" class="Bound">p</a> <a id="7263" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="7265" href="1Lab.Path.Groupoid.html#7246" class="Bound">q</a> <a id="7267" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="7269" href="1Lab.Path.Groupoid.html#7241" class="Bound">p</a> <a id="7271" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="7273" href="1Lab.Path.Groupoid.html#7248" class="Bound">r</a> <a id="7275" class="Symbol">→</a> <a id="7277" href="1Lab.Path.Groupoid.html#7246" class="Bound">q</a> <a id="7279" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="7281" href="1Lab.Path.Groupoid.html#7248" class="Bound">r</a><a id="7282" class="Symbol">)</a>
                  <a id="7302" class="Symbol">(λ</a> <a id="7305" href="1Lab.Path.Groupoid.html#7305" class="Bound">q</a> <a id="7307" href="1Lab.Path.Groupoid.html#7307" class="Bound">r</a> <a id="7309" href="1Lab.Path.Groupoid.html#7309" class="Bound">proof</a> <a id="7315" class="Symbol">→</a> <a id="7317" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="7321" class="Symbol">(</a><a id="7322" href="1Lab.Path.Groupoid.html#4623" data-type="(p : x ≡ y) → refl ∙ p ≡ p" class="Function">∙-id-l</a> <a id="7329" href="1Lab.Path.Groupoid.html#7305" class="Bound">q</a><a id="7330" class="Symbol">)</a> <a id="7332" href="1Lab.Path.html#38293" data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" class="Function Operator">··</a> <a id="7335" href="1Lab.Path.Groupoid.html#7309" class="Bound">proof</a> <a id="7341" href="1Lab.Path.html#38293" data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" class="Function Operator">··</a> <a id="7344" href="1Lab.Path.Groupoid.html#4623" data-type="(p : x ≡ y) → refl ∙ p ≡ p" class="Function">∙-id-l</a> <a id="7351" href="1Lab.Path.Groupoid.html#7307" class="Bound">r</a><a id="7352" class="Symbol">)</a>

  <a id="7357" href="1Lab.Path.Groupoid.html#7357" data-type="(p : y ≡ z) (q r : x ≡ y) → q ∙ p ≡ r ∙ p → q ≡ r" class="Function">∙-cancel&#39;-r</a> <a id="7369" class="Symbol">:</a> <a id="7371" class="Symbol">{</a><a id="7372" href="1Lab.Path.Groupoid.html#7372" class="Bound">x</a> <a id="7374" href="1Lab.Path.Groupoid.html#7374" class="Bound">y</a> <a id="7376" href="1Lab.Path.Groupoid.html#7376" class="Bound">z</a> <a id="7378" class="Symbol">:</a> <a id="7380" href="1Lab.Path.Groupoid.html#4385" class="Generalizable">A</a><a id="7381" class="Symbol">}</a> <a id="7383" class="Symbol">(</a><a id="7384" href="1Lab.Path.Groupoid.html#7384" class="Bound">p</a> <a id="7386" class="Symbol">:</a> <a id="7388" href="1Lab.Path.Groupoid.html#7374" class="Bound">y</a> <a id="7390" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="7392" href="1Lab.Path.Groupoid.html#7376" class="Bound">z</a><a id="7393" class="Symbol">)</a> <a id="7395" class="Symbol">(</a><a id="7396" href="1Lab.Path.Groupoid.html#7396" class="Bound">q</a> <a id="7398" href="1Lab.Path.Groupoid.html#7398" class="Bound">r</a> <a id="7400" class="Symbol">:</a> <a id="7402" href="1Lab.Path.Groupoid.html#7372" class="Bound">x</a> <a id="7404" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="7406" href="1Lab.Path.Groupoid.html#7374" class="Bound">y</a><a id="7407" class="Symbol">)</a>
              <a id="7423" class="Symbol">→</a> <a id="7425" href="1Lab.Path.Groupoid.html#7396" class="Bound">q</a> <a id="7427" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="7429" href="1Lab.Path.Groupoid.html#7384" class="Bound">p</a> <a id="7431" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="7433" href="1Lab.Path.Groupoid.html#7398" class="Bound">r</a> <a id="7435" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="7437" href="1Lab.Path.Groupoid.html#7384" class="Bound">p</a> <a id="7439" class="Symbol">→</a> <a id="7441" href="1Lab.Path.Groupoid.html#7396" class="Bound">q</a> <a id="7443" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="7445" href="1Lab.Path.Groupoid.html#7398" class="Bound">r</a>
  <a id="7449" href="1Lab.Path.Groupoid.html#7357" data-type="(p : y ≡ z) (q r : x ≡ y) → q ∙ p ≡ r ∙ p → q ≡ r" class="Function">∙-cancel&#39;-r</a> <a id="7461" class="Symbol">=</a> <a id="7463" href="1Lab.Path.html#19544" data-type="(P : (y : A) → x ≡ y → Type ℓ₂) → P x refl → (p : x ≡ y) → P y p" class="Function">J</a> <a id="7465" class="Symbol">(λ</a> <a id="7468" href="1Lab.Path.Groupoid.html#7468" class="Bound">y</a> <a id="7470" href="1Lab.Path.Groupoid.html#7470" class="Bound">p</a> <a id="7472" class="Symbol">→</a> <a id="7474" class="Symbol">(</a><a id="7475" href="1Lab.Path.Groupoid.html#7475" class="Bound">q</a> <a id="7477" href="1Lab.Path.Groupoid.html#7477" class="Bound">r</a> <a id="7479" class="Symbol">:</a> <a id="7481" class="Symbol">_</a> <a id="7483" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="7485" class="Symbol">_)</a> <a id="7488" class="Symbol">→</a> <a id="7490" href="1Lab.Path.Groupoid.html#7475" class="Bound">q</a> <a id="7492" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="7494" href="1Lab.Path.Groupoid.html#7470" class="Bound">p</a> <a id="7496" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="7498" href="1Lab.Path.Groupoid.html#7477" class="Bound">r</a> <a id="7500" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="7502" href="1Lab.Path.Groupoid.html#7470" class="Bound">p</a> <a id="7504" class="Symbol">→</a> <a id="7506" href="1Lab.Path.Groupoid.html#7475" class="Bound">q</a> <a id="7508" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="7510" href="1Lab.Path.Groupoid.html#7477" class="Bound">r</a><a id="7511" class="Symbol">)</a>
                  <a id="7531" class="Symbol">(λ</a> <a id="7534" href="1Lab.Path.Groupoid.html#7534" class="Bound">q</a> <a id="7536" href="1Lab.Path.Groupoid.html#7536" class="Bound">r</a> <a id="7538" href="1Lab.Path.Groupoid.html#7538" class="Bound">proof</a> <a id="7544" class="Symbol">→</a> <a id="7546" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="7550" class="Symbol">(</a><a id="7551" href="1Lab.Path.Groupoid.html#4549" data-type="(p : x ≡ y) → p ∙ refl ≡ p" class="Function">∙-id-r</a> <a id="7558" href="1Lab.Path.Groupoid.html#7534" class="Bound">q</a><a id="7559" class="Symbol">)</a> <a id="7561" href="1Lab.Path.html#38293" data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" class="Function Operator">··</a> <a id="7564" href="1Lab.Path.Groupoid.html#7538" class="Bound">proof</a> <a id="7570" href="1Lab.Path.html#38293" data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" class="Function Operator">··</a> <a id="7573" href="1Lab.Path.Groupoid.html#4549" data-type="(p : x ≡ y) → p ∙ refl ≡ p" class="Function">∙-id-r</a> <a id="7580" href="1Lab.Path.Groupoid.html#7536" class="Bound">r</a><a id="7581" class="Symbol">)</a>
</pre>
<h1 id="groupoid-structure-of-types-cont."><a href="#groupoid-structure-of-types-cont." class="header-link">Groupoid
structure of types
(cont.)<span class="header-link-emoji">🔗</span></a></h1>
<p>A useful fact is that if
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span>
is a homotopy <code>f ~ id</code>, then we can “invert” it as such:</p>
<pre class="Agda"><a id="7722" class="Keyword">open</a> <a id="7727" href="1Lab.Path.html" class="Module">1Lab.Path</a>

<a id="homotopy-invert"></a><a id="7738" href="1Lab.Path.Groupoid.html#7738" data-type="(H : (x : A) → f x ≡ x) → H (f x) ≡ ap f (H x)" class="Function">homotopy-invert</a> <a id="7754" class="Symbol">:</a> <a id="7756" class="Symbol">∀</a> <a id="7758" class="Symbol">{</a><a id="7759" href="1Lab.Path.Groupoid.html#7759" class="Bound">a</a><a id="7760" class="Symbol">}</a> <a id="7762" class="Symbol">{</a><a id="7763" href="1Lab.Path.Groupoid.html#7763" class="Bound">A</a> <a id="7765" class="Symbol">:</a> <a id="7767" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="7772" href="1Lab.Path.Groupoid.html#7759" class="Bound">a</a><a id="7773" class="Symbol">}</a> <a id="7775" class="Symbol">{</a><a id="7776" href="1Lab.Path.Groupoid.html#7776" class="Bound">f</a> <a id="7778" class="Symbol">:</a> <a id="7780" href="1Lab.Path.Groupoid.html#7763" class="Bound">A</a> <a id="7782" class="Symbol">→</a> <a id="7784" href="1Lab.Path.Groupoid.html#7763" class="Bound">A</a><a id="7785" class="Symbol">}</a>
                <a id="7803" class="Symbol">→</a> <a id="7805" class="Symbol">(</a><a id="7806" href="1Lab.Path.Groupoid.html#7806" class="Bound">H</a> <a id="7808" class="Symbol">:</a> <a id="7810" class="Symbol">(</a><a id="7811" href="1Lab.Path.Groupoid.html#7811" class="Bound">x</a> <a id="7813" class="Symbol">:</a> <a id="7815" href="1Lab.Path.Groupoid.html#7763" class="Bound">A</a><a id="7816" class="Symbol">)</a> <a id="7818" class="Symbol">→</a> <a id="7820" href="1Lab.Path.Groupoid.html#7776" class="Bound">f</a> <a id="7822" href="1Lab.Path.Groupoid.html#7811" class="Bound">x</a> <a id="7824" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="7826" href="1Lab.Path.Groupoid.html#7811" class="Bound">x</a><a id="7827" class="Symbol">)</a> <a id="7829" class="Symbol">{</a><a id="7830" href="1Lab.Path.Groupoid.html#7830" class="Bound">x</a> <a id="7832" class="Symbol">:</a> <a id="7834" href="1Lab.Path.Groupoid.html#7763" class="Bound">A</a><a id="7835" class="Symbol">}</a>
                <a id="7853" class="Symbol">→</a> <a id="7855" href="1Lab.Path.Groupoid.html#7806" class="Bound">H</a> <a id="7857" class="Symbol">(</a><a id="7858" href="1Lab.Path.Groupoid.html#7776" class="Bound">f</a> <a id="7860" href="1Lab.Path.Groupoid.html#7830" class="Bound">x</a><a id="7861" class="Symbol">)</a> <a id="7863" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="7865" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="7868" href="1Lab.Path.Groupoid.html#7776" class="Bound">f</a> <a id="7870" class="Symbol">(</a><a id="7871" href="1Lab.Path.Groupoid.html#7806" class="Bound">H</a> <a id="7873" href="1Lab.Path.Groupoid.html#7830" class="Bound">x</a><a id="7874" class="Symbol">)</a>
<a id="7876" href="1Lab.Path.Groupoid.html#7738" data-type="(H : (x : A) → f x ≡ x) → H (f x) ≡ ap f (H x)" class="Function">homotopy-invert</a> <a id="7892" class="Symbol">{</a><a id="7893" class="Argument">f</a> <a id="7895" class="Symbol">=</a> <a id="7897" href="1Lab.Path.Groupoid.html#7897" class="Bound">f</a><a id="7898" class="Symbol">}</a> <a id="7900" href="1Lab.Path.Groupoid.html#7900" class="Bound">H</a> <a id="7902" class="Symbol">{</a><a id="7903" class="Argument">x</a> <a id="7905" class="Symbol">=</a> <a id="7907" href="1Lab.Path.Groupoid.html#7907" class="Bound">x</a><a id="7908" class="Symbol">}</a> <a id="7910" class="Symbol">=</a>
  <a id="7914" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="7918" class="Symbol">(</a>
    <a id="7924" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="7927" href="1Lab.Path.Groupoid.html#7897" class="Bound">f</a> <a id="7929" class="Symbol">(</a><a id="7930" href="1Lab.Path.Groupoid.html#7900" class="Bound">H</a> <a id="7932" href="1Lab.Path.Groupoid.html#7907" class="Bound">x</a><a id="7933" class="Symbol">)</a>                     <span class="reasoning-step"><span class="as-written Function"><a id="7955" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="7958" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="7962" class="Symbol">(</a><a id="7963" href="1Lab.Path.Groupoid.html#4549" data-type="(p : x ≡ y) → p ∙ refl ≡ p" class="Function">∙-id-r</a> <a id="7970" class="Symbol">_)</a> <a id="7973" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="7979" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="7982" href="1Lab.Path.Groupoid.html#7897" class="Bound">f</a> <a id="7984" class="Symbol">(</a><a id="7985" href="1Lab.Path.Groupoid.html#7900" class="Bound">H</a> <a id="7987" href="1Lab.Path.Groupoid.html#7907" class="Bound">x</a><a id="7988" class="Symbol">)</a> <a id="7990" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="7992" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>              <span class="reasoning-step"><span class="as-written Function"><a id="8010" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="8013" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="8017" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">_∙_</a> <a id="8021" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="8026" class="Symbol">(</a><a id="8027" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="8031" class="Symbol">(</a><a id="8032" href="1Lab.Path.Groupoid.html#5058" data-type="(p : x ≡ y) → p ∙ sym p ≡ refl" class="Function">∙-inv-r</a> <a id="8040" class="Symbol">_))</a> <a id="8044" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="8050" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="8053" href="1Lab.Path.Groupoid.html#7897" class="Bound">f</a> <a id="8055" class="Symbol">(</a><a id="8056" href="1Lab.Path.Groupoid.html#7900" class="Bound">H</a> <a id="8058" href="1Lab.Path.Groupoid.html#7907" class="Bound">x</a><a id="8059" class="Symbol">)</a> <a id="8061" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="8063" href="1Lab.Path.Groupoid.html#7900" class="Bound">H</a> <a id="8065" href="1Lab.Path.Groupoid.html#7907" class="Bound">x</a> <a id="8067" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="8069" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="8073" class="Symbol">(</a><a id="8074" href="1Lab.Path.Groupoid.html#7900" class="Bound">H</a> <a id="8076" href="1Lab.Path.Groupoid.html#7907" class="Bound">x</a><a id="8077" class="Symbol">)</a>   <span class="reasoning-step"><span class="as-written Function"><a id="8081" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="8084" href="1Lab.Path.Groupoid.html#4743" data-type="(p : w ≡ x) (q : x ≡ y) (r : y ≡ z) → p ∙ q ∙ r ≡ (p ∙ q) ∙ r" class="Function">∙-assoc</a> <a id="8092" class="Symbol">_</a> <a id="8094" class="Symbol">_</a> <a id="8096" class="Symbol">_</a> <a id="8098" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="8104" class="Symbol">(</a><a id="8105" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="8108" href="1Lab.Path.Groupoid.html#7897" class="Bound">f</a> <a id="8110" class="Symbol">(</a><a id="8111" href="1Lab.Path.Groupoid.html#7900" class="Bound">H</a> <a id="8113" href="1Lab.Path.Groupoid.html#7907" class="Bound">x</a><a id="8114" class="Symbol">)</a> <a id="8116" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="8118" href="1Lab.Path.Groupoid.html#7900" class="Bound">H</a> <a id="8120" href="1Lab.Path.Groupoid.html#7907" class="Bound">x</a><a id="8121" class="Symbol">)</a> <a id="8123" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="8125" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="8129" class="Symbol">(</a><a id="8130" href="1Lab.Path.Groupoid.html#7900" class="Bound">H</a> <a id="8132" href="1Lab.Path.Groupoid.html#7907" class="Bound">x</a><a id="8133" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function"><a id="8135" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="8138" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="8142" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">_∙_</a> <a id="8146" class="Symbol">(</a><a id="8147" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="8151" class="Symbol">(</a><a id="8152" href="1Lab.Path.html#58886" data-type="(H : (x : A) → f x ≡ g x) (p : x ≡ y) → H x ∙ ap g p ≡ ap f p ∙ H y" class="Function">homotopy-natural</a> <a id="8169" href="1Lab.Path.Groupoid.html#7900" class="Bound">H</a> <a id="8171" class="Symbol">_))</a> <a id="8175" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="8180" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="8186" class="Symbol">(</a><a id="8187" href="1Lab.Path.Groupoid.html#7900" class="Bound">H</a> <a id="8189" class="Symbol">(</a><a id="8190" href="1Lab.Path.Groupoid.html#7897" class="Bound">f</a> <a id="8192" href="1Lab.Path.Groupoid.html#7907" class="Bound">x</a><a id="8193" class="Symbol">)</a> <a id="8195" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="8197" href="1Lab.Path.Groupoid.html#7900" class="Bound">H</a> <a id="8199" href="1Lab.Path.Groupoid.html#7907" class="Bound">x</a><a id="8200" class="Symbol">)</a> <a id="8202" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="8204" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="8208" class="Symbol">(</a><a id="8209" href="1Lab.Path.Groupoid.html#7900" class="Bound">H</a> <a id="8211" href="1Lab.Path.Groupoid.html#7907" class="Bound">x</a><a id="8212" class="Symbol">)</a>    <span class="reasoning-step"><span class="as-written Function"><a id="8217" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="8220" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="8224" class="Symbol">(</a><a id="8225" href="1Lab.Path.Groupoid.html#4743" data-type="(p : w ≡ x) (q : x ≡ y) (r : y ≡ z) → p ∙ q ∙ r ≡ (p ∙ q) ∙ r" class="Function">∙-assoc</a> <a id="8233" class="Symbol">_</a> <a id="8235" class="Symbol">_</a> <a id="8237" class="Symbol">_)</a> <a id="8240" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="8246" href="1Lab.Path.Groupoid.html#7900" class="Bound">H</a> <a id="8248" class="Symbol">(</a><a id="8249" href="1Lab.Path.Groupoid.html#7897" class="Bound">f</a> <a id="8251" href="1Lab.Path.Groupoid.html#7907" class="Bound">x</a><a id="8252" class="Symbol">)</a> <a id="8254" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="8256" href="1Lab.Path.Groupoid.html#7900" class="Bound">H</a> <a id="8258" href="1Lab.Path.Groupoid.html#7907" class="Bound">x</a> <a id="8260" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="8262" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="8266" class="Symbol">(</a><a id="8267" href="1Lab.Path.Groupoid.html#7900" class="Bound">H</a> <a id="8269" href="1Lab.Path.Groupoid.html#7907" class="Bound">x</a><a id="8270" class="Symbol">)</a>      <span class="reasoning-step"><span class="as-written Function"><a id="8277" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="8280" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="8284" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">_∙_</a> <a id="8288" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="8293" class="Symbol">(</a><a id="8294" href="1Lab.Path.Groupoid.html#5058" data-type="(p : x ≡ y) → p ∙ sym p ≡ refl" class="Function">∙-inv-r</a> <a id="8302" class="Symbol">_)</a> <a id="8305" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="8311" href="1Lab.Path.Groupoid.html#7900" class="Bound">H</a> <a id="8313" class="Symbol">(</a><a id="8314" href="1Lab.Path.Groupoid.html#7897" class="Bound">f</a> <a id="8316" href="1Lab.Path.Groupoid.html#7907" class="Bound">x</a><a id="8317" class="Symbol">)</a> <a id="8319" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="8321" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>                 <span class="reasoning-step"><span class="as-written Function"><a id="8342" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="8345" href="1Lab.Path.Groupoid.html#4549" data-type="(p : x ≡ y) → p ∙ refl ≡ p" class="Function">∙-id-r</a> <a id="8352" class="Symbol">_</a> <a id="8354" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="8360" href="1Lab.Path.Groupoid.html#7900" class="Bound">H</a> <a id="8362" class="Symbol">(</a><a id="8363" href="1Lab.Path.Groupoid.html#7897" class="Bound">f</a> <a id="8365" href="1Lab.Path.Groupoid.html#7907" class="Bound">x</a><a id="8366" class="Symbol">)</a>                        <a id="8391" href="1Lab.Path.html#46945" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
  <a id="8395" class="Symbol">)</a>
</pre>
  </article>
</div>
</main>
</body>
</html>
