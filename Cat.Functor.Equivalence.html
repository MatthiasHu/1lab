<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="keywords" content="Agda,categories,topos" />

  <title>Cat.Functor.Equivalence - 1Lab</title>

  <link rel="stylesheet" href="/css/default.css" />
  <link rel="stylesheet" href="/css/katex.min.css" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Cat.Functor.Equivalence - 1Lab" />
  <meta name="twitter:image" content="https://1lab.dev/static/cube-128x.png" />

  <meta name="og:title" content="Cat.Functor.Equivalence - 1Lab" />
  <meta name="og:image" content="https://1lab.dev/static/cube-128x.png" />
  <meta name="og:site-name" content="1Lab" />
  <meta name="og:type" content="website" />

    <meta name="og:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="twitter:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  
  <script defer src="/main.js"></script>

  <noscript>
    <style>
      body span.reasoning-step .as-written {
        display: inline;
      }

      body span.reasoning-step .alternate {
        display: none;
      }
    </style>
  </noscript>

  <!-- Google font embeds -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;0,800;1,400;1,500;1,600;1,700;1,800&amp;family=Inria+Sans:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&amp;display=swap" rel="stylesheet">
</head>

<body class="text-page">
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <!-- Table of contents (only if the page has a table of contents) -->
    <aside id="toc">
    <div id="toc-container" style="min-width: 10em; font-size: 15pt;">
      <!-- Title for the page -->
      <h3 class="Agda" style="margin-top: 0; margin-bottom: 0; white-space: pre;">
                <a class="Module">Cat.Functor.Equivalence</a>
              </h3>

      <!-- Cube logo -->
      <a id="logo" href="/">
        <img alt="1Lab" src="/static/cube-72x.png" style="display: block; margin-bottom: 1em; margin: auto;" width="32px" height="32px" />
      </a>

      <!-- Actual table of contents (separated from the rest by
      horizontal rules) -->
      <hr />
      <ul>
      <li><a href="#equivalences"><a href="#equivalences" class="header-link">Equivalences<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#fully-faithful-essentially-surjective"><a href="#fully-faithful-essentially-surjective" class="header-link">Fully
      faithful, essentially
      surjective<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#between-categories"><a href="#between-categories" class="header-link">Between
      categories<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      <li><a href="#isomorphisms"><a href="#isomorphisms" class="header-link">Isomorphisms<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      </ul>
      <hr />

      <!-- Sidebar controls -->
      <div style="display: flex; gap: 0.25em; flex-flow: row wrap;">
        <!-- Sidebar equations control -->
        <span class="equations" style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-eqns" type="checkbox" class="equations" id="sidebar-eqns">
          <label for="sidebar-eqns">Equations</label>
        </span>

        <!-- Sidebar fonts control -->
        <span style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-font" type="checkbox" id="toggle-fonts">
          <label for="toggle-fonts">Serif Font</label>
        </span>

        <!-- Sidebar footnotes control -->
        <span class="inline-footnotes" style="display: none; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-fns" type="checkbox" class="inline-footnotes" id="sidebar-fns">
          <label for="sidebar-fns">Inline Footnotes</label>
        </span>
      </div>

      <hr />

      <!-- Navbar navigation (lol) -->
      <div id="return" style="white-space: nowrap;">
        <div class="search-form search-form-proxy" role="form">
          <input id="search-box-proxy" type_="text" placeholder="Search..." autocomplete="off" tabindex="0"></input>
        </div>

              <a href="/">back to index</a> <br />
              <a href="all-pages.html">view all pages</a> <br />
        <a href="https://github.com/plt-amy/cubical-1lab/blob/557652231fac237cc9a4fc37c1c3f140b1961cbd/src/Cat/Functor/Equivalence.lagda.md">link to source</a> <br />
                <hr /> <div class="author-list">Written by Amélia Liao</div> <br />
              </div>
    </div>
  </aside>
  
  <article>
    <!-- Article navigation (narrow screens only) -->
    <div class="narrow-only" id="article-nav">
      <!-- Index return anchor (only if the page is not the index) -->
            <div id="return">
        <a href="/">back to index</a>
      </div>
      
      <!-- Navbar equations control -->
      <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-eqns" type="checkbox" class="equations" id="navbar-eqns">
        <label for="navbar-eqns">Equations</label>
      </span>

      <!-- Navbar footnotes control -->
      <span class="inline-footnotes" style="display: none; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-fns" type="checkbox" class="inline-footnotes" id="navbar-fns">
        <label for="navbar-fns">Inline Footnotes</label>
      </span>
    </div>

<pre class="Agda"><a id="9" class="Keyword">open</a> <a id="14" class="Keyword">import</a> <a id="21" href="Cat.Instances.Functor.html" class="Module">Cat.Instances.Functor</a>
<a id="43" class="Keyword">open</a> <a id="48" class="Keyword">import</a> <a id="55" href="Cat.Functor.Adjoint.html" class="Module">Cat.Functor.Adjoint</a>
<a id="75" class="Keyword">open</a> <a id="80" class="Keyword">import</a> <a id="87" href="Cat.Functor.Base.html" class="Module">Cat.Functor.Base</a>
<a id="104" class="Keyword">open</a> <a id="109" class="Keyword">import</a> <a id="116" href="Cat.Univalent.html" class="Module">Cat.Univalent</a>
<a id="130" class="Keyword">open</a> <a id="135" class="Keyword">import</a> <a id="142" href="Cat.Prelude.html" class="Module">Cat.Prelude</a>

<a id="155" class="Keyword">import</a> <a id="162" href="Cat.Reasoning.html" class="Module">Cat.Reasoning</a>

<a id="177" class="Keyword">module</a> <a id="184" href="Cat.Functor.Equivalence.html" class="Module">Cat.Functor.Equivalence</a> <a id="208" class="Keyword">where</a>
</pre>
<!--
<pre class="Agda"><a id="232" class="Keyword">private</a> <a id="240" class="Keyword">variable</a>
  <a id="251" href="Cat.Functor.Equivalence.html#251" class="Generalizable">o</a> <a id="253" href="Cat.Functor.Equivalence.html#253" class="Generalizable">h</a> <a id="255" class="Symbol">:</a> <a id="257" href="Agda.Primitive.html#582" data-type="Type" class="Postulate">Level</a>
  <a id="265" href="Cat.Functor.Equivalence.html#265" class="Generalizable">C</a> <a id="267" href="Cat.Functor.Equivalence.html#267" class="Generalizable">D</a> <a id="269" class="Symbol">:</a> <a id="271" href="Cat.Base.html#704" data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" class="Record">Precategory</a> <a id="283" href="Cat.Functor.Equivalence.html#251" class="Generalizable">o</a> <a id="285" href="Cat.Functor.Equivalence.html#253" class="Generalizable">h</a>
<a id="287" class="Keyword">open</a> <a id="292" href="Cat.Base.html#7198" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Module">Functor</a> <a id="300" class="Keyword">hiding</a> <a id="307" class="Symbol">(</a><a id="308" href="Cat.Base.html#8958" data-type="(r : Functor C D) → Functor (C ^op) (D ^op)" class="Function">op</a><a id="310" class="Symbol">)</a>
<a id="312" class="Keyword">open</a> <a id="317" href="Cat.Base.html#12227" data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" class="Module Operator">_=&gt;_</a> <a id="322" class="Keyword">hiding</a> <a id="329" class="Symbol">(</a><a id="330" href="Cat.Base.html#13558" data-type="(r : F =&gt; G) → op G =&gt; op F" class="Function">op</a><a id="332" class="Symbol">)</a>
</pre>-->
<h1 id="equivalences"><a href="#equivalences" class="header-link">Equivalences<span class="header-link-emoji">🔗</span></a></h1>
<p>A functor
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>:</mo><mi mathvariant="script">C</mi><mo>→</mo><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">F : \ca{C} \to \ca{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span>
is an <strong>equivalence of categories</strong> when it has a <a href="Cat.Functor.Adjoint.html">right adjoint</a>
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>:</mo><mi mathvariant="script">D</mi><mo>→</mo><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">G : \ca{D} \to \ca{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span>,</span>
with the unit and counit natural transformations being <a href="Cat.Instances.Functor.html#functor-categories">natural
isomorphisms</a>. This immediately implies that our adjoint pair
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>⊣</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">F \dashv G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊣</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span>
extends to an adjoint triple
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>⊣</mo><mi>G</mi><mo>⊣</mo><mi>F</mi></mrow><annotation encoding="application/x-tex">F \dashv G \dashv F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊣</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊣</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span>.</span></p>
<pre class="Agda"><a id="797" class="Keyword">record</a> <a id="is-equivalence"></a><a id="804" href="Cat.Functor.Equivalence.html#804" data-type="(F : Functor C D) → Type (C.o ⊔ C.h ⊔ D.o ⊔ D.h)" class="Record">is-equivalence</a> <a id="819" class="Symbol">(</a><a id="820" href="Cat.Functor.Equivalence.html#820" class="Bound">F</a> <a id="822" class="Symbol">:</a> <a id="824" href="Cat.Base.html#7198" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="832" href="Cat.Functor.Equivalence.html#265" class="Generalizable">C</a> <a id="834" href="Cat.Functor.Equivalence.html#267" class="Generalizable">D</a><a id="835" class="Symbol">)</a> <a id="837" class="Symbol">:</a> <a id="839" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="844" class="Symbol">(</a><a id="845" href="Cat.Functor.Adjoint.html#549" data-type="Precategory o₁ h₁ → Precategory o₂ h₂ → Level" class="Function">adj-level</a> <a id="855" href="Cat.Functor.Equivalence.html#832" class="Bound">C</a> <a id="857" href="Cat.Functor.Equivalence.html#834" class="Bound">D</a><a id="858" class="Symbol">)</a> <a id="860" class="Keyword">where</a>
  <a id="868" class="Keyword">private</a>
    <a id="880" class="Keyword">module</a> <a id="is-equivalence.C"></a><a id="887" href="Cat.Functor.Equivalence.html#887" class="Module">C</a> <a id="889" class="Symbol">=</a> <a id="891" href="Cat.Reasoning.html" class="Module">Cat.Reasoning</a> <a id="905" href="Cat.Functor.Equivalence.html#832" class="Bound">C</a>
    <a id="911" class="Keyword">module</a> <a id="is-equivalence.D"></a><a id="918" href="Cat.Functor.Equivalence.html#918" class="Module">D</a> <a id="920" class="Symbol">=</a> <a id="922" href="Cat.Reasoning.html" class="Module">Cat.Reasoning</a> <a id="936" href="Cat.Functor.Equivalence.html#834" class="Bound">D</a>
    <a id="942" class="Keyword">module</a> <a id="is-equivalence.[C,C]"></a><a id="949" href="Cat.Functor.Equivalence.html#949" class="Module">[C,C]</a> <a id="955" class="Symbol">=</a> <a id="957" href="Cat.Reasoning.html" class="Module">Cat.Reasoning</a> <a id="971" href="Cat.Instances.Functor.html#2100" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Precategory (o₁ ⊔ o₂ ⊔ h₁ ⊔ h₂) (o₁ ⊔ h₁ ⊔ h₂)" class="Function Operator">Cat[</a> <a id="976" href="Cat.Functor.Equivalence.html#832" class="Bound">C</a> <a id="978" href="Cat.Instances.Functor.html#2100" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Precategory (o₁ ⊔ o₂ ⊔ h₁ ⊔ h₂) (o₁ ⊔ h₁ ⊔ h₂)" class="Function Operator">,</a> <a id="980" href="Cat.Functor.Equivalence.html#832" class="Bound">C</a> <a id="982" href="Cat.Instances.Functor.html#2100" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Precategory (o₁ ⊔ o₂ ⊔ h₁ ⊔ h₂) (o₁ ⊔ h₁ ⊔ h₂)" class="Function Operator">]</a>
    <a id="988" class="Keyword">module</a> <a id="is-equivalence.[D,D]"></a><a id="995" href="Cat.Functor.Equivalence.html#995" class="Module">[D,D]</a> <a id="1001" class="Symbol">=</a> <a id="1003" href="Cat.Reasoning.html" class="Module">Cat.Reasoning</a> <a id="1017" href="Cat.Instances.Functor.html#2100" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Precategory (o₁ ⊔ o₂ ⊔ h₁ ⊔ h₂) (o₁ ⊔ h₁ ⊔ h₂)" class="Function Operator">Cat[</a> <a id="1022" href="Cat.Functor.Equivalence.html#834" class="Bound">D</a> <a id="1024" href="Cat.Instances.Functor.html#2100" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Precategory (o₁ ⊔ o₂ ⊔ h₁ ⊔ h₂) (o₁ ⊔ h₁ ⊔ h₂)" class="Function Operator">,</a> <a id="1026" href="Cat.Functor.Equivalence.html#834" class="Bound">D</a> <a id="1028" href="Cat.Instances.Functor.html#2100" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Precategory (o₁ ⊔ o₂ ⊔ h₁ ⊔ h₂) (o₁ ⊔ h₁ ⊔ h₂)" class="Function Operator">]</a>

  <a id="1033" class="Keyword">field</a>
    <a id="is-equivalence.F⁻¹"></a><a id="1043" href="Cat.Functor.Equivalence.html#1043" data-type="is-equivalence F → Functor D C" class="Field">F⁻¹</a>      <a id="1052" class="Symbol">:</a> <a id="1054" href="Cat.Base.html#7198" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="1062" href="Cat.Functor.Equivalence.html#834" class="Bound">D</a> <a id="1064" href="Cat.Functor.Equivalence.html#832" class="Bound">C</a>
    <a id="is-equivalence.F⊣F⁻¹"></a><a id="1070" href="Cat.Functor.Equivalence.html#1070" data-type="(r : is-equivalence F) → F ⊣ r .F⁻¹" class="Field">F⊣F⁻¹</a>    <a id="1079" class="Symbol">:</a> <a id="1081" href="Cat.Functor.Equivalence.html#820" class="Bound">F</a> <a id="1083" href="Cat.Functor.Adjoint.html#2192" data-type="(L : Functor C D) (R₁ : Functor D C) → Type (C.o ⊔ C.h ⊔ D.o ⊔ D.h)" class="Record Operator">⊣</a> <a id="1085" href="Cat.Functor.Equivalence.html#1043" data-type="is-equivalence F → Functor D C" class="Field">F⁻¹</a>

  <a id="1092" class="Keyword">open</a> <a id="1097" href="Cat.Functor.Adjoint.html#2192" data-type="(L : Functor C D) (R₁ : Functor D C) → Type (C.o ⊔ C.h ⊔ D.o ⊔ D.h)" class="Module Operator">_⊣_</a> <a id="1101" href="Cat.Functor.Equivalence.html#1070" data-type="(r : is-equivalence F) → F ⊣ r .F⁻¹" class="Field">F⊣F⁻¹</a> <a id="1107" class="Keyword">public</a>

  <a id="1117" class="Keyword">field</a>
    <a id="is-equivalence.unit-iso"></a><a id="1127" href="Cat.Functor.Equivalence.html#1127" data-type="(r : is-equivalence F) (x : C .Ob) →
is-invertible C (η (r .F⊣F⁻¹) x)" class="Field">unit-iso</a>   <a id="1138" class="Symbol">:</a> <a id="1140" class="Symbol">∀</a> <a id="1142" href="Cat.Functor.Equivalence.html#1142" class="Bound">x</a> <a id="1144" class="Symbol">→</a> <a id="1146" href="Cat.Morphism.html#1930" data-type="(C : Precategory o h) (f : Hom C a b) → Type h" class="Record">C.is-invertible</a> <a id="1162" class="Symbol">(</a><a id="1163" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Function">unit.η</a> <a id="1170" href="Cat.Functor.Equivalence.html#1142" class="Bound">x</a><a id="1171" class="Symbol">)</a>
    <a id="is-equivalence.counit-iso"></a><a id="1177" href="Cat.Functor.Equivalence.html#1177" data-type="(r : is-equivalence F) (x : D .Ob) →
is-invertible D (ε (r .F⊣F⁻¹) x)" class="Field">counit-iso</a> <a id="1188" class="Symbol">:</a> <a id="1190" class="Symbol">∀</a> <a id="1192" href="Cat.Functor.Equivalence.html#1192" class="Bound">x</a> <a id="1194" class="Symbol">→</a> <a id="1196" href="Cat.Morphism.html#1930" data-type="(C : Precategory o h) (f : Hom C a b) → Type h" class="Record">D.is-invertible</a> <a id="1212" class="Symbol">(</a><a id="1213" href="Cat.Functor.Adjoint.html#2466" class="Function">counit.ε</a> <a id="1222" href="Cat.Functor.Equivalence.html#1192" class="Bound">x</a><a id="1223" class="Symbol">)</a>
</pre>
<p>The first thing we note is that having a natural family of invertible
morphisms gives isomorphisms in the respective functor categories:</p>
<pre class="Agda">  <a id="is-equivalence.F∘F⁻¹≅Id"></a><a id="1378" href="Cat.Functor.Equivalence.html#1378" data-type="(r : is-equivalence F) → (Cat[ D , D ] ≅ (F F∘ F⁻¹ r)) Id" class="Function">F∘F⁻¹≅Id</a> <a id="1387" class="Symbol">:</a> <a id="1389" class="Symbol">(</a><a id="1390" href="Cat.Functor.Equivalence.html#820" class="Bound">F</a> <a id="1392" href="Cat.Base.html#9683" data-type="Functor D E → Functor C D → Functor C E" class="Function Operator">F∘</a> <a id="1395" href="Cat.Functor.Equivalence.html#1043" data-type="is-equivalence F → Functor D C" class="Field">F⁻¹</a><a id="1398" class="Symbol">)</a> <a id="1400" href="Cat.Morphism.html#2202" data-type="(C : Precategory o h) (a b : Ob C) → Type h" class="Record Operator">[D,D].≅</a> <a id="1408" href="Cat.Base.html#11708" data-type="Functor C C" class="Function">Id</a>
  <a id="1413" href="Cat.Functor.Equivalence.html#1378" data-type="(r : is-equivalence F) → (Cat[ D , D ] ≅ (F F∘ F⁻¹ r)) Id" class="Function">F∘F⁻¹≅Id</a> <a id="1422" class="Symbol">=</a>
    <a id="1428" href="Cat.Morphism.html#3941" data-type="(C : Precategory o h) (f : Hom C a b) →
is-invertible C f → (C ≅ a) b" class="Function">[D,D].invertible→iso</a> <a id="1449" href="Cat.Functor.Adjoint.html#2370" data-type="L ⊣ R₁ → L F∘ R₁ =&gt; Id" class="Function">counit</a>
      <a id="1462" class="Symbol">(</a><a id="1463" href="Cat.Instances.Functor.html#8551" data-type="(eta : F =&gt; G) →
((x : C .Ob) → is-invertible D (eta .η x)) →
is-invertible Cat[ C , D ] eta" class="Function">componentwise-invertible→invertible</a> <a id="1499" class="Symbol">_</a> <a id="1501" href="Cat.Functor.Equivalence.html#1177" data-type="(r : is-equivalence F) (x : D .Ob) →
is-invertible D (ε (r .F⊣F⁻¹) x)" class="Field">counit-iso</a><a id="1511" class="Symbol">)</a>

  <a id="is-equivalence.Id≅F⁻¹∘F"></a><a id="1516" href="Cat.Functor.Equivalence.html#1516" data-type="(r : is-equivalence F) → (Cat[ C , C ] ≅ Id) (F⁻¹ r F∘ F)" class="Function">Id≅F⁻¹∘F</a> <a id="1525" class="Symbol">:</a> <a id="1527" href="Cat.Base.html#11708" data-type="Functor C C" class="Function">Id</a> <a id="1530" href="Cat.Morphism.html#2202" data-type="(C : Precategory o h) (a b : Ob C) → Type h" class="Record Operator">[C,C].≅</a> <a id="1538" class="Symbol">(</a><a id="1539" href="Cat.Functor.Equivalence.html#1043" data-type="is-equivalence F → Functor D C" class="Field">F⁻¹</a> <a id="1543" href="Cat.Base.html#9683" data-type="Functor D E → Functor C D → Functor C E" class="Function Operator">F∘</a> <a id="1546" href="Cat.Functor.Equivalence.html#820" class="Bound">F</a><a id="1547" class="Symbol">)</a>
  <a id="1551" href="Cat.Functor.Equivalence.html#1516" data-type="(r : is-equivalence F) → (Cat[ C , C ] ≅ Id) (F⁻¹ r F∘ F)" class="Function">Id≅F⁻¹∘F</a> <a id="1560" class="Symbol">=</a>
    <a id="1566" href="Cat.Morphism.html#3941" data-type="(C : Precategory o h) (f : Hom C a b) →
is-invertible C f → (C ≅ a) b" class="Function">[C,C].invertible→iso</a> <a id="1587" href="Cat.Functor.Adjoint.html#2342" data-type="L ⊣ R₁ → Id =&gt; R₁ F∘ L" class="Function">unit</a>
      <a id="1598" class="Symbol">(</a><a id="1599" href="Cat.Instances.Functor.html#8551" data-type="(eta : F =&gt; G) →
((x : C .Ob) → is-invertible D (eta .η x)) →
is-invertible Cat[ C , D ] eta" class="Function">componentwise-invertible→invertible</a> <a id="1635" class="Symbol">_</a> <a id="1637" href="Cat.Functor.Equivalence.html#1127" data-type="(r : is-equivalence F) (x : C .Ob) →
is-invertible C (η (r .F⊣F⁻¹) x)" class="Field">unit-iso</a><a id="1645" class="Symbol">)</a>

  <a id="is-equivalence.unit⁻¹"></a><a id="1650" href="Cat.Functor.Equivalence.html#1650" data-type="(r : is-equivalence F) → Hom Cat[ C , C ] (F⁻¹ r F∘ F) Id" class="Function">unit⁻¹</a> <a id="1657" class="Symbol">=</a> <a id="1659" href="Cat.Morphism.html#2267" data-type="(C ≅ a) b → Hom C b a" class="Field">[C,C]._≅_.from</a> <a id="1674" href="Cat.Functor.Equivalence.html#1516" data-type="(r : is-equivalence F) → (Cat[ C , C ] ≅ Id) (F⁻¹ r F∘ F)" class="Function">Id≅F⁻¹∘F</a>
  <a id="is-equivalence.counit⁻¹"></a><a id="1685" href="Cat.Functor.Equivalence.html#1685" data-type="(r : is-equivalence F) → Hom Cat[ D , D ] Id (F F∘ F⁻¹ r)" class="Function">counit⁻¹</a> <a id="1694" class="Symbol">=</a> <a id="1696" href="Cat.Morphism.html#2267" data-type="(C ≅ a) b → Hom C b a" class="Field">[D,D]._≅_.from</a> <a id="1711" href="Cat.Functor.Equivalence.html#1378" data-type="(r : is-equivalence F) → (Cat[ D , D ] ≅ (F F∘ F⁻¹ r)) Id" class="Function">F∘F⁻¹≅Id</a>
</pre>
<!--
<pre class="Agda">  <a id="is-equivalence.F⁻¹⊣F"></a><a id="1740" href="Cat.Functor.Equivalence.html#1740" data-type="(r : is-equivalence F) → F⁻¹ r ⊣ F" class="Function">F⁻¹⊣F</a> <a id="1746" class="Symbol">:</a> <a id="1748" href="Cat.Functor.Equivalence.html#1043" data-type="is-equivalence F → Functor D C" class="Field">F⁻¹</a> <a id="1752" href="Cat.Functor.Adjoint.html#2192" data-type="(L : Functor C D) (R₁ : Functor D C) → Type (C.o ⊔ C.h ⊔ D.o ⊔ D.h)" class="Record Operator">⊣</a> <a id="1754" href="Cat.Functor.Equivalence.html#820" class="Bound">F</a>
  <a id="1758" href="Cat.Functor.Equivalence.html#1740" data-type="(r : is-equivalence F) → F⁻¹ r ⊣ F" class="Function">F⁻¹⊣F</a> <a id="1764" class="Symbol">=</a> <a id="1766" href="Cat.Functor.Equivalence.html#1821" data-type="(r : is-equivalence F) → F⁻¹ r ⊣ F" class="Function">adj′</a> <a id="1771" class="Keyword">where</a>
    <a id="1781" class="Keyword">module</a> <a id="1788" href="Cat.Functor.Equivalence.html#1788" class="Module">adj</a> <a id="1792" class="Symbol">=</a> <a id="1794" href="Cat.Functor.Adjoint.html#2192" data-type="(L : Functor C D) (R₁ : Functor D C) → Type (C.o ⊔ C.h ⊔ D.o ⊔ D.h)" class="Module Operator">_⊣_</a> <a id="1798" href="Cat.Functor.Equivalence.html#1070" data-type="(r : is-equivalence F) → F ⊣ r .F⁻¹" class="Field">F⊣F⁻¹</a>
    <a id="1808" class="Keyword">open</a> <a id="1813" href="Cat.Functor.Adjoint.html#2192" data-type="(L : Functor C D) (R₁ : Functor D C) → Type (C.o ⊔ C.h ⊔ D.o ⊔ D.h)" class="Module Operator">_⊣_</a>
    <a id="1821" href="Cat.Functor.Equivalence.html#1821" data-type="(r : is-equivalence F) → F⁻¹ r ⊣ F" class="Function">adj′</a> <a id="1826" class="Symbol">:</a> <a id="1828" href="Cat.Functor.Equivalence.html#1043" data-type="is-equivalence F → Functor D C" class="Field">F⁻¹</a> <a id="1832" href="Cat.Functor.Adjoint.html#2192" data-type="(L : Functor C D) (R₁ : Functor D C) → Type (C.o ⊔ C.h ⊔ D.o ⊔ D.h)" class="Record Operator">⊣</a> <a id="1834" href="Cat.Functor.Equivalence.html#820" class="Bound">F</a>
    <a id="1840" href="Cat.Functor.Equivalence.html#1821" data-type="(r : is-equivalence F) → F⁻¹ r ⊣ F" class="Function">adj′</a> <a id="1845" class="Symbol">.</a><a id="1846" href="Cat.Functor.Adjoint.html#2342" data-type="L ⊣ R₁ → Id =&gt; R₁ F∘ L" class="Field">unit</a>   <a id="1853" class="Symbol">=</a> <a id="1855" href="Cat.Functor.Equivalence.html#1685" data-type="(r : is-equivalence F) → Hom Cat[ D , D ] Id (F F∘ F⁻¹ r)" class="Function">counit⁻¹</a>
    <a id="1868" href="Cat.Functor.Equivalence.html#1821" data-type="(r : is-equivalence F) → F⁻¹ r ⊣ F" class="Function">adj′</a> <a id="1873" class="Symbol">.</a><a id="1874" href="Cat.Functor.Adjoint.html#2370" data-type="L ⊣ R₁ → L F∘ R₁ =&gt; Id" class="Field">counit</a> <a id="1881" class="Symbol">=</a> <a id="1883" href="Cat.Functor.Equivalence.html#1650" data-type="(r : is-equivalence F) → Hom Cat[ C , C ] (F⁻¹ r F∘ F) Id" class="Function">unit⁻¹</a>
    <a id="1894" href="Cat.Functor.Equivalence.html#1821" data-type="(r : is-equivalence F) → F⁻¹ r ⊣ F" class="Function">adj′</a> <a id="1899" class="Symbol">.</a><a id="1900" href="Cat.Functor.Adjoint.html#2943" data-type="(r : L ⊣ R₁) →
D ._∘_ (η (r .counit) (F₀ L A)) (F₁ L (r .unit .η A)) ≡ D .id" class="Field">zig</a> <a id="1904" class="Symbol">{</a><a id="1905" href="Cat.Functor.Equivalence.html#1905" class="Bound">a</a><a id="1906" class="Symbol">}</a> <a id="1908" class="Symbol">=</a> <a id="1910" href="Cat.Functor.Equivalence.html#2302" data-type="(r : is-equivalence F) →
C ._∘_ (η (unit⁻¹ r) (F₀ (F⁻¹ r) a)) (F⁻¹ r .F₁ (counit⁻¹ r .η a))
≡ C .id" class="Function">zig′</a> <a id="1915" class="Keyword">where</a> <a id="1921" class="Keyword">abstract</a>
      <a id="1936" href="Cat.Functor.Equivalence.html#1936" data-type="(r : is-equivalence F) →
η (unit⁻¹ r) (F₀ (F⁻¹ r) a) ≡ F₁ (F⁻¹ r) (ε (F⊣F⁻¹ r) a)" class="Function">p</a> <a id="1938" class="Symbol">:</a> <a id="1940" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="1942" href="Cat.Functor.Equivalence.html#1650" data-type="(r : is-equivalence F) → Hom Cat[ C , C ] (F⁻¹ r F∘ F) Id" class="Function">unit⁻¹</a> <a id="1949" class="Symbol">(</a><a id="1950" href="Cat.Base.html#7988" data-type="Functor C D → C .Ob → Ob D" class="Field">F₀</a> <a id="1953" href="Cat.Functor.Equivalence.html#1043" data-type="is-equivalence F → Functor D C" class="Field">F⁻¹</a> <a id="1957" href="Cat.Functor.Equivalence.html#1905" class="Bound">a</a><a id="1958" class="Symbol">)</a> <a id="1960" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="1962" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="1965" href="Cat.Functor.Equivalence.html#1043" data-type="is-equivalence F → Functor D C" class="Field">F⁻¹</a> <a id="1969" class="Symbol">(</a><a id="1970" href="Cat.Functor.Adjoint.html#2466" class="Function">adj.counit.ε</a> <a id="1983" class="Symbol">_)</a>
      <a id="1992" href="Cat.Functor.Equivalence.html#1936" data-type="(r : is-equivalence F) →
η (unit⁻¹ r) (F₀ (F⁻¹ r) a) ≡ F₁ (F⁻¹ r) (ε (F⊣F⁻¹ r) a)" class="Function">p</a> <a id="1994" class="Symbol">=</a>
        <a id="2004" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="2006" href="Cat.Functor.Equivalence.html#1650" data-type="(r : is-equivalence F) → Hom Cat[ C , C ] (F⁻¹ r F∘ F) Id" class="Function">unit⁻¹</a> <a id="2013" class="Symbol">(</a><a id="2014" href="Cat.Base.html#7988" data-type="Functor C D → C .Ob → Ob D" class="Field">F₀</a> <a id="2017" href="Cat.Functor.Equivalence.html#1043" data-type="is-equivalence F → Functor D C" class="Field">F⁻¹</a> <a id="2021" href="Cat.Functor.Equivalence.html#1905" class="Bound">a</a><a id="2022" class="Symbol">)</a>                                                <a id="2071" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="2074" href="Cat.Reasoning.html#1232" data-type="(C : Precategory o ℓ) → a ≡ id C → f ≡ (C ∘ a) f" class="Function">C.introl</a> <a id="2083" href="Cat.Functor.Adjoint.html#3006" data-type="(r : L ⊣ R₁) →
C ._∘_ (F₁ R₁ (η (r .counit) B₁)) (r .unit .η (F₀ R₁ B₁)) ≡ C .id" class="Function">adj.zag</a> <a id="2091" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
        <a id="2101" class="Symbol">(</a><a id="2102" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="2105" href="Cat.Functor.Equivalence.html#1043" data-type="is-equivalence F → Functor D C" class="Field">F⁻¹</a> <a id="2109" class="Symbol">(</a><a id="2110" href="Cat.Functor.Adjoint.html#2466" class="Function">adj.counit.ε</a> <a id="2123" class="Symbol">_)</a> <a id="2126" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="2130" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Function">adj.unit.η</a> <a id="2141" class="Symbol">_)</a> <a id="2144" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="2148" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="2150" href="Cat.Functor.Equivalence.html#1650" data-type="(r : is-equivalence F) → Hom Cat[ C , C ] (F⁻¹ r F∘ F) Id" class="Function">unit⁻¹</a> <a id="2157" class="Symbol">(</a><a id="2158" href="Cat.Base.html#7988" data-type="Functor C D → C .Ob → Ob D" class="Field">F₀</a> <a id="2161" href="Cat.Functor.Equivalence.html#1043" data-type="is-equivalence F → Functor D C" class="Field">F⁻¹</a> <a id="2165" href="Cat.Functor.Equivalence.html#1905" class="Bound">a</a><a id="2166" class="Symbol">)</a> <a id="2168" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="2171" href="Cat.Reasoning.html#2789" data-type="(C : Precategory o ℓ) → (C ∘ h) i ≡ id C → (C ∘ (C ∘ f) h) i ≡ f" class="Function">C.cancelr</a> <a id="2181" class="Symbol">(</a><a id="2182" href="Cat.Functor.Equivalence.html#1127" data-type="(r : is-equivalence F) (x : C .Ob) →
is-invertible C (η (r .F⊣F⁻¹) x)" class="Field">unit-iso</a> <a id="2191" class="Symbol">_</a> <a id="2193" class="Symbol">.</a><a id="2194" href="Cat.Morphism.html#1867" data-type="Inverses C f g → (C ∘ f) g ≡ id C" class="Function">C.is-invertible.invl</a><a id="2214" class="Symbol">)</a> <a id="2216" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
        <a id="2226" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="2229" href="Cat.Functor.Equivalence.html#1043" data-type="is-equivalence F → Functor D C" class="Field">F⁻¹</a> <a id="2233" class="Symbol">(</a><a id="2234" href="Cat.Functor.Adjoint.html#2466" class="Function">adj.counit.ε</a> <a id="2247" class="Symbol">_)</a>                                            <a id="2293" href="1Lab.Path.html#46945" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>

      <a id="2302" href="Cat.Functor.Equivalence.html#2302" data-type="(r : is-equivalence F) →
C ._∘_ (η (unit⁻¹ r) (F₀ (F⁻¹ r) a)) (F⁻¹ r .F₁ (counit⁻¹ r .η a))
≡ C .id" class="Function">zig′</a> <a id="2307" class="Symbol">:</a> <a id="2309" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="2311" href="Cat.Functor.Equivalence.html#1650" data-type="(r : is-equivalence F) → Hom Cat[ C , C ] (F⁻¹ r F∘ F) Id" class="Function">unit⁻¹</a> <a id="2318" class="Symbol">(</a><a id="2319" href="Cat.Base.html#7988" data-type="Functor C D → C .Ob → Ob D" class="Field">F₀</a> <a id="2322" href="Cat.Functor.Equivalence.html#1043" data-type="is-equivalence F → Functor D C" class="Field">F⁻¹</a> <a id="2326" href="Cat.Functor.Equivalence.html#1905" class="Bound">a</a><a id="2327" class="Symbol">)</a> <a id="2329" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="2333" href="Cat.Functor.Equivalence.html#1043" data-type="is-equivalence F → Functor D C" class="Field">F⁻¹</a> <a id="2337" class="Symbol">.</a><a id="2338" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="2341" class="Symbol">(</a><a id="2342" href="Cat.Functor.Equivalence.html#1685" data-type="(r : is-equivalence F) → Hom Cat[ D , D ] Id (F F∘ F⁻¹ r)" class="Function">counit⁻¹</a> <a id="2351" class="Symbol">.</a><a id="2352" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="2354" href="Cat.Functor.Equivalence.html#1905" class="Bound">a</a><a id="2355" class="Symbol">)</a> <a id="2357" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="2359" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">C.id</a>
      <a id="2370" href="Cat.Functor.Equivalence.html#2302" data-type="(r : is-equivalence F) →
C ._∘_ (η (unit⁻¹ r) (F₀ (F⁻¹ r) a)) (F⁻¹ r .F₁ (counit⁻¹ r .η a))
≡ C .id" class="Function">zig′</a> <a id="2375" class="Symbol">=</a> <a id="2377" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="2381" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C._∘_</a> <a id="2387" href="Cat.Functor.Equivalence.html#1936" data-type="(r : is-equivalence F) →
η (unit⁻¹ r) (F₀ (F⁻¹ r) a) ≡ F₁ (F⁻¹ r) (ε (F⊣F⁻¹ r) a)" class="Function">p</a> <a id="2389" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
        <a id="2402" href="1Lab.Path.html#38293" data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" class="Function Operator">··</a> <a id="2405" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="2409" class="Symbol">(</a><a id="2410" href="Cat.Base.html#8375" data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" class="Field">F-∘</a> <a id="2414" href="Cat.Functor.Equivalence.html#1043" data-type="is-equivalence F → Functor D C" class="Field">F⁻¹</a> <a id="2418" class="Symbol">_</a> <a id="2420" class="Symbol">_)</a>
        <a id="2431" href="1Lab.Path.html#38293" data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" class="Function Operator">··</a> <a id="2434" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="2437" class="Symbol">(</a><a id="2438" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="2441" href="Cat.Functor.Equivalence.html#1043" data-type="is-equivalence F → Functor D C" class="Field">F⁻¹</a><a id="2444" class="Symbol">)</a> <a id="2446" class="Symbol">(</a><a id="2447" href="Cat.Functor.Equivalence.html#1177" data-type="(r : is-equivalence F) (x : D .Ob) →
is-invertible D (ε (r .F⊣F⁻¹) x)" class="Field">counit-iso</a> <a id="2458" class="Symbol">_</a> <a id="2460" class="Symbol">.</a><a id="2461" href="Cat.Morphism.html#1867" data-type="Inverses C f g → (C ∘ f) g ≡ id C" class="Function">D.is-invertible.invl</a><a id="2481" class="Symbol">)</a> <a id="2483" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="2485" href="Cat.Base.html#8335" data-type="(r : Functor C D) → r .F₁ (C .id) ≡ id D" class="Field">F-id</a> <a id="2490" href="Cat.Functor.Equivalence.html#1043" data-type="is-equivalence F → Functor D C" class="Field">F⁻¹</a>

    <a id="2499" href="Cat.Functor.Equivalence.html#1821" data-type="(r : is-equivalence F) → F⁻¹ r ⊣ F" class="Function">adj′</a> <a id="2504" class="Symbol">.</a><a id="2505" href="Cat.Functor.Adjoint.html#3006" data-type="(r : L ⊣ R₁) →
C ._∘_ (F₁ R₁ (η (r .counit) B₁)) (r .unit .η (F₀ R₁ B₁)) ≡ C .id" class="Field">zag</a> <a id="2509" class="Symbol">{</a><a id="2510" href="Cat.Functor.Equivalence.html#2510" class="Bound">b</a><a id="2511" class="Symbol">}</a> <a id="2513" class="Symbol">=</a> <a id="2515" href="Cat.Functor.Equivalence.html#2904" data-type="(r : is-equivalence F) →
D ._∘_ (F .F₁ (unit⁻¹ r .η b)) (counit⁻¹ r .η (F₀ F b)) ≡ D .id" class="Function">zag′</a> <a id="2520" class="Keyword">where</a> <a id="2526" class="Keyword">abstract</a>
      <a id="2541" href="Cat.Functor.Equivalence.html#2541" data-type="(r : is-equivalence F) →
counit⁻¹ r .η (F₀ F b) ≡ F .F₁ (η (F⊣F⁻¹ r) b)" class="Function">p</a> <a id="2543" class="Symbol">:</a> <a id="2545" href="Cat.Functor.Equivalence.html#1685" data-type="(r : is-equivalence F) → Hom Cat[ D , D ] Id (F F∘ F⁻¹ r)" class="Function">counit⁻¹</a> <a id="2554" class="Symbol">.</a><a id="2555" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="2557" class="Symbol">(</a><a id="2558" href="Cat.Base.html#7988" data-type="Functor C D → C .Ob → Ob D" class="Field">F₀</a> <a id="2561" href="Cat.Functor.Equivalence.html#820" class="Bound">F</a> <a id="2563" href="Cat.Functor.Equivalence.html#2510" class="Bound">b</a><a id="2564" class="Symbol">)</a> <a id="2566" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="2568" href="Cat.Functor.Equivalence.html#820" class="Bound">F</a> <a id="2570" class="Symbol">.</a><a id="2571" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="2574" class="Symbol">(</a><a id="2575" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Function">adj.unit.η</a> <a id="2586" href="Cat.Functor.Equivalence.html#2510" class="Bound">b</a><a id="2587" class="Symbol">)</a>
      <a id="2595" href="Cat.Functor.Equivalence.html#2541" data-type="(r : is-equivalence F) →
counit⁻¹ r .η (F₀ F b) ≡ F .F₁ (η (F⊣F⁻¹ r) b)" class="Function">p</a> <a id="2597" class="Symbol">=</a>
        <a id="2607" href="Cat.Functor.Equivalence.html#1685" data-type="(r : is-equivalence F) → Hom Cat[ D , D ] Id (F F∘ F⁻¹ r)" class="Function">counit⁻¹</a> <a id="2616" class="Symbol">.</a><a id="2617" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="2619" class="Symbol">_</a>                                                     <a id="2673" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="2676" href="Cat.Reasoning.html#1275" data-type="(C : Precategory o ℓ) → a ≡ id C → f ≡ (C ∘ f) a" class="Function">D.intror</a> <a id="2685" href="Cat.Functor.Adjoint.html#2943" data-type="(r : L ⊣ R₁) →
D ._∘_ (η (r .counit) (F₀ L A)) (F₁ L (r .unit .η A)) ≡ D .id" class="Function">adj.zig</a> <a id="2693" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
        <a id="2703" href="Cat.Functor.Equivalence.html#1685" data-type="(r : is-equivalence F) → Hom Cat[ D , D ] Id (F F∘ F⁻¹ r)" class="Function">counit⁻¹</a> <a id="2712" class="Symbol">.</a><a id="2713" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="2715" class="Symbol">_</a> <a id="2717" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="2721" href="Cat.Functor.Adjoint.html#2466" class="Function">adj.counit.ε</a> <a id="2734" class="Symbol">(</a><a id="2735" href="Cat.Base.html#7988" data-type="Functor C D → C .Ob → Ob D" class="Field">F₀</a> <a id="2738" href="Cat.Functor.Equivalence.html#820" class="Bound">F</a> <a id="2740" href="Cat.Functor.Equivalence.html#2510" class="Bound">b</a><a id="2741" class="Symbol">)</a> <a id="2743" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="2747" class="Symbol">(</a><a id="2748" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="2751" href="Cat.Functor.Equivalence.html#820" class="Bound">F</a> <a id="2753" class="Symbol">(</a><a id="2754" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Function">adj.unit.η</a> <a id="2765" href="Cat.Functor.Equivalence.html#2510" class="Bound">b</a><a id="2766" class="Symbol">))</a> <a id="2769" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="2772" href="Cat.Reasoning.html#2679" data-type="(C : Precategory o ℓ) → (C ∘ h) i ≡ id C → (C ∘ h) ((C ∘ i) f) ≡ f" class="Function">D.cancell</a> <a id="2782" class="Symbol">(</a><a id="2783" href="Cat.Functor.Equivalence.html#1177" data-type="(r : is-equivalence F) (x : D .Ob) →
is-invertible D (ε (r .F⊣F⁻¹) x)" class="Field">counit-iso</a> <a id="2794" class="Symbol">_</a> <a id="2796" class="Symbol">.</a><a id="2797" href="Cat.Morphism.html#1889" data-type="Inverses C f g → (C ∘ g) f ≡ id C" class="Function">D.is-invertible.invr</a><a id="2817" class="Symbol">)</a> <a id="2819" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
        <a id="2829" href="Cat.Functor.Equivalence.html#820" class="Bound">F</a> <a id="2831" class="Symbol">.</a><a id="2832" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="2835" class="Symbol">(</a><a id="2836" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Function">adj.unit.η</a> <a id="2847" href="Cat.Functor.Equivalence.html#2510" class="Bound">b</a><a id="2848" class="Symbol">)</a>                                              <a id="2895" href="1Lab.Path.html#46945" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>

      <a id="2904" href="Cat.Functor.Equivalence.html#2904" data-type="(r : is-equivalence F) →
D ._∘_ (F .F₁ (unit⁻¹ r .η b)) (counit⁻¹ r .η (F₀ F b)) ≡ D .id" class="Function">zag′</a> <a id="2909" class="Symbol">:</a> <a id="2911" href="Cat.Functor.Equivalence.html#820" class="Bound">F</a> <a id="2913" class="Symbol">.</a><a id="2914" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="2917" class="Symbol">(</a><a id="2918" href="Cat.Functor.Equivalence.html#1650" data-type="(r : is-equivalence F) → Hom Cat[ C , C ] (F⁻¹ r F∘ F) Id" class="Function">unit⁻¹</a> <a id="2925" class="Symbol">.</a><a id="2926" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="2928" href="Cat.Functor.Equivalence.html#2510" class="Bound">b</a><a id="2929" class="Symbol">)</a> <a id="2931" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="2935" href="Cat.Functor.Equivalence.html#1685" data-type="(r : is-equivalence F) → Hom Cat[ D , D ] Id (F F∘ F⁻¹ r)" class="Function">counit⁻¹</a> <a id="2944" class="Symbol">.</a><a id="2945" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="2947" class="Symbol">(</a><a id="2948" href="Cat.Base.html#7988" data-type="Functor C D → C .Ob → Ob D" class="Field">F₀</a> <a id="2951" href="Cat.Functor.Equivalence.html#820" class="Bound">F</a> <a id="2953" href="Cat.Functor.Equivalence.html#2510" class="Bound">b</a><a id="2954" class="Symbol">)</a> <a id="2956" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="2958" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">D.id</a>
      <a id="2969" href="Cat.Functor.Equivalence.html#2904" data-type="(r : is-equivalence F) →
D ._∘_ (F .F₁ (unit⁻¹ r .η b)) (counit⁻¹ r .η (F₀ F b)) ≡ D .id" class="Function">zag′</a> <a id="2974" class="Symbol">=</a> <a id="2976" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="2980" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D._∘_</a> <a id="2986" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="2991" href="Cat.Functor.Equivalence.html#2541" data-type="(r : is-equivalence F) →
counit⁻¹ r .η (F₀ F b) ≡ F .F₁ (η (F⊣F⁻¹ r) b)" class="Function">p</a>
        <a id="3001" href="1Lab.Path.html#38293" data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" class="Function Operator">··</a> <a id="3004" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="3008" class="Symbol">(</a><a id="3009" href="Cat.Functor.Equivalence.html#820" class="Bound">F</a> <a id="3011" class="Symbol">.</a><a id="3012" href="Cat.Base.html#8375" data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" class="Field">F-∘</a> <a id="3016" class="Symbol">_</a> <a id="3018" class="Symbol">_)</a>
        <a id="3029" href="1Lab.Path.html#38293" data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" class="Function Operator">··</a> <a id="3032" class="Symbol">(</a><a id="3033" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="3036" class="Symbol">(</a><a id="3037" href="Cat.Functor.Equivalence.html#820" class="Bound">F</a> <a id="3039" class="Symbol">.</a><a id="3040" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a><a id="3042" class="Symbol">)</a> <a id="3044" class="Symbol">(</a><a id="3045" href="Cat.Functor.Equivalence.html#1127" data-type="(r : is-equivalence F) (x : C .Ob) →
is-invertible C (η (r .F⊣F⁻¹) x)" class="Field">unit-iso</a> <a id="3054" class="Symbol">_</a> <a id="3056" class="Symbol">.</a><a id="3057" href="Cat.Morphism.html#1889" data-type="Inverses C f g → (C ∘ g) f ≡ id C" class="Function">C.is-invertible.invr</a><a id="3077" class="Symbol">)</a> <a id="3079" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="3081" href="Cat.Functor.Equivalence.html#820" class="Bound">F</a> <a id="3083" class="Symbol">.</a><a id="3084" href="Cat.Base.html#8335" data-type="(r : Functor C D) → r .F₁ (C .id) ≡ id D" class="Field">F-id</a><a id="3088" class="Symbol">)</a>

  <a id="is-equivalence.inverse-equivalence"></a><a id="3093" href="Cat.Functor.Equivalence.html#3093" data-type="(r : is-equivalence F) → is-equivalence (F⁻¹ r)" class="Function">inverse-equivalence</a> <a id="3113" class="Symbol">:</a> <a id="3115" href="Cat.Functor.Equivalence.html#804" data-type="(F : Functor C D) → Type (C.o ⊔ C.h ⊔ D.o ⊔ D.h)" class="Record">is-equivalence</a> <a id="3130" href="Cat.Functor.Equivalence.html#1043" data-type="is-equivalence F → Functor D C" class="Field">F⁻¹</a>
  <a id="3136" href="Cat.Functor.Equivalence.html#3093" data-type="(r : is-equivalence F) → is-equivalence (F⁻¹ r)" class="Function">inverse-equivalence</a> <a id="3156" class="Symbol">=</a>
    <a id="3162" class="Keyword">record</a> <a id="3169" class="Symbol">{</a> <a id="3171" href="Cat.Functor.Equivalence.html#1043" data-type="is-equivalence F → Functor D C" class="Field">F⁻¹</a> <a id="3175" class="Symbol">=</a> <a id="3177" href="Cat.Functor.Equivalence.html#820" class="Bound">F</a> <a id="3179" class="Symbol">;</a> <a id="3181" href="Cat.Functor.Equivalence.html#1070" data-type="(r : is-equivalence F) → F ⊣ r .F⁻¹" class="Field">F⊣F⁻¹</a> <a id="3187" class="Symbol">=</a> <a id="3189" href="Cat.Functor.Equivalence.html#1740" data-type="(r : is-equivalence F) → F⁻¹ r ⊣ F" class="Function">F⁻¹⊣F</a>
           <a id="3206" class="Symbol">;</a> <a id="3208" href="Cat.Functor.Equivalence.html#1127" data-type="(r : is-equivalence F) (x : C .Ob) →
is-invertible C (η (r .F⊣F⁻¹) x)" class="Field">unit-iso</a>   <a id="3219" class="Symbol">=</a> <a id="3221" class="Symbol">λ</a> <a id="3223" href="Cat.Functor.Equivalence.html#3223" class="Bound">x</a> <a id="3225" class="Symbol">→</a> <a id="3227" href="Cat.Morphism.html#4135" data-type="(C : Precategory o h) (g : is-invertible C f) →
is-invertible C (g .inv)" class="Function">D.is-invertible-inverse</a> <a id="3251" class="Symbol">(</a><a id="3252" href="Cat.Functor.Equivalence.html#1177" data-type="(r : is-equivalence F) (x : D .Ob) →
is-invertible D (ε (r .F⊣F⁻¹) x)" class="Field">counit-iso</a> <a id="3263" class="Symbol">_)</a>
           <a id="3277" class="Symbol">;</a> <a id="3279" href="Cat.Functor.Equivalence.html#1177" data-type="(r : is-equivalence F) (x : D .Ob) →
is-invertible D (ε (r .F⊣F⁻¹) x)" class="Field">counit-iso</a> <a id="3290" class="Symbol">=</a> <a id="3292" class="Symbol">λ</a> <a id="3294" href="Cat.Functor.Equivalence.html#3294" class="Bound">x</a> <a id="3296" class="Symbol">→</a> <a id="3298" href="Cat.Morphism.html#4135" data-type="(C : Precategory o h) (g : is-invertible C f) →
is-invertible C (g .inv)" class="Function">C.is-invertible-inverse</a> <a id="3322" class="Symbol">(</a><a id="3323" href="Cat.Functor.Equivalence.html#1127" data-type="(r : is-equivalence F) (x : C .Ob) →
is-invertible C (η (r .F⊣F⁻¹) x)" class="Field">unit-iso</a> <a id="3332" class="Symbol">_)</a>
           <a id="3346" class="Symbol">}</a>
</pre>-->
<p>We chose, for definiteness, the above definition of equivalence of
categories, since it provides convenient access to the most useful data:
The induced natural isomorphisms, the adjunction unit/counit, and the
triangle identities. It <em>is</em> a lot of data to come up with by
hand, though, so we provide some alternatives:</p>
<h2 id="fully-faithful-essentially-surjective"><a href="#fully-faithful-essentially-surjective" class="header-link">Fully
faithful, essentially
surjective<span class="header-link-emoji">🔗</span></a></h2>
<p>Any <a href="Cat.Functor.Base.html#ff-functors">fully faithful</a>
and <a href="Cat.Functor.Base.html#essential-fibres">(split!)
essentially surjective</a> functor determines an equivalence of
precategories. Recall that “split essentially surjective” means we have
some determined <em>procedure</em> for picking out an essential fibre
over any object
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo>:</mo><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">d : \ca{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span>:</span>
an object
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>F</mi><mo>∗</mo></msup><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo><mo>:</mo><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">F^*(d) : \ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span>
together with a specified isomorphism
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>F</mi><mo>∗</mo></msup><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo><mo>≅</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">F^*(d) \cong d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span>.</span></p>
<pre class="Agda"><a id="4170" class="Keyword">module</a> <a id="4177" href="Cat.Functor.Equivalence.html#4177" class="Module">_</a> <a id="4179" class="Symbol">{</a><a id="4180" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="4182" class="Symbol">:</a> <a id="4184" href="Cat.Base.html#7198" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="4192" href="Cat.Functor.Equivalence.html#265" class="Generalizable">C</a> <a id="4194" href="Cat.Functor.Equivalence.html#267" class="Generalizable">D</a><a id="4195" class="Symbol">}</a> <a id="4197" class="Symbol">(</a><a id="4198" href="Cat.Functor.Equivalence.html#4198" class="Bound">ff</a> <a id="4201" class="Symbol">:</a> <a id="4203" href="Cat.Functor.Base.html#1110" data-type="Functor C D → Type (C.o ⊔ C.h ⊔ D.h)" class="Function">is-fully-faithful</a> <a id="4221" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a><a id="4222" class="Symbol">)</a> <a id="4224" class="Symbol">(</a><a id="4225" href="Cat.Functor.Equivalence.html#4225" class="Bound">eso</a> <a id="4229" class="Symbol">:</a> <a id="4231" href="Cat.Functor.Base.html#4990" data-type="Functor C D → Type (C.o ⊔ D.o ⊔ D.h)" class="Function">is-split-eso</a> <a id="4244" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a><a id="4245" class="Symbol">)</a> <a id="4247" class="Keyword">where</a>
  <a id="4255" class="Keyword">import</a> <a id="4262" href="Cat.Reasoning.html" class="Module">Cat.Reasoning</a> <a id="4276" href="Cat.Functor.Equivalence.html#4192" class="Bound">C</a> as <a id="4281" href="Cat.Functor.Equivalence.html#4281" class="Module">C</a>
  <a id="4285" class="Keyword">import</a> <a id="4292" href="Cat.Reasoning.html" class="Module">Cat.Reasoning</a> <a id="4306" href="Cat.Functor.Equivalence.html#4194" class="Bound">D</a> as <a id="4311" href="Cat.Functor.Equivalence.html#4311" class="Module">D</a>
  <a id="4315" class="Keyword">private</a> <a id="4323" class="Keyword">module</a> <a id="4330" href="Cat.Functor.Equivalence.html#4330" class="Module">di</a> <a id="4333" class="Symbol">=</a> <a id="4335" href="Cat.Morphism.html#2202" data-type="(C : Precategory o h) (a b : Ob C) → Type h" class="Module Operator">D._≅_</a>

  <a id="4344" class="Keyword">private</a>
    <a id="4356" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="4361" class="Symbol">:</a> <a id="4363" class="Symbol">∀</a> <a id="4365" class="Symbol">{</a><a id="4366" href="Cat.Functor.Equivalence.html#4366" class="Bound">x</a> <a id="4368" href="Cat.Functor.Equivalence.html#4368" class="Bound">y</a><a id="4369" class="Symbol">}</a> <a id="4371" class="Symbol">→</a> <a id="4373" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">D.Hom</a> <a id="4379" class="Symbol">(</a><a id="4380" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="4382" class="Symbol">.</a><a id="4383" href="Cat.Base.html#7988" data-type="Functor C D → C .Ob → Ob D" class="Field">F₀</a> <a id="4386" href="Cat.Functor.Equivalence.html#4366" class="Bound">x</a><a id="4387" class="Symbol">)</a> <a id="4389" class="Symbol">(</a><a id="4390" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="4392" class="Symbol">.</a><a id="4393" href="Cat.Base.html#7988" data-type="Functor C D → C .Ob → Ob D" class="Field">F₀</a> <a id="4396" href="Cat.Functor.Equivalence.html#4368" class="Bound">y</a><a id="4397" class="Symbol">)</a> <a id="4399" class="Symbol">→</a> <a id="4401" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">C.Hom</a> <a id="4407" class="Symbol">_</a> <a id="4409" class="Symbol">_</a>
    <a id="4415" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="4420" class="Symbol">=</a> <a id="4422" href="1Lab.Equiv.html#6449" data-type="is-equiv f → B₁ → A" class="Function">equiv→inverse</a> <a id="4436" href="Cat.Functor.Equivalence.html#4198" class="Bound">ff</a>
</pre>
<p>It remains to show that, when
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span>
is fully faithful, this assignment of essential fibres extends to a
functor
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">D</mi><mo>→</mo><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">\ca{D} \to \ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span>.</span>
For the object part, we send
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>
to the specified preimage. For the morphism part, the splitting gives us
isomorphisms
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>F</mi><mo>∗</mo></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>≅</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">F^*(x) \cong x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>
and
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>F</mi><mo>∗</mo></msup><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo>≅</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">F^*(y) \cong y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>,</span>
so that we may form the composite
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>F</mi><mo>∗</mo></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>→</mo><mi>x</mi><mo>→</mo><mi>y</mi><mo>→</mo><msup><mi>F</mi><mo>∗</mo></msup><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F^*(x) \to x \to y \to F^*(y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>;</span>
Fullness then completes the construction.</p>
<pre class="Agda">  <a id="4853" href="Cat.Functor.Equivalence.html#4853" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) → Functor D C" class="Function">ff+split-eso→inverse</a> <a id="4874" class="Symbol">:</a> <a id="4876" href="Cat.Base.html#7198" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="4884" href="Cat.Functor.Equivalence.html#4194" class="Bound">D</a> <a id="4886" href="Cat.Functor.Equivalence.html#4192" class="Bound">C</a>
  <a id="4890" href="Cat.Functor.Equivalence.html#4853" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) → Functor D C" class="Function">ff+split-eso→inverse</a> <a id="4911" class="Symbol">.</a><a id="4912" href="Cat.Base.html#7988" data-type="Functor C D → C .Ob → Ob D" class="Field">F₀</a> <a id="4915" href="Cat.Functor.Equivalence.html#4915" class="Bound">x</a>         <a id="4925" class="Symbol">=</a> <a id="4927" href="Cat.Functor.Equivalence.html#4225" class="Bound">eso</a> <a id="4931" href="Cat.Functor.Equivalence.html#4915" class="Bound">x</a> <a id="4933" class="Symbol">.</a><a id="4934" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a>
  <a id="4940" href="Cat.Functor.Equivalence.html#4853" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) → Functor D C" class="Function">ff+split-eso→inverse</a> <a id="4961" class="Symbol">.</a><a id="4962" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="4965" class="Symbol">{</a><a id="4966" href="Cat.Functor.Equivalence.html#4966" class="Bound">x</a><a id="4967" class="Symbol">}</a> <a id="4969" class="Symbol">{</a><a id="4970" href="Cat.Functor.Equivalence.html#4970" class="Bound">y</a><a id="4971" class="Symbol">}</a> <a id="4973" href="Cat.Functor.Equivalence.html#4973" class="Bound">f</a> <a id="4975" class="Symbol">=</a>
    <a id="4981" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="4986" class="Symbol">(</a><a id="4987" href="Cat.Functor.Equivalence.html#5157" class="Function">f*y-iso</a> <a id="4995" class="Symbol">.</a><a id="4996" href="Cat.Morphism.html#2267" data-type="(C ≅ a) b → Hom C b a" class="Field">D._≅_.from</a> <a id="5007" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="5011" href="Cat.Functor.Equivalence.html#4973" class="Bound">f</a> <a id="5013" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="5017" href="Cat.Functor.Equivalence.html#5097" class="Function">f*x-iso</a> <a id="5025" class="Symbol">.</a><a id="5026" href="Cat.Morphism.html#2244" data-type="(C ≅ a) b → Hom C a b" class="Field">D._≅_.to</a><a id="5034" class="Symbol">)</a>
    <a id="5040" class="Keyword">where</a>
      <a id="5052" class="Keyword">open</a> <a id="5057" href="Agda.Builtin.Sigma.html#139" data-type="(A : Type a) (B₁ : A → Type b) → Type (a ⊔ b)" class="Module">∑</a> <a id="5059" class="Symbol">(</a><a id="5060" href="Cat.Functor.Equivalence.html#4225" class="Bound">eso</a> <a id="5064" href="Cat.Functor.Equivalence.html#4966" class="Bound">x</a><a id="5065" class="Symbol">)</a> <a id="5067" class="Keyword">renaming</a> <a id="5076" class="Symbol">(</a><a id="5077" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="5081" class="Symbol">to</a> <a id="5084" class="Field">f*x</a> <a id="5088" class="Symbol">;</a> <a id="5090" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="5094" class="Symbol">to</a> <a id="5097" class="Field">f*x-iso</a><a id="5104" class="Symbol">)</a>
      <a id="5112" class="Keyword">open</a> <a id="5117" href="Agda.Builtin.Sigma.html#139" data-type="(A : Type a) (B₁ : A → Type b) → Type (a ⊔ b)" class="Module">∑</a> <a id="5119" class="Symbol">(</a><a id="5120" href="Cat.Functor.Equivalence.html#4225" class="Bound">eso</a> <a id="5124" href="Cat.Functor.Equivalence.html#4970" class="Bound">y</a><a id="5125" class="Symbol">)</a> <a id="5127" class="Keyword">renaming</a> <a id="5136" class="Symbol">(</a><a id="5137" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="5141" class="Symbol">to</a> <a id="5144" class="Field">f*y</a> <a id="5148" class="Symbol">;</a> <a id="5150" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="5154" class="Symbol">to</a> <a id="5157" class="Field">f*y-iso</a><a id="5164" class="Symbol">)</a>
</pre>
<details>
<summary>
We must then, as usual, prove that this definition preserves identities
and distributes over composites, so that we really have a functor.
Preservation of identities is immediate; Distribution over composites is
by faithfulness.
</summary>
<pre class="Agda">  <a id="5442" href="Cat.Functor.Equivalence.html#4853" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) → Functor D C" class="Function">ff+split-eso→inverse</a> <a id="5463" class="Symbol">.</a><a id="5464" href="Cat.Base.html#8335" data-type="(r : Functor C D) → r .F₁ (C .id) ≡ id D" class="Field">F-id</a> <a id="5469" class="Symbol">{</a><a id="5470" href="Cat.Functor.Equivalence.html#5470" class="Bound">x</a><a id="5471" class="Symbol">}</a> <a id="5473" class="Symbol">=</a>
    <a id="5479" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="5484" class="Symbol">(</a><a id="5485" href="Cat.Functor.Equivalence.html#5881" class="Function">f*x-iso</a> <a id="5493" class="Symbol">.</a><a id="5494" href="Cat.Morphism.html#2267" data-type="(C ≅ a) b → Hom C b a" class="Field">di.from</a> <a id="5502" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="5506" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">D.id</a> <a id="5511" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="5515" href="Cat.Functor.Equivalence.html#5881" class="Function">f*x-iso</a> <a id="5523" class="Symbol">.</a><a id="5524" href="Cat.Morphism.html#2244" data-type="(C ≅ a) b → Hom C a b" class="Field">di.to</a><a id="5529" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function"><a id="5531" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="5534" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="5537" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="5542" class="Symbol">(</a><a id="5543" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="5547" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D._∘_</a> <a id="5553" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="5558" class="Symbol">(</a><a id="5559" href="Cat.Base.html#3482" data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ (r .id) f ≡ f" class="Function">D.idl</a> <a id="5565" class="Symbol">_))</a> <a id="5569" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="5575" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="5580" class="Symbol">(</a><a id="5581" href="Cat.Functor.Equivalence.html#5881" class="Function">f*x-iso</a> <a id="5589" class="Symbol">.</a><a id="5590" href="Cat.Morphism.html#2267" data-type="(C ≅ a) b → Hom C b a" class="Field">di.from</a> <a id="5598" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="5602" href="Cat.Functor.Equivalence.html#5881" class="Function">f*x-iso</a> <a id="5610" class="Symbol">.</a><a id="5611" href="Cat.Morphism.html#2244" data-type="(C ≅ a) b → Hom C a b" class="Field">di.to</a><a id="5616" class="Symbol">)</a>          <span class="reasoning-step"><span class="as-written Function"><a id="5627" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="5630" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="5633" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="5638" class="Symbol">(</a><a id="5639" href="Cat.Functor.Equivalence.html#5881" class="Function">f*x-iso</a> <a id="5647" class="Symbol">.</a><a id="5648" href="Cat.Morphism.html#1889" data-type="Inverses C f g → (C ∘ g) f ≡ id C" class="Function">di.invr</a><a id="5655" class="Symbol">)</a> <a id="5657" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="5663" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="5668" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">D.id</a>                                           <span class="reasoning-step"><span class="as-written Function Operator"><a id="5715" href="1Lab.Path.html#46771" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">≡˘⟨</a> <a id="5719" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="5722" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="5727" class="Symbol">(</a><a id="5728" href="Cat.Base.html#8335" data-type="(r : Functor C D) → r .F₁ (C .id) ≡ id D" class="Field">F-id</a> <a id="5733" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a><a id="5734" class="Symbol">)</a> <a id="5736" href="1Lab.Path.html#46771" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡˘</span></span>
    <a id="5742" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="5747" class="Symbol">(</a><a id="5748" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="5751" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="5753" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">C.id</a><a id="5757" class="Symbol">)</a>                                    <span class="reasoning-step"><span class="as-written Function"><a id="5794" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="5797" href="1Lab.Equiv.html#6679" data-type="(eqv : is-equiv f) (x : A) → equiv→inverse eqv (f x) ≡ x" class="Function">equiv→unit</a> <a id="5808" href="Cat.Functor.Equivalence.html#4198" class="Bound">ff</a> <a id="5811" class="Symbol">_</a> <a id="5813" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="5819" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">C.id</a> <a id="5824" href="1Lab.Path.html#46945" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
    <a id="5830" class="Keyword">where</a> <a id="5836" class="Keyword">open</a> <a id="5841" href="Agda.Builtin.Sigma.html#139" data-type="(A : Type a) (B₁ : A → Type b) → Type (a ⊔ b)" class="Module">∑</a> <a id="5843" class="Symbol">(</a><a id="5844" href="Cat.Functor.Equivalence.html#4225" class="Bound">eso</a> <a id="5848" href="Cat.Functor.Equivalence.html#5470" class="Bound">x</a><a id="5849" class="Symbol">)</a> <a id="5851" class="Keyword">renaming</a> <a id="5860" class="Symbol">(</a><a id="5861" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="5865" class="Symbol">to</a> <a id="5868" class="Field">f*x</a> <a id="5872" class="Symbol">;</a> <a id="5874" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="5878" class="Symbol">to</a> <a id="5881" class="Field">f*x-iso</a><a id="5888" class="Symbol">)</a>

  <a id="5893" href="Cat.Functor.Equivalence.html#4853" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) → Functor D C" class="Function">ff+split-eso→inverse</a> <a id="5914" class="Symbol">.</a><a id="5915" href="Cat.Base.html#8375" data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" class="Field">F-∘</a> <a id="5919" class="Symbol">{</a><a id="5920" href="Cat.Functor.Equivalence.html#5920" class="Bound">x</a><a id="5921" class="Symbol">}</a> <a id="5923" class="Symbol">{</a><a id="5924" href="Cat.Functor.Equivalence.html#5924" class="Bound">y</a><a id="5925" class="Symbol">}</a> <a id="5927" class="Symbol">{</a><a id="5928" href="Cat.Functor.Equivalence.html#5928" class="Bound">z</a><a id="5929" class="Symbol">}</a> <a id="5931" href="Cat.Functor.Equivalence.html#5931" class="Bound">f</a> <a id="5933" href="Cat.Functor.Equivalence.html#5933" class="Bound">g</a> <a id="5935" class="Symbol">=</a>
    <a id="5941" href="Cat.Functor.Base.html#1212" data-type="is-fully-faithful F → is-faithful F" class="Function">fully-faithful→faithful</a> <a id="5965" class="Symbol">{</a><a id="5966" class="Argument">F</a> <a id="5968" class="Symbol">=</a> <a id="5970" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a><a id="5971" class="Symbol">}</a> <a id="5973" href="Cat.Functor.Equivalence.html#4198" class="Bound">ff</a> <a id="5976" class="Symbol">(</a>
      <a id="5984" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="5987" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="5989" class="Symbol">(</a><a id="5990" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="5995" class="Symbol">(</a><a id="5996" href="Cat.Functor.Equivalence.html#6733" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (f : D .Hom y z)
(g : D .Hom x y) →
Hom D z (F₀ F (eso z .fst))" class="Function">ffz</a> <a id="6000" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="6004" class="Symbol">(</a><a id="6005" href="Cat.Functor.Equivalence.html#5931" class="Bound">f</a> <a id="6007" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="6011" href="Cat.Functor.Equivalence.html#5933" class="Bound">g</a><a id="6012" class="Symbol">)</a> <a id="6014" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="6018" href="Cat.Functor.Equivalence.html#6874" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (f : D .Hom y z)
(g : D .Hom x y) →
Hom D (F₀ F (eso x .fst)) x" class="Function">ftx</a><a id="6021" class="Symbol">))</a>      <span class="reasoning-step"><span class="as-written Function"><a id="6029" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="6032" href="1Lab.Equiv.html#6548" data-type="(eqv : is-equiv f) (x : B₁) → f (equiv→inverse eqv x) ≡ x" class="Function">equiv→counit</a> <a id="6045" href="Cat.Functor.Equivalence.html#4198" class="Bound">ff</a> <a id="6048" class="Symbol">_</a> <a id="6050" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="6058" href="Cat.Functor.Equivalence.html#6733" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (f : D .Hom y z)
(g : D .Hom x y) →
Hom D z (F₀ F (eso z .fst))" class="Function">ffz</a> <a id="6062" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="6066" class="Symbol">(</a><a id="6067" href="Cat.Functor.Equivalence.html#5931" class="Bound">f</a> <a id="6069" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="6073" href="Cat.Functor.Equivalence.html#5933" class="Bound">g</a><a id="6074" class="Symbol">)</a> <a id="6076" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="6080" href="Cat.Functor.Equivalence.html#6874" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (f : D .Hom y z)
(g : D .Hom x y) →
Hom D (F₀ F (eso x .fst)) x" class="Function">ftx</a>                    <span class="reasoning-step"><span class="as-written Function"><a id="6103" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="6106" href="Cat.Solver.html#7426" data-type="Term → Term → TC ⊤" class="Macro">solve</a> <a id="6112" href="Cat.Functor.Equivalence.html#4194" class="Bound">D</a> <a id="6114" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="6122" href="Cat.Functor.Equivalence.html#6733" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (f : D .Hom y z)
(g : D .Hom x y) →
Hom D z (F₀ F (eso z .fst))" class="Function">ffz</a> <a id="6126" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="6130" href="Cat.Functor.Equivalence.html#5931" class="Bound">f</a> <a id="6132" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="6136" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">D.id</a> <a id="6141" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="6145" href="Cat.Functor.Equivalence.html#5933" class="Bound">g</a> <a id="6147" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="6151" href="Cat.Functor.Equivalence.html#6874" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (f : D .Hom y z)
(g : D .Hom x y) →
Hom D (F₀ F (eso x .fst)) x" class="Function">ftx</a>             <span class="reasoning-step"><span class="as-written Function Operator"><a id="6167" href="1Lab.Path.html#46771" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">≡˘⟨</a> <a id="6171" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="6174" class="Symbol">(λ</a> <a id="6177" href="Cat.Functor.Equivalence.html#6177" class="Bound">x</a> <a id="6179" class="Symbol">→</a> <a id="6181" href="Cat.Functor.Equivalence.html#6733" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (f : D .Hom y z)
(g : D .Hom x y) →
Hom D z (F₀ F (eso z .fst))" class="Function">ffz</a> <a id="6185" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="6189" class="Symbol">(</a><a id="6190" href="Cat.Functor.Equivalence.html#5931" class="Bound">f</a> <a id="6192" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="6196" class="Symbol">(</a><a id="6197" href="Cat.Functor.Equivalence.html#6177" class="Bound">x</a> <a id="6199" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="6203" class="Symbol">(</a><a id="6204" href="Cat.Functor.Equivalence.html#5933" class="Bound">g</a> <a id="6206" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="6210" href="Cat.Functor.Equivalence.html#6874" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (f : D .Hom y z)
(g : D .Hom x y) →
Hom D (F₀ F (eso x .fst)) x" class="Function">ftx</a><a id="6213" class="Symbol">))))</a> <a id="6218" class="Symbol">(</a><a id="6219" href="Cat.Functor.Equivalence.html#6657" class="Function">f*y-iso</a> <a id="6227" class="Symbol">.</a><a id="6228" href="Cat.Morphism.html#1867" data-type="Inverses C f g → (C ∘ f) g ≡ id C" class="Function">di.invl</a><a id="6235" class="Symbol">)</a> <a id="6237" href="1Lab.Path.html#46771" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡˘</span></span>
      <a id="6245" href="Cat.Functor.Equivalence.html#6733" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (f : D .Hom y z)
(g : D .Hom x y) →
Hom D z (F₀ F (eso z .fst))" class="Function">ffz</a> <a id="6249" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="6253" href="Cat.Functor.Equivalence.html#5931" class="Bound">f</a> <a id="6255" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="6259" class="Symbol">(</a><a id="6260" href="Cat.Functor.Equivalence.html#6818" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (f : D .Hom y z)
(g : D .Hom x y) →
Hom D (F₀ F (eso y .fst)) y" class="Function">fty</a> <a id="6264" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="6268" href="Cat.Functor.Equivalence.html#6789" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (f : D .Hom y z)
(g : D .Hom x y) →
Hom D y (F₀ F (eso y .fst))" class="Function">ffy</a><a id="6271" class="Symbol">)</a> <a id="6273" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="6277" href="Cat.Functor.Equivalence.html#5933" class="Bound">g</a> <a id="6279" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="6283" href="Cat.Functor.Equivalence.html#6874" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (f : D .Hom y z)
(g : D .Hom x y) →
Hom D (F₀ F (eso x .fst)) x" class="Function">ftx</a>    <span class="reasoning-step"><span class="as-written Function"><a id="6290" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="6293" href="Cat.Solver.html#7426" data-type="Term → Term → TC ⊤" class="Macro">solve</a> <a id="6299" href="Cat.Functor.Equivalence.html#4194" class="Bound">D</a> <a id="6301" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="6309" class="Symbol">(</a><a id="6310" href="Cat.Functor.Equivalence.html#6733" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (f : D .Hom y z)
(g : D .Hom x y) →
Hom D z (F₀ F (eso z .fst))" class="Function">ffz</a> <a id="6314" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="6318" href="Cat.Functor.Equivalence.html#5931" class="Bound">f</a> <a id="6320" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="6324" href="Cat.Functor.Equivalence.html#6818" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (f : D .Hom y z)
(g : D .Hom x y) →
Hom D (F₀ F (eso y .fst)) y" class="Function">fty</a><a id="6327" class="Symbol">)</a> <a id="6329" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="6333" class="Symbol">(</a><a id="6334" href="Cat.Functor.Equivalence.html#6789" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (f : D .Hom y z)
(g : D .Hom x y) →
Hom D y (F₀ F (eso y .fst))" class="Function">ffy</a> <a id="6338" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="6342" href="Cat.Functor.Equivalence.html#5933" class="Bound">g</a> <a id="6344" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="6348" href="Cat.Functor.Equivalence.html#6874" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (f : D .Hom y z)
(g : D .Hom x y) →
Hom D (F₀ F (eso x .fst)) x" class="Function">ftx</a><a id="6351" class="Symbol">)</a>  <span class="reasoning-step"><span class="as-written Function Operator"><a id="6354" href="1Lab.Path.html#46771" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">≡˘⟨</a> <a id="6358" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="6362" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D._∘_</a> <a id="6368" class="Symbol">(</a><a id="6369" href="1Lab.Equiv.html#6548" data-type="(eqv : is-equiv f) (x : B₁) → f (equiv→inverse eqv x) ≡ x" class="Function">equiv→counit</a> <a id="6382" href="Cat.Functor.Equivalence.html#4198" class="Bound">ff</a> <a id="6385" class="Symbol">_)</a> <a id="6388" class="Symbol">(</a><a id="6389" href="1Lab.Equiv.html#6548" data-type="(eqv : is-equiv f) (x : B₁) → f (equiv→inverse eqv x) ≡ x" class="Function">equiv→counit</a> <a id="6402" href="Cat.Functor.Equivalence.html#4198" class="Bound">ff</a> <a id="6405" class="Symbol">_)</a> <a id="6408" href="1Lab.Path.html#46771" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡˘</span></span>
      <a id="6416" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="6419" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="6421" class="Symbol">(</a><a id="6422" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="6427" class="Symbol">_)</a> <a id="6430" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="6434" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="6437" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="6439" class="Symbol">(</a><a id="6440" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="6445" class="Symbol">_)</a>              <span class="reasoning-step"><span class="as-written Function Operator"><a id="6461" href="1Lab.Path.html#46771" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">≡˘⟨</a> <a id="6465" href="Cat.Base.html#8375" data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" class="Field">F-∘</a> <a id="6469" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="6471" class="Symbol">_</a> <a id="6473" class="Symbol">_</a> <a id="6475" href="1Lab.Path.html#46771" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡˘</span></span>
      <a id="6483" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="6486" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="6488" class="Symbol">(</a><a id="6489" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="6494" class="Symbol">_</a> <a id="6496" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="6500" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="6505" class="Symbol">_)</a>                     <a id="6528" href="1Lab.Path.html#46945" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
    <a id="6534" class="Symbol">)</a>
    <a id="6540" class="Keyword">where</a>
      <a id="6552" class="Keyword">open</a> <a id="6557" href="Agda.Builtin.Sigma.html#139" data-type="(A : Type a) (B₁ : A → Type b) → Type (a ⊔ b)" class="Module">∑</a> <a id="6559" class="Symbol">(</a><a id="6560" href="Cat.Functor.Equivalence.html#4225" class="Bound">eso</a> <a id="6564" href="Cat.Functor.Equivalence.html#5920" class="Bound">x</a><a id="6565" class="Symbol">)</a> <a id="6567" class="Keyword">renaming</a> <a id="6576" class="Symbol">(</a><a id="6577" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="6581" class="Symbol">to</a> <a id="6584" class="Field">f*x</a> <a id="6588" class="Symbol">;</a> <a id="6590" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="6594" class="Symbol">to</a> <a id="6597" class="Field">f*x-iso</a><a id="6604" class="Symbol">)</a>
      <a id="6612" class="Keyword">open</a> <a id="6617" href="Agda.Builtin.Sigma.html#139" data-type="(A : Type a) (B₁ : A → Type b) → Type (a ⊔ b)" class="Module">∑</a> <a id="6619" class="Symbol">(</a><a id="6620" href="Cat.Functor.Equivalence.html#4225" class="Bound">eso</a> <a id="6624" href="Cat.Functor.Equivalence.html#5924" class="Bound">y</a><a id="6625" class="Symbol">)</a> <a id="6627" class="Keyword">renaming</a> <a id="6636" class="Symbol">(</a><a id="6637" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="6641" class="Symbol">to</a> <a id="6644" class="Field">f*y</a> <a id="6648" class="Symbol">;</a> <a id="6650" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="6654" class="Symbol">to</a> <a id="6657" class="Field">f*y-iso</a><a id="6664" class="Symbol">)</a>
      <a id="6672" class="Keyword">open</a> <a id="6677" href="Agda.Builtin.Sigma.html#139" data-type="(A : Type a) (B₁ : A → Type b) → Type (a ⊔ b)" class="Module">∑</a> <a id="6679" class="Symbol">(</a><a id="6680" href="Cat.Functor.Equivalence.html#4225" class="Bound">eso</a> <a id="6684" href="Cat.Functor.Equivalence.html#5928" class="Bound">z</a><a id="6685" class="Symbol">)</a> <a id="6687" class="Keyword">renaming</a> <a id="6696" class="Symbol">(</a><a id="6697" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="6701" class="Symbol">to</a> <a id="6704" class="Field">f*z</a> <a id="6708" class="Symbol">;</a> <a id="6710" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="6714" class="Symbol">to</a> <a id="6717" class="Field">f*z-iso</a><a id="6724" class="Symbol">)</a>

      <a id="6733" href="Cat.Functor.Equivalence.html#6733" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (f : D .Hom y z)
(g : D .Hom x y) →
Hom D z (F₀ F (eso z .fst))" class="Function">ffz</a> <a id="6737" class="Symbol">=</a> <a id="6739" href="Cat.Functor.Equivalence.html#6717" class="Function">f*z-iso</a> <a id="6747" class="Symbol">.</a><a id="6748" href="Cat.Morphism.html#2267" data-type="(C ≅ a) b → Hom C b a" class="Field">di.from</a>
      <a id="6762" href="Cat.Functor.Equivalence.html#6762" class="Function">ftz</a> <a id="6766" class="Symbol">=</a> <a id="6768" href="Cat.Functor.Equivalence.html#6717" class="Function">f*z-iso</a> <a id="6776" class="Symbol">.</a><a id="6777" href="Cat.Morphism.html#2244" data-type="(C ≅ a) b → Hom C a b" class="Field">di.to</a>
      <a id="6789" href="Cat.Functor.Equivalence.html#6789" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (f : D .Hom y z)
(g : D .Hom x y) →
Hom D y (F₀ F (eso y .fst))" class="Function">ffy</a> <a id="6793" class="Symbol">=</a> <a id="6795" href="Cat.Functor.Equivalence.html#6657" class="Function">f*y-iso</a> <a id="6803" class="Symbol">.</a><a id="6804" href="Cat.Morphism.html#2267" data-type="(C ≅ a) b → Hom C b a" class="Field">di.from</a>
      <a id="6818" href="Cat.Functor.Equivalence.html#6818" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (f : D .Hom y z)
(g : D .Hom x y) →
Hom D (F₀ F (eso y .fst)) y" class="Function">fty</a> <a id="6822" class="Symbol">=</a> <a id="6824" href="Cat.Functor.Equivalence.html#6657" class="Function">f*y-iso</a> <a id="6832" class="Symbol">.</a><a id="6833" href="Cat.Morphism.html#2244" data-type="(C ≅ a) b → Hom C a b" class="Field">di.to</a>
      <a id="6845" href="Cat.Functor.Equivalence.html#6845" class="Function">ffx</a> <a id="6849" class="Symbol">=</a> <a id="6851" href="Cat.Functor.Equivalence.html#6597" class="Function">f*x-iso</a> <a id="6859" class="Symbol">.</a><a id="6860" href="Cat.Morphism.html#2267" data-type="(C ≅ a) b → Hom C b a" class="Field">di.from</a>
      <a id="6874" href="Cat.Functor.Equivalence.html#6874" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (f : D .Hom y z)
(g : D .Hom x y) →
Hom D (F₀ F (eso x .fst)) x" class="Function">ftx</a> <a id="6878" class="Symbol">=</a> <a id="6880" href="Cat.Functor.Equivalence.html#6597" class="Function">f*x-iso</a> <a id="6888" class="Symbol">.</a><a id="6889" href="Cat.Morphism.html#2244" data-type="(C ≅ a) b → Hom C a b" class="Field">di.to</a>
</pre>
</details>
<p>We will, for brevity, refer to the functor we’ve just built as
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span>,</span>
rather than its “proper name”
<span class="Agda"><a href="Cat.Functor.Equivalence.html#4853" class="Function">ff+split-eso→inverse</a></span>.
Hercules now only has 11 labours to go: We must construct unit and
counit natural transformations, prove that they satisfy the triangle
identities, and prove that the unit/counit we define are componentwise
invertible. I’ll keep the proofs of naturality in
<code>&lt;details&gt;</code> tags since.. they’re <em>rough</em>.</p>
<pre class="Agda">  <a id="7351" class="Keyword">private</a>
    <a id="7363" href="Cat.Functor.Equivalence.html#7363" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) → Functor D C" class="Function">G</a> <a id="7365" class="Symbol">=</a> <a id="7367" href="Cat.Functor.Equivalence.html#4853" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) → Functor D C" class="Function">ff+split-eso→inverse</a>
</pre>
<p>For the unit, we have an object
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>:</mo><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">x : \ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span>
and we’re asked to provide a morphism
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>→</mo><msup><mi>F</mi><mo>∗</mo></msup><mi>F</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x \to F^*F(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>
— where, recall, the notation
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>F</mi><mo>∗</mo></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F^*(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>
represents the chosen essential fibre of
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span>
over
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>.</span>
By fullness, it suffices to provide a morphism
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>→</mo><mi>F</mi><msup><mi>F</mi><mo>∗</mo></msup><mi>F</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(x) \to FF^*F(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>;</span>
But recall that the essential fibre
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>F</mi><mo>∗</mo></msup><mi>F</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F^*F(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>
comes equipped with an isomorphism
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><msup><mi>F</mi><mo>∗</mo></msup><mi>F</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>≅</mo><mi>F</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">FF^*F(x) \cong F(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>.</span></p>
<pre class="Agda">  <a id="7771" href="Cat.Functor.Equivalence.html#7771" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Id =&gt; G ff eso F∘ F" class="Function">ff+split-eso→unit</a> <a id="7789" class="Symbol">:</a> <a id="7791" href="Cat.Base.html#11708" data-type="Functor C C" class="Function">Id</a> <a id="7794" href="Cat.Base.html#12227" data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" class="Record Operator">=&gt;</a> <a id="7797" class="Symbol">(</a><a id="7798" href="Cat.Functor.Equivalence.html#7363" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) → Functor D C" class="Function">G</a> <a id="7800" href="Cat.Base.html#9683" data-type="Functor D E → Functor C D → Functor C E" class="Function Operator">F∘</a> <a id="7803" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a><a id="7804" class="Symbol">)</a>
  <a id="7808" href="Cat.Functor.Equivalence.html#7771" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Id =&gt; G ff eso F∘ F" class="Function">ff+split-eso→unit</a> <a id="7826" class="Symbol">.</a><a id="7827" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="7829" href="Cat.Functor.Equivalence.html#7829" class="Bound">x</a> <a id="7831" class="Symbol">=</a> <a id="7833" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="7838" class="Symbol">(</a><a id="7839" href="Cat.Functor.Equivalence.html#7919" class="Function">f*x-iso</a> <a id="7847" class="Symbol">.</a><a id="7848" href="Cat.Morphism.html#2267" data-type="(C ≅ a) b → Hom C b a" class="Field">di.from</a><a id="7855" class="Symbol">)</a>
    <a id="7861" class="Keyword">where</a> <a id="7867" class="Keyword">open</a> <a id="7872" href="Agda.Builtin.Sigma.html#139" data-type="(A : Type a) (B₁ : A → Type b) → Type (a ⊔ b)" class="Module">∑</a> <a id="7874" class="Symbol">(</a><a id="7875" href="Cat.Functor.Equivalence.html#4225" class="Bound">eso</a> <a id="7879" class="Symbol">(</a><a id="7880" href="Cat.Base.html#7988" data-type="Functor C D → C .Ob → Ob D" class="Field">F₀</a> <a id="7883" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="7885" href="Cat.Functor.Equivalence.html#7829" class="Bound">x</a><a id="7886" class="Symbol">))</a> <a id="7889" class="Keyword">renaming</a> <a id="7898" class="Symbol">(</a><a id="7899" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="7903" class="Symbol">to</a> <a id="7906" class="Field">f*x</a> <a id="7910" class="Symbol">;</a> <a id="7912" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="7916" class="Symbol">to</a> <a id="7919" class="Field">f*x-iso</a><a id="7926" class="Symbol">)</a>
</pre>
<details>
<summary>
Naturality of
<span class="Agda"><a href="Cat.Functor.Equivalence.html#7771" class="Function">ff+split-eso→unit</a></span>.
</summary>
<pre class="Agda">  <a id="8017" href="Cat.Functor.Equivalence.html#7771" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Id =&gt; G ff eso F∘ F" class="Function">ff+split-eso→unit</a> <a id="8035" class="Symbol">.</a><a id="8036" href="Cat.Base.html#13355" data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" class="Field">is-natural</a> <a id="8047" href="Cat.Functor.Equivalence.html#8047" class="Bound">x</a> <a id="8049" href="Cat.Functor.Equivalence.html#8049" class="Bound">y</a> <a id="8051" href="Cat.Functor.Equivalence.html#8051" class="Bound">f</a> <a id="8053" class="Symbol">=</a>
    <a id="8059" href="Cat.Functor.Base.html#1212" data-type="is-fully-faithful F → is-faithful F" class="Function">fully-faithful→faithful</a> <a id="8083" class="Symbol">{</a><a id="8084" class="Argument">F</a> <a id="8086" class="Symbol">=</a> <a id="8088" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a><a id="8089" class="Symbol">}</a> <a id="8091" href="Cat.Functor.Equivalence.html#4198" class="Bound">ff</a> <a id="8094" class="Symbol">(</a>
      <a id="8102" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="8105" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="8107" class="Symbol">(</a><a id="8108" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="8113" href="Cat.Functor.Equivalence.html#8983" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : C .Ob)
(f : C .Hom x y) →
Hom D (F₀ F y) (F₀ F (eso (F₀ F y) .fst))" class="Function">ffy</a> <a id="8117" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="8121" href="Cat.Functor.Equivalence.html#8051" class="Bound">f</a><a id="8122" class="Symbol">)</a>                                    <span class="reasoning-step"><span class="as-written Function"><a id="8159" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="8162" href="Cat.Base.html#8375" data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" class="Field">F-∘</a> <a id="8166" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="8168" class="Symbol">_</a> <a id="8170" class="Symbol">_</a> <a id="8172" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="8180" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="8183" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="8185" class="Symbol">(</a><a id="8186" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="8191" href="Cat.Functor.Equivalence.html#8983" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : C .Ob)
(f : C .Hom x y) →
Hom D (F₀ F y) (F₀ F (eso (F₀ F y) .fst))" class="Function">ffy</a><a id="8194" class="Symbol">)</a> <a id="8196" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8200" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="8203" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="8205" href="Cat.Functor.Equivalence.html#8051" class="Bound">f</a>                               <span class="reasoning-step"><span class="as-written Function"><a id="8237" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="8240" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="8244" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D._∘_</a> <a id="8250" class="Symbol">(</a><a id="8251" href="1Lab.Equiv.html#6548" data-type="(eqv : is-equiv f) (x : B₁) → f (equiv→inverse eqv x) ≡ x" class="Function">equiv→counit</a> <a id="8264" href="Cat.Functor.Equivalence.html#4198" class="Bound">ff</a> <a id="8267" class="Symbol">_)</a> <a id="8270" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="8275" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="8283" href="Cat.Functor.Equivalence.html#8983" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : C .Ob)
(f : C .Hom x y) →
Hom D (F₀ F y) (F₀ F (eso (F₀ F y) .fst))" class="Function">ffy</a> <a id="8287" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8291" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="8294" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="8296" href="Cat.Functor.Equivalence.html#8051" class="Bound">f</a>                                           <span class="reasoning-step"><span class="as-written Function"><a id="8340" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="8343" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="8347" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D._∘_</a> <a id="8353" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="8358" class="Symbol">(</a><a id="8359" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="8363" class="Symbol">(</a><a id="8364" href="Cat.Base.html#3437" data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ f (r .id) ≡ f" class="Function">D.idr</a> <a id="8370" class="Symbol">_)</a> <a id="8373" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="8375" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="8378" class="Symbol">(</a><a id="8379" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="8382" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="8384" href="Cat.Functor.Equivalence.html#8051" class="Bound">f</a> <a id="8386" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘_</a><a id="8390" class="Symbol">)</a> <a id="8392" class="Symbol">(</a><a id="8393" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="8397" class="Symbol">(</a><a id="8398" href="Cat.Functor.Equivalence.html#8900" class="Function">f*x-iso</a> <a id="8406" class="Symbol">.</a><a id="8407" href="Cat.Morphism.html#1867" data-type="Inverses C f g → (C ∘ f) g ≡ id C" class="Function">di.invl</a><a id="8414" class="Symbol">)))</a> <a id="8418" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="8426" href="Cat.Functor.Equivalence.html#8983" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : C .Ob)
(f : C .Hom x y) →
Hom D (F₀ F y) (F₀ F (eso (F₀ F y) .fst))" class="Function">ffy</a> <a id="8430" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8434" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="8437" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="8439" href="Cat.Functor.Equivalence.html#8051" class="Bound">f</a> <a id="8441" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8445" href="Cat.Functor.Equivalence.html#9068" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : C .Ob)
(f : C .Hom x y) →
Hom D (F₀ F (eso (F₀ F x) .fst)) (F₀ F x)" class="Function">ftx</a> <a id="8449" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8453" href="Cat.Functor.Equivalence.html#9039" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : C .Ob)
(f : C .Hom x y) →
Hom D (F₀ F x) (F₀ F (eso (F₀ F x) .fst))" class="Function">ffx</a>                           <span class="reasoning-step"><span class="as-written Function"><a id="8483" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="8486" href="Cat.Solver.html#7426" data-type="Term → Term → TC ⊤" class="Macro">solve</a> <a id="8492" href="Cat.Functor.Equivalence.html#4194" class="Bound">D</a> <a id="8494" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="8502" class="Symbol">(</a><a id="8503" href="Cat.Functor.Equivalence.html#8983" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : C .Ob)
(f : C .Hom x y) →
Hom D (F₀ F y) (F₀ F (eso (F₀ F y) .fst))" class="Function">ffy</a> <a id="8507" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8511" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="8514" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="8516" href="Cat.Functor.Equivalence.html#8051" class="Bound">f</a> <a id="8518" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8522" href="Cat.Functor.Equivalence.html#9068" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : C .Ob)
(f : C .Hom x y) →
Hom D (F₀ F (eso (F₀ F x) .fst)) (F₀ F x)" class="Function">ftx</a><a id="8525" class="Symbol">)</a> <a id="8527" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8531" href="Cat.Functor.Equivalence.html#9039" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : C .Ob)
(f : C .Hom x y) →
Hom D (F₀ F x) (F₀ F (eso (F₀ F x) .fst))" class="Function">ffx</a>                         <span class="reasoning-step"><span class="as-written Function Operator"><a id="8559" href="1Lab.Path.html#46771" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">≡˘⟨</a> <a id="8563" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="8567" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D._∘_</a> <a id="8573" class="Symbol">(</a><a id="8574" href="1Lab.Equiv.html#6548" data-type="(eqv : is-equiv f) (x : B₁) → f (equiv→inverse eqv x) ≡ x" class="Function">equiv→counit</a> <a id="8587" href="Cat.Functor.Equivalence.html#4198" class="Bound">ff</a> <a id="8590" class="Symbol">_)</a> <a id="8593" class="Symbol">(</a><a id="8594" href="1Lab.Equiv.html#6548" data-type="(eqv : is-equiv f) (x : B₁) → f (equiv→inverse eqv x) ≡ x" class="Function">equiv→counit</a> <a id="8607" href="Cat.Functor.Equivalence.html#4198" class="Bound">ff</a> <a id="8610" class="Symbol">_)</a> <a id="8613" href="1Lab.Path.html#46771" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡˘</span></span>
      <a id="8621" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="8624" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="8626" class="Symbol">(</a><a id="8627" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="8632" class="Symbol">(</a><a id="8633" href="Cat.Functor.Equivalence.html#8983" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : C .Ob)
(f : C .Hom x y) →
Hom D (F₀ F y) (F₀ F (eso (F₀ F y) .fst))" class="Function">ffy</a> <a id="8637" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8641" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="8644" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="8646" href="Cat.Functor.Equivalence.html#8051" class="Bound">f</a> <a id="8648" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8652" href="Cat.Functor.Equivalence.html#9068" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : C .Ob)
(f : C .Hom x y) →
Hom D (F₀ F (eso (F₀ F x) .fst)) (F₀ F x)" class="Function">ftx</a><a id="8655" class="Symbol">))</a> <a id="8658" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8662" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="8665" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="8667" class="Symbol">(</a><a id="8668" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="8673" href="Cat.Functor.Equivalence.html#9039" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : C .Ob)
(f : C .Hom x y) →
Hom D (F₀ F x) (F₀ F (eso (F₀ F x) .fst))" class="Function">ffx</a><a id="8676" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function Operator"><a id="8678" href="1Lab.Path.html#46771" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">≡˘⟨</a> <a id="8682" href="Cat.Base.html#8375" data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" class="Field">F-∘</a> <a id="8686" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="8688" class="Symbol">_</a> <a id="8690" class="Symbol">_</a> <a id="8692" href="1Lab.Path.html#46771" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡˘</span></span>
      <a id="8700" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="8703" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="8705" class="Symbol">(</a><a id="8706" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="8711" class="Symbol">(</a><a id="8712" href="Cat.Functor.Equivalence.html#8983" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : C .Ob)
(f : C .Hom x y) →
Hom D (F₀ F y) (F₀ F (eso (F₀ F y) .fst))" class="Function">ffy</a> <a id="8716" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8720" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="8723" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="8725" href="Cat.Functor.Equivalence.html#8051" class="Bound">f</a> <a id="8727" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8731" href="Cat.Functor.Equivalence.html#9068" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : C .Ob)
(f : C .Hom x y) →
Hom D (F₀ F (eso (F₀ F x) .fst)) (F₀ F x)" class="Function">ftx</a><a id="8734" class="Symbol">)</a> <a id="8736" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="8740" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="8745" href="Cat.Functor.Equivalence.html#9039" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : C .Ob)
(f : C .Hom x y) →
Hom D (F₀ F x) (F₀ F (eso (F₀ F x) .fst))" class="Function">ffx</a><a id="8748" class="Symbol">)</a>        <a id="8757" href="1Lab.Path.html#46869" data-type="(x : A) → x ≡ y → x ≡ y" class="Function Operator">≡⟨⟩</a>
      <a id="8767" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="8770" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="8772" class="Symbol">(</a><a id="8773" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="8776" class="Symbol">(</a><a id="8777" href="Cat.Functor.Equivalence.html#7363" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) → Functor D C" class="Function">G</a> <a id="8779" href="Cat.Base.html#9683" data-type="Functor D E → Functor C D → Functor C E" class="Function Operator">F∘</a> <a id="8782" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a><a id="8783" class="Symbol">)</a> <a id="8785" href="Cat.Functor.Equivalence.html#8051" class="Bound">f</a> <a id="8787" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="8791" href="Cat.Functor.Equivalence.html#9096" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : C .Ob)
(f : C .Hom x y) →
C .Hom x (eso (F₀ F x) .fst)" class="Function">x→f*x</a><a id="8796" class="Symbol">)</a>                           <a id="8824" href="1Lab.Path.html#46945" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
    <a id="8830" class="Symbol">)</a>
    <a id="8836" class="Keyword">where</a>
      <a id="8848" class="Keyword">open</a> <a id="8853" href="Agda.Builtin.Sigma.html#139" data-type="(A : Type a) (B₁ : A → Type b) → Type (a ⊔ b)" class="Module">∑</a> <a id="8855" class="Symbol">(</a><a id="8856" href="Cat.Functor.Equivalence.html#4225" class="Bound">eso</a> <a id="8860" class="Symbol">(</a><a id="8861" href="Cat.Base.html#7988" data-type="Functor C D → C .Ob → Ob D" class="Field">F₀</a> <a id="8864" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="8866" href="Cat.Functor.Equivalence.html#8047" class="Bound">x</a><a id="8867" class="Symbol">))</a> <a id="8870" class="Keyword">renaming</a> <a id="8879" class="Symbol">(</a><a id="8880" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="8884" class="Symbol">to</a> <a id="8887" class="Field">f*x</a> <a id="8891" class="Symbol">;</a> <a id="8893" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="8897" class="Symbol">to</a> <a id="8900" class="Field">f*x-iso</a><a id="8907" class="Symbol">)</a>
      <a id="8915" class="Keyword">open</a> <a id="8920" href="Agda.Builtin.Sigma.html#139" data-type="(A : Type a) (B₁ : A → Type b) → Type (a ⊔ b)" class="Module">∑</a> <a id="8922" class="Symbol">(</a><a id="8923" href="Cat.Functor.Equivalence.html#4225" class="Bound">eso</a> <a id="8927" class="Symbol">(</a><a id="8928" href="Cat.Base.html#7988" data-type="Functor C D → C .Ob → Ob D" class="Field">F₀</a> <a id="8931" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="8933" href="Cat.Functor.Equivalence.html#8049" class="Bound">y</a><a id="8934" class="Symbol">))</a> <a id="8937" class="Keyword">renaming</a> <a id="8946" class="Symbol">(</a><a id="8947" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="8951" class="Symbol">to</a> <a id="8954" class="Field">f*y</a> <a id="8958" class="Symbol">;</a> <a id="8960" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="8964" class="Symbol">to</a> <a id="8967" class="Field">f*y-iso</a><a id="8974" class="Symbol">)</a>

      <a id="8983" href="Cat.Functor.Equivalence.html#8983" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : C .Ob)
(f : C .Hom x y) →
Hom D (F₀ F y) (F₀ F (eso (F₀ F y) .fst))" class="Function">ffy</a> <a id="8987" class="Symbol">=</a> <a id="8989" href="Cat.Functor.Equivalence.html#8967" class="Function">f*y-iso</a> <a id="8997" class="Symbol">.</a><a id="8998" href="Cat.Morphism.html#2267" data-type="(C ≅ a) b → Hom C b a" class="Field">di.from</a>
      <a id="9012" href="Cat.Functor.Equivalence.html#9012" class="Function">fty</a> <a id="9016" class="Symbol">=</a> <a id="9018" href="Cat.Functor.Equivalence.html#8967" class="Function">f*y-iso</a> <a id="9026" class="Symbol">.</a><a id="9027" href="Cat.Morphism.html#2244" data-type="(C ≅ a) b → Hom C a b" class="Field">di.to</a>
      <a id="9039" href="Cat.Functor.Equivalence.html#9039" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : C .Ob)
(f : C .Hom x y) →
Hom D (F₀ F x) (F₀ F (eso (F₀ F x) .fst))" class="Function">ffx</a> <a id="9043" class="Symbol">=</a> <a id="9045" href="Cat.Functor.Equivalence.html#8900" class="Function">f*x-iso</a> <a id="9053" class="Symbol">.</a><a id="9054" href="Cat.Morphism.html#2267" data-type="(C ≅ a) b → Hom C b a" class="Field">di.from</a>
      <a id="9068" href="Cat.Functor.Equivalence.html#9068" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : C .Ob)
(f : C .Hom x y) →
Hom D (F₀ F (eso (F₀ F x) .fst)) (F₀ F x)" class="Function">ftx</a> <a id="9072" class="Symbol">=</a> <a id="9074" href="Cat.Functor.Equivalence.html#8900" class="Function">f*x-iso</a> <a id="9082" class="Symbol">.</a><a id="9083" href="Cat.Morphism.html#2244" data-type="(C ≅ a) b → Hom C a b" class="Field">di.to</a>

      <a id="9096" href="Cat.Functor.Equivalence.html#9096" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : C .Ob)
(f : C .Hom x y) →
C .Hom x (eso (F₀ F x) .fst)" class="Function">x→f*x</a> <a id="9102" class="Symbol">:</a> <a id="9104" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">C.Hom</a> <a id="9110" href="Cat.Functor.Equivalence.html#8047" class="Bound">x</a> <a id="9112" href="Cat.Functor.Equivalence.html#8887" class="Function">f*x</a>
      <a id="9122" href="Cat.Functor.Equivalence.html#9096" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : C .Ob)
(f : C .Hom x y) →
C .Hom x (eso (F₀ F x) .fst)" class="Function">x→f*x</a> <a id="9128" class="Symbol">=</a> <a id="9130" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="9135" class="Symbol">(</a><a id="9136" href="Cat.Functor.Equivalence.html#8900" class="Function">f*x-iso</a> <a id="9144" class="Symbol">.</a><a id="9145" href="Cat.Morphism.html#2267" data-type="(C ≅ a) b → Hom C b a" class="Field">di.from</a><a id="9152" class="Symbol">)</a>

      <a id="9161" href="Cat.Functor.Equivalence.html#9161" class="Function">y→f*y</a> <a id="9167" class="Symbol">:</a> <a id="9169" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">C.Hom</a> <a id="9175" href="Cat.Functor.Equivalence.html#8049" class="Bound">y</a> <a id="9177" href="Cat.Functor.Equivalence.html#8954" class="Function">f*y</a>
      <a id="9187" href="Cat.Functor.Equivalence.html#9161" class="Function">y→f*y</a> <a id="9193" class="Symbol">=</a> <a id="9195" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="9200" class="Symbol">(</a><a id="9201" href="Cat.Functor.Equivalence.html#8967" class="Function">f*y-iso</a> <a id="9209" class="Symbol">.</a><a id="9210" href="Cat.Morphism.html#2267" data-type="(C ≅ a) b → Hom C b a" class="Field">di.from</a><a id="9217" class="Symbol">)</a>
</pre>
</details>
<p>For the counit, we have to provide a morphism
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><msup><mi>F</mi><mo>∗</mo></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>→</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">FF^*(x) \to x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>;</span>
We can again pick the given isomorphism.</p>
<pre class="Agda">  <a id="9351" href="Cat.Functor.Equivalence.html#9351" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
F F∘ G ff eso =&gt; Id" class="Function">ff+split-eso→counit</a> <a id="9371" class="Symbol">:</a> <a id="9373" class="Symbol">(</a><a id="9374" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="9376" href="Cat.Base.html#9683" data-type="Functor D E → Functor C D → Functor C E" class="Function Operator">F∘</a> <a id="9379" href="Cat.Functor.Equivalence.html#7363" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) → Functor D C" class="Function">G</a><a id="9380" class="Symbol">)</a> <a id="9382" href="Cat.Base.html#12227" data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" class="Record Operator">=&gt;</a> <a id="9385" href="Cat.Base.html#11708" data-type="Functor C C" class="Function">Id</a>
  <a id="9390" href="Cat.Functor.Equivalence.html#9351" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
F F∘ G ff eso =&gt; Id" class="Function">ff+split-eso→counit</a> <a id="9410" class="Symbol">.</a><a id="9411" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="9413" href="Cat.Functor.Equivalence.html#9413" class="Bound">x</a> <a id="9415" class="Symbol">=</a> <a id="9417" href="Cat.Functor.Equivalence.html#9487" class="Function">f*x-iso</a> <a id="9425" class="Symbol">.</a><a id="9426" href="Cat.Morphism.html#2244" data-type="(C ≅ a) b → Hom C a b" class="Field">di.to</a>
    <a id="9436" class="Keyword">where</a> <a id="9442" class="Keyword">open</a> <a id="9447" href="Agda.Builtin.Sigma.html#139" data-type="(A : Type a) (B₁ : A → Type b) → Type (a ⊔ b)" class="Module">∑</a> <a id="9449" class="Symbol">(</a><a id="9450" href="Cat.Functor.Equivalence.html#4225" class="Bound">eso</a> <a id="9454" href="Cat.Functor.Equivalence.html#9413" class="Bound">x</a><a id="9455" class="Symbol">)</a> <a id="9457" class="Keyword">renaming</a> <a id="9466" class="Symbol">(</a><a id="9467" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="9471" class="Symbol">to</a> <a id="9474" class="Field">f*x</a> <a id="9478" class="Symbol">;</a> <a id="9480" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="9484" class="Symbol">to</a> <a id="9487" class="Field">f*x-iso</a><a id="9494" class="Symbol">)</a>
</pre>
<details>
<summary>
Naturality of
<span class="Agda"><a href="Cat.Functor.Equivalence.html#9351" class="Function">ff+split-eso→counit</a></span>
</summary>
<pre class="Agda">  <a id="9586" href="Cat.Functor.Equivalence.html#9351" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
F F∘ G ff eso =&gt; Id" class="Function">ff+split-eso→counit</a> <a id="9606" class="Symbol">.</a><a id="9607" href="Cat.Base.html#13355" data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" class="Field">is-natural</a> <a id="9618" href="Cat.Functor.Equivalence.html#9618" class="Bound">x</a> <a id="9620" href="Cat.Functor.Equivalence.html#9620" class="Bound">y</a> <a id="9622" href="Cat.Functor.Equivalence.html#9622" class="Bound">f</a> <a id="9624" class="Symbol">=</a>
    <a id="9630" href="Cat.Functor.Equivalence.html#9999" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : D .Ob)
(f : D .Hom x y) →
Hom D (F₀ F (eso y .fst)) y" class="Function">fty</a> <a id="9634" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="9638" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="9641" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="9643" class="Symbol">(</a><a id="9644" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="9649" class="Symbol">(</a><a id="9650" href="Cat.Functor.Equivalence.html#9970" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : D .Ob)
(f : D .Hom x y) →
Hom D y (F₀ F (eso y .fst))" class="Function">ffy</a> <a id="9654" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="9658" href="Cat.Functor.Equivalence.html#9622" class="Bound">f</a> <a id="9660" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="9664" href="Cat.Functor.Equivalence.html#10026" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : D .Ob)
(f : D .Hom x y) →
Hom D (F₀ F (eso x .fst)) x" class="Function">ftx</a><a id="9667" class="Symbol">))</a> <span class="reasoning-step"><span class="as-written Function"><a id="9670" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="9673" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="9676" class="Symbol">(</a><a id="9677" href="Cat.Functor.Equivalence.html#9999" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : D .Ob)
(f : D .Hom x y) →
Hom D (F₀ F (eso y .fst)) y" class="Function">fty</a> <a id="9681" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘_</a><a id="9685" class="Symbol">)</a> <a id="9687" class="Symbol">(</a><a id="9688" href="1Lab.Equiv.html#6548" data-type="(eqv : is-equiv f) (x : B₁) → f (equiv→inverse eqv x) ≡ x" class="Function">equiv→counit</a> <a id="9701" href="Cat.Functor.Equivalence.html#4198" class="Bound">ff</a> <a id="9704" class="Symbol">_)</a> <a id="9707" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="9713" href="Cat.Functor.Equivalence.html#9999" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : D .Ob)
(f : D .Hom x y) →
Hom D (F₀ F (eso y .fst)) y" class="Function">fty</a> <a id="9717" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="9721" href="Cat.Functor.Equivalence.html#9970" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : D .Ob)
(f : D .Hom x y) →
Hom D y (F₀ F (eso y .fst))" class="Function">ffy</a> <a id="9725" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="9729" href="Cat.Functor.Equivalence.html#9622" class="Bound">f</a> <a id="9731" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="9735" href="Cat.Functor.Equivalence.html#10026" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : D .Ob)
(f : D .Hom x y) →
Hom D (F₀ F (eso x .fst)) x" class="Function">ftx</a>               <span class="reasoning-step"><span class="as-written Function"><a id="9753" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="9756" href="Cat.Reasoning.html#2679" data-type="(C : Precategory o ℓ) → (C ∘ h) i ≡ id C → (C ∘ h) ((C ∘ i) f) ≡ f" class="Function">D.cancell</a> <a id="9766" class="Symbol">(</a><a id="9767" href="Cat.Functor.Equivalence.html#9954" class="Function">f*y-iso</a> <a id="9775" class="Symbol">.</a><a id="9776" href="Cat.Morphism.html#1867" data-type="Inverses C f g → (C ∘ f) g ≡ id C" class="Function">di.invl</a><a id="9783" class="Symbol">)</a> <a id="9785" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="9791" href="Cat.Functor.Equivalence.html#9622" class="Bound">f</a> <a id="9793" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="9797" href="Cat.Functor.Equivalence.html#10026" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : D .Ob)
(f : D .Hom x y) →
Hom D (F₀ F (eso x .fst)) x" class="Function">ftx</a>                               <a id="9831" href="1Lab.Path.html#46945" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
    <a id="9837" class="Keyword">where</a>
      <a id="9849" class="Keyword">open</a> <a id="9854" href="Agda.Builtin.Sigma.html#139" data-type="(A : Type a) (B₁ : A → Type b) → Type (a ⊔ b)" class="Module">∑</a> <a id="9856" class="Symbol">(</a><a id="9857" href="Cat.Functor.Equivalence.html#4225" class="Bound">eso</a> <a id="9861" href="Cat.Functor.Equivalence.html#9618" class="Bound">x</a><a id="9862" class="Symbol">)</a> <a id="9864" class="Keyword">renaming</a> <a id="9873" class="Symbol">(</a><a id="9874" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="9878" class="Symbol">to</a> <a id="9881" class="Field">f*x</a> <a id="9885" class="Symbol">;</a> <a id="9887" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="9891" class="Symbol">to</a> <a id="9894" class="Field">f*x-iso</a><a id="9901" class="Symbol">)</a>
      <a id="9909" class="Keyword">open</a> <a id="9914" href="Agda.Builtin.Sigma.html#139" data-type="(A : Type a) (B₁ : A → Type b) → Type (a ⊔ b)" class="Module">∑</a> <a id="9916" class="Symbol">(</a><a id="9917" href="Cat.Functor.Equivalence.html#4225" class="Bound">eso</a> <a id="9921" href="Cat.Functor.Equivalence.html#9620" class="Bound">y</a><a id="9922" class="Symbol">)</a> <a id="9924" class="Keyword">renaming</a> <a id="9933" class="Symbol">(</a><a id="9934" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="9938" class="Symbol">to</a> <a id="9941" class="Field">f*y</a> <a id="9945" class="Symbol">;</a> <a id="9947" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="9951" class="Symbol">to</a> <a id="9954" class="Field">f*y-iso</a><a id="9961" class="Symbol">)</a>

      <a id="9970" href="Cat.Functor.Equivalence.html#9970" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : D .Ob)
(f : D .Hom x y) →
Hom D y (F₀ F (eso y .fst))" class="Function">ffy</a> <a id="9974" class="Symbol">=</a> <a id="9976" href="Cat.Functor.Equivalence.html#9954" class="Function">f*y-iso</a> <a id="9984" class="Symbol">.</a><a id="9985" href="Cat.Morphism.html#2267" data-type="(C ≅ a) b → Hom C b a" class="Field">di.from</a>
      <a id="9999" href="Cat.Functor.Equivalence.html#9999" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : D .Ob)
(f : D .Hom x y) →
Hom D (F₀ F (eso y .fst)) y" class="Function">fty</a> <a id="10003" class="Symbol">=</a> <a id="10005" href="Cat.Functor.Equivalence.html#9954" class="Function">f*y-iso</a> <a id="10013" class="Symbol">.</a><a id="10014" href="Cat.Morphism.html#2244" data-type="(C ≅ a) b → Hom C a b" class="Field">di.to</a>
      <a id="10026" href="Cat.Functor.Equivalence.html#10026" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : D .Ob)
(f : D .Hom x y) →
Hom D (F₀ F (eso x .fst)) x" class="Function">ftx</a> <a id="10030" class="Symbol">=</a> <a id="10032" href="Cat.Functor.Equivalence.html#9894" class="Function">f*x-iso</a> <a id="10040" class="Symbol">.</a><a id="10041" href="Cat.Morphism.html#2244" data-type="(C ≅ a) b → Hom C a b" class="Field">di.to</a>
</pre>
</details>
<p>Checking the triangle identities, and that the adjunction unit/counit
defined above are natural isomorphisms, is routine. We present the
calculations without commentary:</p>
<pre class="Agda">  <a id="10245" class="Keyword">open</a> <a id="10250" href="Cat.Functor.Adjoint.html#2192" data-type="(L : Functor C D) (R₁ : Functor D C) → Type (C.o ⊔ C.h ⊔ D.o ⊔ D.h)" class="Module Operator">_⊣_</a>

  <a id="10257" href="Cat.Functor.Equivalence.html#10257" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) → F ⊣ G ff eso" class="Function">ff+split-eso→F⊣inverse</a> <a id="10280" class="Symbol">:</a> <a id="10282" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="10284" href="Cat.Functor.Adjoint.html#2192" data-type="(L : Functor C D) (R₁ : Functor D C) → Type (C.o ⊔ C.h ⊔ D.o ⊔ D.h)" class="Record Operator">⊣</a> <a id="10286" href="Cat.Functor.Equivalence.html#7363" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) → Functor D C" class="Function">G</a>
  <a id="10290" href="Cat.Functor.Equivalence.html#10257" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) → F ⊣ G ff eso" class="Function">ff+split-eso→F⊣inverse</a> <a id="10313" class="Symbol">.</a><a id="10314" href="Cat.Functor.Adjoint.html#2342" data-type="L ⊣ R₁ → Id =&gt; R₁ F∘ L" class="Field">unit</a>    <a id="10322" class="Symbol">=</a> <a id="10324" href="Cat.Functor.Equivalence.html#7771" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Id =&gt; G ff eso F∘ F" class="Function">ff+split-eso→unit</a>
  <a id="10344" href="Cat.Functor.Equivalence.html#10257" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) → F ⊣ G ff eso" class="Function">ff+split-eso→F⊣inverse</a> <a id="10367" class="Symbol">.</a><a id="10368" href="Cat.Functor.Adjoint.html#2370" data-type="L ⊣ R₁ → L F∘ R₁ =&gt; Id" class="Field">counit</a>  <a id="10376" class="Symbol">=</a> <a id="10378" href="Cat.Functor.Equivalence.html#9351" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
F F∘ G ff eso =&gt; Id" class="Function">ff+split-eso→counit</a>
  <a id="10400" href="Cat.Functor.Equivalence.html#10257" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) → F ⊣ G ff eso" class="Function">ff+split-eso→F⊣inverse</a> <a id="10423" class="Symbol">.</a><a id="10424" href="Cat.Functor.Adjoint.html#2943" data-type="(r : L ⊣ R₁) →
D ._∘_ (η (r .counit) (F₀ L A)) (F₁ L (r .unit .η A)) ≡ D .id" class="Field">zig</a> <a id="10428" class="Symbol">{</a><a id="10429" href="Cat.Functor.Equivalence.html#10429" class="Bound">x</a><a id="10430" class="Symbol">}</a> <a id="10432" class="Symbol">=</a>
    <a id="10438" href="Cat.Functor.Equivalence.html#10711" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Hom D (F₀ F (eso (F₀ F x) .fst)) (F₀ F x)" class="Function">ftx</a> <a id="10442" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="10446" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="10449" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="10451" class="Symbol">(</a><a id="10452" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="10457" href="Cat.Functor.Equivalence.html#10682" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Hom D (F₀ F x) (F₀ F (eso (F₀ F x) .fst))" class="Function">ffx</a><a id="10460" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function"><a id="10462" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="10465" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="10468" class="Symbol">(</a><a id="10469" href="Cat.Functor.Equivalence.html#10711" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Hom D (F₀ F (eso (F₀ F x) .fst)) (F₀ F x)" class="Function">ftx</a> <a id="10473" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘_</a><a id="10477" class="Symbol">)</a> <a id="10479" class="Symbol">(</a><a id="10480" href="1Lab.Equiv.html#6548" data-type="(eqv : is-equiv f) (x : B₁) → f (equiv→inverse eqv x) ≡ x" class="Function">equiv→counit</a> <a id="10493" href="Cat.Functor.Equivalence.html#4198" class="Bound">ff</a> <a id="10496" class="Symbol">_)</a> <a id="10499" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="10505" href="Cat.Functor.Equivalence.html#10711" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Hom D (F₀ F (eso (F₀ F x) .fst)) (F₀ F x)" class="Function">ftx</a> <a id="10509" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="10513" href="Cat.Functor.Equivalence.html#10682" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Hom D (F₀ F x) (F₀ F (eso (F₀ F x) .fst))" class="Function">ffx</a>             <span class="reasoning-step"><span class="as-written Function"><a id="10529" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="10532" href="Cat.Functor.Equivalence.html#10666" class="Function">f*x-iso</a> <a id="10540" class="Symbol">.</a><a id="10541" href="Cat.Morphism.html#1867" data-type="Inverses C f g → (C ∘ f) g ≡ id C" class="Function">di.invl</a> <a id="10549" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="10555" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">D.id</a>                    <a id="10579" href="1Lab.Path.html#46945" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
</pre>
<!--
<pre class="Agda">    <a id="10602" class="Keyword">where</a>
      <a id="10614" class="Keyword">open</a> <a id="10619" href="Agda.Builtin.Sigma.html#139" data-type="(A : Type a) (B₁ : A → Type b) → Type (a ⊔ b)" class="Module">∑</a> <a id="10621" class="Symbol">(</a><a id="10622" href="Cat.Functor.Equivalence.html#4225" class="Bound">eso</a> <a id="10626" class="Symbol">(</a><a id="10627" href="Cat.Base.html#7988" data-type="Functor C D → C .Ob → Ob D" class="Field">F₀</a> <a id="10630" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="10632" href="Cat.Functor.Equivalence.html#10429" class="Bound">x</a><a id="10633" class="Symbol">))</a> <a id="10636" class="Keyword">renaming</a> <a id="10645" class="Symbol">(</a><a id="10646" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="10650" class="Symbol">to</a> <a id="10653" class="Field">f*x</a> <a id="10657" class="Symbol">;</a> <a id="10659" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="10663" class="Symbol">to</a> <a id="10666" class="Field">f*x-iso</a><a id="10673" class="Symbol">)</a>

      <a id="10682" href="Cat.Functor.Equivalence.html#10682" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Hom D (F₀ F x) (F₀ F (eso (F₀ F x) .fst))" class="Function">ffx</a> <a id="10686" class="Symbol">=</a> <a id="10688" href="Cat.Functor.Equivalence.html#10666" class="Function">f*x-iso</a> <a id="10696" class="Symbol">.</a><a id="10697" href="Cat.Morphism.html#2267" data-type="(C ≅ a) b → Hom C b a" class="Field">di.from</a>
      <a id="10711" href="Cat.Functor.Equivalence.html#10711" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Hom D (F₀ F (eso (F₀ F x) .fst)) (F₀ F x)" class="Function">ftx</a> <a id="10715" class="Symbol">=</a> <a id="10717" href="Cat.Functor.Equivalence.html#10666" class="Function">f*x-iso</a> <a id="10725" class="Symbol">.</a><a id="10726" href="Cat.Morphism.html#2244" data-type="(C ≅ a) b → Hom C a b" class="Field">di.to</a>
</pre>-->
<p>The
<span class="Agda"><a href="Cat.Functor.Adjoint.html#3006" class="Field">zag</a></span>
identity needs an appeal to faithfulness:</p>
<pre class="Agda">  <a id="10811" href="Cat.Functor.Equivalence.html#10257" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) → F ⊣ G ff eso" class="Function">ff+split-eso→F⊣inverse</a> <a id="10834" class="Symbol">.</a><a id="10835" href="Cat.Functor.Adjoint.html#3006" data-type="(r : L ⊣ R₁) →
C ._∘_ (F₁ R₁ (η (r .counit) B₁)) (r .unit .η (F₀ R₁ B₁)) ≡ C .id" class="Field">zag</a> <a id="10839" class="Symbol">{</a><a id="10840" href="Cat.Functor.Equivalence.html#10840" class="Bound">x</a><a id="10841" class="Symbol">}</a> <a id="10843" class="Symbol">=</a>
    <a id="10849" href="Cat.Functor.Base.html#1212" data-type="is-fully-faithful F → is-faithful F" class="Function">fully-faithful→faithful</a> <a id="10873" class="Symbol">{</a><a id="10874" class="Argument">F</a> <a id="10876" class="Symbol">=</a> <a id="10878" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a><a id="10879" class="Symbol">}</a> <a id="10881" href="Cat.Functor.Equivalence.html#4198" class="Bound">ff</a> <a id="10884" class="Symbol">(</a>
      <a id="10892" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="10895" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="10897" class="Symbol">(</a><a id="10898" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="10903" class="Symbol">(</a><a id="10904" href="Cat.Functor.Equivalence.html#11648" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Hom D x (F₀ F (eso x .fst))" class="Function">ffx</a> <a id="10908" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="10912" href="Cat.Functor.Equivalence.html#11677" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Hom D (F₀ F (eso x .fst)) x" class="Function">ftx</a> <a id="10916" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="10920" href="Cat.Functor.Equivalence.html#11736" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Hom D (F₀ F (eso (F₀ F (eso x .fst)) .fst)) (F₀ F (eso x .fst))" class="Function">fftx</a><a id="10924" class="Symbol">)</a> <a id="10926" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="10930" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="10935" href="Cat.Functor.Equivalence.html#11704" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Hom D (F₀ F (eso x .fst)) (F₀ F (eso (F₀ F (eso x .fst)) .fst))" class="Function">fffx</a><a id="10939" class="Symbol">)</a>        <span class="reasoning-step"><span class="as-written Function"><a id="10948" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="10951" href="Cat.Base.html#8375" data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" class="Field">F-∘</a> <a id="10955" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="10957" class="Symbol">_</a> <a id="10959" class="Symbol">_</a> <a id="10961" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="10969" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="10972" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="10974" class="Symbol">(</a><a id="10975" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="10980" class="Symbol">(</a><a id="10981" href="Cat.Functor.Equivalence.html#11648" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Hom D x (F₀ F (eso x .fst))" class="Function">ffx</a> <a id="10985" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="10989" href="Cat.Functor.Equivalence.html#11677" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Hom D (F₀ F (eso x .fst)) x" class="Function">ftx</a> <a id="10993" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="10997" href="Cat.Functor.Equivalence.html#11736" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Hom D (F₀ F (eso (F₀ F (eso x .fst)) .fst)) (F₀ F (eso x .fst))" class="Function">fftx</a><a id="11001" class="Symbol">))</a> <a id="11004" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="11008" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="11011" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="11013" class="Symbol">(</a><a id="11014" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="11019" href="Cat.Functor.Equivalence.html#11704" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Hom D (F₀ F (eso x .fst)) (F₀ F (eso (F₀ F (eso x .fst)) .fst))" class="Function">fffx</a><a id="11023" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function"><a id="11025" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="11028" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="11032" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D._∘_</a> <a id="11038" class="Symbol">(</a><a id="11039" href="1Lab.Equiv.html#6548" data-type="(eqv : is-equiv f) (x : B₁) → f (equiv→inverse eqv x) ≡ x" class="Function">equiv→counit</a> <a id="11052" href="Cat.Functor.Equivalence.html#4198" class="Bound">ff</a> <a id="11055" class="Symbol">_)</a> <a id="11058" class="Symbol">(</a><a id="11059" href="1Lab.Equiv.html#6548" data-type="(eqv : is-equiv f) (x : B₁) → f (equiv→inverse eqv x) ≡ x" class="Function">equiv→counit</a> <a id="11072" href="Cat.Functor.Equivalence.html#4198" class="Bound">ff</a> <a id="11075" class="Symbol">_)</a> <a id="11078" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="11086" class="Symbol">(</a><a id="11087" href="Cat.Functor.Equivalence.html#11648" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Hom D x (F₀ F (eso x .fst))" class="Function">ffx</a> <a id="11091" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="11095" href="Cat.Functor.Equivalence.html#11677" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Hom D (F₀ F (eso x .fst)) x" class="Function">ftx</a> <a id="11099" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="11103" href="Cat.Functor.Equivalence.html#11736" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Hom D (F₀ F (eso (F₀ F (eso x .fst)) .fst)) (F₀ F (eso x .fst))" class="Function">fftx</a><a id="11107" class="Symbol">)</a> <a id="11109" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="11113" href="Cat.Functor.Equivalence.html#11704" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Hom D (F₀ F (eso x .fst)) (F₀ F (eso (F₀ F (eso x .fst)) .fst))" class="Function">fffx</a>                         <span class="reasoning-step"><span class="as-written Function"><a id="11142" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="11145" href="Cat.Solver.html#7426" data-type="Term → Term → TC ⊤" class="Macro">solve</a> <a id="11151" href="Cat.Functor.Equivalence.html#4194" class="Bound">D</a> <a id="11153" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="11161" class="Symbol">(</a><a id="11162" href="Cat.Functor.Equivalence.html#11648" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Hom D x (F₀ F (eso x .fst))" class="Function">ffx</a> <a id="11166" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="11170" href="Cat.Functor.Equivalence.html#11677" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Hom D (F₀ F (eso x .fst)) x" class="Function">ftx</a><a id="11173" class="Symbol">)</a> <a id="11175" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="11179" class="Symbol">(</a><a id="11180" href="Cat.Functor.Equivalence.html#11736" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Hom D (F₀ F (eso (F₀ F (eso x .fst)) .fst)) (F₀ F (eso x .fst))" class="Function">fftx</a> <a id="11185" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="11189" href="Cat.Functor.Equivalence.html#11704" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Hom D (F₀ F (eso x .fst)) (F₀ F (eso (F₀ F (eso x .fst)) .fst))" class="Function">fffx</a><a id="11193" class="Symbol">)</a>                       <span class="reasoning-step"><span class="as-written Function"><a id="11217" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="11220" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="11224" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D._∘_</a> <a id="11230" class="Symbol">(</a><a id="11231" href="Cat.Functor.Equivalence.html#11559" class="Function">f*x-iso</a> <a id="11239" class="Symbol">.</a><a id="11240" href="Cat.Morphism.html#1889" data-type="Inverses C f g → (C ∘ g) f ≡ id C" class="Function">di.invr</a><a id="11247" class="Symbol">)</a> <a id="11249" class="Symbol">(</a><a id="11250" href="Cat.Functor.Equivalence.html#11630" class="Function">f*f*x-iso</a> <a id="11260" class="Symbol">.</a><a id="11261" href="Cat.Morphism.html#1867" data-type="Inverses C f g → (C ∘ f) g ≡ id C" class="Function">di.invl</a><a id="11268" class="Symbol">)</a> <a id="11270" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="11278" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">D.id</a> <a id="11283" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="11287" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">D.id</a>                                           <span class="reasoning-step"><span class="as-written Function"><a id="11334" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="11337" href="Cat.Base.html#3482" data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ (r .id) f ≡ f" class="Function">D.idl</a> <a id="11343" class="Symbol">_</a> <a id="11345" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="11347" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="11351" class="Symbol">(</a><a id="11352" href="Cat.Base.html#8335" data-type="(r : Functor C D) → r .F₁ (C .id) ≡ id D" class="Field">F-id</a> <a id="11357" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a><a id="11358" class="Symbol">)</a> <a id="11360" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="11368" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="11371" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="11373" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">C.id</a>                                               <a id="11424" href="1Lab.Path.html#46945" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
    <a id="11430" class="Symbol">)</a>
</pre>
<p>Now to show they are componentwise invertible:</p>
<!--
<pre class="Agda">    <a id="11502" class="Keyword">where</a>
      <a id="11514" class="Keyword">open</a> <a id="11519" href="Agda.Builtin.Sigma.html#139" data-type="(A : Type a) (B₁ : A → Type b) → Type (a ⊔ b)" class="Module">∑</a> <a id="11521" class="Symbol">(</a><a id="11522" href="Cat.Functor.Equivalence.html#4225" class="Bound">eso</a> <a id="11526" href="Cat.Functor.Equivalence.html#10840" class="Bound">x</a><a id="11527" class="Symbol">)</a> <a id="11529" class="Keyword">renaming</a> <a id="11538" class="Symbol">(</a><a id="11539" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="11543" class="Symbol">to</a> <a id="11546" class="Field">f*x</a> <a id="11550" class="Symbol">;</a> <a id="11552" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="11556" class="Symbol">to</a> <a id="11559" class="Field">f*x-iso</a><a id="11566" class="Symbol">)</a>
      <a id="11574" class="Keyword">open</a> <a id="11579" href="Agda.Builtin.Sigma.html#139" data-type="(A : Type a) (B₁ : A → Type b) → Type (a ⊔ b)" class="Module">∑</a> <a id="11581" class="Symbol">(</a><a id="11582" href="Cat.Functor.Equivalence.html#4225" class="Bound">eso</a> <a id="11586" class="Symbol">(</a><a id="11587" href="Cat.Base.html#7988" data-type="Functor C D → C .Ob → Ob D" class="Field">F₀</a> <a id="11590" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="11592" href="Cat.Functor.Equivalence.html#11546" class="Function">f*x</a><a id="11595" class="Symbol">))</a> <a id="11598" class="Keyword">renaming</a> <a id="11607" class="Symbol">(</a><a id="11608" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="11612" class="Symbol">to</a> <a id="11615" class="Field">f*f*x</a> <a id="11621" class="Symbol">;</a> <a id="11623" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="11627" class="Symbol">to</a> <a id="11630" class="Field">f*f*x-iso</a><a id="11639" class="Symbol">)</a>

      <a id="11648" href="Cat.Functor.Equivalence.html#11648" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Hom D x (F₀ F (eso x .fst))" class="Function">ffx</a> <a id="11652" class="Symbol">=</a> <a id="11654" href="Cat.Functor.Equivalence.html#11559" class="Function">f*x-iso</a> <a id="11662" class="Symbol">.</a><a id="11663" href="Cat.Morphism.html#2267" data-type="(C ≅ a) b → Hom C b a" class="Field">di.from</a>
      <a id="11677" href="Cat.Functor.Equivalence.html#11677" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Hom D (F₀ F (eso x .fst)) x" class="Function">ftx</a> <a id="11681" class="Symbol">=</a> <a id="11683" href="Cat.Functor.Equivalence.html#11559" class="Function">f*x-iso</a> <a id="11691" class="Symbol">.</a><a id="11692" href="Cat.Morphism.html#2244" data-type="(C ≅ a) b → Hom C a b" class="Field">di.to</a>
      <a id="11704" href="Cat.Functor.Equivalence.html#11704" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Hom D (F₀ F (eso x .fst)) (F₀ F (eso (F₀ F (eso x .fst)) .fst))" class="Function">fffx</a> <a id="11709" class="Symbol">=</a> <a id="11711" href="Cat.Functor.Equivalence.html#11630" class="Function">f*f*x-iso</a> <a id="11721" class="Symbol">.</a><a id="11722" href="Cat.Morphism.html#2267" data-type="(C ≅ a) b → Hom C b a" class="Field">di.from</a>
      <a id="11736" href="Cat.Functor.Equivalence.html#11736" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Hom D (F₀ F (eso (F₀ F (eso x .fst)) .fst)) (F₀ F (eso x .fst))" class="Function">fftx</a> <a id="11741" class="Symbol">=</a> <a id="11743" href="Cat.Functor.Equivalence.html#11630" class="Function">f*f*x-iso</a> <a id="11753" class="Symbol">.</a><a id="11754" href="Cat.Morphism.html#2244" data-type="(C ≅ a) b → Hom C a b" class="Field">di.to</a>
</pre>-->
<pre class="Agda">  <a id="11779" class="Keyword">open</a> <a id="11784" href="Cat.Functor.Equivalence.html#804" data-type="(F : Functor C D) → Type (C.o ⊔ C.h ⊔ D.o ⊔ D.h)" class="Module">is-equivalence</a>

  <a id="11802" href="Cat.Functor.Equivalence.html#11802" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
is-equivalence F" class="Function">ff+split-eso→is-equivalence</a> <a id="11830" class="Symbol">:</a> <a id="11832" href="Cat.Functor.Equivalence.html#804" data-type="(F : Functor C D) → Type (C.o ⊔ C.h ⊔ D.o ⊔ D.h)" class="Record">is-equivalence</a> <a id="11847" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a>
  <a id="11851" href="Cat.Functor.Equivalence.html#11802" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
is-equivalence F" class="Function">ff+split-eso→is-equivalence</a> <a id="11879" class="Symbol">.</a><a id="11880" href="Cat.Functor.Equivalence.html#1043" data-type="is-equivalence F → Functor D C" class="Field">F⁻¹</a> <a id="11884" class="Symbol">=</a> <a id="11886" href="Cat.Functor.Equivalence.html#7363" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) → Functor D C" class="Function">G</a>
  <a id="11890" href="Cat.Functor.Equivalence.html#11802" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
is-equivalence F" class="Function">ff+split-eso→is-equivalence</a> <a id="11918" class="Symbol">.</a><a id="11919" href="Cat.Functor.Equivalence.html#1070" data-type="(r : is-equivalence F) → F ⊣ r .F⁻¹" class="Field">F⊣F⁻¹</a> <a id="11925" class="Symbol">=</a> <a id="11927" href="Cat.Functor.Equivalence.html#10257" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) → F ⊣ G ff eso" class="Function">ff+split-eso→F⊣inverse</a>
  <a id="11952" href="Cat.Functor.Equivalence.html#11802" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
is-equivalence F" class="Function">ff+split-eso→is-equivalence</a> <a id="11980" class="Symbol">.</a><a id="11981" href="Cat.Functor.Equivalence.html#1177" data-type="(r : is-equivalence F) (x : D .Ob) →
is-invertible D (ε (r .F⊣F⁻¹) x)" class="Field">counit-iso</a> <a id="11992" href="Cat.Functor.Equivalence.html#11992" class="Bound">x</a> <a id="11994" class="Symbol">=</a> <a id="11996" class="Keyword">record</a>
    <a id="12007" class="Symbol">{</a> <a id="12009" href="Cat.Morphism.html#1985" data-type="is-invertible C f → Hom C b a" class="Field">inv</a>      <a id="12018" class="Symbol">=</a> <a id="12020" href="Cat.Functor.Equivalence.html#12188" class="Function">f*x-iso</a> <a id="12028" class="Symbol">.</a><a id="12029" href="Cat.Morphism.html#2267" data-type="(C ≅ a) b → Hom C b a" class="Field">di.from</a>
    <a id="12041" class="Symbol">;</a> <a id="12043" href="Cat.Morphism.html#2003" data-type="(r : is-invertible C f) → Inverses C f (r .inv)" class="Field">inverses</a> <a id="12052" class="Symbol">=</a> <a id="12054" class="Keyword">record</a>
      <a id="12067" class="Symbol">{</a> <a id="12069" href="Cat.Morphism.html#1867" data-type="Inverses C f g → (C ∘ f) g ≡ id C" class="Field">invl</a> <a id="12074" class="Symbol">=</a> <a id="12076" href="Cat.Functor.Equivalence.html#12188" class="Function">f*x-iso</a> <a id="12084" class="Symbol">.</a><a id="12085" href="Cat.Morphism.html#1867" data-type="Inverses C f g → (C ∘ f) g ≡ id C" class="Function">di.invl</a>
      <a id="12099" class="Symbol">;</a> <a id="12101" href="Cat.Morphism.html#1889" data-type="Inverses C f g → (C ∘ g) f ≡ id C" class="Field">invr</a> <a id="12106" class="Symbol">=</a> <a id="12108" href="Cat.Functor.Equivalence.html#12188" class="Function">f*x-iso</a> <a id="12116" class="Symbol">.</a><a id="12117" href="Cat.Morphism.html#1889" data-type="Inverses C f g → (C ∘ g) f ≡ id C" class="Function">di.invr</a> <a id="12125" class="Symbol">}</a>
    <a id="12131" class="Symbol">}</a>
    <a id="12137" class="Keyword">where</a> <a id="12143" class="Keyword">open</a> <a id="12148" href="Agda.Builtin.Sigma.html#139" data-type="(A : Type a) (B₁ : A → Type b) → Type (a ⊔ b)" class="Module">∑</a> <a id="12150" class="Symbol">(</a><a id="12151" href="Cat.Functor.Equivalence.html#4225" class="Bound">eso</a> <a id="12155" href="Cat.Functor.Equivalence.html#11992" class="Bound">x</a><a id="12156" class="Symbol">)</a> <a id="12158" class="Keyword">renaming</a> <a id="12167" class="Symbol">(</a><a id="12168" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="12172" class="Symbol">to</a> <a id="12175" class="Field">f*x</a> <a id="12179" class="Symbol">;</a> <a id="12181" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="12185" class="Symbol">to</a> <a id="12188" class="Field">f*x-iso</a><a id="12195" class="Symbol">)</a>
</pre>
<p>Since the unit is defined in terms of fullness, showing it is
invertible needs an appeal to faithfulness (two, actually):</p>
<pre class="Agda">  <a id="12335" href="Cat.Functor.Equivalence.html#11802" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
is-equivalence F" class="Function">ff+split-eso→is-equivalence</a> <a id="12363" class="Symbol">.</a><a id="12364" href="Cat.Functor.Equivalence.html#1127" data-type="(r : is-equivalence F) (x : C .Ob) →
is-invertible C (η (r .F⊣F⁻¹) x)" class="Field">unit-iso</a> <a id="12373" href="Cat.Functor.Equivalence.html#12373" class="Bound">x</a> <a id="12375" class="Symbol">=</a> <a id="12377" class="Keyword">record</a>
    <a id="12388" class="Symbol">{</a> <a id="12390" href="Cat.Morphism.html#1985" data-type="is-invertible C f → Hom C b a" class="Field">inv</a>      <a id="12399" class="Symbol">=</a> <a id="12401" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="12406" class="Symbol">(</a><a id="12407" href="Cat.Functor.Equivalence.html#13309" class="Function">f*x-iso</a> <a id="12415" class="Symbol">.</a><a id="12416" href="Cat.Morphism.html#2244" data-type="(C ≅ a) b → Hom C a b" class="Field">di.to</a><a id="12421" class="Symbol">)</a>
    <a id="12427" class="Symbol">;</a> <a id="12429" href="Cat.Morphism.html#2003" data-type="(r : is-invertible C f) → Inverses C f (r .inv)" class="Field">inverses</a> <a id="12438" class="Symbol">=</a> <a id="12440" class="Keyword">record</a>
      <a id="12453" class="Symbol">{</a> <a id="12455" href="Cat.Morphism.html#1867" data-type="Inverses C f g → (C ∘ f) g ≡ id C" class="Field">invl</a> <a id="12460" class="Symbol">=</a> <a id="12462" href="Cat.Functor.Base.html#1212" data-type="is-fully-faithful F → is-faithful F" class="Function">fully-faithful→faithful</a> <a id="12486" class="Symbol">{</a><a id="12487" class="Argument">F</a> <a id="12489" class="Symbol">=</a> <a id="12491" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a><a id="12492" class="Symbol">}</a> <a id="12494" href="Cat.Functor.Equivalence.html#4198" class="Bound">ff</a> <a id="12497" class="Symbol">(</a>
          <a id="12509" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="12512" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="12514" class="Symbol">(</a><a id="12515" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="12520" href="Cat.Functor.Equivalence.html#13324" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x : C .Ob) →
Hom D (F₀ F x) (F₀ F (eso (F₀ F x) .fst))" class="Function">ffx</a> <a id="12524" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="12528" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="12533" href="Cat.Functor.Equivalence.html#13353" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x : C .Ob) →
Hom D (F₀ F (eso (F₀ F x) .fst)) (F₀ F x)" class="Function">ftx</a><a id="12536" class="Symbol">)</a>        <span class="reasoning-step"><span class="as-written Function"><a id="12545" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="12548" href="Cat.Base.html#8375" data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" class="Field">F-∘</a> <a id="12552" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="12554" class="Symbol">_</a> <a id="12556" class="Symbol">_</a> <a id="12558" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
          <a id="12570" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="12573" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="12575" class="Symbol">(</a><a id="12576" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="12581" href="Cat.Functor.Equivalence.html#13324" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x : C .Ob) →
Hom D (F₀ F x) (F₀ F (eso (F₀ F x) .fst))" class="Function">ffx</a><a id="12584" class="Symbol">)</a> <a id="12586" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="12590" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="12593" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="12595" class="Symbol">(</a><a id="12596" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="12601" href="Cat.Functor.Equivalence.html#13353" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x : C .Ob) →
Hom D (F₀ F (eso (F₀ F x) .fst)) (F₀ F x)" class="Function">ftx</a><a id="12604" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function"><a id="12606" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="12609" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="12613" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D._∘_</a> <a id="12619" class="Symbol">(</a><a id="12620" href="1Lab.Equiv.html#6548" data-type="(eqv : is-equiv f) (x : B₁) → f (equiv→inverse eqv x) ≡ x" class="Function">equiv→counit</a> <a id="12633" href="Cat.Functor.Equivalence.html#4198" class="Bound">ff</a> <a id="12636" class="Symbol">_)</a> <a id="12639" class="Symbol">(</a><a id="12640" href="1Lab.Equiv.html#6548" data-type="(eqv : is-equiv f) (x : B₁) → f (equiv→inverse eqv x) ≡ x" class="Function">equiv→counit</a> <a id="12653" href="Cat.Functor.Equivalence.html#4198" class="Bound">ff</a> <a id="12656" class="Symbol">_)</a> <a id="12659" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
          <a id="12671" href="Cat.Functor.Equivalence.html#13324" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x : C .Ob) →
Hom D (F₀ F x) (F₀ F (eso (F₀ F x) .fst))" class="Function">ffx</a> <a id="12675" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="12679" href="Cat.Functor.Equivalence.html#13353" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x : C .Ob) →
Hom D (F₀ F (eso (F₀ F x) .fst)) (F₀ F x)" class="Function">ftx</a>                         <span class="reasoning-step"><span class="as-written Function"><a id="12707" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="12710" href="Cat.Functor.Equivalence.html#13309" class="Function">f*x-iso</a> <a id="12718" class="Symbol">.</a><a id="12719" href="Cat.Morphism.html#1889" data-type="Inverses C f g → (C ∘ g) f ≡ id C" class="Function">di.invr</a> <a id="12727" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
          <a id="12739" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">D.id</a>                                <span class="reasoning-step"><span class="as-written Function Operator"><a id="12775" href="1Lab.Path.html#46771" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">≡˘⟨</a> <a id="12779" href="Cat.Base.html#8335" data-type="(r : Functor C D) → r .F₁ (C .id) ≡ id D" class="Field">F-id</a> <a id="12784" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="12786" href="1Lab.Path.html#46771" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡˘</span></span>
          <a id="12798" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="12801" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="12803" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">C.id</a>                           <a id="12834" href="1Lab.Path.html#46945" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a><a id="12835" class="Symbol">)</a>
      <a id="12843" class="Symbol">;</a> <a id="12845" href="Cat.Morphism.html#1889" data-type="Inverses C f g → (C ∘ g) f ≡ id C" class="Field">invr</a> <a id="12850" class="Symbol">=</a> <a id="12852" href="Cat.Functor.Base.html#1212" data-type="is-fully-faithful F → is-faithful F" class="Function">fully-faithful→faithful</a> <a id="12876" class="Symbol">{</a><a id="12877" class="Argument">F</a> <a id="12879" class="Symbol">=</a> <a id="12881" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a><a id="12882" class="Symbol">}</a> <a id="12884" href="Cat.Functor.Equivalence.html#4198" class="Bound">ff</a> <a id="12887" class="Symbol">(</a>
          <a id="12899" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="12902" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="12904" class="Symbol">(</a><a id="12905" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="12910" href="Cat.Functor.Equivalence.html#13353" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x : C .Ob) →
Hom D (F₀ F (eso (F₀ F x) .fst)) (F₀ F x)" class="Function">ftx</a> <a id="12914" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="12918" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="12923" href="Cat.Functor.Equivalence.html#13324" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x : C .Ob) →
Hom D (F₀ F x) (F₀ F (eso (F₀ F x) .fst))" class="Function">ffx</a><a id="12926" class="Symbol">)</a>        <span class="reasoning-step"><span class="as-written Function"><a id="12935" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="12938" href="Cat.Base.html#8375" data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" class="Field">F-∘</a> <a id="12942" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="12944" class="Symbol">_</a> <a id="12946" class="Symbol">_</a> <a id="12948" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
          <a id="12960" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="12963" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="12965" class="Symbol">(</a><a id="12966" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="12971" href="Cat.Functor.Equivalence.html#13353" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x : C .Ob) →
Hom D (F₀ F (eso (F₀ F x) .fst)) (F₀ F x)" class="Function">ftx</a><a id="12974" class="Symbol">)</a> <a id="12976" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="12980" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="12983" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="12985" class="Symbol">(</a><a id="12986" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="12991" href="Cat.Functor.Equivalence.html#13324" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x : C .Ob) →
Hom D (F₀ F x) (F₀ F (eso (F₀ F x) .fst))" class="Function">ffx</a><a id="12994" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function"><a id="12996" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="12999" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="13003" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D._∘_</a> <a id="13009" class="Symbol">(</a><a id="13010" href="1Lab.Equiv.html#6548" data-type="(eqv : is-equiv f) (x : B₁) → f (equiv→inverse eqv x) ≡ x" class="Function">equiv→counit</a> <a id="13023" href="Cat.Functor.Equivalence.html#4198" class="Bound">ff</a> <a id="13026" class="Symbol">_)</a> <a id="13029" class="Symbol">(</a><a id="13030" href="1Lab.Equiv.html#6548" data-type="(eqv : is-equiv f) (x : B₁) → f (equiv→inverse eqv x) ≡ x" class="Function">equiv→counit</a> <a id="13043" href="Cat.Functor.Equivalence.html#4198" class="Bound">ff</a> <a id="13046" class="Symbol">_)</a> <a id="13049" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
          <a id="13061" href="Cat.Functor.Equivalence.html#13353" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x : C .Ob) →
Hom D (F₀ F (eso (F₀ F x) .fst)) (F₀ F x)" class="Function">ftx</a> <a id="13065" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="13069" href="Cat.Functor.Equivalence.html#13324" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x : C .Ob) →
Hom D (F₀ F x) (F₀ F (eso (F₀ F x) .fst))" class="Function">ffx</a>                         <span class="reasoning-step"><span class="as-written Function"><a id="13097" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="13100" href="Cat.Functor.Equivalence.html#13309" class="Function">f*x-iso</a> <a id="13108" class="Symbol">.</a><a id="13109" href="Cat.Morphism.html#1867" data-type="Inverses C f g → (C ∘ f) g ≡ id C" class="Function">di.invl</a> <a id="13117" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
          <a id="13129" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">D.id</a>                                <span class="reasoning-step"><span class="as-written Function Operator"><a id="13165" href="1Lab.Path.html#46771" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">≡˘⟨</a> <a id="13169" href="Cat.Base.html#8335" data-type="(r : Functor C D) → r .F₁ (C .id) ≡ id D" class="Field">F-id</a> <a id="13174" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="13176" href="1Lab.Path.html#46771" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡˘</span></span>
          <a id="13188" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="13191" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="13193" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">C.id</a>                           <a id="13224" href="1Lab.Path.html#46945" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a><a id="13225" class="Symbol">)</a>
      <a id="13233" class="Symbol">}</a>
    <a id="13239" class="Symbol">}</a>
    <a id="13245" class="Keyword">where</a>
      <a id="13257" class="Keyword">open</a> <a id="13262" href="Agda.Builtin.Sigma.html#139" data-type="(A : Type a) (B₁ : A → Type b) → Type (a ⊔ b)" class="Module">∑</a> <a id="13264" class="Symbol">(</a><a id="13265" href="Cat.Functor.Equivalence.html#4225" class="Bound">eso</a> <a id="13269" class="Symbol">(</a><a id="13270" href="Cat.Base.html#7988" data-type="Functor C D → C .Ob → Ob D" class="Field">F₀</a> <a id="13273" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="13275" href="Cat.Functor.Equivalence.html#12373" class="Bound">x</a><a id="13276" class="Symbol">))</a> <a id="13279" class="Keyword">renaming</a> <a id="13288" class="Symbol">(</a><a id="13289" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="13293" class="Symbol">to</a> <a id="13296" class="Field">f*x</a> <a id="13300" class="Symbol">;</a> <a id="13302" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="13306" class="Symbol">to</a> <a id="13309" class="Field">f*x-iso</a><a id="13316" class="Symbol">)</a>
      <a id="13324" href="Cat.Functor.Equivalence.html#13324" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x : C .Ob) →
Hom D (F₀ F x) (F₀ F (eso (F₀ F x) .fst))" class="Function">ffx</a> <a id="13328" class="Symbol">=</a> <a id="13330" href="Cat.Functor.Equivalence.html#13309" class="Function">f*x-iso</a> <a id="13338" class="Symbol">.</a><a id="13339" href="Cat.Morphism.html#2267" data-type="(C ≅ a) b → Hom C b a" class="Field">di.from</a>
      <a id="13353" href="Cat.Functor.Equivalence.html#13353" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x : C .Ob) →
Hom D (F₀ F (eso (F₀ F x) .fst)) (F₀ F x)" class="Function">ftx</a> <a id="13357" class="Symbol">=</a> <a id="13359" href="Cat.Functor.Equivalence.html#13309" class="Function">f*x-iso</a> <a id="13367" class="Symbol">.</a><a id="13368" href="Cat.Morphism.html#2244" data-type="(C ≅ a) b → Hom C a b" class="Field">di.to</a>
</pre>
<h3 id="between-categories"><a href="#between-categories" class="header-link">Between
categories<span class="header-link-emoji">🔗</span></a></h3>
<p>Above, we made an equivalence out of any fully faithful and
<em>split</em> essentially surjective functor. In set-theoretic
mathematics (and indeed between <a href="Cat.Instances.StrictCat.html">strict categories</a>), the
splitting condition can not be lifted constructively: the statement
“every (ff, eso) functor between strict categories is an equivalence” is
equivalent to the axiom of choice.</p>
<p>However, between <a href="Cat.Univalent.html">univalent
categories</a>, the situation is different: Any essentially surjective
functor splits. In particular, any functor between univalent categories
has propositional <a href="Cat.Functor.Base.html#essential-fibres">essential fibres</a>, so a
“mere” essential surjection is automatically split. However, note that
<em>both</em> the domain <em>and</em> codomain have to be categories for
the argument to go through.</p>
<pre class="Agda"><a id="14287" class="Keyword">module</a>
  <a id="14296" href="Cat.Functor.Equivalence.html#14296" class="Module">_</a> <a id="14298" class="Symbol">(</a><a id="14299" href="Cat.Functor.Equivalence.html#14299" class="Bound">F</a> <a id="14301" class="Symbol">:</a> <a id="14303" href="Cat.Base.html#7198" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="14311" href="Cat.Functor.Equivalence.html#265" class="Generalizable">C</a> <a id="14313" href="Cat.Functor.Equivalence.html#267" class="Generalizable">D</a><a id="14314" class="Symbol">)</a> <a id="14316" class="Symbol">(</a><a id="14317" href="Cat.Functor.Equivalence.html#14317" class="Bound">ccat</a> <a id="14322" class="Symbol">:</a> <a id="14324" href="Cat.Univalent.html#946" data-type="(C : Precategory o h) → Type (o ⊔ h)" class="Function">is-category</a> <a id="14336" href="Cat.Functor.Equivalence.html#265" class="Generalizable">C</a><a id="14337" class="Symbol">)</a> <a id="14339" class="Symbol">(</a><a id="14340" href="Cat.Functor.Equivalence.html#14340" class="Bound">dcat</a> <a id="14345" class="Symbol">:</a> <a id="14347" href="Cat.Univalent.html#946" data-type="(C : Precategory o h) → Type (o ⊔ h)" class="Function">is-category</a> <a id="14359" href="Cat.Functor.Equivalence.html#267" class="Generalizable">D</a><a id="14360" class="Symbol">)</a>
    <a id="14366" class="Symbol">(</a><a id="14367" href="Cat.Functor.Equivalence.html#14367" class="Bound">ff</a> <a id="14370" class="Symbol">:</a> <a id="14372" href="Cat.Functor.Base.html#1110" data-type="Functor C D → Type (C.o ⊔ C.h ⊔ D.h)" class="Function">is-fully-faithful</a> <a id="14390" href="Cat.Functor.Equivalence.html#14299" class="Bound">F</a><a id="14391" class="Symbol">)</a>
  <a id="14395" class="Keyword">where</a>
  <a id="14403" class="Keyword">private</a>
    <a id="14415" class="Keyword">module</a> <a id="14422" href="Cat.Functor.Equivalence.html#14422" class="Module">C</a> <a id="14424" class="Symbol">=</a> <a id="14426" href="Cat.Reasoning.html" class="Module">Cat.Reasoning</a> <a id="14440" href="Cat.Functor.Equivalence.html#14311" class="Bound">C</a>
    <a id="14446" class="Keyword">module</a> <a id="14453" href="Cat.Functor.Equivalence.html#14453" class="Module">D</a> <a id="14455" class="Symbol">=</a> <a id="14457" href="Cat.Reasoning.html" class="Module">Cat.Reasoning</a> <a id="14471" href="Cat.Functor.Equivalence.html#14313" class="Bound">D</a>
</pre>
<p>So, suppose we have categories
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">\ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span>
and
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">\ca{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span>,</span>
together with a fully faithful functor
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>:</mo><mi mathvariant="script">C</mi><mo>→</mo><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">F : \ca{C} \to \ca{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span>.</span>
For any
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>:</mo><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">y : \ca{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span>,</span>
we’re given an inhabitant of
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∥</mi><msub><mo>∑</mo><mrow><mi>x</mi><mo>:</mo><mi mathvariant="script">C</mi></mrow></msub><mi>F</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>≅</mo><mi>y</mi><mi mathvariant="normal">∥</mi></mrow><annotation encoding="application/x-tex">\| \sum_{x : \ca{C}} F(x) \cong y \|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0497em;vertical-align:-0.2997em;"></span><span class="mord">∥</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1786em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mrel mtight">:</span><span class="mord mathcal mtight" style="margin-right:0.05834em;">C</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord">∥</span></span></span></span>,</span>
which we want to “get out” from under the truncation. For this, we’ll
show that the type being truncated is a proposition, so that we may
“untruncate” it.</p>
<pre class="Agda">  <a id="14853" href="Cat.Functor.Equivalence.html#14853" data-type="(F : Functor C D) →
is-category C →
is-category D →
is-fully-faithful F → (y : D .Ob) → is-prop (Essential-fibre F y)" class="Function">Essential-fibre-between-cats-is-prop</a> <a id="14890" class="Symbol">:</a> <a id="14892" class="Symbol">∀</a> <a id="14894" href="Cat.Functor.Equivalence.html#14894" class="Bound">y</a> <a id="14896" class="Symbol">→</a> <a id="14898" href="1Lab.HLevel.html#2597" data-type="Type ℓ → Type ℓ" class="Function">is-prop</a> <a id="14906" class="Symbol">(</a><a id="14907" href="Cat.Functor.Base.html#4586" data-type="Functor C D → D .Ob → Type (C.o ⊔ D.h)" class="Function">Essential-fibre</a> <a id="14923" href="Cat.Functor.Equivalence.html#14299" class="Bound">F</a> <a id="14925" href="Cat.Functor.Equivalence.html#14894" class="Bound">y</a><a id="14926" class="Symbol">)</a>
  <a id="14930" href="Cat.Functor.Equivalence.html#14853" data-type="(F : Functor C D) →
is-category C →
is-category D →
is-fully-faithful F → (y : D .Ob) → is-prop (Essential-fibre F y)" class="Function">Essential-fibre-between-cats-is-prop</a> <a id="14967" href="Cat.Functor.Equivalence.html#14967" class="Bound">z</a> <a id="14969" class="Symbol">(</a><a id="14970" href="Cat.Functor.Equivalence.html#14970" class="Bound">x</a> <a id="14972" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="14974" href="Cat.Functor.Equivalence.html#14974" class="Bound">i</a><a id="14975" class="Symbol">)</a> <a id="14977" class="Symbol">(</a><a id="14978" href="Cat.Functor.Equivalence.html#14978" class="Bound">y</a> <a id="14980" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="14982" href="Cat.Functor.Equivalence.html#14982" class="Bound">j</a><a id="14983" class="Symbol">)</a> <a id="14985" class="Symbol">=</a> <a id="14987" href="Cat.Functor.Equivalence.html#17300" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
(x , i) ≡ (y , j)" class="Function">they&#39;re-equal</a> <a id="15001" class="Keyword">where</a>
</pre>
<p>For this magic trick, assume we’re given a
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>:</mo><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">z : \ca{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span>,</span>
together with objects
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>:</mo><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">x, y : \ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span>
and isomorphisms
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>:</mo><mi>F</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>≅</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">i : F(x) \cong z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span>
and
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>:</mo><mi>F</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo>≅</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">j : F(y) \cong z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span>.</span>
We must show that
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≡</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \equiv y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4637em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>,</span>
and that over this path,
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i = j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>.</span>
Since
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span>
is fully faithful, we can
<span class="Agda"><a href="Cat.Functor.Base.html#3852" class="Function">find an isomorphism</a></span>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≅</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \cong y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.589em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>
in
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">\ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span>,</span>
which
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span>
sends back to
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>∘</mo><msup><mi>j</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">i \circ j^{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0085em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>.</span></p>
<pre class="Agda">    <a id="15412" href="Cat.Functor.Equivalence.html#15412" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
(D ≅ F₀ F x) (F₀ F y)" class="Function">Fx≅Fy</a> <a id="15418" class="Symbol">:</a> <a id="15420" href="Cat.Base.html#7988" data-type="Functor C D → C .Ob → Ob D" class="Field">F₀</a> <a id="15423" href="Cat.Functor.Equivalence.html#14299" class="Bound">F</a> <a id="15425" href="Cat.Functor.Equivalence.html#14970" class="Bound">x</a> <a id="15427" href="Cat.Morphism.html#2202" data-type="(C : Precategory o h) (a b : Ob C) → Type h" class="Record Operator">D.≅</a> <a id="15431" href="Cat.Base.html#7988" data-type="Functor C D → C .Ob → Ob D" class="Field">F₀</a> <a id="15434" href="Cat.Functor.Equivalence.html#14299" class="Bound">F</a> <a id="15436" href="Cat.Functor.Equivalence.html#14978" class="Bound">y</a>
    <a id="15442" href="Cat.Functor.Equivalence.html#15412" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
(D ≅ F₀ F x) (F₀ F y)" class="Function">Fx≅Fy</a> <a id="15448" class="Symbol">=</a> <a id="15450" href="Cat.Functor.Equivalence.html#14974" class="Bound">i</a> <a id="15452" href="Cat.Morphism.html#7585" data-type="(C : Precategory o h) → (C ≅ a) b → (C ≅ b) c → (C ≅ a) c" class="Function Operator">D.∘Iso</a> <a id="15459" class="Symbol">(</a><a id="15460" href="Cat.Functor.Equivalence.html#14982" class="Bound">j</a> <a id="15462" href="Cat.Morphism.html#7747" data-type="(C : Precategory o h) → (C ≅ a) b → (C ≅ b) a" class="Function Operator">D.Iso⁻¹</a><a id="15469" class="Symbol">)</a>

    <a id="15476" href="Cat.Functor.Equivalence.html#15476" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
(C ≅ x) y" class="Function">x≅y</a> <a id="15480" class="Symbol">:</a> <a id="15482" href="Cat.Functor.Equivalence.html#14970" class="Bound">x</a> <a id="15484" href="Cat.Morphism.html#2202" data-type="(C : Precategory o h) (a b : Ob C) → Type h" class="Record Operator">C.≅</a> <a id="15488" href="Cat.Functor.Equivalence.html#14978" class="Bound">y</a>
    <a id="15494" href="Cat.Functor.Equivalence.html#15476" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
(C ≅ x) y" class="Function">x≅y</a> <a id="15498" class="Symbol">=</a> <a id="15500" href="Cat.Functor.Base.html#3852" data-type="is-fully-faithful F → (D ≅ F₀ F X) (F₀ F Y) → (C ≅ X) Y" class="Function">is-ff→essentially-injective</a> <a id="15528" class="Symbol">{</a><a id="15529" class="Argument">F</a> <a id="15531" class="Symbol">=</a> <a id="15533" href="Cat.Functor.Equivalence.html#14299" class="Bound">F</a><a id="15534" class="Symbol">}</a> <a id="15536" href="Cat.Functor.Equivalence.html#14367" class="Bound">ff</a> <a id="15539" href="Cat.Functor.Equivalence.html#15412" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
(D ≅ F₀ F x) (F₀ F y)" class="Function">Fx≅Fy</a>
</pre>
<p>Furthermore, since we’re working with categories, these isomorphisms
restrict to <em>paths</em>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≡</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \equiv y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4637em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>
and
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>≡</mo><mi>F</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(x) \equiv F(y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>.</span>
We’re half-done: we’ve shown that some
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>:</mo><mi>x</mi><mo>≡</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">p : x \equiv y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4637em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>
exists, and it remains to show that over this path we have
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>≡</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i \equiv j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>.</span>
More specifically, we must give a path
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>≡</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i \equiv j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>
laying over
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">p</mi></mrow><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\id{ap}(F)(p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">ap</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span>.</span></p>
<pre class="Agda">    <a id="15899" href="Cat.Functor.Equivalence.html#15899" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
x ≡ y" class="Function">x≡y</a> <a id="15903" class="Symbol">:</a> <a id="15905" href="Cat.Functor.Equivalence.html#14970" class="Bound">x</a> <a id="15907" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="15909" href="Cat.Functor.Equivalence.html#14978" class="Bound">y</a>
    <a id="15915" href="Cat.Functor.Equivalence.html#15899" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
x ≡ y" class="Function">x≡y</a> <a id="15919" class="Symbol">=</a> <a id="15921" href="Cat.Univalent.html#2601" data-type="(C : Precategory o h) → is-category C → (C ≅ A) B₁ → A ≡ B₁" class="Function">iso→path</a> <a id="15930" href="Cat.Functor.Equivalence.html#14311" class="Bound">C</a> <a id="15932" href="Cat.Functor.Equivalence.html#14317" class="Bound">ccat</a> <a id="15937" href="Cat.Functor.Equivalence.html#15476" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
(C ≅ x) y" class="Function">x≅y</a>

    <a id="15946" href="Cat.Functor.Equivalence.html#15946" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
F₀ F x ≡ F₀ F y" class="Function">Fx≡Fy</a> <a id="15952" class="Symbol">:</a> <a id="15954" href="Cat.Base.html#7988" data-type="Functor C D → C .Ob → Ob D" class="Field">F₀</a> <a id="15957" href="Cat.Functor.Equivalence.html#14299" class="Bound">F</a> <a id="15959" href="Cat.Functor.Equivalence.html#14970" class="Bound">x</a> <a id="15961" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="15963" href="Cat.Base.html#7988" data-type="Functor C D → C .Ob → Ob D" class="Field">F₀</a> <a id="15966" href="Cat.Functor.Equivalence.html#14299" class="Bound">F</a> <a id="15968" href="Cat.Functor.Equivalence.html#14978" class="Bound">y</a>
    <a id="15974" href="Cat.Functor.Equivalence.html#15946" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
F₀ F x ≡ F₀ F y" class="Function">Fx≡Fy</a> <a id="15980" class="Symbol">=</a> <a id="15982" href="Cat.Univalent.html#2601" data-type="(C : Precategory o h) → is-category C → (C ≅ A) B₁ → A ≡ B₁" class="Function">iso→path</a> <a id="15991" href="Cat.Functor.Equivalence.html#14313" class="Bound">D</a> <a id="15993" href="Cat.Functor.Equivalence.html#14340" class="Bound">dcat</a> <a id="15998" href="Cat.Functor.Equivalence.html#15412" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
(D ≅ F₀ F x) (F₀ F y)" class="Function">Fx≅Fy</a>
</pre>
<p>Rather than showing it over
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>:</mo><mi>x</mi><mo>≡</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">p : x\equiv y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4637em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>
directly, we’ll show it over the path
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>≡</mo><mi>F</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(x) \equiv F(y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>
we constructed independently. This is because we can use the helper
<code class="sourceCode agda">Hom-pathp-reflr-iso</code> to establish
the result with far less computation:</p>
<pre class="Agda">    <a id="16271" href="Cat.Functor.Equivalence.html#16271" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
PathP (λ i₁ → (D ≅ Fx≡Fy F ccat dcat ff z x i y j i₁) z) i j" class="Function">over′</a> <a id="16277" class="Symbol">:</a> <a id="16279" href="Agda.Primitive.Cubical.html#2013" class="Postulate">PathP</a> <a id="16285" class="Symbol">(λ</a> <a id="16288" href="Cat.Functor.Equivalence.html#16288" class="Bound">i</a> <a id="16290" class="Symbol">→</a> <a id="16292" href="Cat.Functor.Equivalence.html#15946" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
F₀ F x ≡ F₀ F y" class="Function">Fx≡Fy</a> <a id="16298" href="Cat.Functor.Equivalence.html#16288" class="Bound">i</a> <a id="16300" href="Cat.Morphism.html#2202" data-type="(C : Precategory o h) (a b : Ob C) → Type h" class="Record Operator">D.≅</a> <a id="16304" href="Cat.Functor.Equivalence.html#14967" class="Bound">z</a><a id="16305" class="Symbol">)</a> <a id="16307" href="Cat.Functor.Equivalence.html#14974" class="Bound">i</a> <a id="16309" href="Cat.Functor.Equivalence.html#14982" class="Bound">j</a>
    <a id="16315" href="Cat.Functor.Equivalence.html#16271" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
PathP (λ i₁ → (D ≅ Fx≡Fy F ccat dcat ff z x i y j i₁) z) i j" class="Function">over′</a> <a id="16321" class="Symbol">=</a> <a id="16323" href="Cat.Morphism.html#6459" data-type="(C : Precategory o h) (p : a ≡ c) (q : b ≡ d) →
PathP (λ i → Hom C (p i) (q i)) (f .to) (g .to) →
PathP (λ i → (C ≅ p i) (q i)) f g" class="Function">D.≅-pathp</a> <a id="16333" href="Cat.Functor.Equivalence.html#15946" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
F₀ F x ≡ F₀ F y" class="Function">Fx≡Fy</a> <a id="16339" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
      <a id="16350" class="Symbol">(</a><a id="16351" href="Cat.Univalent.html#6030" data-type="(C : Precategory o h) (isc : is-category C) →
(C ∘ h) (p .from) ≡ h&#39; →
PathP (λ i → Hom C (iso→path C isc p i) B₁) h h&#39;" class="Function">Hom-pathp-refll-iso</a> <a id="16371" href="Cat.Functor.Equivalence.html#14313" class="Bound">D</a> <a id="16373" href="Cat.Functor.Equivalence.html#14340" class="Bound">dcat</a> <a id="16378" class="Symbol">(</a><a id="16379" href="Cat.Reasoning.html#2679" data-type="(C : Precategory o ℓ) → (C ∘ h) i ≡ id C → (C ∘ h) ((C ∘ i) f) ≡ f" class="Function">D.cancell</a> <a id="16389" class="Symbol">(</a><a id="16390" href="Cat.Functor.Equivalence.html#14974" class="Bound">i</a> <a id="16392" class="Symbol">.</a><a id="16393" href="Cat.Morphism.html#1867" data-type="Inverses C f g → (C ∘ f) g ≡ id C" class="Function">D._≅_.invl</a><a id="16403" class="Symbol">)))</a>
</pre>
<p>We must then connect
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">p</mi></mrow><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\id{ap}(F)(p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">ap</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span>
with this path
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>≅</mo><mi>F</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(x) \cong F(y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>.</span>
But since we originally got
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>
by full faithfulness of
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span>,</span>
they <em>are</em> indeed the same path:</p>
<pre class="Agda">    <a id="16590" class="Keyword">abstract</a>
      <a id="16605" href="Cat.Functor.Equivalence.html#16605" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
ap (F₀ F) (x≡y F ccat dcat ff z x i y j) ≡
Fx≡Fy F ccat dcat ff z x i y j" class="Function">square</a> <a id="16612" class="Symbol">:</a> <a id="16614" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="16617" class="Symbol">(</a><a id="16618" href="Cat.Base.html#7988" data-type="Functor C D → C .Ob → Ob D" class="Field">F₀</a> <a id="16621" href="Cat.Functor.Equivalence.html#14299" class="Bound">F</a><a id="16622" class="Symbol">)</a> <a id="16624" href="Cat.Functor.Equivalence.html#15899" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
x ≡ y" class="Function">x≡y</a> <a id="16628" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="16630" href="Cat.Functor.Equivalence.html#15946" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
F₀ F x ≡ F₀ F y" class="Function">Fx≡Fy</a>
      <a id="16642" href="Cat.Functor.Equivalence.html#16605" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
ap (F₀ F) (x≡y F ccat dcat ff z x i y j) ≡
Fx≡Fy F ccat dcat ff z x i y j" class="Function">square</a> <a id="16649" class="Symbol">=</a>
        <a id="16659" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="16662" class="Symbol">(</a><a id="16663" href="Cat.Base.html#7988" data-type="Functor C D → C .Ob → Ob D" class="Field">F₀</a> <a id="16666" href="Cat.Functor.Equivalence.html#14299" class="Bound">F</a><a id="16667" class="Symbol">)</a> <a id="16669" href="Cat.Functor.Equivalence.html#15899" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
x ≡ y" class="Function">x≡y</a>                       <span class="reasoning-step"><span class="as-written Function"><a id="16695" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="16698" href="Cat.Functor.Base.html#5579" data-type="(F : Functor C D) (i : (C ≅ x) y) (ccat : is-category C)
(dcat : is-category D) →
ap (F₀ F) (iso→path C ccat i) ≡ iso→path D dcat (F-map-iso F i)" class="Function">F-map-path</a> <a id="16709" href="Cat.Functor.Equivalence.html#14299" class="Bound">F</a> <a id="16711" href="Cat.Functor.Equivalence.html#15476" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
(C ≅ x) y" class="Function">x≅y</a> <a id="16715" href="Cat.Functor.Equivalence.html#14317" class="Bound">ccat</a> <a id="16720" href="Cat.Functor.Equivalence.html#14340" class="Bound">dcat</a> <a id="16725" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
        <a id="16735" href="Cat.Univalent.html#2601" data-type="(C : Precategory o h) → is-category C → (C ≅ A) B₁ → A ≡ B₁" class="Function">iso→path</a> <a id="16744" href="Cat.Functor.Equivalence.html#14313" class="Bound">D</a> <a id="16746" href="Cat.Functor.Equivalence.html#14340" class="Bound">dcat</a> <a id="16751" class="Symbol">(</a><a id="16752" href="Cat.Functor.Base.html#5283" data-type="(F : Functor C D) → (C ≅ x) y → (D ≅ F₀ F x) (F₀ F y)" class="Function">F-map-iso</a> <a id="16762" href="Cat.Functor.Equivalence.html#14299" class="Bound">F</a> <a id="16764" href="Cat.Functor.Equivalence.html#15476" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
(C ≅ x) y" class="Function">x≅y</a><a id="16767" class="Symbol">)</a>   <span class="reasoning-step"><span class="as-written Function"><a id="16771" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="16774" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="16777" class="Symbol">(</a><a id="16778" href="Cat.Univalent.html#2601" data-type="(C : Precategory o h) → is-category C → (C ≅ A) B₁ → A ≡ B₁" class="Function">iso→path</a> <a id="16787" href="Cat.Functor.Equivalence.html#14313" class="Bound">D</a> <a id="16789" href="Cat.Functor.Equivalence.html#14340" class="Bound">dcat</a><a id="16793" class="Symbol">)</a> <a id="16795" class="Symbol">(</a><a id="16796" href="1Lab.Equiv.html#6548" data-type="(eqv : is-equiv f) (x : B₁) → f (equiv→inverse eqv x) ≡ x" class="Function">equiv→counit</a> <a id="16809" class="Symbol">(</a><a id="16810" href="Cat.Functor.Base.html#6439" data-type="is-fully-faithful F → is-equiv (F-map-iso F)" class="Function">is-ff→F-map-iso-is-equiv</a> <a id="16835" class="Symbol">{</a><a id="16836" class="Argument">F</a> <a id="16838" class="Symbol">=</a> <a id="16840" href="Cat.Functor.Equivalence.html#14299" class="Bound">F</a><a id="16841" class="Symbol">}</a> <a id="16843" href="Cat.Functor.Equivalence.html#14367" class="Bound">ff</a><a id="16845" class="Symbol">)</a> <a id="16847" class="Symbol">_)</a>  <a id="16851" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
        <a id="16861" href="Cat.Univalent.html#2601" data-type="(C : Precategory o h) → is-category C → (C ≅ A) B₁ → A ≡ B₁" class="Function">iso→path</a> <a id="16870" href="Cat.Functor.Equivalence.html#14313" class="Bound">D</a> <a id="16872" href="Cat.Functor.Equivalence.html#14340" class="Bound">dcat</a> <a id="16877" href="Cat.Functor.Equivalence.html#15412" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
(D ≅ F₀ F x) (F₀ F y)" class="Function">Fx≅Fy</a>               <a id="16897" href="1Lab.Path.html#46945" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>

    <a id="16904" href="Cat.Functor.Equivalence.html#16904" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
PathP (λ i₁ → (D ≅ F₀ F (x≡y F ccat dcat ff z x i y j i₁)) z) i j" class="Function">over</a> <a id="16909" class="Symbol">:</a> <a id="16911" href="Agda.Primitive.Cubical.html#2013" class="Postulate">PathP</a> <a id="16917" class="Symbol">(λ</a> <a id="16920" href="Cat.Functor.Equivalence.html#16920" class="Bound">i</a> <a id="16922" class="Symbol">→</a> <a id="16924" href="Cat.Base.html#7988" data-type="Functor C D → C .Ob → Ob D" class="Field">F₀</a> <a id="16927" href="Cat.Functor.Equivalence.html#14299" class="Bound">F</a> <a id="16929" class="Symbol">(</a><a id="16930" href="Cat.Functor.Equivalence.html#15899" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
x ≡ y" class="Function">x≡y</a> <a id="16934" href="Cat.Functor.Equivalence.html#16920" class="Bound">i</a><a id="16935" class="Symbol">)</a> <a id="16937" href="Cat.Morphism.html#2202" data-type="(C : Precategory o h) (a b : Ob C) → Type h" class="Record Operator">D.≅</a> <a id="16941" href="Cat.Functor.Equivalence.html#14967" class="Bound">z</a><a id="16942" class="Symbol">)</a> <a id="16944" href="Cat.Functor.Equivalence.html#14974" class="Bound">i</a> <a id="16946" href="Cat.Functor.Equivalence.html#14982" class="Bound">j</a>
    <a id="16952" href="Cat.Functor.Equivalence.html#16904" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
PathP (λ i₁ → (D ≅ F₀ F (x≡y F ccat dcat ff z x i y j i₁)) z) i j" class="Function">over</a> <a id="16957" class="Symbol">=</a> <a id="16959" href="1Lab.Path.html#11776" data-type="A ≡ B₁ → A → B₁" class="Function">transport</a> <a id="16969" class="Symbol">(λ</a> <a id="16972" href="Cat.Functor.Equivalence.html#16972" class="Bound">l</a> <a id="16974" class="Symbol">→</a> <a id="16976" href="Agda.Primitive.Cubical.html#2013" class="Postulate">PathP</a> <a id="16982" class="Symbol">(λ</a> <a id="16985" href="Cat.Functor.Equivalence.html#16985" class="Bound">m</a> <a id="16987" class="Symbol">→</a> <a id="16989" href="Cat.Functor.Equivalence.html#16605" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
ap (F₀ F) (x≡y F ccat dcat ff z x i y j) ≡
Fx≡Fy F ccat dcat ff z x i y j" class="Function">square</a> <a id="16996" class="Symbol">(</a><a id="16997" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="16999" href="Cat.Functor.Equivalence.html#16972" class="Bound">l</a><a id="17000" class="Symbol">)</a> <a id="17002" href="Cat.Functor.Equivalence.html#16985" class="Bound">m</a> <a id="17004" href="Cat.Morphism.html#2202" data-type="(C : Precategory o h) (a b : Ob C) → Type h" class="Record Operator">D.≅</a> <a id="17008" href="Cat.Functor.Equivalence.html#14967" class="Bound">z</a><a id="17009" class="Symbol">)</a> <a id="17011" href="Cat.Functor.Equivalence.html#14974" class="Bound">i</a> <a id="17013" href="Cat.Functor.Equivalence.html#14982" class="Bound">j</a><a id="17014" class="Symbol">)</a> <a id="17016" href="Cat.Functor.Equivalence.html#16271" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
PathP (λ i₁ → (D ≅ Fx≡Fy F ccat dcat ff z x i y j i₁) z) i j" class="Function">over′</a>
</pre>
<p>Hence — blink and you’ll miss it — the essential fibres of
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span>
over any
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>:</mo><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">z : \ca{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span>
are propositions, so it suffices for them to be merely inhabited for the
functor to be split eso. With tongue firmly in cheek we call this result
the <em>theorem of choice</em>.</p>
<pre class="Agda">    <a id="17300" href="Cat.Functor.Equivalence.html#17300" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
(x , i) ≡ (y , j)" class="Function">they&#39;re-equal</a> <a id="17314" class="Symbol">=</a> <a id="17316" href="1Lab.Path.html#57276" data-type="(p : x .fst ≡ y .fst) →
PathP (λ i → B₁ (p i)) (x .snd) (y .snd) → x ≡ y" class="Function">Σ-pathp</a> <a id="17324" href="Cat.Functor.Equivalence.html#15899" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
x ≡ y" class="Function">x≡y</a> <a id="17328" href="Cat.Functor.Equivalence.html#16904" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
PathP (λ i₁ → (D ≅ F₀ F (x≡y F ccat dcat ff z x i y j i₁)) z) i j" class="Function">over</a>

  <a id="17336" href="Cat.Functor.Equivalence.html#17336" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) →
is-eso F → is-split-eso F" class="Function">Theorem-of-choice</a> <a id="17354" class="Symbol">:</a> <a id="17356" href="Cat.Functor.Base.html#5070" data-type="Functor C D → Type (C.o ⊔ D.o ⊔ D.h)" class="Function">is-eso</a> <a id="17363" href="Cat.Functor.Equivalence.html#14299" class="Bound">F</a> <a id="17365" class="Symbol">→</a> <a id="17367" href="Cat.Functor.Base.html#4990" data-type="Functor C D → Type (C.o ⊔ D.o ⊔ D.h)" class="Function">is-split-eso</a> <a id="17380" href="Cat.Functor.Equivalence.html#14299" class="Bound">F</a>
  <a id="17384" href="Cat.Functor.Equivalence.html#17336" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) →
is-eso F → is-split-eso F" class="Function">Theorem-of-choice</a> <a id="17402" href="Cat.Functor.Equivalence.html#17402" class="Bound">eso</a> <a id="17406" href="Cat.Functor.Equivalence.html#17406" class="Bound">y</a> <a id="17408" class="Symbol">=</a>
    <a id="17414" href="1Lab.HIT.Truncation.html#1408" data-type="((x : ∥ A ∥) → is-prop (P x)) →
((x : A) → P (inc x)) → (x : ∥ A ∥) → P x" class="Function">∥-∥-elim</a> <a id="17423" class="Symbol">(λ</a> <a id="17426" href="Cat.Functor.Equivalence.html#17426" class="Bound">_</a> <a id="17428" class="Symbol">→</a> <a id="17430" href="Cat.Functor.Equivalence.html#14853" data-type="(F : Functor C D) →
is-category C →
is-category D →
is-fully-faithful F → (y : D .Ob) → is-prop (Essential-fibre F y)" class="Function">Essential-fibre-between-cats-is-prop</a> <a id="17467" href="Cat.Functor.Equivalence.html#17406" class="Bound">y</a><a id="17468" class="Symbol">)</a>
      <a id="17476" class="Symbol">(λ</a> <a id="17479" href="Cat.Functor.Equivalence.html#17479" class="Bound">x</a> <a id="17481" class="Symbol">→</a> <a id="17483" href="Cat.Functor.Equivalence.html#17479" class="Bound">x</a><a id="17484" class="Symbol">)</a> <a id="17486" class="Symbol">(</a><a id="17487" href="Cat.Functor.Equivalence.html#17402" class="Bound">eso</a> <a id="17491" href="Cat.Functor.Equivalence.html#17406" class="Bound">y</a><a id="17492" class="Symbol">)</a>
</pre>
<p>This theorem implies that any fully faithful, “merely” essentially
surjective functor between categories is an equivalence:</p>
<pre class="Agda">  <a id="17634" href="Cat.Functor.Equivalence.html#17634" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) →
is-eso F → is-equivalence F" class="Function">ff+eso→is-equivalence</a> <a id="17656" class="Symbol">:</a> <a id="17658" href="Cat.Functor.Base.html#5070" data-type="Functor C D → Type (C.o ⊔ D.o ⊔ D.h)" class="Function">is-eso</a> <a id="17665" href="Cat.Functor.Equivalence.html#14299" class="Bound">F</a> <a id="17667" class="Symbol">→</a> <a id="17669" href="Cat.Functor.Equivalence.html#804" data-type="(F : Functor C D) → Type (C.o ⊔ C.h ⊔ D.o ⊔ D.h)" class="Record">is-equivalence</a> <a id="17684" href="Cat.Functor.Equivalence.html#14299" class="Bound">F</a>
  <a id="17688" href="Cat.Functor.Equivalence.html#17634" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) →
is-eso F → is-equivalence F" class="Function">ff+eso→is-equivalence</a> <a id="17710" href="Cat.Functor.Equivalence.html#17710" class="Bound">eso</a> <a id="17714" class="Symbol">=</a> <a id="17716" href="Cat.Functor.Equivalence.html#11802" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
is-equivalence F" class="Function">ff+split-eso→is-equivalence</a> <a id="17744" href="Cat.Functor.Equivalence.html#14367" class="Bound">ff</a> <a id="17747" class="Symbol">(</a><a id="17748" href="Cat.Functor.Equivalence.html#17336" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) →
is-eso F → is-split-eso F" class="Function">Theorem-of-choice</a> <a id="17766" href="Cat.Functor.Equivalence.html#17710" class="Bound">eso</a><a id="17769" class="Symbol">)</a>
</pre>
<h2 id="isomorphisms"><a href="#isomorphisms" class="header-link">Isomorphisms<span class="header-link-emoji">🔗</span></a></h2>
<p>Another, more direct way of proving that a functor is an equivalence
of precategories is proving that it is an <strong>isomorphism of
precategories</strong>: It’s fully faithful, thus a typal equivalence of
morphisms, and in addition its action on objects is an equivalence of
types.</p>
<pre class="Agda"><a id="18073" class="Keyword">record</a> <a id="is-precat-iso"></a><a id="18080" href="Cat.Functor.Equivalence.html#18080" data-type="(F : Functor C D) → Type (C.o ⊔ C.h ⊔ D.o ⊔ D.h)" class="Record">is-precat-iso</a> <a id="18094" class="Symbol">(</a><a id="18095" href="Cat.Functor.Equivalence.html#18095" class="Bound">F</a> <a id="18097" class="Symbol">:</a> <a id="18099" href="Cat.Base.html#7198" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="18107" href="Cat.Functor.Equivalence.html#265" class="Generalizable">C</a> <a id="18109" href="Cat.Functor.Equivalence.html#267" class="Generalizable">D</a><a id="18110" class="Symbol">)</a> <a id="18112" class="Symbol">:</a> <a id="18114" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="18119" class="Symbol">(</a><a id="18120" href="Cat.Functor.Adjoint.html#549" data-type="Precategory o₁ h₁ → Precategory o₂ h₂ → Level" class="Function">adj-level</a> <a id="18130" href="Cat.Functor.Equivalence.html#18107" class="Bound">C</a> <a id="18132" href="Cat.Functor.Equivalence.html#18109" class="Bound">D</a><a id="18133" class="Symbol">)</a> <a id="18135" class="Keyword">where</a>
  <a id="18143" class="Keyword">field</a>
    <a id="is-precat-iso.has-is-ff"></a><a id="18153" href="Cat.Functor.Equivalence.html#18153" data-type="is-precat-iso F → is-fully-faithful F" class="Field">has-is-ff</a>  <a id="18164" class="Symbol">:</a> <a id="18166" href="Cat.Functor.Base.html#1110" data-type="Functor C D → Type (C.o ⊔ C.h ⊔ D.h)" class="Function">is-fully-faithful</a> <a id="18184" href="Cat.Functor.Equivalence.html#18095" class="Bound">F</a>
    <a id="is-precat-iso.has-is-iso"></a><a id="18190" href="Cat.Functor.Equivalence.html#18190" data-type="is-precat-iso F → is-equiv (F₀ F)" class="Field">has-is-iso</a> <a id="18201" class="Symbol">:</a> <a id="18203" href="1Lab.Equiv.html#2286" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-equiv</a> <a id="18212" class="Symbol">(</a><a id="18213" href="Cat.Base.html#7988" data-type="Functor C D → C .Ob → Ob D" class="Field">F₀</a> <a id="18216" href="Cat.Functor.Equivalence.html#18095" class="Bound">F</a><a id="18217" class="Symbol">)</a>
</pre>
<p>Such a functor is (immediately) fully faithful, and the inverse
<span class="Agda"><a href="Cat.Functor.Equivalence.html#18190" class="Field">has-is-iso</a></span>
means that it is split essentially surjective; For given
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>:</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">y : D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>,</span>
the inverse of
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">F_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
gives us an object
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>F</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F^{-1}(y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>;</span>
We must then provide an isomorphism
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><msup><mi>F</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>≅</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">F(F^{-1}(y)) \cong y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>,</span>
but those are identical, hence isomorphic.</p>
<pre class="Agda"><a id="18539" class="Keyword">module</a> <a id="18546" href="Cat.Functor.Equivalence.html#18546" class="Module">_</a> <a id="18548" class="Symbol">{</a><a id="18549" href="Cat.Functor.Equivalence.html#18549" class="Bound">F</a> <a id="18551" class="Symbol">:</a> <a id="18553" href="Cat.Base.html#7198" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="18561" href="Cat.Functor.Equivalence.html#265" class="Generalizable">C</a> <a id="18563" href="Cat.Functor.Equivalence.html#267" class="Generalizable">D</a><a id="18564" class="Symbol">}</a> <a id="18566" class="Symbol">(</a><a id="18567" href="Cat.Functor.Equivalence.html#18567" class="Bound">p</a> <a id="18569" class="Symbol">:</a> <a id="18571" href="Cat.Functor.Equivalence.html#18080" data-type="(F : Functor C D) → Type (C.o ⊔ C.h ⊔ D.o ⊔ D.h)" class="Record">is-precat-iso</a> <a id="18585" href="Cat.Functor.Equivalence.html#18549" class="Bound">F</a><a id="18586" class="Symbol">)</a> <a id="18588" class="Keyword">where</a>
  <a id="18596" class="Keyword">open</a> <a id="18601" href="Cat.Functor.Equivalence.html#18080" data-type="(F : Functor C D) → Type (C.o ⊔ C.h ⊔ D.o ⊔ D.h)" class="Module">is-precat-iso</a> <a id="18615" href="Cat.Functor.Equivalence.html#18567" class="Bound">p</a>

  <a id="18620" href="Cat.Functor.Equivalence.html#18620" data-type="(p : is-precat-iso F) → is-split-eso F" class="Function">is-precat-iso→is-split-eso</a> <a id="18647" class="Symbol">:</a> <a id="18649" href="Cat.Functor.Base.html#4990" data-type="Functor C D → Type (C.o ⊔ D.o ⊔ D.h)" class="Function">is-split-eso</a> <a id="18662" href="Cat.Functor.Equivalence.html#18549" class="Bound">F</a>
  <a id="18666" href="Cat.Functor.Equivalence.html#18620" data-type="(p : is-precat-iso F) → is-split-eso F" class="Function">is-precat-iso→is-split-eso</a> <a id="18693" href="Cat.Functor.Equivalence.html#18693" class="Bound">ob</a> <a id="18696" class="Symbol">=</a> <a id="18698" href="1Lab.Equiv.html#6449" data-type="is-equiv f → B₁ → A" class="Function">equiv→inverse</a> <a id="18712" href="Cat.Functor.Equivalence.html#18190" data-type="is-precat-iso F → is-equiv (F₀ F)" class="Field">has-is-iso</a> <a id="18723" href="Cat.Functor.Equivalence.html#18693" class="Bound">ob</a> <a id="18726" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="18728" href="Cat.Functor.Equivalence.html#18743" data-type="(p : is-precat-iso F) (ob : D .Ob) →
(D ≅ F₀ F (equiv→inverse (has-is-iso p) ob)) ob" class="Function">isom</a>
    <a id="18737" class="Keyword">where</a> <a id="18743" href="Cat.Functor.Equivalence.html#18743" data-type="(p : is-precat-iso F) (ob : D .Ob) →
(D ≅ F₀ F (equiv→inverse (has-is-iso p) ob)) ob" class="Function">isom</a> <a id="18748" class="Symbol">=</a> <a id="18750" href="Cat.Univalent.html#1379" data-type="(C : Precategory o h) → A ≡ B₁ → (C ≅ A) B₁" class="Function">path→iso</a> <a id="18759" href="Cat.Functor.Equivalence.html#18563" class="Bound">D</a> <a id="18761" class="Symbol">(</a><a id="18762" href="1Lab.Equiv.html#6548" data-type="(eqv : is-equiv f) (x : B₁) → f (equiv→inverse eqv x) ≡ x" class="Function">equiv→counit</a> <a id="18775" href="Cat.Functor.Equivalence.html#18190" data-type="is-precat-iso F → is-equiv (F₀ F)" class="Field">has-is-iso</a> <a id="18786" class="Symbol">_)</a>
</pre>
<p>Thus, by the theorem above,
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span>
is an adjoint equivalence of precategories.</p>
<pre class="Agda">  <a id="18881" href="Cat.Functor.Equivalence.html#18881" data-type="(p : is-precat-iso F) → is-equivalence F" class="Function">is-precat-iso→is-equivalence</a> <a id="18910" class="Symbol">:</a> <a id="18912" href="Cat.Functor.Equivalence.html#804" data-type="(F : Functor C D) → Type (C.o ⊔ C.h ⊔ D.o ⊔ D.h)" class="Record">is-equivalence</a> <a id="18927" href="Cat.Functor.Equivalence.html#18549" class="Bound">F</a>
  <a id="18931" href="Cat.Functor.Equivalence.html#18881" data-type="(p : is-precat-iso F) → is-equivalence F" class="Function">is-precat-iso→is-equivalence</a> <a id="18960" class="Symbol">=</a>
    <a id="18966" href="Cat.Functor.Equivalence.html#11802" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
is-equivalence F" class="Function">ff+split-eso→is-equivalence</a> <a id="18994" href="Cat.Functor.Equivalence.html#18153" data-type="is-precat-iso F → is-fully-faithful F" class="Field">has-is-ff</a> <a id="19004" href="Cat.Functor.Equivalence.html#18620" data-type="(p : is-precat-iso F) → is-split-eso F" class="Function">is-precat-iso→is-split-eso</a>
</pre>
  </article>
</div>
</main>
</body>
</html>
