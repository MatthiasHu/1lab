<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="keywords" content="Agda,categories,topos" />

  <title>Cat.Functor.Equivalence - 1Lab</title>

  <link rel="stylesheet" href="/css/default.css" />
  <link rel="stylesheet" href="/css/katex.min.css" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Cat.Functor.Equivalence - 1Lab" />
  <meta name="twitter:image" content="https://1lab.dev/static/cube-128x.png" />

  <meta name="og:title" content="Cat.Functor.Equivalence - 1Lab" />
  <meta name="og:image" content="https://1lab.dev/static/cube-128x.png" />
  <meta name="og:site-name" content="1Lab" />
  <meta name="og:type" content="website" />

    <meta name="og:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="twitter:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  
  <script defer src="/main.js"></script>

  <noscript>
    <style>
      body span.reasoning-step .as-written {
        display: inline;
      }

      body span.reasoning-step .alternate {
        display: none;
      }
    </style>
  </noscript>

  <!-- Google font embeds -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;0,800;1,400;1,500;1,600;1,700;1,800&amp;family=Inria+Sans:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&amp;display=swap" rel="stylesheet">
</head>

<body class="text-page">
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <!-- Table of contents (only if the page has a table of contents) -->
    <aside id="toc">
    <div id="toc-container" style="min-width: 10em; font-size: 15pt;">
      <!-- Title for the page -->
      <h3 class="Agda" style="margin-top: 0; margin-bottom: 0; white-space: pre;">
                <a class="Module">Cat.Functor.Equivalence</a>
              </h3>

      <!-- Cube logo -->
      <a id="logo" href="/">
        <img alt="1Lab" src="/static/cube-72x.png" style="display: block; margin-bottom: 1em; margin: auto;" width="32px" height="32px" />
      </a>

      <!-- Actual table of contents (separated from the rest by
      horizontal rules) -->
      <hr />
      <ul>
      <li><a href="#equivalences"><a href="#equivalences" class="header-link">Equivalences<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#fully-faithful-essentially-surjective"><a href="#fully-faithful-essentially-surjective" class="header-link">Fully
      faithful, essentially
      surjective<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#between-categories"><a href="#between-categories" class="header-link">Between
      categories<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      <li><a href="#isomorphisms"><a href="#isomorphisms" class="header-link">Isomorphisms<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      </ul>
      <hr />

      <!-- Sidebar controls -->
      <div style="display: flex; gap: 0.25em; flex-flow: row wrap;">
        <!-- Sidebar equations control -->
        <span class="equations" style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-eqns" type="checkbox" class="equations" id="sidebar-eqns">
          <label for="sidebar-eqns">Equations</label>
        </span>

        <!-- Sidebar fonts control -->
        <span style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-font" type="checkbox" id="toggle-fonts">
          <label for="toggle-fonts">Serif Font</label>
        </span>

        <!-- Sidebar footnotes control -->
        <span class="inline-footnotes" style="display: none; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-fns" type="checkbox" class="inline-footnotes" id="sidebar-fns">
          <label for="sidebar-fns">Inline Footnotes</label>
        </span>
      </div>

      <hr />

      <!-- Navbar navigation (lol) -->
      <div id="return" style="white-space: nowrap;">
        <div class="search-form search-form-proxy" role="form">
          <input id="search-box-proxy" type_="text" placeholder="Search..." autocomplete="off" tabindex="0"></input>
        </div>

              <a href="/">back to index</a> <br />
              <a href="all-pages.html">view all pages</a> <br />
        <a href="https://github.com/plt-amy/cubical-1lab/blob/5705685951a13e03eb66d1841fcf3b3de8c3ed50/src/Cat/Functor/Equivalence.lagda.md">link to source</a> <br />
                <hr /> <div class="author-list">Written by Amélia Liao</div> <br />
              </div>
    </div>
  </aside>
  
  <article>
    <!-- Article navigation (narrow screens only) -->
    <div class="narrow-only" id="article-nav">
      <!-- Index return anchor (only if the page is not the index) -->
            <div id="return">
        <a href="/">back to index</a>
      </div>
      
      <!-- Navbar equations control -->
      <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-eqns" type="checkbox" class="equations" id="navbar-eqns">
        <label for="navbar-eqns">Equations</label>
      </span>

      <!-- Navbar footnotes control -->
      <span class="inline-footnotes" style="display: none; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-fns" type="checkbox" class="inline-footnotes" id="navbar-fns">
        <label for="navbar-fns">Inline Footnotes</label>
      </span>
    </div>

<pre class="Agda"><a id="9" class="Keyword">open</a> <a id="14" class="Keyword">import</a> <a id="21" href="Cat.Instances.Functor.html" class="Module">Cat.Instances.Functor</a>
<a id="43" class="Keyword">open</a> <a id="48" class="Keyword">import</a> <a id="55" href="Cat.Functor.Adjoint.html" class="Module">Cat.Functor.Adjoint</a>
<a id="75" class="Keyword">open</a> <a id="80" class="Keyword">import</a> <a id="87" href="Cat.Functor.Base.html" class="Module">Cat.Functor.Base</a>
<a id="104" class="Keyword">open</a> <a id="109" class="Keyword">import</a> <a id="116" href="Cat.Univalent.html" class="Module">Cat.Univalent</a>
<a id="130" class="Keyword">open</a> <a id="135" class="Keyword">import</a> <a id="142" href="Cat.Prelude.html" class="Module">Cat.Prelude</a>

<a id="155" class="Keyword">import</a> <a id="162" href="Cat.Reasoning.html" class="Module">Cat.Reasoning</a>

<a id="177" class="Keyword">module</a> <a id="184" href="Cat.Functor.Equivalence.html" class="Module">Cat.Functor.Equivalence</a> <a id="208" class="Keyword">where</a>
</pre>
<!--
<pre class="Agda"><a id="232" class="Keyword">private</a> <a id="240" class="Keyword">variable</a>
  <a id="251" href="Cat.Functor.Equivalence.html#251" class="Generalizable">o</a> <a id="253" href="Cat.Functor.Equivalence.html#253" class="Generalizable">h</a> <a id="255" class="Symbol">:</a> <a id="257" href="Agda.Primitive.html#582" data-type="Type" class="Postulate">Level</a>
  <a id="265" href="Cat.Functor.Equivalence.html#265" class="Generalizable">C</a> <a id="267" href="Cat.Functor.Equivalence.html#267" class="Generalizable">D</a> <a id="269" class="Symbol">:</a> <a id="271" href="Cat.Base.html#704" data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" class="Record">Precategory</a> <a id="283" href="Cat.Functor.Equivalence.html#251" class="Generalizable">o</a> <a id="285" href="Cat.Functor.Equivalence.html#253" class="Generalizable">h</a>
<a id="287" class="Keyword">open</a> <a id="292" href="Cat.Base.html#7198" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Module">Functor</a> <a id="300" class="Keyword">hiding</a> <a id="307" class="Symbol">(</a><a id="308" href="Cat.Base.html#8958" data-type="(r : Functor C D) → Functor (C ^op) (D ^op)" class="Function">op</a><a id="310" class="Symbol">)</a>
<a id="312" class="Keyword">open</a> <a id="317" href="Cat.Base.html#12227" data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" class="Module Operator">_=&gt;_</a> <a id="322" class="Keyword">hiding</a> <a id="329" class="Symbol">(</a><a id="330" href="Cat.Base.html#13558" data-type="(r : F =&gt; G) → op G =&gt; op F" class="Function">op</a><a id="332" class="Symbol">)</a>
</pre>-->
<h1 id="equivalences"><a href="#equivalences" class="header-link">Equivalences<span class="header-link-emoji">🔗</span></a></h1>
<p>A functor
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>:</mo><mi mathvariant="script">C</mi><mo>→</mo><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">F : \ca{C} \to \ca{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span>
is an <strong>equivalence of categories</strong> when it has a <a href="Cat.Functor.Adjoint.html">right adjoint</a>
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>:</mo><mi mathvariant="script">D</mi><mo>→</mo><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">G : \ca{D} \to \ca{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span>,</span>
with the unit and counit natural transformations being <a href="Cat.Instances.Functor.html#functor-categories">natural
isomorphisms</a>. This immediately implies that our adjoint pair
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>⊣</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">F \dashv G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊣</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span>
extends to an adjoint triple
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>⊣</mo><mi>G</mi><mo>⊣</mo><mi>F</mi></mrow><annotation encoding="application/x-tex">F \dashv G \dashv F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊣</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊣</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span>.</span></p>
<pre class="Agda"><a id="797" class="Keyword">record</a> <a id="is-equivalence"></a><a id="804" href="Cat.Functor.Equivalence.html#804" data-type="(F : Functor C D) → Type (C.o ⊔ C.h ⊔ D.o ⊔ D.h)" class="Record">is-equivalence</a> <a id="819" class="Symbol">(</a><a id="820" href="Cat.Functor.Equivalence.html#820" class="Bound">F</a> <a id="822" class="Symbol">:</a> <a id="824" href="Cat.Base.html#7198" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="832" href="Cat.Functor.Equivalence.html#265" class="Generalizable">C</a> <a id="834" href="Cat.Functor.Equivalence.html#267" class="Generalizable">D</a><a id="835" class="Symbol">)</a> <a id="837" class="Symbol">:</a> <a id="839" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="844" class="Symbol">(</a><a id="845" href="Cat.Functor.Adjoint.html#549" data-type="Precategory o₁ h₁ → Precategory o₂ h₂ → Level" class="Function">adj-level</a> <a id="855" href="Cat.Functor.Equivalence.html#832" class="Bound">C</a> <a id="857" href="Cat.Functor.Equivalence.html#834" class="Bound">D</a><a id="858" class="Symbol">)</a> <a id="860" class="Keyword">where</a>
  <a id="868" class="Keyword">private</a>
    <a id="880" class="Keyword">module</a> <a id="is-equivalence.C"></a><a id="887" href="Cat.Functor.Equivalence.html#887" class="Module">C</a> <a id="889" class="Symbol">=</a> <a id="891" href="Cat.Reasoning.html" class="Module">Cat.Reasoning</a> <a id="905" href="Cat.Functor.Equivalence.html#832" class="Bound">C</a>
    <a id="911" class="Keyword">module</a> <a id="is-equivalence.D"></a><a id="918" href="Cat.Functor.Equivalence.html#918" class="Module">D</a> <a id="920" class="Symbol">=</a> <a id="922" href="Cat.Reasoning.html" class="Module">Cat.Reasoning</a> <a id="936" href="Cat.Functor.Equivalence.html#834" class="Bound">D</a>
    <a id="942" class="Keyword">module</a> <a id="is-equivalence.[C,C]"></a><a id="949" href="Cat.Functor.Equivalence.html#949" class="Module">[C,C]</a> <a id="955" class="Symbol">=</a> <a id="957" href="Cat.Reasoning.html" class="Module">Cat.Reasoning</a> <a id="971" href="Cat.Instances.Functor.html#2100" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Precategory (o₁ ⊔ o₂ ⊔ h₁ ⊔ h₂) (o₁ ⊔ h₁ ⊔ h₂)" class="Function Operator">Cat[</a> <a id="976" href="Cat.Functor.Equivalence.html#832" class="Bound">C</a> <a id="978" href="Cat.Instances.Functor.html#2100" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Precategory (o₁ ⊔ o₂ ⊔ h₁ ⊔ h₂) (o₁ ⊔ h₁ ⊔ h₂)" class="Function Operator">,</a> <a id="980" href="Cat.Functor.Equivalence.html#832" class="Bound">C</a> <a id="982" href="Cat.Instances.Functor.html#2100" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Precategory (o₁ ⊔ o₂ ⊔ h₁ ⊔ h₂) (o₁ ⊔ h₁ ⊔ h₂)" class="Function Operator">]</a>
    <a id="988" class="Keyword">module</a> <a id="is-equivalence.[D,D]"></a><a id="995" href="Cat.Functor.Equivalence.html#995" class="Module">[D,D]</a> <a id="1001" class="Symbol">=</a> <a id="1003" href="Cat.Reasoning.html" class="Module">Cat.Reasoning</a> <a id="1017" href="Cat.Instances.Functor.html#2100" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Precategory (o₁ ⊔ o₂ ⊔ h₁ ⊔ h₂) (o₁ ⊔ h₁ ⊔ h₂)" class="Function Operator">Cat[</a> <a id="1022" href="Cat.Functor.Equivalence.html#834" class="Bound">D</a> <a id="1024" href="Cat.Instances.Functor.html#2100" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Precategory (o₁ ⊔ o₂ ⊔ h₁ ⊔ h₂) (o₁ ⊔ h₁ ⊔ h₂)" class="Function Operator">,</a> <a id="1026" href="Cat.Functor.Equivalence.html#834" class="Bound">D</a> <a id="1028" href="Cat.Instances.Functor.html#2100" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Precategory (o₁ ⊔ o₂ ⊔ h₁ ⊔ h₂) (o₁ ⊔ h₁ ⊔ h₂)" class="Function Operator">]</a>

  <a id="1033" class="Keyword">field</a>
    <a id="is-equivalence.F⁻¹"></a><a id="1043" href="Cat.Functor.Equivalence.html#1043" data-type="is-equivalence F → Functor D C" class="Field">F⁻¹</a>      <a id="1052" class="Symbol">:</a> <a id="1054" href="Cat.Base.html#7198" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="1062" href="Cat.Functor.Equivalence.html#834" class="Bound">D</a> <a id="1064" href="Cat.Functor.Equivalence.html#832" class="Bound">C</a>
    <a id="is-equivalence.F⊣F⁻¹"></a><a id="1070" href="Cat.Functor.Equivalence.html#1070" data-type="(r : is-equivalence F) → F ⊣ r .F⁻¹" class="Field">F⊣F⁻¹</a>    <a id="1079" class="Symbol">:</a> <a id="1081" href="Cat.Functor.Equivalence.html#820" class="Bound">F</a> <a id="1083" href="Cat.Functor.Adjoint.html#2192" data-type="(L : Functor C D) (R₁ : Functor D C) → Type (C.o ⊔ C.h ⊔ D.o ⊔ D.h)" class="Record Operator">⊣</a> <a id="1085" href="Cat.Functor.Equivalence.html#1043" data-type="is-equivalence F → Functor D C" class="Field">F⁻¹</a>

  <a id="1092" class="Keyword">open</a> <a id="1097" href="Cat.Functor.Adjoint.html#2192" data-type="(L : Functor C D) (R₁ : Functor D C) → Type (C.o ⊔ C.h ⊔ D.o ⊔ D.h)" class="Module Operator">_⊣_</a> <a id="1101" href="Cat.Functor.Equivalence.html#1070" data-type="(r : is-equivalence F) → F ⊣ r .F⁻¹" class="Field">F⊣F⁻¹</a> <a id="1107" class="Keyword">public</a>

  <a id="1117" class="Keyword">field</a>
    <a id="is-equivalence.unit-iso"></a><a id="1127" href="Cat.Functor.Equivalence.html#1127" data-type="(r : is-equivalence F) (x : C .Ob) →
is-invertible C (η (r .F⊣F⁻¹) x)" class="Field">unit-iso</a>   <a id="1138" class="Symbol">:</a> <a id="1140" class="Symbol">∀</a> <a id="1142" href="Cat.Functor.Equivalence.html#1142" class="Bound">x</a> <a id="1144" class="Symbol">→</a> <a id="1146" href="Cat.Morphism.html#1930" data-type="(C : Precategory o h) (f : Hom C a b) → Type h" class="Record">C.is-invertible</a> <a id="1162" class="Symbol">(</a><a id="1163" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Function">unit.η</a> <a id="1170" href="Cat.Functor.Equivalence.html#1142" class="Bound">x</a><a id="1171" class="Symbol">)</a>
    <a id="is-equivalence.counit-iso"></a><a id="1177" href="Cat.Functor.Equivalence.html#1177" data-type="(r : is-equivalence F) (x : D .Ob) →
is-invertible D (ε (r .F⊣F⁻¹) x)" class="Field">counit-iso</a> <a id="1188" class="Symbol">:</a> <a id="1190" class="Symbol">∀</a> <a id="1192" href="Cat.Functor.Equivalence.html#1192" class="Bound">x</a> <a id="1194" class="Symbol">→</a> <a id="1196" href="Cat.Morphism.html#1930" data-type="(C : Precategory o h) (f : Hom C a b) → Type h" class="Record">D.is-invertible</a> <a id="1212" class="Symbol">(</a><a id="1213" href="Cat.Functor.Adjoint.html#2466" class="Function">counit.ε</a> <a id="1222" href="Cat.Functor.Equivalence.html#1192" class="Bound">x</a><a id="1223" class="Symbol">)</a>
</pre>
<p>The first thing we note is that having a natural family of invertible
morphisms gives isomorphisms in the respective functor categories:</p>
<pre class="Agda">  <a id="is-equivalence.F∘F⁻¹≅Id"></a><a id="1378" href="Cat.Functor.Equivalence.html#1378" data-type="(r : is-equivalence F) → (Cat[ D , D ] ≅ (F F∘ F⁻¹ r)) Id" class="Function">F∘F⁻¹≅Id</a> <a id="1387" class="Symbol">:</a> <a id="1389" class="Symbol">(</a><a id="1390" href="Cat.Functor.Equivalence.html#820" class="Bound">F</a> <a id="1392" href="Cat.Base.html#9683" data-type="Functor D E → Functor C D → Functor C E" class="Function Operator">F∘</a> <a id="1395" href="Cat.Functor.Equivalence.html#1043" data-type="is-equivalence F → Functor D C" class="Field">F⁻¹</a><a id="1398" class="Symbol">)</a> <a id="1400" href="Cat.Morphism.html#2202" data-type="(C : Precategory o h) (a b : Ob C) → Type h" class="Record Operator">[D,D].≅</a> <a id="1408" href="Cat.Base.html#11708" data-type="Functor C C" class="Function">Id</a>
  <a id="1413" href="Cat.Functor.Equivalence.html#1378" data-type="(r : is-equivalence F) → (Cat[ D , D ] ≅ (F F∘ F⁻¹ r)) Id" class="Function">F∘F⁻¹≅Id</a> <a id="1422" class="Symbol">=</a>
    <a id="1428" href="Cat.Morphism.html#3941" data-type="(C : Precategory o h) (f : Hom C a b) →
is-invertible C f → (C ≅ a) b" class="Function">[D,D].invertible→iso</a> <a id="1449" href="Cat.Functor.Adjoint.html#2370" data-type="L ⊣ R₁ → L F∘ R₁ =&gt; Id" class="Function">counit</a>
      <a id="1462" class="Symbol">(</a><a id="1463" href="Cat.Instances.Functor.html#8554" data-type="(eta : F =&gt; G) →
((x : C .Ob) → is-invertible D (eta .η x)) →
is-invertible Cat[ C , D ] eta" class="Function">componentwise-invertible→invertible</a> <a id="1499" class="Symbol">_</a> <a id="1501" href="Cat.Functor.Equivalence.html#1177" data-type="(r : is-equivalence F) (x : D .Ob) →
is-invertible D (ε (r .F⊣F⁻¹) x)" class="Field">counit-iso</a><a id="1511" class="Symbol">)</a>

  <a id="is-equivalence.Id≅F⁻¹∘F"></a><a id="1516" href="Cat.Functor.Equivalence.html#1516" data-type="(r : is-equivalence F) → (Cat[ C , C ] ≅ Id) (F⁻¹ r F∘ F)" class="Function">Id≅F⁻¹∘F</a> <a id="1525" class="Symbol">:</a> <a id="1527" href="Cat.Base.html#11708" data-type="Functor C C" class="Function">Id</a> <a id="1530" href="Cat.Morphism.html#2202" data-type="(C : Precategory o h) (a b : Ob C) → Type h" class="Record Operator">[C,C].≅</a> <a id="1538" class="Symbol">(</a><a id="1539" href="Cat.Functor.Equivalence.html#1043" data-type="is-equivalence F → Functor D C" class="Field">F⁻¹</a> <a id="1543" href="Cat.Base.html#9683" data-type="Functor D E → Functor C D → Functor C E" class="Function Operator">F∘</a> <a id="1546" href="Cat.Functor.Equivalence.html#820" class="Bound">F</a><a id="1547" class="Symbol">)</a>
  <a id="1551" href="Cat.Functor.Equivalence.html#1516" data-type="(r : is-equivalence F) → (Cat[ C , C ] ≅ Id) (F⁻¹ r F∘ F)" class="Function">Id≅F⁻¹∘F</a> <a id="1560" class="Symbol">=</a>
    <a id="1566" href="Cat.Morphism.html#3941" data-type="(C : Precategory o h) (f : Hom C a b) →
is-invertible C f → (C ≅ a) b" class="Function">[C,C].invertible→iso</a> <a id="1587" href="Cat.Functor.Adjoint.html#2342" data-type="L ⊣ R₁ → Id =&gt; R₁ F∘ L" class="Function">unit</a>
      <a id="1598" class="Symbol">(</a><a id="1599" href="Cat.Instances.Functor.html#8554" data-type="(eta : F =&gt; G) →
((x : C .Ob) → is-invertible D (eta .η x)) →
is-invertible Cat[ C , D ] eta" class="Function">componentwise-invertible→invertible</a> <a id="1635" class="Symbol">_</a> <a id="1637" href="Cat.Functor.Equivalence.html#1127" data-type="(r : is-equivalence F) (x : C .Ob) →
is-invertible C (η (r .F⊣F⁻¹) x)" class="Field">unit-iso</a><a id="1645" class="Symbol">)</a>

  <a id="is-equivalence.unit⁻¹"></a><a id="1650" href="Cat.Functor.Equivalence.html#1650" data-type="(r : is-equivalence F) → Hom Cat[ C , C ] (F⁻¹ r F∘ F) Id" class="Function">unit⁻¹</a> <a id="1657" class="Symbol">=</a> <a id="1659" href="Cat.Morphism.html#2267" data-type="(C ≅ a) b → Hom C b a" class="Field">[C,C]._≅_.from</a> <a id="1674" href="Cat.Functor.Equivalence.html#1516" data-type="(r : is-equivalence F) → (Cat[ C , C ] ≅ Id) (F⁻¹ r F∘ F)" class="Function">Id≅F⁻¹∘F</a>
  <a id="is-equivalence.counit⁻¹"></a><a id="1685" href="Cat.Functor.Equivalence.html#1685" data-type="(r : is-equivalence F) → Hom Cat[ D , D ] Id (F F∘ F⁻¹ r)" class="Function">counit⁻¹</a> <a id="1694" class="Symbol">=</a> <a id="1696" href="Cat.Morphism.html#2267" data-type="(C ≅ a) b → Hom C b a" class="Field">[D,D]._≅_.from</a> <a id="1711" href="Cat.Functor.Equivalence.html#1378" data-type="(r : is-equivalence F) → (Cat[ D , D ] ≅ (F F∘ F⁻¹ r)) Id" class="Function">F∘F⁻¹≅Id</a>
</pre>
<!--
<pre class="Agda">  <a id="is-equivalence.F⁻¹⊣F"></a><a id="1740" href="Cat.Functor.Equivalence.html#1740" data-type="(r : is-equivalence F) → F⁻¹ r ⊣ F" class="Function">F⁻¹⊣F</a> <a id="1746" class="Symbol">:</a> <a id="1748" href="Cat.Functor.Equivalence.html#1043" data-type="is-equivalence F → Functor D C" class="Field">F⁻¹</a> <a id="1752" href="Cat.Functor.Adjoint.html#2192" data-type="(L : Functor C D) (R₁ : Functor D C) → Type (C.o ⊔ C.h ⊔ D.o ⊔ D.h)" class="Record Operator">⊣</a> <a id="1754" href="Cat.Functor.Equivalence.html#820" class="Bound">F</a>
  <a id="1758" href="Cat.Functor.Equivalence.html#1740" data-type="(r : is-equivalence F) → F⁻¹ r ⊣ F" class="Function">F⁻¹⊣F</a> <a id="1764" class="Symbol">=</a> <a id="1766" href="Cat.Functor.Equivalence.html#1821" data-type="(r : is-equivalence F) → F⁻¹ r ⊣ F" class="Function">adj′</a> <a id="1771" class="Keyword">where</a>
    <a id="1781" class="Keyword">module</a> <a id="1788" href="Cat.Functor.Equivalence.html#1788" class="Module">adj</a> <a id="1792" class="Symbol">=</a> <a id="1794" href="Cat.Functor.Adjoint.html#2192" data-type="(L : Functor C D) (R₁ : Functor D C) → Type (C.o ⊔ C.h ⊔ D.o ⊔ D.h)" class="Module Operator">_⊣_</a> <a id="1798" href="Cat.Functor.Equivalence.html#1070" data-type="(r : is-equivalence F) → F ⊣ r .F⁻¹" class="Field">F⊣F⁻¹</a>
    <a id="1808" class="Keyword">open</a> <a id="1813" href="Cat.Functor.Adjoint.html#2192" data-type="(L : Functor C D) (R₁ : Functor D C) → Type (C.o ⊔ C.h ⊔ D.o ⊔ D.h)" class="Module Operator">_⊣_</a>
    <a id="1821" href="Cat.Functor.Equivalence.html#1821" data-type="(r : is-equivalence F) → F⁻¹ r ⊣ F" class="Function">adj′</a> <a id="1826" class="Symbol">:</a> <a id="1828" href="Cat.Functor.Equivalence.html#1043" data-type="is-equivalence F → Functor D C" class="Field">F⁻¹</a> <a id="1832" href="Cat.Functor.Adjoint.html#2192" data-type="(L : Functor C D) (R₁ : Functor D C) → Type (C.o ⊔ C.h ⊔ D.o ⊔ D.h)" class="Record Operator">⊣</a> <a id="1834" href="Cat.Functor.Equivalence.html#820" class="Bound">F</a>
    <a id="1840" href="Cat.Functor.Equivalence.html#1821" data-type="(r : is-equivalence F) → F⁻¹ r ⊣ F" class="Function">adj′</a> <a id="1845" class="Symbol">.</a><a id="1846" href="Cat.Functor.Adjoint.html#2342" data-type="L ⊣ R₁ → Id =&gt; R₁ F∘ L" class="Field">unit</a>   <a id="1853" class="Symbol">=</a> <a id="1855" href="Cat.Functor.Equivalence.html#1685" data-type="(r : is-equivalence F) → Hom Cat[ D , D ] Id (F F∘ F⁻¹ r)" class="Function">counit⁻¹</a>
    <a id="1868" href="Cat.Functor.Equivalence.html#1821" data-type="(r : is-equivalence F) → F⁻¹ r ⊣ F" class="Function">adj′</a> <a id="1873" class="Symbol">.</a><a id="1874" href="Cat.Functor.Adjoint.html#2370" data-type="L ⊣ R₁ → L F∘ R₁ =&gt; Id" class="Field">counit</a> <a id="1881" class="Symbol">=</a> <a id="1883" href="Cat.Functor.Equivalence.html#1650" data-type="(r : is-equivalence F) → Hom Cat[ C , C ] (F⁻¹ r F∘ F) Id" class="Function">unit⁻¹</a>
    <a id="1894" href="Cat.Functor.Equivalence.html#1821" data-type="(r : is-equivalence F) → F⁻¹ r ⊣ F" class="Function">adj′</a> <a id="1899" class="Symbol">.</a><a id="1900" href="Cat.Functor.Adjoint.html#2943" data-type="(r : L ⊣ R₁) →
D ._∘_ (η (r .counit) (F₀ L A)) (F₁ L (r .unit .η A)) ≡ D .id" class="Field">zig</a> <a id="1904" class="Symbol">{</a><a id="1905" href="Cat.Functor.Equivalence.html#1905" class="Bound">a</a><a id="1906" class="Symbol">}</a> <a id="1908" class="Symbol">=</a> <a id="1910" href="Cat.Functor.Equivalence.html#2302" data-type="(r : is-equivalence F) →
C ._∘_ (η (unit⁻¹ r) (F₀ (F⁻¹ r) a)) (F⁻¹ r .F₁ (counit⁻¹ r .η a))
≡ C .id" class="Function">zig′</a> <a id="1915" class="Keyword">where</a> <a id="1921" class="Keyword">abstract</a>
      <a id="1936" href="Cat.Functor.Equivalence.html#1936" data-type="(r : is-equivalence F) →
η (unit⁻¹ r) (F₀ (F⁻¹ r) a) ≡ F₁ (F⁻¹ r) (ε (F⊣F⁻¹ r) a)" class="Function">p</a> <a id="1938" class="Symbol">:</a> <a id="1940" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="1942" href="Cat.Functor.Equivalence.html#1650" data-type="(r : is-equivalence F) → Hom Cat[ C , C ] (F⁻¹ r F∘ F) Id" class="Function">unit⁻¹</a> <a id="1949" class="Symbol">(</a><a id="1950" href="Cat.Base.html#7988" data-type="Functor C D → C .Ob → Ob D" class="Field">F₀</a> <a id="1953" href="Cat.Functor.Equivalence.html#1043" data-type="is-equivalence F → Functor D C" class="Field">F⁻¹</a> <a id="1957" href="Cat.Functor.Equivalence.html#1905" class="Bound">a</a><a id="1958" class="Symbol">)</a> <a id="1960" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="1962" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="1965" href="Cat.Functor.Equivalence.html#1043" data-type="is-equivalence F → Functor D C" class="Field">F⁻¹</a> <a id="1969" class="Symbol">(</a><a id="1970" href="Cat.Functor.Adjoint.html#2466" class="Function">adj.counit.ε</a> <a id="1983" class="Symbol">_)</a>
      <a id="1992" href="Cat.Functor.Equivalence.html#1936" data-type="(r : is-equivalence F) →
η (unit⁻¹ r) (F₀ (F⁻¹ r) a) ≡ F₁ (F⁻¹ r) (ε (F⊣F⁻¹ r) a)" class="Function">p</a> <a id="1994" class="Symbol">=</a>
        <a id="2004" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="2006" href="Cat.Functor.Equivalence.html#1650" data-type="(r : is-equivalence F) → Hom Cat[ C , C ] (F⁻¹ r F∘ F) Id" class="Function">unit⁻¹</a> <a id="2013" class="Symbol">(</a><a id="2014" href="Cat.Base.html#7988" data-type="Functor C D → C .Ob → Ob D" class="Field">F₀</a> <a id="2017" href="Cat.Functor.Equivalence.html#1043" data-type="is-equivalence F → Functor D C" class="Field">F⁻¹</a> <a id="2021" href="Cat.Functor.Equivalence.html#1905" class="Bound">a</a><a id="2022" class="Symbol">)</a>                                                <a id="2071" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="2074" href="Cat.Reasoning.html#1232" data-type="(C : Precategory o ℓ) → a ≡ id C → f ≡ (C ∘ a) f" class="Function">C.introl</a> <a id="2083" href="Cat.Functor.Adjoint.html#3006" data-type="(r : L ⊣ R₁) →
C ._∘_ (F₁ R₁ (η (r .counit) B₁)) (r .unit .η (F₀ R₁ B₁)) ≡ C .id" class="Function">adj.zag</a> <a id="2091" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
        <a id="2101" class="Symbol">(</a><a id="2102" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="2105" href="Cat.Functor.Equivalence.html#1043" data-type="is-equivalence F → Functor D C" class="Field">F⁻¹</a> <a id="2109" class="Symbol">(</a><a id="2110" href="Cat.Functor.Adjoint.html#2466" class="Function">adj.counit.ε</a> <a id="2123" class="Symbol">_)</a> <a id="2126" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="2130" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Function">adj.unit.η</a> <a id="2141" class="Symbol">_)</a> <a id="2144" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="2148" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="2150" href="Cat.Functor.Equivalence.html#1650" data-type="(r : is-equivalence F) → Hom Cat[ C , C ] (F⁻¹ r F∘ F) Id" class="Function">unit⁻¹</a> <a id="2157" class="Symbol">(</a><a id="2158" href="Cat.Base.html#7988" data-type="Functor C D → C .Ob → Ob D" class="Field">F₀</a> <a id="2161" href="Cat.Functor.Equivalence.html#1043" data-type="is-equivalence F → Functor D C" class="Field">F⁻¹</a> <a id="2165" href="Cat.Functor.Equivalence.html#1905" class="Bound">a</a><a id="2166" class="Symbol">)</a> <a id="2168" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="2171" href="Cat.Reasoning.html#2789" data-type="(C : Precategory o ℓ) → (C ∘ h) i ≡ id C → (C ∘ (C ∘ f) h) i ≡ f" class="Function">C.cancelr</a> <a id="2181" class="Symbol">(</a><a id="2182" href="Cat.Functor.Equivalence.html#1127" data-type="(r : is-equivalence F) (x : C .Ob) →
is-invertible C (η (r .F⊣F⁻¹) x)" class="Field">unit-iso</a> <a id="2191" class="Symbol">_</a> <a id="2193" class="Symbol">.</a><a id="2194" href="Cat.Morphism.html#1867" data-type="Inverses C f g → (C ∘ f) g ≡ id C" class="Function">C.is-invertible.invl</a><a id="2214" class="Symbol">)</a> <a id="2216" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
        <a id="2226" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="2229" href="Cat.Functor.Equivalence.html#1043" data-type="is-equivalence F → Functor D C" class="Field">F⁻¹</a> <a id="2233" class="Symbol">(</a><a id="2234" href="Cat.Functor.Adjoint.html#2466" class="Function">adj.counit.ε</a> <a id="2247" class="Symbol">_)</a>                                            <a id="2293" href="1Lab.Path.html#46945" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>

      <a id="2302" href="Cat.Functor.Equivalence.html#2302" data-type="(r : is-equivalence F) →
C ._∘_ (η (unit⁻¹ r) (F₀ (F⁻¹ r) a)) (F⁻¹ r .F₁ (counit⁻¹ r .η a))
≡ C .id" class="Function">zig′</a> <a id="2307" class="Symbol">:</a> <a id="2309" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="2311" href="Cat.Functor.Equivalence.html#1650" data-type="(r : is-equivalence F) → Hom Cat[ C , C ] (F⁻¹ r F∘ F) Id" class="Function">unit⁻¹</a> <a id="2318" class="Symbol">(</a><a id="2319" href="Cat.Base.html#7988" data-type="Functor C D → C .Ob → Ob D" class="Field">F₀</a> <a id="2322" href="Cat.Functor.Equivalence.html#1043" data-type="is-equivalence F → Functor D C" class="Field">F⁻¹</a> <a id="2326" href="Cat.Functor.Equivalence.html#1905" class="Bound">a</a><a id="2327" class="Symbol">)</a> <a id="2329" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="2333" href="Cat.Functor.Equivalence.html#1043" data-type="is-equivalence F → Functor D C" class="Field">F⁻¹</a> <a id="2337" class="Symbol">.</a><a id="2338" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="2341" class="Symbol">(</a><a id="2342" href="Cat.Functor.Equivalence.html#1685" data-type="(r : is-equivalence F) → Hom Cat[ D , D ] Id (F F∘ F⁻¹ r)" class="Function">counit⁻¹</a> <a id="2351" class="Symbol">.</a><a id="2352" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="2354" href="Cat.Functor.Equivalence.html#1905" class="Bound">a</a><a id="2355" class="Symbol">)</a> <a id="2357" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="2359" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">C.id</a>
      <a id="2370" href="Cat.Functor.Equivalence.html#2302" data-type="(r : is-equivalence F) →
C ._∘_ (η (unit⁻¹ r) (F₀ (F⁻¹ r) a)) (F⁻¹ r .F₁ (counit⁻¹ r .η a))
≡ C .id" class="Function">zig′</a> <a id="2375" class="Symbol">=</a> <a id="2377" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="2381" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C._∘_</a> <a id="2387" href="Cat.Functor.Equivalence.html#1936" data-type="(r : is-equivalence F) →
η (unit⁻¹ r) (F₀ (F⁻¹ r) a) ≡ F₁ (F⁻¹ r) (ε (F⊣F⁻¹ r) a)" class="Function">p</a> <a id="2389" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
        <a id="2402" href="1Lab.Path.html#38293" data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" class="Function Operator">··</a> <a id="2405" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="2409" class="Symbol">(</a><a id="2410" href="Cat.Base.html#8375" data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" class="Field">F-∘</a> <a id="2414" href="Cat.Functor.Equivalence.html#1043" data-type="is-equivalence F → Functor D C" class="Field">F⁻¹</a> <a id="2418" class="Symbol">_</a> <a id="2420" class="Symbol">_)</a>
        <a id="2431" href="1Lab.Path.html#38293" data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" class="Function Operator">··</a> <a id="2434" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="2437" class="Symbol">(</a><a id="2438" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="2441" href="Cat.Functor.Equivalence.html#1043" data-type="is-equivalence F → Functor D C" class="Field">F⁻¹</a><a id="2444" class="Symbol">)</a> <a id="2446" class="Symbol">(</a><a id="2447" href="Cat.Functor.Equivalence.html#1177" data-type="(r : is-equivalence F) (x : D .Ob) →
is-invertible D (ε (r .F⊣F⁻¹) x)" class="Field">counit-iso</a> <a id="2458" class="Symbol">_</a> <a id="2460" class="Symbol">.</a><a id="2461" href="Cat.Morphism.html#1867" data-type="Inverses C f g → (C ∘ f) g ≡ id C" class="Function">D.is-invertible.invl</a><a id="2481" class="Symbol">)</a> <a id="2483" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="2485" href="Cat.Base.html#8335" data-type="(r : Functor C D) → r .F₁ (C .id) ≡ id D" class="Field">F-id</a> <a id="2490" href="Cat.Functor.Equivalence.html#1043" data-type="is-equivalence F → Functor D C" class="Field">F⁻¹</a>

    <a id="2499" href="Cat.Functor.Equivalence.html#1821" data-type="(r : is-equivalence F) → F⁻¹ r ⊣ F" class="Function">adj′</a> <a id="2504" class="Symbol">.</a><a id="2505" href="Cat.Functor.Adjoint.html#3006" data-type="(r : L ⊣ R₁) →
C ._∘_ (F₁ R₁ (η (r .counit) B₁)) (r .unit .η (F₀ R₁ B₁)) ≡ C .id" class="Field">zag</a> <a id="2509" class="Symbol">{</a><a id="2510" href="Cat.Functor.Equivalence.html#2510" class="Bound">b</a><a id="2511" class="Symbol">}</a> <a id="2513" class="Symbol">=</a> <a id="2515" href="Cat.Functor.Equivalence.html#2904" data-type="(r : is-equivalence F) →
D ._∘_ (F .F₁ (unit⁻¹ r .η b)) (counit⁻¹ r .η (F₀ F b)) ≡ D .id" class="Function">zag′</a> <a id="2520" class="Keyword">where</a> <a id="2526" class="Keyword">abstract</a>
      <a id="2541" href="Cat.Functor.Equivalence.html#2541" data-type="(r : is-equivalence F) →
counit⁻¹ r .η (F₀ F b) ≡ F .F₁ (η (F⊣F⁻¹ r) b)" class="Function">p</a> <a id="2543" class="Symbol">:</a> <a id="2545" href="Cat.Functor.Equivalence.html#1685" data-type="(r : is-equivalence F) → Hom Cat[ D , D ] Id (F F∘ F⁻¹ r)" class="Function">counit⁻¹</a> <a id="2554" class="Symbol">.</a><a id="2555" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="2557" class="Symbol">(</a><a id="2558" href="Cat.Base.html#7988" data-type="Functor C D → C .Ob → Ob D" class="Field">F₀</a> <a id="2561" href="Cat.Functor.Equivalence.html#820" class="Bound">F</a> <a id="2563" href="Cat.Functor.Equivalence.html#2510" class="Bound">b</a><a id="2564" class="Symbol">)</a> <a id="2566" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="2568" href="Cat.Functor.Equivalence.html#820" class="Bound">F</a> <a id="2570" class="Symbol">.</a><a id="2571" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="2574" class="Symbol">(</a><a id="2575" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Function">adj.unit.η</a> <a id="2586" href="Cat.Functor.Equivalence.html#2510" class="Bound">b</a><a id="2587" class="Symbol">)</a>
      <a id="2595" href="Cat.Functor.Equivalence.html#2541" data-type="(r : is-equivalence F) →
counit⁻¹ r .η (F₀ F b) ≡ F .F₁ (η (F⊣F⁻¹ r) b)" class="Function">p</a> <a id="2597" class="Symbol">=</a>
        <a id="2607" href="Cat.Functor.Equivalence.html#1685" data-type="(r : is-equivalence F) → Hom Cat[ D , D ] Id (F F∘ F⁻¹ r)" class="Function">counit⁻¹</a> <a id="2616" class="Symbol">.</a><a id="2617" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="2619" class="Symbol">_</a>                                                     <a id="2673" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="2676" href="Cat.Reasoning.html#1275" data-type="(C : Precategory o ℓ) → a ≡ id C → f ≡ (C ∘ f) a" class="Function">D.intror</a> <a id="2685" href="Cat.Functor.Adjoint.html#2943" data-type="(r : L ⊣ R₁) →
D ._∘_ (η (r .counit) (F₀ L A)) (F₁ L (r .unit .η A)) ≡ D .id" class="Function">adj.zig</a> <a id="2693" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
        <a id="2703" href="Cat.Functor.Equivalence.html#1685" data-type="(r : is-equivalence F) → Hom Cat[ D , D ] Id (F F∘ F⁻¹ r)" class="Function">counit⁻¹</a> <a id="2712" class="Symbol">.</a><a id="2713" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="2715" class="Symbol">_</a> <a id="2717" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="2721" href="Cat.Functor.Adjoint.html#2466" class="Function">adj.counit.ε</a> <a id="2734" class="Symbol">(</a><a id="2735" href="Cat.Base.html#7988" data-type="Functor C D → C .Ob → Ob D" class="Field">F₀</a> <a id="2738" href="Cat.Functor.Equivalence.html#820" class="Bound">F</a> <a id="2740" href="Cat.Functor.Equivalence.html#2510" class="Bound">b</a><a id="2741" class="Symbol">)</a> <a id="2743" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="2747" class="Symbol">(</a><a id="2748" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="2751" href="Cat.Functor.Equivalence.html#820" class="Bound">F</a> <a id="2753" class="Symbol">(</a><a id="2754" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Function">adj.unit.η</a> <a id="2765" href="Cat.Functor.Equivalence.html#2510" class="Bound">b</a><a id="2766" class="Symbol">))</a> <a id="2769" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="2772" href="Cat.Reasoning.html#2679" data-type="(C : Precategory o ℓ) → (C ∘ h) i ≡ id C → (C ∘ h) ((C ∘ i) f) ≡ f" class="Function">D.cancell</a> <a id="2782" class="Symbol">(</a><a id="2783" href="Cat.Functor.Equivalence.html#1177" data-type="(r : is-equivalence F) (x : D .Ob) →
is-invertible D (ε (r .F⊣F⁻¹) x)" class="Field">counit-iso</a> <a id="2794" class="Symbol">_</a> <a id="2796" class="Symbol">.</a><a id="2797" href="Cat.Morphism.html#1889" data-type="Inverses C f g → (C ∘ g) f ≡ id C" class="Function">D.is-invertible.invr</a><a id="2817" class="Symbol">)</a> <a id="2819" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
        <a id="2829" href="Cat.Functor.Equivalence.html#820" class="Bound">F</a> <a id="2831" class="Symbol">.</a><a id="2832" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="2835" class="Symbol">(</a><a id="2836" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Function">adj.unit.η</a> <a id="2847" href="Cat.Functor.Equivalence.html#2510" class="Bound">b</a><a id="2848" class="Symbol">)</a>                                              <a id="2895" href="1Lab.Path.html#46945" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>

      <a id="2904" href="Cat.Functor.Equivalence.html#2904" data-type="(r : is-equivalence F) →
D ._∘_ (F .F₁ (unit⁻¹ r .η b)) (counit⁻¹ r .η (F₀ F b)) ≡ D .id" class="Function">zag′</a> <a id="2909" class="Symbol">:</a> <a id="2911" href="Cat.Functor.Equivalence.html#820" class="Bound">F</a> <a id="2913" class="Symbol">.</a><a id="2914" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="2917" class="Symbol">(</a><a id="2918" href="Cat.Functor.Equivalence.html#1650" data-type="(r : is-equivalence F) → Hom Cat[ C , C ] (F⁻¹ r F∘ F) Id" class="Function">unit⁻¹</a> <a id="2925" class="Symbol">.</a><a id="2926" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="2928" href="Cat.Functor.Equivalence.html#2510" class="Bound">b</a><a id="2929" class="Symbol">)</a> <a id="2931" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="2935" href="Cat.Functor.Equivalence.html#1685" data-type="(r : is-equivalence F) → Hom Cat[ D , D ] Id (F F∘ F⁻¹ r)" class="Function">counit⁻¹</a> <a id="2944" class="Symbol">.</a><a id="2945" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="2947" class="Symbol">(</a><a id="2948" href="Cat.Base.html#7988" data-type="Functor C D → C .Ob → Ob D" class="Field">F₀</a> <a id="2951" href="Cat.Functor.Equivalence.html#820" class="Bound">F</a> <a id="2953" href="Cat.Functor.Equivalence.html#2510" class="Bound">b</a><a id="2954" class="Symbol">)</a> <a id="2956" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="2958" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">D.id</a>
      <a id="2969" href="Cat.Functor.Equivalence.html#2904" data-type="(r : is-equivalence F) →
D ._∘_ (F .F₁ (unit⁻¹ r .η b)) (counit⁻¹ r .η (F₀ F b)) ≡ D .id" class="Function">zag′</a> <a id="2974" class="Symbol">=</a> <a id="2976" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="2980" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D._∘_</a> <a id="2986" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="2991" href="Cat.Functor.Equivalence.html#2541" data-type="(r : is-equivalence F) →
counit⁻¹ r .η (F₀ F b) ≡ F .F₁ (η (F⊣F⁻¹ r) b)" class="Function">p</a>
        <a id="3001" href="1Lab.Path.html#38293" data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" class="Function Operator">··</a> <a id="3004" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="3008" class="Symbol">(</a><a id="3009" href="Cat.Functor.Equivalence.html#820" class="Bound">F</a> <a id="3011" class="Symbol">.</a><a id="3012" href="Cat.Base.html#8375" data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" class="Field">F-∘</a> <a id="3016" class="Symbol">_</a> <a id="3018" class="Symbol">_)</a>
        <a id="3029" href="1Lab.Path.html#38293" data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" class="Function Operator">··</a> <a id="3032" class="Symbol">(</a><a id="3033" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="3036" class="Symbol">(</a><a id="3037" href="Cat.Functor.Equivalence.html#820" class="Bound">F</a> <a id="3039" class="Symbol">.</a><a id="3040" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a><a id="3042" class="Symbol">)</a> <a id="3044" class="Symbol">(</a><a id="3045" href="Cat.Functor.Equivalence.html#1127" data-type="(r : is-equivalence F) (x : C .Ob) →
is-invertible C (η (r .F⊣F⁻¹) x)" class="Field">unit-iso</a> <a id="3054" class="Symbol">_</a> <a id="3056" class="Symbol">.</a><a id="3057" href="Cat.Morphism.html#1889" data-type="Inverses C f g → (C ∘ g) f ≡ id C" class="Function">C.is-invertible.invr</a><a id="3077" class="Symbol">)</a> <a id="3079" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="3081" href="Cat.Functor.Equivalence.html#820" class="Bound">F</a> <a id="3083" class="Symbol">.</a><a id="3084" href="Cat.Base.html#8335" data-type="(r : Functor C D) → r .F₁ (C .id) ≡ id D" class="Field">F-id</a><a id="3088" class="Symbol">)</a>

  <a id="is-equivalence.inverse-equivalence"></a><a id="3093" href="Cat.Functor.Equivalence.html#3093" data-type="(r : is-equivalence F) → is-equivalence (F⁻¹ r)" class="Function">inverse-equivalence</a> <a id="3113" class="Symbol">:</a> <a id="3115" href="Cat.Functor.Equivalence.html#804" data-type="(F : Functor C D) → Type (C.o ⊔ C.h ⊔ D.o ⊔ D.h)" class="Record">is-equivalence</a> <a id="3130" href="Cat.Functor.Equivalence.html#1043" data-type="is-equivalence F → Functor D C" class="Field">F⁻¹</a>
  <a id="3136" href="Cat.Functor.Equivalence.html#3093" data-type="(r : is-equivalence F) → is-equivalence (F⁻¹ r)" class="Function">inverse-equivalence</a> <a id="3156" class="Symbol">=</a>
    <a id="3162" class="Keyword">record</a> <a id="3169" class="Symbol">{</a> <a id="3171" href="Cat.Functor.Equivalence.html#1043" data-type="is-equivalence F → Functor D C" class="Field">F⁻¹</a> <a id="3175" class="Symbol">=</a> <a id="3177" href="Cat.Functor.Equivalence.html#820" class="Bound">F</a> <a id="3179" class="Symbol">;</a> <a id="3181" href="Cat.Functor.Equivalence.html#1070" data-type="(r : is-equivalence F) → F ⊣ r .F⁻¹" class="Field">F⊣F⁻¹</a> <a id="3187" class="Symbol">=</a> <a id="3189" href="Cat.Functor.Equivalence.html#1740" data-type="(r : is-equivalence F) → F⁻¹ r ⊣ F" class="Function">F⁻¹⊣F</a>
           <a id="3206" class="Symbol">;</a> <a id="3208" href="Cat.Functor.Equivalence.html#1127" data-type="(r : is-equivalence F) (x : C .Ob) →
is-invertible C (η (r .F⊣F⁻¹) x)" class="Field">unit-iso</a>   <a id="3219" class="Symbol">=</a> <a id="3221" class="Symbol">λ</a> <a id="3223" href="Cat.Functor.Equivalence.html#3223" class="Bound">x</a> <a id="3225" class="Symbol">→</a> <a id="3227" href="Cat.Morphism.html#4135" data-type="(C : Precategory o h) (g : is-invertible C f) →
is-invertible C (g .inv)" class="Function">D.is-invertible-inverse</a> <a id="3251" class="Symbol">(</a><a id="3252" href="Cat.Functor.Equivalence.html#1177" data-type="(r : is-equivalence F) (x : D .Ob) →
is-invertible D (ε (r .F⊣F⁻¹) x)" class="Field">counit-iso</a> <a id="3263" class="Symbol">_)</a>
           <a id="3277" class="Symbol">;</a> <a id="3279" href="Cat.Functor.Equivalence.html#1177" data-type="(r : is-equivalence F) (x : D .Ob) →
is-invertible D (ε (r .F⊣F⁻¹) x)" class="Field">counit-iso</a> <a id="3290" class="Symbol">=</a> <a id="3292" class="Symbol">λ</a> <a id="3294" href="Cat.Functor.Equivalence.html#3294" class="Bound">x</a> <a id="3296" class="Symbol">→</a> <a id="3298" href="Cat.Morphism.html#4135" data-type="(C : Precategory o h) (g : is-invertible C f) →
is-invertible C (g .inv)" class="Function">C.is-invertible-inverse</a> <a id="3322" class="Symbol">(</a><a id="3323" href="Cat.Functor.Equivalence.html#1127" data-type="(r : is-equivalence F) (x : C .Ob) →
is-invertible C (η (r .F⊣F⁻¹) x)" class="Field">unit-iso</a> <a id="3332" class="Symbol">_)</a>
           <a id="3346" class="Symbol">}</a>
</pre>-->
<p>We chose, for definiteness, the above definition of equivalence of
categories, since it provides convenient access to the most useful data:
The induced natural isomorphisms, the adjunction unit/counit, and the
triangle identities. It <em>is</em> a lot of data to come up with by
hand, though, so we provide some alternatives:</p>
<h2 id="fully-faithful-essentially-surjective"><a href="#fully-faithful-essentially-surjective" class="header-link">Fully
faithful, essentially
surjective<span class="header-link-emoji">🔗</span></a></h2>
<p>Any <a href="Cat.Functor.Base.html#ff-functors">fully faithful</a>
and <a href="Cat.Functor.Base.html#essential-fibres">(split!)
essentially surjective</a> functor determines an equivalence of
precategories. Recall that “split essentially surjective” means we have
some determined <em>procedure</em> for picking out an essential fibre
over any object
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo>:</mo><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">d : \ca{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span>:</span>
an object
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>F</mi><mo>∗</mo></msup><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo><mo>:</mo><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">F^*(d) : \ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span>
together with a specified isomorphism
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>F</mi><mo>∗</mo></msup><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo><mo>≅</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">F^*(d) \cong d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span>.</span></p>
<pre class="Agda"><a id="4170" class="Keyword">module</a> <a id="4177" href="Cat.Functor.Equivalence.html#4177" class="Module">_</a> <a id="4179" class="Symbol">{</a><a id="4180" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="4182" class="Symbol">:</a> <a id="4184" href="Cat.Base.html#7198" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="4192" href="Cat.Functor.Equivalence.html#265" class="Generalizable">C</a> <a id="4194" href="Cat.Functor.Equivalence.html#267" class="Generalizable">D</a><a id="4195" class="Symbol">}</a> <a id="4197" class="Symbol">(</a><a id="4198" href="Cat.Functor.Equivalence.html#4198" class="Bound">ff</a> <a id="4201" class="Symbol">:</a> <a id="4203" href="Cat.Functor.Base.html#1110" data-type="Functor C D → Type (C.o ⊔ C.h ⊔ D.h)" class="Function">is-fully-faithful</a> <a id="4221" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a><a id="4222" class="Symbol">)</a> <a id="4224" class="Symbol">(</a><a id="4225" href="Cat.Functor.Equivalence.html#4225" class="Bound">eso</a> <a id="4229" class="Symbol">:</a> <a id="4231" href="Cat.Functor.Base.html#5029" data-type="Functor C D → Type (C.o ⊔ D.o ⊔ D.h)" class="Function">is-split-eso</a> <a id="4244" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a><a id="4245" class="Symbol">)</a> <a id="4247" class="Keyword">where</a>
  <a id="4255" class="Keyword">import</a> <a id="4262" href="Cat.Reasoning.html" class="Module">Cat.Reasoning</a> <a id="4276" href="Cat.Functor.Equivalence.html#4192" class="Bound">C</a> as <a id="4281" href="Cat.Functor.Equivalence.html#4281" class="Module">C</a>
  <a id="4285" class="Keyword">import</a> <a id="4292" href="Cat.Reasoning.html" class="Module">Cat.Reasoning</a> <a id="4306" href="Cat.Functor.Equivalence.html#4194" class="Bound">D</a> as <a id="4311" href="Cat.Functor.Equivalence.html#4311" class="Module">D</a>
  <a id="4315" class="Keyword">private</a> <a id="4323" class="Keyword">module</a> <a id="4330" href="Cat.Functor.Equivalence.html#4330" class="Module">di</a> <a id="4333" class="Symbol">=</a> <a id="4335" href="Cat.Morphism.html#2202" data-type="(C : Precategory o h) (a b : Ob C) → Type h" class="Module Operator">D._≅_</a>

  <a id="4344" class="Keyword">private</a>
    <a id="4356" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="4361" class="Symbol">:</a> <a id="4363" class="Symbol">∀</a> <a id="4365" class="Symbol">{</a><a id="4366" href="Cat.Functor.Equivalence.html#4366" class="Bound">x</a> <a id="4368" href="Cat.Functor.Equivalence.html#4368" class="Bound">y</a><a id="4369" class="Symbol">}</a> <a id="4371" class="Symbol">→</a> <a id="4373" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">D.Hom</a> <a id="4379" class="Symbol">(</a><a id="4380" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="4382" class="Symbol">.</a><a id="4383" href="Cat.Base.html#7988" data-type="Functor C D → C .Ob → Ob D" class="Field">F₀</a> <a id="4386" href="Cat.Functor.Equivalence.html#4366" class="Bound">x</a><a id="4387" class="Symbol">)</a> <a id="4389" class="Symbol">(</a><a id="4390" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="4392" class="Symbol">.</a><a id="4393" href="Cat.Base.html#7988" data-type="Functor C D → C .Ob → Ob D" class="Field">F₀</a> <a id="4396" href="Cat.Functor.Equivalence.html#4368" class="Bound">y</a><a id="4397" class="Symbol">)</a> <a id="4399" class="Symbol">→</a> <a id="4401" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">C.Hom</a> <a id="4407" class="Symbol">_</a> <a id="4409" class="Symbol">_</a>
    <a id="4415" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="4420" class="Symbol">=</a> <a id="4422" href="1Lab.Equiv.html#6449" data-type="is-equiv f → B₁ → A" class="Function">equiv→inverse</a> <a id="4436" href="Cat.Functor.Equivalence.html#4198" class="Bound">ff</a>
</pre>
<p>It remains to show that, when
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span>
is fully faithful, this assignment of essential fibres extends to a
functor
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">D</mi><mo>→</mo><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">\ca{D} \to \ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span>.</span>
For the object part, we send
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>
to the specified preimage. For the morphism part, the splitting gives us
isomorphisms
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>F</mi><mo>∗</mo></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>≅</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">F^*(x) \cong x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>
and
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>F</mi><mo>∗</mo></msup><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo>≅</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">F^*(y) \cong y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>,</span>
so that we may form the composite
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>F</mi><mo>∗</mo></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>→</mo><mi>x</mi><mo>→</mo><mi>y</mi><mo>→</mo><msup><mi>F</mi><mo>∗</mo></msup><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F^*(x) \to x \to y \to F^*(y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>;</span>
Fullness then completes the construction.</p>
<pre class="Agda">  <a id="4853" href="Cat.Functor.Equivalence.html#4853" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) → Functor D C" class="Function">ff+split-eso→inverse</a> <a id="4874" class="Symbol">:</a> <a id="4876" href="Cat.Base.html#7198" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="4884" href="Cat.Functor.Equivalence.html#4194" class="Bound">D</a> <a id="4886" href="Cat.Functor.Equivalence.html#4192" class="Bound">C</a>
  <a id="4890" href="Cat.Functor.Equivalence.html#4853" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) → Functor D C" class="Function">ff+split-eso→inverse</a> <a id="4911" class="Symbol">.</a><a id="4912" href="Cat.Base.html#7988" data-type="Functor C D → C .Ob → Ob D" class="Field">F₀</a> <a id="4915" href="Cat.Functor.Equivalence.html#4915" class="Bound">x</a>         <a id="4925" class="Symbol">=</a> <a id="4927" href="Cat.Functor.Equivalence.html#4225" class="Bound">eso</a> <a id="4931" href="Cat.Functor.Equivalence.html#4915" class="Bound">x</a> <a id="4933" class="Symbol">.</a><a id="4934" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a>
  <a id="4940" href="Cat.Functor.Equivalence.html#4853" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) → Functor D C" class="Function">ff+split-eso→inverse</a> <a id="4961" class="Symbol">.</a><a id="4962" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="4965" class="Symbol">{</a><a id="4966" href="Cat.Functor.Equivalence.html#4966" class="Bound">x</a><a id="4967" class="Symbol">}</a> <a id="4969" class="Symbol">{</a><a id="4970" href="Cat.Functor.Equivalence.html#4970" class="Bound">y</a><a id="4971" class="Symbol">}</a> <a id="4973" href="Cat.Functor.Equivalence.html#4973" class="Bound">f</a> <a id="4975" class="Symbol">=</a>
    <a id="4981" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="4986" class="Symbol">(</a><a id="4987" href="Cat.Functor.Equivalence.html#5157" class="Function">f*y-iso</a> <a id="4995" class="Symbol">.</a><a id="4996" href="Cat.Morphism.html#2267" data-type="(C ≅ a) b → Hom C b a" class="Field">D._≅_.from</a> <a id="5007" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="5011" href="Cat.Functor.Equivalence.html#4973" class="Bound">f</a> <a id="5013" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="5017" href="Cat.Functor.Equivalence.html#5097" class="Function">f*x-iso</a> <a id="5025" class="Symbol">.</a><a id="5026" href="Cat.Morphism.html#2244" data-type="(C ≅ a) b → Hom C a b" class="Field">D._≅_.to</a><a id="5034" class="Symbol">)</a>
    <a id="5040" class="Keyword">where</a>
      <a id="5052" class="Keyword">open</a> <a id="5057" href="Agda.Builtin.Sigma.html#139" data-type="(A : Type a) (B₁ : A → Type b) → Type (a ⊔ b)" class="Module">∑</a> <a id="5059" class="Symbol">(</a><a id="5060" href="Cat.Functor.Equivalence.html#4225" class="Bound">eso</a> <a id="5064" href="Cat.Functor.Equivalence.html#4966" class="Bound">x</a><a id="5065" class="Symbol">)</a> <a id="5067" class="Keyword">renaming</a> <a id="5076" class="Symbol">(</a><a id="5077" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="5081" class="Symbol">to</a> <a id="5084" class="Field">f*x</a> <a id="5088" class="Symbol">;</a> <a id="5090" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="5094" class="Symbol">to</a> <a id="5097" class="Field">f*x-iso</a><a id="5104" class="Symbol">)</a>
      <a id="5112" class="Keyword">open</a> <a id="5117" href="Agda.Builtin.Sigma.html#139" data-type="(A : Type a) (B₁ : A → Type b) → Type (a ⊔ b)" class="Module">∑</a> <a id="5119" class="Symbol">(</a><a id="5120" href="Cat.Functor.Equivalence.html#4225" class="Bound">eso</a> <a id="5124" href="Cat.Functor.Equivalence.html#4970" class="Bound">y</a><a id="5125" class="Symbol">)</a> <a id="5127" class="Keyword">renaming</a> <a id="5136" class="Symbol">(</a><a id="5137" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="5141" class="Symbol">to</a> <a id="5144" class="Field">f*y</a> <a id="5148" class="Symbol">;</a> <a id="5150" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="5154" class="Symbol">to</a> <a id="5157" class="Field">f*y-iso</a><a id="5164" class="Symbol">)</a>
</pre>
<details>
<summary>
We must then, as usual, prove that this definition preserves identities
and distributes over composites, so that we really have a functor.
Preservation of identities is immediate; Distribution over composites is
by faithfulness.
</summary>
<pre class="Agda">  <a id="5442" href="Cat.Functor.Equivalence.html#4853" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) → Functor D C" class="Function">ff+split-eso→inverse</a> <a id="5463" class="Symbol">.</a><a id="5464" href="Cat.Base.html#8335" data-type="(r : Functor C D) → r .F₁ (C .id) ≡ id D" class="Field">F-id</a> <a id="5469" class="Symbol">{</a><a id="5470" href="Cat.Functor.Equivalence.html#5470" class="Bound">x</a><a id="5471" class="Symbol">}</a> <a id="5473" class="Symbol">=</a>
    <a id="5479" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="5484" class="Symbol">(</a><a id="5485" href="Cat.Functor.Equivalence.html#5887" class="Function">f*x-iso</a> <a id="5493" class="Symbol">.</a><a id="5494" href="Cat.Morphism.html#2267" data-type="(C ≅ a) b → Hom C b a" class="Field">di.from</a> <a id="5502" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="5506" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">D.id</a> <a id="5511" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="5515" href="Cat.Functor.Equivalence.html#5887" class="Function">f*x-iso</a> <a id="5523" class="Symbol">.</a><a id="5524" href="Cat.Morphism.html#2244" data-type="(C ≅ a) b → Hom C a b" class="Field">di.to</a><a id="5529" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function"><a id="5531" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="5534" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="5537" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="5542" class="Symbol">(</a><a id="5543" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="5547" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D._∘_</a> <a id="5553" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="5558" class="Symbol">(</a><a id="5559" href="Cat.Base.html#3482" data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ (r .id) f ≡ f" class="Function">D.idl</a> <a id="5565" class="Symbol">_))</a> <a id="5569" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="5575" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="5580" class="Symbol">(</a><a id="5581" href="Cat.Functor.Equivalence.html#5887" class="Function">f*x-iso</a> <a id="5589" class="Symbol">.</a><a id="5590" href="Cat.Morphism.html#2267" data-type="(C ≅ a) b → Hom C b a" class="Field">di.from</a> <a id="5598" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="5602" href="Cat.Functor.Equivalence.html#5887" class="Function">f*x-iso</a> <a id="5610" class="Symbol">.</a><a id="5611" href="Cat.Morphism.html#2244" data-type="(C ≅ a) b → Hom C a b" class="Field">di.to</a><a id="5616" class="Symbol">)</a>          <span class="reasoning-step"><span class="as-written Function"><a id="5627" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="5630" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="5633" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="5638" class="Symbol">(</a><a id="5639" href="Cat.Functor.Equivalence.html#5887" class="Function">f*x-iso</a> <a id="5647" class="Symbol">.</a><a id="5648" href="Cat.Morphism.html#1889" data-type="Inverses C f g → (C ∘ g) f ≡ id C" class="Function">di.invr</a><a id="5655" class="Symbol">)</a> <a id="5657" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="5663" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="5668" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">D.id</a>                                           <span class="reasoning-step"><span class="as-written Function Operator"><a id="5715" href="1Lab.Path.html#46771" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">≡˘⟨</a> <a id="5719" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="5722" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="5727" class="Symbol">(</a><a id="5728" href="Cat.Base.html#8335" data-type="(r : Functor C D) → r .F₁ (C .id) ≡ id D" class="Field">F-id</a> <a id="5733" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a><a id="5734" class="Symbol">)</a> <a id="5736" href="1Lab.Path.html#46771" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡˘</span></span>
    <a id="5742" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="5747" class="Symbol">(</a><a id="5748" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="5751" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="5753" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">C.id</a><a id="5757" class="Symbol">)</a>                                    <span class="reasoning-step"><span class="as-written Function"><a id="5794" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="5797" href="1Lab.Equiv.html#6688" data-type="(eqv : is-equiv f) → is-left-inverse (equiv→inverse eqv) f" class="Function">equiv→retraction</a> <a id="5814" href="Cat.Functor.Equivalence.html#4198" class="Bound">ff</a> <a id="5817" class="Symbol">_</a> <a id="5819" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="5825" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">C.id</a> <a id="5830" href="1Lab.Path.html#46945" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
    <a id="5836" class="Keyword">where</a> <a id="5842" class="Keyword">open</a> <a id="5847" href="Agda.Builtin.Sigma.html#139" data-type="(A : Type a) (B₁ : A → Type b) → Type (a ⊔ b)" class="Module">∑</a> <a id="5849" class="Symbol">(</a><a id="5850" href="Cat.Functor.Equivalence.html#4225" class="Bound">eso</a> <a id="5854" href="Cat.Functor.Equivalence.html#5470" class="Bound">x</a><a id="5855" class="Symbol">)</a> <a id="5857" class="Keyword">renaming</a> <a id="5866" class="Symbol">(</a><a id="5867" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="5871" class="Symbol">to</a> <a id="5874" class="Field">f*x</a> <a id="5878" class="Symbol">;</a> <a id="5880" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="5884" class="Symbol">to</a> <a id="5887" class="Field">f*x-iso</a><a id="5894" class="Symbol">)</a>

  <a id="5899" href="Cat.Functor.Equivalence.html#4853" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) → Functor D C" class="Function">ff+split-eso→inverse</a> <a id="5920" class="Symbol">.</a><a id="5921" href="Cat.Base.html#8375" data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" class="Field">F-∘</a> <a id="5925" class="Symbol">{</a><a id="5926" href="Cat.Functor.Equivalence.html#5926" class="Bound">x</a><a id="5927" class="Symbol">}</a> <a id="5929" class="Symbol">{</a><a id="5930" href="Cat.Functor.Equivalence.html#5930" class="Bound">y</a><a id="5931" class="Symbol">}</a> <a id="5933" class="Symbol">{</a><a id="5934" href="Cat.Functor.Equivalence.html#5934" class="Bound">z</a><a id="5935" class="Symbol">}</a> <a id="5937" href="Cat.Functor.Equivalence.html#5937" class="Bound">f</a> <a id="5939" href="Cat.Functor.Equivalence.html#5939" class="Bound">g</a> <a id="5941" class="Symbol">=</a>
    <a id="5947" href="Cat.Functor.Base.html#1212" data-type="is-fully-faithful F → is-faithful F" class="Function">fully-faithful→faithful</a> <a id="5971" class="Symbol">{</a><a id="5972" class="Argument">F</a> <a id="5974" class="Symbol">=</a> <a id="5976" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a><a id="5977" class="Symbol">}</a> <a id="5979" href="Cat.Functor.Equivalence.html#4198" class="Bound">ff</a> <a id="5982" class="Symbol">(</a>
      <a id="5990" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="5993" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="5995" class="Symbol">(</a><a id="5996" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="6001" class="Symbol">(</a><a id="6002" href="Cat.Functor.Equivalence.html#6742" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (f : D .Hom y z)
(g : D .Hom x y) →
Hom D z (F₀ F (eso z .fst))" class="Function">ffz</a> <a id="6006" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="6010" class="Symbol">(</a><a id="6011" href="Cat.Functor.Equivalence.html#5937" class="Bound">f</a> <a id="6013" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="6017" href="Cat.Functor.Equivalence.html#5939" class="Bound">g</a><a id="6018" class="Symbol">)</a> <a id="6020" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="6024" href="Cat.Functor.Equivalence.html#6883" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (f : D .Hom y z)
(g : D .Hom x y) →
Hom D (F₀ F (eso x .fst)) x" class="Function">ftx</a><a id="6027" class="Symbol">))</a>      <span class="reasoning-step"><span class="as-written Function"><a id="6035" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="6038" href="1Lab.Equiv.html#6548" data-type="(eqv : is-equiv f) → is-right-inverse (equiv→inverse eqv) f" class="Function">equiv→section</a> <a id="6052" href="Cat.Functor.Equivalence.html#4198" class="Bound">ff</a> <a id="6055" class="Symbol">_</a> <a id="6057" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="6065" href="Cat.Functor.Equivalence.html#6742" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (f : D .Hom y z)
(g : D .Hom x y) →
Hom D z (F₀ F (eso z .fst))" class="Function">ffz</a> <a id="6069" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="6073" class="Symbol">(</a><a id="6074" href="Cat.Functor.Equivalence.html#5937" class="Bound">f</a> <a id="6076" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="6080" href="Cat.Functor.Equivalence.html#5939" class="Bound">g</a><a id="6081" class="Symbol">)</a> <a id="6083" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="6087" href="Cat.Functor.Equivalence.html#6883" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (f : D .Hom y z)
(g : D .Hom x y) →
Hom D (F₀ F (eso x .fst)) x" class="Function">ftx</a>                    <span class="reasoning-step"><span class="as-written Function"><a id="6110" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="6113" href="Cat.Solver.html#7426" data-type="Term → Term → TC ⊤" class="Macro">solve</a> <a id="6119" href="Cat.Functor.Equivalence.html#4194" class="Bound">D</a> <a id="6121" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="6129" href="Cat.Functor.Equivalence.html#6742" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (f : D .Hom y z)
(g : D .Hom x y) →
Hom D z (F₀ F (eso z .fst))" class="Function">ffz</a> <a id="6133" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="6137" href="Cat.Functor.Equivalence.html#5937" class="Bound">f</a> <a id="6139" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="6143" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">D.id</a> <a id="6148" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="6152" href="Cat.Functor.Equivalence.html#5939" class="Bound">g</a> <a id="6154" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="6158" href="Cat.Functor.Equivalence.html#6883" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (f : D .Hom y z)
(g : D .Hom x y) →
Hom D (F₀ F (eso x .fst)) x" class="Function">ftx</a>             <span class="reasoning-step"><span class="as-written Function Operator"><a id="6174" href="1Lab.Path.html#46771" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">≡˘⟨</a> <a id="6178" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="6181" class="Symbol">(λ</a> <a id="6184" href="Cat.Functor.Equivalence.html#6184" class="Bound">x</a> <a id="6186" class="Symbol">→</a> <a id="6188" href="Cat.Functor.Equivalence.html#6742" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (f : D .Hom y z)
(g : D .Hom x y) →
Hom D z (F₀ F (eso z .fst))" class="Function">ffz</a> <a id="6192" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="6196" class="Symbol">(</a><a id="6197" href="Cat.Functor.Equivalence.html#5937" class="Bound">f</a> <a id="6199" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="6203" class="Symbol">(</a><a id="6204" href="Cat.Functor.Equivalence.html#6184" class="Bound">x</a> <a id="6206" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="6210" class="Symbol">(</a><a id="6211" href="Cat.Functor.Equivalence.html#5939" class="Bound">g</a> <a id="6213" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="6217" href="Cat.Functor.Equivalence.html#6883" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (f : D .Hom y z)
(g : D .Hom x y) →
Hom D (F₀ F (eso x .fst)) x" class="Function">ftx</a><a id="6220" class="Symbol">))))</a> <a id="6225" class="Symbol">(</a><a id="6226" href="Cat.Functor.Equivalence.html#6666" class="Function">f*y-iso</a> <a id="6234" class="Symbol">.</a><a id="6235" href="Cat.Morphism.html#1867" data-type="Inverses C f g → (C ∘ f) g ≡ id C" class="Function">di.invl</a><a id="6242" class="Symbol">)</a> <a id="6244" href="1Lab.Path.html#46771" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡˘</span></span>
      <a id="6252" href="Cat.Functor.Equivalence.html#6742" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (f : D .Hom y z)
(g : D .Hom x y) →
Hom D z (F₀ F (eso z .fst))" class="Function">ffz</a> <a id="6256" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="6260" href="Cat.Functor.Equivalence.html#5937" class="Bound">f</a> <a id="6262" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="6266" class="Symbol">(</a><a id="6267" href="Cat.Functor.Equivalence.html#6827" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (f : D .Hom y z)
(g : D .Hom x y) →
Hom D (F₀ F (eso y .fst)) y" class="Function">fty</a> <a id="6271" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="6275" href="Cat.Functor.Equivalence.html#6798" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (f : D .Hom y z)
(g : D .Hom x y) →
Hom D y (F₀ F (eso y .fst))" class="Function">ffy</a><a id="6278" class="Symbol">)</a> <a id="6280" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="6284" href="Cat.Functor.Equivalence.html#5939" class="Bound">g</a> <a id="6286" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="6290" href="Cat.Functor.Equivalence.html#6883" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (f : D .Hom y z)
(g : D .Hom x y) →
Hom D (F₀ F (eso x .fst)) x" class="Function">ftx</a>    <span class="reasoning-step"><span class="as-written Function"><a id="6297" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="6300" href="Cat.Solver.html#7426" data-type="Term → Term → TC ⊤" class="Macro">solve</a> <a id="6306" href="Cat.Functor.Equivalence.html#4194" class="Bound">D</a> <a id="6308" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="6316" class="Symbol">(</a><a id="6317" href="Cat.Functor.Equivalence.html#6742" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (f : D .Hom y z)
(g : D .Hom x y) →
Hom D z (F₀ F (eso z .fst))" class="Function">ffz</a> <a id="6321" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="6325" href="Cat.Functor.Equivalence.html#5937" class="Bound">f</a> <a id="6327" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="6331" href="Cat.Functor.Equivalence.html#6827" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (f : D .Hom y z)
(g : D .Hom x y) →
Hom D (F₀ F (eso y .fst)) y" class="Function">fty</a><a id="6334" class="Symbol">)</a> <a id="6336" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="6340" class="Symbol">(</a><a id="6341" href="Cat.Functor.Equivalence.html#6798" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (f : D .Hom y z)
(g : D .Hom x y) →
Hom D y (F₀ F (eso y .fst))" class="Function">ffy</a> <a id="6345" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="6349" href="Cat.Functor.Equivalence.html#5939" class="Bound">g</a> <a id="6351" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="6355" href="Cat.Functor.Equivalence.html#6883" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (f : D .Hom y z)
(g : D .Hom x y) →
Hom D (F₀ F (eso x .fst)) x" class="Function">ftx</a><a id="6358" class="Symbol">)</a>  <span class="reasoning-step"><span class="as-written Function Operator"><a id="6361" href="1Lab.Path.html#46771" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">≡˘⟨</a> <a id="6365" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="6369" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D._∘_</a> <a id="6375" class="Symbol">(</a><a id="6376" href="1Lab.Equiv.html#6548" data-type="(eqv : is-equiv f) → is-right-inverse (equiv→inverse eqv) f" class="Function">equiv→section</a> <a id="6390" href="Cat.Functor.Equivalence.html#4198" class="Bound">ff</a> <a id="6393" class="Symbol">_)</a> <a id="6396" class="Symbol">(</a><a id="6397" href="1Lab.Equiv.html#6548" data-type="(eqv : is-equiv f) → is-right-inverse (equiv→inverse eqv) f" class="Function">equiv→section</a> <a id="6411" href="Cat.Functor.Equivalence.html#4198" class="Bound">ff</a> <a id="6414" class="Symbol">_)</a> <a id="6417" href="1Lab.Path.html#46771" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡˘</span></span>
      <a id="6425" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="6428" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="6430" class="Symbol">(</a><a id="6431" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="6436" class="Symbol">_)</a> <a id="6439" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="6443" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="6446" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="6448" class="Symbol">(</a><a id="6449" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="6454" class="Symbol">_)</a>              <span class="reasoning-step"><span class="as-written Function Operator"><a id="6470" href="1Lab.Path.html#46771" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">≡˘⟨</a> <a id="6474" href="Cat.Base.html#8375" data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" class="Field">F-∘</a> <a id="6478" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="6480" class="Symbol">_</a> <a id="6482" class="Symbol">_</a> <a id="6484" href="1Lab.Path.html#46771" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡˘</span></span>
      <a id="6492" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="6495" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="6497" class="Symbol">(</a><a id="6498" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="6503" class="Symbol">_</a> <a id="6505" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="6509" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="6514" class="Symbol">_)</a>                     <a id="6537" href="1Lab.Path.html#46945" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
    <a id="6543" class="Symbol">)</a>
    <a id="6549" class="Keyword">where</a>
      <a id="6561" class="Keyword">open</a> <a id="6566" href="Agda.Builtin.Sigma.html#139" data-type="(A : Type a) (B₁ : A → Type b) → Type (a ⊔ b)" class="Module">∑</a> <a id="6568" class="Symbol">(</a><a id="6569" href="Cat.Functor.Equivalence.html#4225" class="Bound">eso</a> <a id="6573" href="Cat.Functor.Equivalence.html#5926" class="Bound">x</a><a id="6574" class="Symbol">)</a> <a id="6576" class="Keyword">renaming</a> <a id="6585" class="Symbol">(</a><a id="6586" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="6590" class="Symbol">to</a> <a id="6593" class="Field">f*x</a> <a id="6597" class="Symbol">;</a> <a id="6599" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="6603" class="Symbol">to</a> <a id="6606" class="Field">f*x-iso</a><a id="6613" class="Symbol">)</a>
      <a id="6621" class="Keyword">open</a> <a id="6626" href="Agda.Builtin.Sigma.html#139" data-type="(A : Type a) (B₁ : A → Type b) → Type (a ⊔ b)" class="Module">∑</a> <a id="6628" class="Symbol">(</a><a id="6629" href="Cat.Functor.Equivalence.html#4225" class="Bound">eso</a> <a id="6633" href="Cat.Functor.Equivalence.html#5930" class="Bound">y</a><a id="6634" class="Symbol">)</a> <a id="6636" class="Keyword">renaming</a> <a id="6645" class="Symbol">(</a><a id="6646" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="6650" class="Symbol">to</a> <a id="6653" class="Field">f*y</a> <a id="6657" class="Symbol">;</a> <a id="6659" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="6663" class="Symbol">to</a> <a id="6666" class="Field">f*y-iso</a><a id="6673" class="Symbol">)</a>
      <a id="6681" class="Keyword">open</a> <a id="6686" href="Agda.Builtin.Sigma.html#139" data-type="(A : Type a) (B₁ : A → Type b) → Type (a ⊔ b)" class="Module">∑</a> <a id="6688" class="Symbol">(</a><a id="6689" href="Cat.Functor.Equivalence.html#4225" class="Bound">eso</a> <a id="6693" href="Cat.Functor.Equivalence.html#5934" class="Bound">z</a><a id="6694" class="Symbol">)</a> <a id="6696" class="Keyword">renaming</a> <a id="6705" class="Symbol">(</a><a id="6706" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="6710" class="Symbol">to</a> <a id="6713" class="Field">f*z</a> <a id="6717" class="Symbol">;</a> <a id="6719" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="6723" class="Symbol">to</a> <a id="6726" class="Field">f*z-iso</a><a id="6733" class="Symbol">)</a>

      <a id="6742" href="Cat.Functor.Equivalence.html#6742" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (f : D .Hom y z)
(g : D .Hom x y) →
Hom D z (F₀ F (eso z .fst))" class="Function">ffz</a> <a id="6746" class="Symbol">=</a> <a id="6748" href="Cat.Functor.Equivalence.html#6726" class="Function">f*z-iso</a> <a id="6756" class="Symbol">.</a><a id="6757" href="Cat.Morphism.html#2267" data-type="(C ≅ a) b → Hom C b a" class="Field">di.from</a>
      <a id="6771" href="Cat.Functor.Equivalence.html#6771" class="Function">ftz</a> <a id="6775" class="Symbol">=</a> <a id="6777" href="Cat.Functor.Equivalence.html#6726" class="Function">f*z-iso</a> <a id="6785" class="Symbol">.</a><a id="6786" href="Cat.Morphism.html#2244" data-type="(C ≅ a) b → Hom C a b" class="Field">di.to</a>
      <a id="6798" href="Cat.Functor.Equivalence.html#6798" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (f : D .Hom y z)
(g : D .Hom x y) →
Hom D y (F₀ F (eso y .fst))" class="Function">ffy</a> <a id="6802" class="Symbol">=</a> <a id="6804" href="Cat.Functor.Equivalence.html#6666" class="Function">f*y-iso</a> <a id="6812" class="Symbol">.</a><a id="6813" href="Cat.Morphism.html#2267" data-type="(C ≅ a) b → Hom C b a" class="Field">di.from</a>
      <a id="6827" href="Cat.Functor.Equivalence.html#6827" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (f : D .Hom y z)
(g : D .Hom x y) →
Hom D (F₀ F (eso y .fst)) y" class="Function">fty</a> <a id="6831" class="Symbol">=</a> <a id="6833" href="Cat.Functor.Equivalence.html#6666" class="Function">f*y-iso</a> <a id="6841" class="Symbol">.</a><a id="6842" href="Cat.Morphism.html#2244" data-type="(C ≅ a) b → Hom C a b" class="Field">di.to</a>
      <a id="6854" href="Cat.Functor.Equivalence.html#6854" class="Function">ffx</a> <a id="6858" class="Symbol">=</a> <a id="6860" href="Cat.Functor.Equivalence.html#6606" class="Function">f*x-iso</a> <a id="6868" class="Symbol">.</a><a id="6869" href="Cat.Morphism.html#2267" data-type="(C ≅ a) b → Hom C b a" class="Field">di.from</a>
      <a id="6883" href="Cat.Functor.Equivalence.html#6883" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (f : D .Hom y z)
(g : D .Hom x y) →
Hom D (F₀ F (eso x .fst)) x" class="Function">ftx</a> <a id="6887" class="Symbol">=</a> <a id="6889" href="Cat.Functor.Equivalence.html#6606" class="Function">f*x-iso</a> <a id="6897" class="Symbol">.</a><a id="6898" href="Cat.Morphism.html#2244" data-type="(C ≅ a) b → Hom C a b" class="Field">di.to</a>
</pre>
</details>
<p>We will, for brevity, refer to the functor we’ve just built as
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span>,</span>
rather than its “proper name”
<span class="Agda"><a href="Cat.Functor.Equivalence.html#4853" class="Function">ff+split-eso→inverse</a></span>.
Hercules now only has 11 labours to go: We must construct unit and
counit natural transformations, prove that they satisfy the triangle
identities, and prove that the unit/counit we define are componentwise
invertible. I’ll keep the proofs of naturality in
<code>&lt;details&gt;</code> tags since.. they’re <em>rough</em>.</p>
<pre class="Agda">  <a id="7360" class="Keyword">private</a>
    <a id="7372" href="Cat.Functor.Equivalence.html#7372" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) → Functor D C" class="Function">G</a> <a id="7374" class="Symbol">=</a> <a id="7376" href="Cat.Functor.Equivalence.html#4853" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) → Functor D C" class="Function">ff+split-eso→inverse</a>
</pre>
<p>For the unit, we have an object
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>:</mo><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">x : \ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span>
and we’re asked to provide a morphism
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>→</mo><msup><mi>F</mi><mo>∗</mo></msup><mi>F</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x \to F^*F(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>
— where, recall, the notation
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>F</mi><mo>∗</mo></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F^*(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>
represents the chosen essential fibre of
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span>
over
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>.</span>
By fullness, it suffices to provide a morphism
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>→</mo><mi>F</mi><msup><mi>F</mi><mo>∗</mo></msup><mi>F</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(x) \to FF^*F(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>;</span>
But recall that the essential fibre
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>F</mi><mo>∗</mo></msup><mi>F</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F^*F(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>
comes equipped with an isomorphism
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><msup><mi>F</mi><mo>∗</mo></msup><mi>F</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>≅</mo><mi>F</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">FF^*F(x) \cong F(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>.</span></p>
<pre class="Agda">  <a id="7780" href="Cat.Functor.Equivalence.html#7780" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Id =&gt; G ff eso F∘ F" class="Function">ff+split-eso→unit</a> <a id="7798" class="Symbol">:</a> <a id="7800" href="Cat.Base.html#11708" data-type="Functor C C" class="Function">Id</a> <a id="7803" href="Cat.Base.html#12227" data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" class="Record Operator">=&gt;</a> <a id="7806" class="Symbol">(</a><a id="7807" href="Cat.Functor.Equivalence.html#7372" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) → Functor D C" class="Function">G</a> <a id="7809" href="Cat.Base.html#9683" data-type="Functor D E → Functor C D → Functor C E" class="Function Operator">F∘</a> <a id="7812" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a><a id="7813" class="Symbol">)</a>
  <a id="7817" href="Cat.Functor.Equivalence.html#7780" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Id =&gt; G ff eso F∘ F" class="Function">ff+split-eso→unit</a> <a id="7835" class="Symbol">.</a><a id="7836" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="7838" href="Cat.Functor.Equivalence.html#7838" class="Bound">x</a> <a id="7840" class="Symbol">=</a> <a id="7842" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="7847" class="Symbol">(</a><a id="7848" href="Cat.Functor.Equivalence.html#7928" class="Function">f*x-iso</a> <a id="7856" class="Symbol">.</a><a id="7857" href="Cat.Morphism.html#2267" data-type="(C ≅ a) b → Hom C b a" class="Field">di.from</a><a id="7864" class="Symbol">)</a>
    <a id="7870" class="Keyword">where</a> <a id="7876" class="Keyword">open</a> <a id="7881" href="Agda.Builtin.Sigma.html#139" data-type="(A : Type a) (B₁ : A → Type b) → Type (a ⊔ b)" class="Module">∑</a> <a id="7883" class="Symbol">(</a><a id="7884" href="Cat.Functor.Equivalence.html#4225" class="Bound">eso</a> <a id="7888" class="Symbol">(</a><a id="7889" href="Cat.Base.html#7988" data-type="Functor C D → C .Ob → Ob D" class="Field">F₀</a> <a id="7892" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="7894" href="Cat.Functor.Equivalence.html#7838" class="Bound">x</a><a id="7895" class="Symbol">))</a> <a id="7898" class="Keyword">renaming</a> <a id="7907" class="Symbol">(</a><a id="7908" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="7912" class="Symbol">to</a> <a id="7915" class="Field">f*x</a> <a id="7919" class="Symbol">;</a> <a id="7921" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="7925" class="Symbol">to</a> <a id="7928" class="Field">f*x-iso</a><a id="7935" class="Symbol">)</a>
</pre>
<details>
<summary>
Naturality of
<span class="Agda"><a href="Cat.Functor.Equivalence.html#7780" class="Function">ff+split-eso→unit</a></span>.
</summary>
<pre class="Agda">  <a id="8026" href="Cat.Functor.Equivalence.html#7780" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Id =&gt; G ff eso F∘ F" class="Function">ff+split-eso→unit</a> <a id="8044" class="Symbol">.</a><a id="8045" href="Cat.Base.html#13355" data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" class="Field">is-natural</a> <a id="8056" href="Cat.Functor.Equivalence.html#8056" class="Bound">x</a> <a id="8058" href="Cat.Functor.Equivalence.html#8058" class="Bound">y</a> <a id="8060" href="Cat.Functor.Equivalence.html#8060" class="Bound">f</a> <a id="8062" class="Symbol">=</a>
    <a id="8068" href="Cat.Functor.Base.html#1212" data-type="is-fully-faithful F → is-faithful F" class="Function">fully-faithful→faithful</a> <a id="8092" class="Symbol">{</a><a id="8093" class="Argument">F</a> <a id="8095" class="Symbol">=</a> <a id="8097" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a><a id="8098" class="Symbol">}</a> <a id="8100" href="Cat.Functor.Equivalence.html#4198" class="Bound">ff</a> <a id="8103" class="Symbol">(</a>
      <a id="8111" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="8114" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="8116" class="Symbol">(</a><a id="8117" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="8122" href="Cat.Functor.Equivalence.html#8995" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : C .Ob)
(f : C .Hom x y) →
Hom D (F₀ F y) (F₀ F (eso (F₀ F y) .fst))" class="Function">ffy</a> <a id="8126" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="8130" href="Cat.Functor.Equivalence.html#8060" class="Bound">f</a><a id="8131" class="Symbol">)</a>                                    <span class="reasoning-step"><span class="as-written Function"><a id="8168" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="8171" href="Cat.Base.html#8375" data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" class="Field">F-∘</a> <a id="8175" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="8177" class="Symbol">_</a> <a id="8179" class="Symbol">_</a> <a id="8181" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="8189" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="8192" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="8194" class="Symbol">(</a><a id="8195" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="8200" href="Cat.Functor.Equivalence.html#8995" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : C .Ob)
(f : C .Hom x y) →
Hom D (F₀ F y) (F₀ F (eso (F₀ F y) .fst))" class="Function">ffy</a><a id="8203" class="Symbol">)</a> <a id="8205" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8209" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="8212" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="8214" href="Cat.Functor.Equivalence.html#8060" class="Bound">f</a>                               <span class="reasoning-step"><span class="as-written Function"><a id="8246" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="8249" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="8253" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D._∘_</a> <a id="8259" class="Symbol">(</a><a id="8260" href="1Lab.Equiv.html#6548" data-type="(eqv : is-equiv f) → is-right-inverse (equiv→inverse eqv) f" class="Function">equiv→section</a> <a id="8274" href="Cat.Functor.Equivalence.html#4198" class="Bound">ff</a> <a id="8277" class="Symbol">_)</a> <a id="8280" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="8285" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="8293" href="Cat.Functor.Equivalence.html#8995" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : C .Ob)
(f : C .Hom x y) →
Hom D (F₀ F y) (F₀ F (eso (F₀ F y) .fst))" class="Function">ffy</a> <a id="8297" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8301" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="8304" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="8306" href="Cat.Functor.Equivalence.html#8060" class="Bound">f</a>                                           <span class="reasoning-step"><span class="as-written Function"><a id="8350" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="8353" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="8357" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D._∘_</a> <a id="8363" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="8368" class="Symbol">(</a><a id="8369" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="8373" class="Symbol">(</a><a id="8374" href="Cat.Base.html#3437" data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ f (r .id) ≡ f" class="Function">D.idr</a> <a id="8380" class="Symbol">_)</a> <a id="8383" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="8385" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="8388" class="Symbol">(</a><a id="8389" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="8392" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="8394" href="Cat.Functor.Equivalence.html#8060" class="Bound">f</a> <a id="8396" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘_</a><a id="8400" class="Symbol">)</a> <a id="8402" class="Symbol">(</a><a id="8403" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="8407" class="Symbol">(</a><a id="8408" href="Cat.Functor.Equivalence.html#8912" class="Function">f*x-iso</a> <a id="8416" class="Symbol">.</a><a id="8417" href="Cat.Morphism.html#1867" data-type="Inverses C f g → (C ∘ f) g ≡ id C" class="Function">di.invl</a><a id="8424" class="Symbol">)))</a> <a id="8428" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="8436" href="Cat.Functor.Equivalence.html#8995" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : C .Ob)
(f : C .Hom x y) →
Hom D (F₀ F y) (F₀ F (eso (F₀ F y) .fst))" class="Function">ffy</a> <a id="8440" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8444" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="8447" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="8449" href="Cat.Functor.Equivalence.html#8060" class="Bound">f</a> <a id="8451" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8455" href="Cat.Functor.Equivalence.html#9080" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : C .Ob)
(f : C .Hom x y) →
Hom D (F₀ F (eso (F₀ F x) .fst)) (F₀ F x)" class="Function">ftx</a> <a id="8459" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8463" href="Cat.Functor.Equivalence.html#9051" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : C .Ob)
(f : C .Hom x y) →
Hom D (F₀ F x) (F₀ F (eso (F₀ F x) .fst))" class="Function">ffx</a>                           <span class="reasoning-step"><span class="as-written Function"><a id="8493" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="8496" href="Cat.Solver.html#7426" data-type="Term → Term → TC ⊤" class="Macro">solve</a> <a id="8502" href="Cat.Functor.Equivalence.html#4194" class="Bound">D</a> <a id="8504" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="8512" class="Symbol">(</a><a id="8513" href="Cat.Functor.Equivalence.html#8995" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : C .Ob)
(f : C .Hom x y) →
Hom D (F₀ F y) (F₀ F (eso (F₀ F y) .fst))" class="Function">ffy</a> <a id="8517" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8521" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="8524" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="8526" href="Cat.Functor.Equivalence.html#8060" class="Bound">f</a> <a id="8528" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8532" href="Cat.Functor.Equivalence.html#9080" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : C .Ob)
(f : C .Hom x y) →
Hom D (F₀ F (eso (F₀ F x) .fst)) (F₀ F x)" class="Function">ftx</a><a id="8535" class="Symbol">)</a> <a id="8537" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8541" href="Cat.Functor.Equivalence.html#9051" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : C .Ob)
(f : C .Hom x y) →
Hom D (F₀ F x) (F₀ F (eso (F₀ F x) .fst))" class="Function">ffx</a>                         <span class="reasoning-step"><span class="as-written Function Operator"><a id="8569" href="1Lab.Path.html#46771" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">≡˘⟨</a> <a id="8573" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="8577" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D._∘_</a> <a id="8583" class="Symbol">(</a><a id="8584" href="1Lab.Equiv.html#6548" data-type="(eqv : is-equiv f) → is-right-inverse (equiv→inverse eqv) f" class="Function">equiv→section</a> <a id="8598" href="Cat.Functor.Equivalence.html#4198" class="Bound">ff</a> <a id="8601" class="Symbol">_)</a> <a id="8604" class="Symbol">(</a><a id="8605" href="1Lab.Equiv.html#6548" data-type="(eqv : is-equiv f) → is-right-inverse (equiv→inverse eqv) f" class="Function">equiv→section</a> <a id="8619" href="Cat.Functor.Equivalence.html#4198" class="Bound">ff</a> <a id="8622" class="Symbol">_)</a> <a id="8625" href="1Lab.Path.html#46771" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡˘</span></span>
      <a id="8633" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="8636" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="8638" class="Symbol">(</a><a id="8639" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="8644" class="Symbol">(</a><a id="8645" href="Cat.Functor.Equivalence.html#8995" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : C .Ob)
(f : C .Hom x y) →
Hom D (F₀ F y) (F₀ F (eso (F₀ F y) .fst))" class="Function">ffy</a> <a id="8649" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8653" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="8656" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="8658" href="Cat.Functor.Equivalence.html#8060" class="Bound">f</a> <a id="8660" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8664" href="Cat.Functor.Equivalence.html#9080" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : C .Ob)
(f : C .Hom x y) →
Hom D (F₀ F (eso (F₀ F x) .fst)) (F₀ F x)" class="Function">ftx</a><a id="8667" class="Symbol">))</a> <a id="8670" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8674" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="8677" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="8679" class="Symbol">(</a><a id="8680" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="8685" href="Cat.Functor.Equivalence.html#9051" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : C .Ob)
(f : C .Hom x y) →
Hom D (F₀ F x) (F₀ F (eso (F₀ F x) .fst))" class="Function">ffx</a><a id="8688" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function Operator"><a id="8690" href="1Lab.Path.html#46771" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">≡˘⟨</a> <a id="8694" href="Cat.Base.html#8375" data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" class="Field">F-∘</a> <a id="8698" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="8700" class="Symbol">_</a> <a id="8702" class="Symbol">_</a> <a id="8704" href="1Lab.Path.html#46771" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡˘</span></span>
      <a id="8712" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="8715" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="8717" class="Symbol">(</a><a id="8718" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="8723" class="Symbol">(</a><a id="8724" href="Cat.Functor.Equivalence.html#8995" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : C .Ob)
(f : C .Hom x y) →
Hom D (F₀ F y) (F₀ F (eso (F₀ F y) .fst))" class="Function">ffy</a> <a id="8728" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8732" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="8735" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="8737" href="Cat.Functor.Equivalence.html#8060" class="Bound">f</a> <a id="8739" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8743" href="Cat.Functor.Equivalence.html#9080" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : C .Ob)
(f : C .Hom x y) →
Hom D (F₀ F (eso (F₀ F x) .fst)) (F₀ F x)" class="Function">ftx</a><a id="8746" class="Symbol">)</a> <a id="8748" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="8752" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="8757" href="Cat.Functor.Equivalence.html#9051" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : C .Ob)
(f : C .Hom x y) →
Hom D (F₀ F x) (F₀ F (eso (F₀ F x) .fst))" class="Function">ffx</a><a id="8760" class="Symbol">)</a>        <a id="8769" href="1Lab.Path.html#46869" data-type="(x : A) → x ≡ y → x ≡ y" class="Function Operator">≡⟨⟩</a>
      <a id="8779" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="8782" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="8784" class="Symbol">(</a><a id="8785" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="8788" class="Symbol">(</a><a id="8789" href="Cat.Functor.Equivalence.html#7372" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) → Functor D C" class="Function">G</a> <a id="8791" href="Cat.Base.html#9683" data-type="Functor D E → Functor C D → Functor C E" class="Function Operator">F∘</a> <a id="8794" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a><a id="8795" class="Symbol">)</a> <a id="8797" href="Cat.Functor.Equivalence.html#8060" class="Bound">f</a> <a id="8799" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="8803" href="Cat.Functor.Equivalence.html#9108" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : C .Ob)
(f : C .Hom x y) →
C .Hom x (eso (F₀ F x) .fst)" class="Function">x→f*x</a><a id="8808" class="Symbol">)</a>                           <a id="8836" href="1Lab.Path.html#46945" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
    <a id="8842" class="Symbol">)</a>
    <a id="8848" class="Keyword">where</a>
      <a id="8860" class="Keyword">open</a> <a id="8865" href="Agda.Builtin.Sigma.html#139" data-type="(A : Type a) (B₁ : A → Type b) → Type (a ⊔ b)" class="Module">∑</a> <a id="8867" class="Symbol">(</a><a id="8868" href="Cat.Functor.Equivalence.html#4225" class="Bound">eso</a> <a id="8872" class="Symbol">(</a><a id="8873" href="Cat.Base.html#7988" data-type="Functor C D → C .Ob → Ob D" class="Field">F₀</a> <a id="8876" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="8878" href="Cat.Functor.Equivalence.html#8056" class="Bound">x</a><a id="8879" class="Symbol">))</a> <a id="8882" class="Keyword">renaming</a> <a id="8891" class="Symbol">(</a><a id="8892" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="8896" class="Symbol">to</a> <a id="8899" class="Field">f*x</a> <a id="8903" class="Symbol">;</a> <a id="8905" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="8909" class="Symbol">to</a> <a id="8912" class="Field">f*x-iso</a><a id="8919" class="Symbol">)</a>
      <a id="8927" class="Keyword">open</a> <a id="8932" href="Agda.Builtin.Sigma.html#139" data-type="(A : Type a) (B₁ : A → Type b) → Type (a ⊔ b)" class="Module">∑</a> <a id="8934" class="Symbol">(</a><a id="8935" href="Cat.Functor.Equivalence.html#4225" class="Bound">eso</a> <a id="8939" class="Symbol">(</a><a id="8940" href="Cat.Base.html#7988" data-type="Functor C D → C .Ob → Ob D" class="Field">F₀</a> <a id="8943" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="8945" href="Cat.Functor.Equivalence.html#8058" class="Bound">y</a><a id="8946" class="Symbol">))</a> <a id="8949" class="Keyword">renaming</a> <a id="8958" class="Symbol">(</a><a id="8959" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="8963" class="Symbol">to</a> <a id="8966" class="Field">f*y</a> <a id="8970" class="Symbol">;</a> <a id="8972" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="8976" class="Symbol">to</a> <a id="8979" class="Field">f*y-iso</a><a id="8986" class="Symbol">)</a>

      <a id="8995" href="Cat.Functor.Equivalence.html#8995" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : C .Ob)
(f : C .Hom x y) →
Hom D (F₀ F y) (F₀ F (eso (F₀ F y) .fst))" class="Function">ffy</a> <a id="8999" class="Symbol">=</a> <a id="9001" href="Cat.Functor.Equivalence.html#8979" class="Function">f*y-iso</a> <a id="9009" class="Symbol">.</a><a id="9010" href="Cat.Morphism.html#2267" data-type="(C ≅ a) b → Hom C b a" class="Field">di.from</a>
      <a id="9024" href="Cat.Functor.Equivalence.html#9024" class="Function">fty</a> <a id="9028" class="Symbol">=</a> <a id="9030" href="Cat.Functor.Equivalence.html#8979" class="Function">f*y-iso</a> <a id="9038" class="Symbol">.</a><a id="9039" href="Cat.Morphism.html#2244" data-type="(C ≅ a) b → Hom C a b" class="Field">di.to</a>
      <a id="9051" href="Cat.Functor.Equivalence.html#9051" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : C .Ob)
(f : C .Hom x y) →
Hom D (F₀ F x) (F₀ F (eso (F₀ F x) .fst))" class="Function">ffx</a> <a id="9055" class="Symbol">=</a> <a id="9057" href="Cat.Functor.Equivalence.html#8912" class="Function">f*x-iso</a> <a id="9065" class="Symbol">.</a><a id="9066" href="Cat.Morphism.html#2267" data-type="(C ≅ a) b → Hom C b a" class="Field">di.from</a>
      <a id="9080" href="Cat.Functor.Equivalence.html#9080" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : C .Ob)
(f : C .Hom x y) →
Hom D (F₀ F (eso (F₀ F x) .fst)) (F₀ F x)" class="Function">ftx</a> <a id="9084" class="Symbol">=</a> <a id="9086" href="Cat.Functor.Equivalence.html#8912" class="Function">f*x-iso</a> <a id="9094" class="Symbol">.</a><a id="9095" href="Cat.Morphism.html#2244" data-type="(C ≅ a) b → Hom C a b" class="Field">di.to</a>

      <a id="9108" href="Cat.Functor.Equivalence.html#9108" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : C .Ob)
(f : C .Hom x y) →
C .Hom x (eso (F₀ F x) .fst)" class="Function">x→f*x</a> <a id="9114" class="Symbol">:</a> <a id="9116" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">C.Hom</a> <a id="9122" href="Cat.Functor.Equivalence.html#8056" class="Bound">x</a> <a id="9124" href="Cat.Functor.Equivalence.html#8899" class="Function">f*x</a>
      <a id="9134" href="Cat.Functor.Equivalence.html#9108" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : C .Ob)
(f : C .Hom x y) →
C .Hom x (eso (F₀ F x) .fst)" class="Function">x→f*x</a> <a id="9140" class="Symbol">=</a> <a id="9142" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="9147" class="Symbol">(</a><a id="9148" href="Cat.Functor.Equivalence.html#8912" class="Function">f*x-iso</a> <a id="9156" class="Symbol">.</a><a id="9157" href="Cat.Morphism.html#2267" data-type="(C ≅ a) b → Hom C b a" class="Field">di.from</a><a id="9164" class="Symbol">)</a>

      <a id="9173" href="Cat.Functor.Equivalence.html#9173" class="Function">y→f*y</a> <a id="9179" class="Symbol">:</a> <a id="9181" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">C.Hom</a> <a id="9187" href="Cat.Functor.Equivalence.html#8058" class="Bound">y</a> <a id="9189" href="Cat.Functor.Equivalence.html#8966" class="Function">f*y</a>
      <a id="9199" href="Cat.Functor.Equivalence.html#9173" class="Function">y→f*y</a> <a id="9205" class="Symbol">=</a> <a id="9207" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="9212" class="Symbol">(</a><a id="9213" href="Cat.Functor.Equivalence.html#8979" class="Function">f*y-iso</a> <a id="9221" class="Symbol">.</a><a id="9222" href="Cat.Morphism.html#2267" data-type="(C ≅ a) b → Hom C b a" class="Field">di.from</a><a id="9229" class="Symbol">)</a>
</pre>
</details>
<p>For the counit, we have to provide a morphism
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><msup><mi>F</mi><mo>∗</mo></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>→</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">FF^*(x) \to x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>;</span>
We can again pick the given isomorphism.</p>
<pre class="Agda">  <a id="9363" href="Cat.Functor.Equivalence.html#9363" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
F F∘ G ff eso =&gt; Id" class="Function">ff+split-eso→counit</a> <a id="9383" class="Symbol">:</a> <a id="9385" class="Symbol">(</a><a id="9386" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="9388" href="Cat.Base.html#9683" data-type="Functor D E → Functor C D → Functor C E" class="Function Operator">F∘</a> <a id="9391" href="Cat.Functor.Equivalence.html#7372" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) → Functor D C" class="Function">G</a><a id="9392" class="Symbol">)</a> <a id="9394" href="Cat.Base.html#12227" data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" class="Record Operator">=&gt;</a> <a id="9397" href="Cat.Base.html#11708" data-type="Functor C C" class="Function">Id</a>
  <a id="9402" href="Cat.Functor.Equivalence.html#9363" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
F F∘ G ff eso =&gt; Id" class="Function">ff+split-eso→counit</a> <a id="9422" class="Symbol">.</a><a id="9423" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="9425" href="Cat.Functor.Equivalence.html#9425" class="Bound">x</a> <a id="9427" class="Symbol">=</a> <a id="9429" href="Cat.Functor.Equivalence.html#9499" class="Function">f*x-iso</a> <a id="9437" class="Symbol">.</a><a id="9438" href="Cat.Morphism.html#2244" data-type="(C ≅ a) b → Hom C a b" class="Field">di.to</a>
    <a id="9448" class="Keyword">where</a> <a id="9454" class="Keyword">open</a> <a id="9459" href="Agda.Builtin.Sigma.html#139" data-type="(A : Type a) (B₁ : A → Type b) → Type (a ⊔ b)" class="Module">∑</a> <a id="9461" class="Symbol">(</a><a id="9462" href="Cat.Functor.Equivalence.html#4225" class="Bound">eso</a> <a id="9466" href="Cat.Functor.Equivalence.html#9425" class="Bound">x</a><a id="9467" class="Symbol">)</a> <a id="9469" class="Keyword">renaming</a> <a id="9478" class="Symbol">(</a><a id="9479" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="9483" class="Symbol">to</a> <a id="9486" class="Field">f*x</a> <a id="9490" class="Symbol">;</a> <a id="9492" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="9496" class="Symbol">to</a> <a id="9499" class="Field">f*x-iso</a><a id="9506" class="Symbol">)</a>
</pre>
<details>
<summary>
Naturality of
<span class="Agda"><a href="Cat.Functor.Equivalence.html#9363" class="Function">ff+split-eso→counit</a></span>
</summary>
<pre class="Agda">  <a id="9598" href="Cat.Functor.Equivalence.html#9363" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
F F∘ G ff eso =&gt; Id" class="Function">ff+split-eso→counit</a> <a id="9618" class="Symbol">.</a><a id="9619" href="Cat.Base.html#13355" data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" class="Field">is-natural</a> <a id="9630" href="Cat.Functor.Equivalence.html#9630" class="Bound">x</a> <a id="9632" href="Cat.Functor.Equivalence.html#9632" class="Bound">y</a> <a id="9634" href="Cat.Functor.Equivalence.html#9634" class="Bound">f</a> <a id="9636" class="Symbol">=</a>
    <a id="9642" href="Cat.Functor.Equivalence.html#10012" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : D .Ob)
(f : D .Hom x y) →
Hom D (F₀ F (eso y .fst)) y" class="Function">fty</a> <a id="9646" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="9650" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="9653" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="9655" class="Symbol">(</a><a id="9656" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="9661" class="Symbol">(</a><a id="9662" href="Cat.Functor.Equivalence.html#9983" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : D .Ob)
(f : D .Hom x y) →
Hom D y (F₀ F (eso y .fst))" class="Function">ffy</a> <a id="9666" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="9670" href="Cat.Functor.Equivalence.html#9634" class="Bound">f</a> <a id="9672" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="9676" href="Cat.Functor.Equivalence.html#10039" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : D .Ob)
(f : D .Hom x y) →
Hom D (F₀ F (eso x .fst)) x" class="Function">ftx</a><a id="9679" class="Symbol">))</a> <span class="reasoning-step"><span class="as-written Function"><a id="9682" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="9685" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="9688" class="Symbol">(</a><a id="9689" href="Cat.Functor.Equivalence.html#10012" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : D .Ob)
(f : D .Hom x y) →
Hom D (F₀ F (eso y .fst)) y" class="Function">fty</a> <a id="9693" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘_</a><a id="9697" class="Symbol">)</a> <a id="9699" class="Symbol">(</a><a id="9700" href="1Lab.Equiv.html#6548" data-type="(eqv : is-equiv f) → is-right-inverse (equiv→inverse eqv) f" class="Function">equiv→section</a> <a id="9714" href="Cat.Functor.Equivalence.html#4198" class="Bound">ff</a> <a id="9717" class="Symbol">_)</a> <a id="9720" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="9726" href="Cat.Functor.Equivalence.html#10012" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : D .Ob)
(f : D .Hom x y) →
Hom D (F₀ F (eso y .fst)) y" class="Function">fty</a> <a id="9730" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="9734" href="Cat.Functor.Equivalence.html#9983" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : D .Ob)
(f : D .Hom x y) →
Hom D y (F₀ F (eso y .fst))" class="Function">ffy</a> <a id="9738" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="9742" href="Cat.Functor.Equivalence.html#9634" class="Bound">f</a> <a id="9744" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="9748" href="Cat.Functor.Equivalence.html#10039" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : D .Ob)
(f : D .Hom x y) →
Hom D (F₀ F (eso x .fst)) x" class="Function">ftx</a>               <span class="reasoning-step"><span class="as-written Function"><a id="9766" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="9769" href="Cat.Reasoning.html#2679" data-type="(C : Precategory o ℓ) → (C ∘ h) i ≡ id C → (C ∘ h) ((C ∘ i) f) ≡ f" class="Function">D.cancell</a> <a id="9779" class="Symbol">(</a><a id="9780" href="Cat.Functor.Equivalence.html#9967" class="Function">f*y-iso</a> <a id="9788" class="Symbol">.</a><a id="9789" href="Cat.Morphism.html#1867" data-type="Inverses C f g → (C ∘ f) g ≡ id C" class="Function">di.invl</a><a id="9796" class="Symbol">)</a> <a id="9798" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="9804" href="Cat.Functor.Equivalence.html#9634" class="Bound">f</a> <a id="9806" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="9810" href="Cat.Functor.Equivalence.html#10039" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : D .Ob)
(f : D .Hom x y) →
Hom D (F₀ F (eso x .fst)) x" class="Function">ftx</a>                               <a id="9844" href="1Lab.Path.html#46945" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
    <a id="9850" class="Keyword">where</a>
      <a id="9862" class="Keyword">open</a> <a id="9867" href="Agda.Builtin.Sigma.html#139" data-type="(A : Type a) (B₁ : A → Type b) → Type (a ⊔ b)" class="Module">∑</a> <a id="9869" class="Symbol">(</a><a id="9870" href="Cat.Functor.Equivalence.html#4225" class="Bound">eso</a> <a id="9874" href="Cat.Functor.Equivalence.html#9630" class="Bound">x</a><a id="9875" class="Symbol">)</a> <a id="9877" class="Keyword">renaming</a> <a id="9886" class="Symbol">(</a><a id="9887" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="9891" class="Symbol">to</a> <a id="9894" class="Field">f*x</a> <a id="9898" class="Symbol">;</a> <a id="9900" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="9904" class="Symbol">to</a> <a id="9907" class="Field">f*x-iso</a><a id="9914" class="Symbol">)</a>
      <a id="9922" class="Keyword">open</a> <a id="9927" href="Agda.Builtin.Sigma.html#139" data-type="(A : Type a) (B₁ : A → Type b) → Type (a ⊔ b)" class="Module">∑</a> <a id="9929" class="Symbol">(</a><a id="9930" href="Cat.Functor.Equivalence.html#4225" class="Bound">eso</a> <a id="9934" href="Cat.Functor.Equivalence.html#9632" class="Bound">y</a><a id="9935" class="Symbol">)</a> <a id="9937" class="Keyword">renaming</a> <a id="9946" class="Symbol">(</a><a id="9947" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="9951" class="Symbol">to</a> <a id="9954" class="Field">f*y</a> <a id="9958" class="Symbol">;</a> <a id="9960" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="9964" class="Symbol">to</a> <a id="9967" class="Field">f*y-iso</a><a id="9974" class="Symbol">)</a>

      <a id="9983" href="Cat.Functor.Equivalence.html#9983" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : D .Ob)
(f : D .Hom x y) →
Hom D y (F₀ F (eso y .fst))" class="Function">ffy</a> <a id="9987" class="Symbol">=</a> <a id="9989" href="Cat.Functor.Equivalence.html#9967" class="Function">f*y-iso</a> <a id="9997" class="Symbol">.</a><a id="9998" href="Cat.Morphism.html#2267" data-type="(C ≅ a) b → Hom C b a" class="Field">di.from</a>
      <a id="10012" href="Cat.Functor.Equivalence.html#10012" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : D .Ob)
(f : D .Hom x y) →
Hom D (F₀ F (eso y .fst)) y" class="Function">fty</a> <a id="10016" class="Symbol">=</a> <a id="10018" href="Cat.Functor.Equivalence.html#9967" class="Function">f*y-iso</a> <a id="10026" class="Symbol">.</a><a id="10027" href="Cat.Morphism.html#2244" data-type="(C ≅ a) b → Hom C a b" class="Field">di.to</a>
      <a id="10039" href="Cat.Functor.Equivalence.html#10039" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x y : D .Ob)
(f : D .Hom x y) →
Hom D (F₀ F (eso x .fst)) x" class="Function">ftx</a> <a id="10043" class="Symbol">=</a> <a id="10045" href="Cat.Functor.Equivalence.html#9907" class="Function">f*x-iso</a> <a id="10053" class="Symbol">.</a><a id="10054" href="Cat.Morphism.html#2244" data-type="(C ≅ a) b → Hom C a b" class="Field">di.to</a>
</pre>
</details>
<p>Checking the triangle identities, and that the adjunction unit/counit
defined above are natural isomorphisms, is routine. We present the
calculations without commentary:</p>
<pre class="Agda">  <a id="10258" class="Keyword">open</a> <a id="10263" href="Cat.Functor.Adjoint.html#2192" data-type="(L : Functor C D) (R₁ : Functor D C) → Type (C.o ⊔ C.h ⊔ D.o ⊔ D.h)" class="Module Operator">_⊣_</a>

  <a id="10270" href="Cat.Functor.Equivalence.html#10270" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) → F ⊣ G ff eso" class="Function">ff+split-eso→F⊣inverse</a> <a id="10293" class="Symbol">:</a> <a id="10295" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="10297" href="Cat.Functor.Adjoint.html#2192" data-type="(L : Functor C D) (R₁ : Functor D C) → Type (C.o ⊔ C.h ⊔ D.o ⊔ D.h)" class="Record Operator">⊣</a> <a id="10299" href="Cat.Functor.Equivalence.html#7372" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) → Functor D C" class="Function">G</a>
  <a id="10303" href="Cat.Functor.Equivalence.html#10270" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) → F ⊣ G ff eso" class="Function">ff+split-eso→F⊣inverse</a> <a id="10326" class="Symbol">.</a><a id="10327" href="Cat.Functor.Adjoint.html#2342" data-type="L ⊣ R₁ → Id =&gt; R₁ F∘ L" class="Field">unit</a>    <a id="10335" class="Symbol">=</a> <a id="10337" href="Cat.Functor.Equivalence.html#7780" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Id =&gt; G ff eso F∘ F" class="Function">ff+split-eso→unit</a>
  <a id="10357" href="Cat.Functor.Equivalence.html#10270" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) → F ⊣ G ff eso" class="Function">ff+split-eso→F⊣inverse</a> <a id="10380" class="Symbol">.</a><a id="10381" href="Cat.Functor.Adjoint.html#2370" data-type="L ⊣ R₁ → L F∘ R₁ =&gt; Id" class="Field">counit</a>  <a id="10389" class="Symbol">=</a> <a id="10391" href="Cat.Functor.Equivalence.html#9363" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
F F∘ G ff eso =&gt; Id" class="Function">ff+split-eso→counit</a>
  <a id="10413" href="Cat.Functor.Equivalence.html#10270" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) → F ⊣ G ff eso" class="Function">ff+split-eso→F⊣inverse</a> <a id="10436" class="Symbol">.</a><a id="10437" href="Cat.Functor.Adjoint.html#2943" data-type="(r : L ⊣ R₁) →
D ._∘_ (η (r .counit) (F₀ L A)) (F₁ L (r .unit .η A)) ≡ D .id" class="Field">zig</a> <a id="10441" class="Symbol">{</a><a id="10442" href="Cat.Functor.Equivalence.html#10442" class="Bound">x</a><a id="10443" class="Symbol">}</a> <a id="10445" class="Symbol">=</a>
    <a id="10451" href="Cat.Functor.Equivalence.html#10725" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Hom D (F₀ F (eso (F₀ F x) .fst)) (F₀ F x)" class="Function">ftx</a> <a id="10455" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="10459" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="10462" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="10464" class="Symbol">(</a><a id="10465" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="10470" href="Cat.Functor.Equivalence.html#10696" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Hom D (F₀ F x) (F₀ F (eso (F₀ F x) .fst))" class="Function">ffx</a><a id="10473" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function"><a id="10475" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="10478" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="10481" class="Symbol">(</a><a id="10482" href="Cat.Functor.Equivalence.html#10725" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Hom D (F₀ F (eso (F₀ F x) .fst)) (F₀ F x)" class="Function">ftx</a> <a id="10486" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘_</a><a id="10490" class="Symbol">)</a> <a id="10492" class="Symbol">(</a><a id="10493" href="1Lab.Equiv.html#6548" data-type="(eqv : is-equiv f) → is-right-inverse (equiv→inverse eqv) f" class="Function">equiv→section</a> <a id="10507" href="Cat.Functor.Equivalence.html#4198" class="Bound">ff</a> <a id="10510" class="Symbol">_)</a> <a id="10513" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="10519" href="Cat.Functor.Equivalence.html#10725" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Hom D (F₀ F (eso (F₀ F x) .fst)) (F₀ F x)" class="Function">ftx</a> <a id="10523" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="10527" href="Cat.Functor.Equivalence.html#10696" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Hom D (F₀ F x) (F₀ F (eso (F₀ F x) .fst))" class="Function">ffx</a>             <span class="reasoning-step"><span class="as-written Function"><a id="10543" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="10546" href="Cat.Functor.Equivalence.html#10680" class="Function">f*x-iso</a> <a id="10554" class="Symbol">.</a><a id="10555" href="Cat.Morphism.html#1867" data-type="Inverses C f g → (C ∘ f) g ≡ id C" class="Function">di.invl</a> <a id="10563" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="10569" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">D.id</a>                    <a id="10593" href="1Lab.Path.html#46945" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
</pre>
<!--
<pre class="Agda">    <a id="10616" class="Keyword">where</a>
      <a id="10628" class="Keyword">open</a> <a id="10633" href="Agda.Builtin.Sigma.html#139" data-type="(A : Type a) (B₁ : A → Type b) → Type (a ⊔ b)" class="Module">∑</a> <a id="10635" class="Symbol">(</a><a id="10636" href="Cat.Functor.Equivalence.html#4225" class="Bound">eso</a> <a id="10640" class="Symbol">(</a><a id="10641" href="Cat.Base.html#7988" data-type="Functor C D → C .Ob → Ob D" class="Field">F₀</a> <a id="10644" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="10646" href="Cat.Functor.Equivalence.html#10442" class="Bound">x</a><a id="10647" class="Symbol">))</a> <a id="10650" class="Keyword">renaming</a> <a id="10659" class="Symbol">(</a><a id="10660" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="10664" class="Symbol">to</a> <a id="10667" class="Field">f*x</a> <a id="10671" class="Symbol">;</a> <a id="10673" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="10677" class="Symbol">to</a> <a id="10680" class="Field">f*x-iso</a><a id="10687" class="Symbol">)</a>

      <a id="10696" href="Cat.Functor.Equivalence.html#10696" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Hom D (F₀ F x) (F₀ F (eso (F₀ F x) .fst))" class="Function">ffx</a> <a id="10700" class="Symbol">=</a> <a id="10702" href="Cat.Functor.Equivalence.html#10680" class="Function">f*x-iso</a> <a id="10710" class="Symbol">.</a><a id="10711" href="Cat.Morphism.html#2267" data-type="(C ≅ a) b → Hom C b a" class="Field">di.from</a>
      <a id="10725" href="Cat.Functor.Equivalence.html#10725" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Hom D (F₀ F (eso (F₀ F x) .fst)) (F₀ F x)" class="Function">ftx</a> <a id="10729" class="Symbol">=</a> <a id="10731" href="Cat.Functor.Equivalence.html#10680" class="Function">f*x-iso</a> <a id="10739" class="Symbol">.</a><a id="10740" href="Cat.Morphism.html#2244" data-type="(C ≅ a) b → Hom C a b" class="Field">di.to</a>
</pre>-->
<p>The
<span class="Agda"><a href="Cat.Functor.Adjoint.html#3006" class="Field">zag</a></span>
identity needs an appeal to faithfulness:</p>
<pre class="Agda">  <a id="10825" href="Cat.Functor.Equivalence.html#10270" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) → F ⊣ G ff eso" class="Function">ff+split-eso→F⊣inverse</a> <a id="10848" class="Symbol">.</a><a id="10849" href="Cat.Functor.Adjoint.html#3006" data-type="(r : L ⊣ R₁) →
C ._∘_ (F₁ R₁ (η (r .counit) B₁)) (r .unit .η (F₀ R₁ B₁)) ≡ C .id" class="Field">zag</a> <a id="10853" class="Symbol">{</a><a id="10854" href="Cat.Functor.Equivalence.html#10854" class="Bound">x</a><a id="10855" class="Symbol">}</a> <a id="10857" class="Symbol">=</a>
    <a id="10863" href="Cat.Functor.Base.html#1212" data-type="is-fully-faithful F → is-faithful F" class="Function">fully-faithful→faithful</a> <a id="10887" class="Symbol">{</a><a id="10888" class="Argument">F</a> <a id="10890" class="Symbol">=</a> <a id="10892" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a><a id="10893" class="Symbol">}</a> <a id="10895" href="Cat.Functor.Equivalence.html#4198" class="Bound">ff</a> <a id="10898" class="Symbol">(</a>
      <a id="10906" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="10909" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="10911" class="Symbol">(</a><a id="10912" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="10917" class="Symbol">(</a><a id="10918" href="Cat.Functor.Equivalence.html#11664" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Hom D x (F₀ F (eso x .fst))" class="Function">ffx</a> <a id="10922" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="10926" href="Cat.Functor.Equivalence.html#11693" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Hom D (F₀ F (eso x .fst)) x" class="Function">ftx</a> <a id="10930" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="10934" href="Cat.Functor.Equivalence.html#11752" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Hom D (F₀ F (eso (F₀ F (eso x .fst)) .fst)) (F₀ F (eso x .fst))" class="Function">fftx</a><a id="10938" class="Symbol">)</a> <a id="10940" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="10944" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="10949" href="Cat.Functor.Equivalence.html#11720" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Hom D (F₀ F (eso x .fst)) (F₀ F (eso (F₀ F (eso x .fst)) .fst))" class="Function">fffx</a><a id="10953" class="Symbol">)</a>        <span class="reasoning-step"><span class="as-written Function"><a id="10962" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="10965" href="Cat.Base.html#8375" data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" class="Field">F-∘</a> <a id="10969" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="10971" class="Symbol">_</a> <a id="10973" class="Symbol">_</a> <a id="10975" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="10983" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="10986" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="10988" class="Symbol">(</a><a id="10989" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="10994" class="Symbol">(</a><a id="10995" href="Cat.Functor.Equivalence.html#11664" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Hom D x (F₀ F (eso x .fst))" class="Function">ffx</a> <a id="10999" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="11003" href="Cat.Functor.Equivalence.html#11693" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Hom D (F₀ F (eso x .fst)) x" class="Function">ftx</a> <a id="11007" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="11011" href="Cat.Functor.Equivalence.html#11752" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Hom D (F₀ F (eso (F₀ F (eso x .fst)) .fst)) (F₀ F (eso x .fst))" class="Function">fftx</a><a id="11015" class="Symbol">))</a> <a id="11018" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="11022" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="11025" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="11027" class="Symbol">(</a><a id="11028" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="11033" href="Cat.Functor.Equivalence.html#11720" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Hom D (F₀ F (eso x .fst)) (F₀ F (eso (F₀ F (eso x .fst)) .fst))" class="Function">fffx</a><a id="11037" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function"><a id="11039" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="11042" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="11046" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D._∘_</a> <a id="11052" class="Symbol">(</a><a id="11053" href="1Lab.Equiv.html#6548" data-type="(eqv : is-equiv f) → is-right-inverse (equiv→inverse eqv) f" class="Function">equiv→section</a> <a id="11067" href="Cat.Functor.Equivalence.html#4198" class="Bound">ff</a> <a id="11070" class="Symbol">_)</a> <a id="11073" class="Symbol">(</a><a id="11074" href="1Lab.Equiv.html#6548" data-type="(eqv : is-equiv f) → is-right-inverse (equiv→inverse eqv) f" class="Function">equiv→section</a> <a id="11088" href="Cat.Functor.Equivalence.html#4198" class="Bound">ff</a> <a id="11091" class="Symbol">_)</a> <a id="11094" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="11102" class="Symbol">(</a><a id="11103" href="Cat.Functor.Equivalence.html#11664" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Hom D x (F₀ F (eso x .fst))" class="Function">ffx</a> <a id="11107" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="11111" href="Cat.Functor.Equivalence.html#11693" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Hom D (F₀ F (eso x .fst)) x" class="Function">ftx</a> <a id="11115" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="11119" href="Cat.Functor.Equivalence.html#11752" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Hom D (F₀ F (eso (F₀ F (eso x .fst)) .fst)) (F₀ F (eso x .fst))" class="Function">fftx</a><a id="11123" class="Symbol">)</a> <a id="11125" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="11129" href="Cat.Functor.Equivalence.html#11720" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Hom D (F₀ F (eso x .fst)) (F₀ F (eso (F₀ F (eso x .fst)) .fst))" class="Function">fffx</a>                         <span class="reasoning-step"><span class="as-written Function"><a id="11158" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="11161" href="Cat.Solver.html#7426" data-type="Term → Term → TC ⊤" class="Macro">solve</a> <a id="11167" href="Cat.Functor.Equivalence.html#4194" class="Bound">D</a> <a id="11169" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="11177" class="Symbol">(</a><a id="11178" href="Cat.Functor.Equivalence.html#11664" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Hom D x (F₀ F (eso x .fst))" class="Function">ffx</a> <a id="11182" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="11186" href="Cat.Functor.Equivalence.html#11693" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Hom D (F₀ F (eso x .fst)) x" class="Function">ftx</a><a id="11189" class="Symbol">)</a> <a id="11191" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="11195" class="Symbol">(</a><a id="11196" href="Cat.Functor.Equivalence.html#11752" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Hom D (F₀ F (eso (F₀ F (eso x .fst)) .fst)) (F₀ F (eso x .fst))" class="Function">fftx</a> <a id="11201" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="11205" href="Cat.Functor.Equivalence.html#11720" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Hom D (F₀ F (eso x .fst)) (F₀ F (eso (F₀ F (eso x .fst)) .fst))" class="Function">fffx</a><a id="11209" class="Symbol">)</a>                       <span class="reasoning-step"><span class="as-written Function"><a id="11233" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="11236" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="11240" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D._∘_</a> <a id="11246" class="Symbol">(</a><a id="11247" href="Cat.Functor.Equivalence.html#11575" class="Function">f*x-iso</a> <a id="11255" class="Symbol">.</a><a id="11256" href="Cat.Morphism.html#1889" data-type="Inverses C f g → (C ∘ g) f ≡ id C" class="Function">di.invr</a><a id="11263" class="Symbol">)</a> <a id="11265" class="Symbol">(</a><a id="11266" href="Cat.Functor.Equivalence.html#11646" class="Function">f*f*x-iso</a> <a id="11276" class="Symbol">.</a><a id="11277" href="Cat.Morphism.html#1867" data-type="Inverses C f g → (C ∘ f) g ≡ id C" class="Function">di.invl</a><a id="11284" class="Symbol">)</a> <a id="11286" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="11294" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">D.id</a> <a id="11299" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="11303" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">D.id</a>                                           <span class="reasoning-step"><span class="as-written Function"><a id="11350" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="11353" href="Cat.Base.html#3482" data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ (r .id) f ≡ f" class="Function">D.idl</a> <a id="11359" class="Symbol">_</a> <a id="11361" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="11363" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="11367" class="Symbol">(</a><a id="11368" href="Cat.Base.html#8335" data-type="(r : Functor C D) → r .F₁ (C .id) ≡ id D" class="Field">F-id</a> <a id="11373" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a><a id="11374" class="Symbol">)</a> <a id="11376" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="11384" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="11387" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="11389" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">C.id</a>                                               <a id="11440" href="1Lab.Path.html#46945" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
    <a id="11446" class="Symbol">)</a>
</pre>
<p>Now to show they are componentwise invertible:</p>
<!--
<pre class="Agda">    <a id="11518" class="Keyword">where</a>
      <a id="11530" class="Keyword">open</a> <a id="11535" href="Agda.Builtin.Sigma.html#139" data-type="(A : Type a) (B₁ : A → Type b) → Type (a ⊔ b)" class="Module">∑</a> <a id="11537" class="Symbol">(</a><a id="11538" href="Cat.Functor.Equivalence.html#4225" class="Bound">eso</a> <a id="11542" href="Cat.Functor.Equivalence.html#10854" class="Bound">x</a><a id="11543" class="Symbol">)</a> <a id="11545" class="Keyword">renaming</a> <a id="11554" class="Symbol">(</a><a id="11555" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="11559" class="Symbol">to</a> <a id="11562" class="Field">f*x</a> <a id="11566" class="Symbol">;</a> <a id="11568" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="11572" class="Symbol">to</a> <a id="11575" class="Field">f*x-iso</a><a id="11582" class="Symbol">)</a>
      <a id="11590" class="Keyword">open</a> <a id="11595" href="Agda.Builtin.Sigma.html#139" data-type="(A : Type a) (B₁ : A → Type b) → Type (a ⊔ b)" class="Module">∑</a> <a id="11597" class="Symbol">(</a><a id="11598" href="Cat.Functor.Equivalence.html#4225" class="Bound">eso</a> <a id="11602" class="Symbol">(</a><a id="11603" href="Cat.Base.html#7988" data-type="Functor C D → C .Ob → Ob D" class="Field">F₀</a> <a id="11606" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="11608" href="Cat.Functor.Equivalence.html#11562" class="Function">f*x</a><a id="11611" class="Symbol">))</a> <a id="11614" class="Keyword">renaming</a> <a id="11623" class="Symbol">(</a><a id="11624" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="11628" class="Symbol">to</a> <a id="11631" class="Field">f*f*x</a> <a id="11637" class="Symbol">;</a> <a id="11639" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="11643" class="Symbol">to</a> <a id="11646" class="Field">f*f*x-iso</a><a id="11655" class="Symbol">)</a>

      <a id="11664" href="Cat.Functor.Equivalence.html#11664" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Hom D x (F₀ F (eso x .fst))" class="Function">ffx</a> <a id="11668" class="Symbol">=</a> <a id="11670" href="Cat.Functor.Equivalence.html#11575" class="Function">f*x-iso</a> <a id="11678" class="Symbol">.</a><a id="11679" href="Cat.Morphism.html#2267" data-type="(C ≅ a) b → Hom C b a" class="Field">di.from</a>
      <a id="11693" href="Cat.Functor.Equivalence.html#11693" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Hom D (F₀ F (eso x .fst)) x" class="Function">ftx</a> <a id="11697" class="Symbol">=</a> <a id="11699" href="Cat.Functor.Equivalence.html#11575" class="Function">f*x-iso</a> <a id="11707" class="Symbol">.</a><a id="11708" href="Cat.Morphism.html#2244" data-type="(C ≅ a) b → Hom C a b" class="Field">di.to</a>
      <a id="11720" href="Cat.Functor.Equivalence.html#11720" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Hom D (F₀ F (eso x .fst)) (F₀ F (eso (F₀ F (eso x .fst)) .fst))" class="Function">fffx</a> <a id="11725" class="Symbol">=</a> <a id="11727" href="Cat.Functor.Equivalence.html#11646" class="Function">f*f*x-iso</a> <a id="11737" class="Symbol">.</a><a id="11738" href="Cat.Morphism.html#2267" data-type="(C ≅ a) b → Hom C b a" class="Field">di.from</a>
      <a id="11752" href="Cat.Functor.Equivalence.html#11752" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
Hom D (F₀ F (eso (F₀ F (eso x .fst)) .fst)) (F₀ F (eso x .fst))" class="Function">fftx</a> <a id="11757" class="Symbol">=</a> <a id="11759" href="Cat.Functor.Equivalence.html#11646" class="Function">f*f*x-iso</a> <a id="11769" class="Symbol">.</a><a id="11770" href="Cat.Morphism.html#2244" data-type="(C ≅ a) b → Hom C a b" class="Field">di.to</a>
</pre>-->
<pre class="Agda">  <a id="11795" class="Keyword">open</a> <a id="11800" href="Cat.Functor.Equivalence.html#804" data-type="(F : Functor C D) → Type (C.o ⊔ C.h ⊔ D.o ⊔ D.h)" class="Module">is-equivalence</a>

  <a id="11818" href="Cat.Functor.Equivalence.html#11818" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
is-equivalence F" class="Function">ff+split-eso→is-equivalence</a> <a id="11846" class="Symbol">:</a> <a id="11848" href="Cat.Functor.Equivalence.html#804" data-type="(F : Functor C D) → Type (C.o ⊔ C.h ⊔ D.o ⊔ D.h)" class="Record">is-equivalence</a> <a id="11863" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a>
  <a id="11867" href="Cat.Functor.Equivalence.html#11818" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
is-equivalence F" class="Function">ff+split-eso→is-equivalence</a> <a id="11895" class="Symbol">.</a><a id="11896" href="Cat.Functor.Equivalence.html#1043" data-type="is-equivalence F → Functor D C" class="Field">F⁻¹</a> <a id="11900" class="Symbol">=</a> <a id="11902" href="Cat.Functor.Equivalence.html#7372" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) → Functor D C" class="Function">G</a>
  <a id="11906" href="Cat.Functor.Equivalence.html#11818" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
is-equivalence F" class="Function">ff+split-eso→is-equivalence</a> <a id="11934" class="Symbol">.</a><a id="11935" href="Cat.Functor.Equivalence.html#1070" data-type="(r : is-equivalence F) → F ⊣ r .F⁻¹" class="Field">F⊣F⁻¹</a> <a id="11941" class="Symbol">=</a> <a id="11943" href="Cat.Functor.Equivalence.html#10270" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) → F ⊣ G ff eso" class="Function">ff+split-eso→F⊣inverse</a>
  <a id="11968" href="Cat.Functor.Equivalence.html#11818" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
is-equivalence F" class="Function">ff+split-eso→is-equivalence</a> <a id="11996" class="Symbol">.</a><a id="11997" href="Cat.Functor.Equivalence.html#1177" data-type="(r : is-equivalence F) (x : D .Ob) →
is-invertible D (ε (r .F⊣F⁻¹) x)" class="Field">counit-iso</a> <a id="12008" href="Cat.Functor.Equivalence.html#12008" class="Bound">x</a> <a id="12010" class="Symbol">=</a> <a id="12012" class="Keyword">record</a>
    <a id="12023" class="Symbol">{</a> <a id="12025" href="Cat.Morphism.html#1985" data-type="is-invertible C f → Hom C b a" class="Field">inv</a>      <a id="12034" class="Symbol">=</a> <a id="12036" href="Cat.Functor.Equivalence.html#12204" class="Function">f*x-iso</a> <a id="12044" class="Symbol">.</a><a id="12045" href="Cat.Morphism.html#2267" data-type="(C ≅ a) b → Hom C b a" class="Field">di.from</a>
    <a id="12057" class="Symbol">;</a> <a id="12059" href="Cat.Morphism.html#2003" data-type="(r : is-invertible C f) → Inverses C f (r .inv)" class="Field">inverses</a> <a id="12068" class="Symbol">=</a> <a id="12070" class="Keyword">record</a>
      <a id="12083" class="Symbol">{</a> <a id="12085" href="Cat.Morphism.html#1867" data-type="Inverses C f g → (C ∘ f) g ≡ id C" class="Field">invl</a> <a id="12090" class="Symbol">=</a> <a id="12092" href="Cat.Functor.Equivalence.html#12204" class="Function">f*x-iso</a> <a id="12100" class="Symbol">.</a><a id="12101" href="Cat.Morphism.html#1867" data-type="Inverses C f g → (C ∘ f) g ≡ id C" class="Function">di.invl</a>
      <a id="12115" class="Symbol">;</a> <a id="12117" href="Cat.Morphism.html#1889" data-type="Inverses C f g → (C ∘ g) f ≡ id C" class="Field">invr</a> <a id="12122" class="Symbol">=</a> <a id="12124" href="Cat.Functor.Equivalence.html#12204" class="Function">f*x-iso</a> <a id="12132" class="Symbol">.</a><a id="12133" href="Cat.Morphism.html#1889" data-type="Inverses C f g → (C ∘ g) f ≡ id C" class="Function">di.invr</a> <a id="12141" class="Symbol">}</a>
    <a id="12147" class="Symbol">}</a>
    <a id="12153" class="Keyword">where</a> <a id="12159" class="Keyword">open</a> <a id="12164" href="Agda.Builtin.Sigma.html#139" data-type="(A : Type a) (B₁ : A → Type b) → Type (a ⊔ b)" class="Module">∑</a> <a id="12166" class="Symbol">(</a><a id="12167" href="Cat.Functor.Equivalence.html#4225" class="Bound">eso</a> <a id="12171" href="Cat.Functor.Equivalence.html#12008" class="Bound">x</a><a id="12172" class="Symbol">)</a> <a id="12174" class="Keyword">renaming</a> <a id="12183" class="Symbol">(</a><a id="12184" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="12188" class="Symbol">to</a> <a id="12191" class="Field">f*x</a> <a id="12195" class="Symbol">;</a> <a id="12197" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="12201" class="Symbol">to</a> <a id="12204" class="Field">f*x-iso</a><a id="12211" class="Symbol">)</a>
</pre>
<p>Since the unit is defined in terms of fullness, showing it is
invertible needs an appeal to faithfulness (two, actually):</p>
<pre class="Agda">  <a id="12351" href="Cat.Functor.Equivalence.html#11818" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
is-equivalence F" class="Function">ff+split-eso→is-equivalence</a> <a id="12379" class="Symbol">.</a><a id="12380" href="Cat.Functor.Equivalence.html#1127" data-type="(r : is-equivalence F) (x : C .Ob) →
is-invertible C (η (r .F⊣F⁻¹) x)" class="Field">unit-iso</a> <a id="12389" href="Cat.Functor.Equivalence.html#12389" class="Bound">x</a> <a id="12391" class="Symbol">=</a> <a id="12393" class="Keyword">record</a>
    <a id="12404" class="Symbol">{</a> <a id="12406" href="Cat.Morphism.html#1985" data-type="is-invertible C f → Hom C b a" class="Field">inv</a>      <a id="12415" class="Symbol">=</a> <a id="12417" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="12422" class="Symbol">(</a><a id="12423" href="Cat.Functor.Equivalence.html#13329" class="Function">f*x-iso</a> <a id="12431" class="Symbol">.</a><a id="12432" href="Cat.Morphism.html#2244" data-type="(C ≅ a) b → Hom C a b" class="Field">di.to</a><a id="12437" class="Symbol">)</a>
    <a id="12443" class="Symbol">;</a> <a id="12445" href="Cat.Morphism.html#2003" data-type="(r : is-invertible C f) → Inverses C f (r .inv)" class="Field">inverses</a> <a id="12454" class="Symbol">=</a> <a id="12456" class="Keyword">record</a>
      <a id="12469" class="Symbol">{</a> <a id="12471" href="Cat.Morphism.html#1867" data-type="Inverses C f g → (C ∘ f) g ≡ id C" class="Field">invl</a> <a id="12476" class="Symbol">=</a> <a id="12478" href="Cat.Functor.Base.html#1212" data-type="is-fully-faithful F → is-faithful F" class="Function">fully-faithful→faithful</a> <a id="12502" class="Symbol">{</a><a id="12503" class="Argument">F</a> <a id="12505" class="Symbol">=</a> <a id="12507" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a><a id="12508" class="Symbol">}</a> <a id="12510" href="Cat.Functor.Equivalence.html#4198" class="Bound">ff</a> <a id="12513" class="Symbol">(</a>
          <a id="12525" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="12528" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="12530" class="Symbol">(</a><a id="12531" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="12536" href="Cat.Functor.Equivalence.html#13344" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x : C .Ob) →
Hom D (F₀ F x) (F₀ F (eso (F₀ F x) .fst))" class="Function">ffx</a> <a id="12540" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="12544" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="12549" href="Cat.Functor.Equivalence.html#13373" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x : C .Ob) →
Hom D (F₀ F (eso (F₀ F x) .fst)) (F₀ F x)" class="Function">ftx</a><a id="12552" class="Symbol">)</a>        <span class="reasoning-step"><span class="as-written Function"><a id="12561" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="12564" href="Cat.Base.html#8375" data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" class="Field">F-∘</a> <a id="12568" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="12570" class="Symbol">_</a> <a id="12572" class="Symbol">_</a> <a id="12574" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
          <a id="12586" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="12589" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="12591" class="Symbol">(</a><a id="12592" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="12597" href="Cat.Functor.Equivalence.html#13344" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x : C .Ob) →
Hom D (F₀ F x) (F₀ F (eso (F₀ F x) .fst))" class="Function">ffx</a><a id="12600" class="Symbol">)</a> <a id="12602" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="12606" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="12609" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="12611" class="Symbol">(</a><a id="12612" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="12617" href="Cat.Functor.Equivalence.html#13373" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x : C .Ob) →
Hom D (F₀ F (eso (F₀ F x) .fst)) (F₀ F x)" class="Function">ftx</a><a id="12620" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function"><a id="12622" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="12625" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="12629" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D._∘_</a> <a id="12635" class="Symbol">(</a><a id="12636" href="1Lab.Equiv.html#6548" data-type="(eqv : is-equiv f) → is-right-inverse (equiv→inverse eqv) f" class="Function">equiv→section</a> <a id="12650" href="Cat.Functor.Equivalence.html#4198" class="Bound">ff</a> <a id="12653" class="Symbol">_)</a> <a id="12656" class="Symbol">(</a><a id="12657" href="1Lab.Equiv.html#6548" data-type="(eqv : is-equiv f) → is-right-inverse (equiv→inverse eqv) f" class="Function">equiv→section</a> <a id="12671" href="Cat.Functor.Equivalence.html#4198" class="Bound">ff</a> <a id="12674" class="Symbol">_)</a> <a id="12677" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
          <a id="12689" href="Cat.Functor.Equivalence.html#13344" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x : C .Ob) →
Hom D (F₀ F x) (F₀ F (eso (F₀ F x) .fst))" class="Function">ffx</a> <a id="12693" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="12697" href="Cat.Functor.Equivalence.html#13373" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x : C .Ob) →
Hom D (F₀ F (eso (F₀ F x) .fst)) (F₀ F x)" class="Function">ftx</a>                         <span class="reasoning-step"><span class="as-written Function"><a id="12725" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="12728" href="Cat.Functor.Equivalence.html#13329" class="Function">f*x-iso</a> <a id="12736" class="Symbol">.</a><a id="12737" href="Cat.Morphism.html#1889" data-type="Inverses C f g → (C ∘ g) f ≡ id C" class="Function">di.invr</a> <a id="12745" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
          <a id="12757" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">D.id</a>                                <span class="reasoning-step"><span class="as-written Function Operator"><a id="12793" href="1Lab.Path.html#46771" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">≡˘⟨</a> <a id="12797" href="Cat.Base.html#8335" data-type="(r : Functor C D) → r .F₁ (C .id) ≡ id D" class="Field">F-id</a> <a id="12802" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="12804" href="1Lab.Path.html#46771" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡˘</span></span>
          <a id="12816" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="12819" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="12821" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">C.id</a>                           <a id="12852" href="1Lab.Path.html#46945" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a><a id="12853" class="Symbol">)</a>
      <a id="12861" class="Symbol">;</a> <a id="12863" href="Cat.Morphism.html#1889" data-type="Inverses C f g → (C ∘ g) f ≡ id C" class="Field">invr</a> <a id="12868" class="Symbol">=</a> <a id="12870" href="Cat.Functor.Base.html#1212" data-type="is-fully-faithful F → is-faithful F" class="Function">fully-faithful→faithful</a> <a id="12894" class="Symbol">{</a><a id="12895" class="Argument">F</a> <a id="12897" class="Symbol">=</a> <a id="12899" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a><a id="12900" class="Symbol">}</a> <a id="12902" href="Cat.Functor.Equivalence.html#4198" class="Bound">ff</a> <a id="12905" class="Symbol">(</a>
          <a id="12917" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="12920" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="12922" class="Symbol">(</a><a id="12923" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="12928" href="Cat.Functor.Equivalence.html#13373" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x : C .Ob) →
Hom D (F₀ F (eso (F₀ F x) .fst)) (F₀ F x)" class="Function">ftx</a> <a id="12932" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="12936" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="12941" href="Cat.Functor.Equivalence.html#13344" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x : C .Ob) →
Hom D (F₀ F x) (F₀ F (eso (F₀ F x) .fst))" class="Function">ffx</a><a id="12944" class="Symbol">)</a>        <span class="reasoning-step"><span class="as-written Function"><a id="12953" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="12956" href="Cat.Base.html#8375" data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" class="Field">F-∘</a> <a id="12960" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="12962" class="Symbol">_</a> <a id="12964" class="Symbol">_</a> <a id="12966" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
          <a id="12978" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="12981" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="12983" class="Symbol">(</a><a id="12984" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="12989" href="Cat.Functor.Equivalence.html#13373" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x : C .Ob) →
Hom D (F₀ F (eso (F₀ F x) .fst)) (F₀ F x)" class="Function">ftx</a><a id="12992" class="Symbol">)</a> <a id="12994" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="12998" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="13001" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="13003" class="Symbol">(</a><a id="13004" href="Cat.Functor.Equivalence.html#4356" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
D .Hom (F .F₀ x) (F .F₀ y) → C .Hom x y" class="Function">ff⁻¹</a> <a id="13009" href="Cat.Functor.Equivalence.html#13344" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x : C .Ob) →
Hom D (F₀ F x) (F₀ F (eso (F₀ F x) .fst))" class="Function">ffx</a><a id="13012" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function"><a id="13014" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="13017" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="13021" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D._∘_</a> <a id="13027" class="Symbol">(</a><a id="13028" href="1Lab.Equiv.html#6548" data-type="(eqv : is-equiv f) → is-right-inverse (equiv→inverse eqv) f" class="Function">equiv→section</a> <a id="13042" href="Cat.Functor.Equivalence.html#4198" class="Bound">ff</a> <a id="13045" class="Symbol">_)</a> <a id="13048" class="Symbol">(</a><a id="13049" href="1Lab.Equiv.html#6548" data-type="(eqv : is-equiv f) → is-right-inverse (equiv→inverse eqv) f" class="Function">equiv→section</a> <a id="13063" href="Cat.Functor.Equivalence.html#4198" class="Bound">ff</a> <a id="13066" class="Symbol">_)</a> <a id="13069" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
          <a id="13081" href="Cat.Functor.Equivalence.html#13373" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x : C .Ob) →
Hom D (F₀ F (eso (F₀ F x) .fst)) (F₀ F x)" class="Function">ftx</a> <a id="13085" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="13089" href="Cat.Functor.Equivalence.html#13344" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x : C .Ob) →
Hom D (F₀ F x) (F₀ F (eso (F₀ F x) .fst))" class="Function">ffx</a>                         <span class="reasoning-step"><span class="as-written Function"><a id="13117" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="13120" href="Cat.Functor.Equivalence.html#13329" class="Function">f*x-iso</a> <a id="13128" class="Symbol">.</a><a id="13129" href="Cat.Morphism.html#1867" data-type="Inverses C f g → (C ∘ f) g ≡ id C" class="Function">di.invl</a> <a id="13137" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
          <a id="13149" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">D.id</a>                                <span class="reasoning-step"><span class="as-written Function Operator"><a id="13185" href="1Lab.Path.html#46771" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">≡˘⟨</a> <a id="13189" href="Cat.Base.html#8335" data-type="(r : Functor C D) → r .F₁ (C .id) ≡ id D" class="Field">F-id</a> <a id="13194" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="13196" href="1Lab.Path.html#46771" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡˘</span></span>
          <a id="13208" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="13211" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="13213" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">C.id</a>                           <a id="13244" href="1Lab.Path.html#46945" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a><a id="13245" class="Symbol">)</a>
      <a id="13253" class="Symbol">}</a>
    <a id="13259" class="Symbol">}</a>
    <a id="13265" class="Keyword">where</a>
      <a id="13277" class="Keyword">open</a> <a id="13282" href="Agda.Builtin.Sigma.html#139" data-type="(A : Type a) (B₁ : A → Type b) → Type (a ⊔ b)" class="Module">∑</a> <a id="13284" class="Symbol">(</a><a id="13285" href="Cat.Functor.Equivalence.html#4225" class="Bound">eso</a> <a id="13289" class="Symbol">(</a><a id="13290" href="Cat.Base.html#7988" data-type="Functor C D → C .Ob → Ob D" class="Field">F₀</a> <a id="13293" href="Cat.Functor.Equivalence.html#4180" class="Bound">F</a> <a id="13295" href="Cat.Functor.Equivalence.html#12389" class="Bound">x</a><a id="13296" class="Symbol">))</a> <a id="13299" class="Keyword">renaming</a> <a id="13308" class="Symbol">(</a><a id="13309" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="13313" class="Symbol">to</a> <a id="13316" class="Field">f*x</a> <a id="13320" class="Symbol">;</a> <a id="13322" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="13326" class="Symbol">to</a> <a id="13329" class="Field">f*x-iso</a><a id="13336" class="Symbol">)</a>
      <a id="13344" href="Cat.Functor.Equivalence.html#13344" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x : C .Ob) →
Hom D (F₀ F x) (F₀ F (eso (F₀ F x) .fst))" class="Function">ffx</a> <a id="13348" class="Symbol">=</a> <a id="13350" href="Cat.Functor.Equivalence.html#13329" class="Function">f*x-iso</a> <a id="13358" class="Symbol">.</a><a id="13359" href="Cat.Morphism.html#2267" data-type="(C ≅ a) b → Hom C b a" class="Field">di.from</a>
      <a id="13373" href="Cat.Functor.Equivalence.html#13373" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) (x : C .Ob) →
Hom D (F₀ F (eso (F₀ F x) .fst)) (F₀ F x)" class="Function">ftx</a> <a id="13377" class="Symbol">=</a> <a id="13379" href="Cat.Functor.Equivalence.html#13329" class="Function">f*x-iso</a> <a id="13387" class="Symbol">.</a><a id="13388" href="Cat.Morphism.html#2244" data-type="(C ≅ a) b → Hom C a b" class="Field">di.to</a>
</pre>
<h3 id="between-categories"><a href="#between-categories" class="header-link">Between
categories<span class="header-link-emoji">🔗</span></a></h3>
<p>Above, we made an equivalence out of any fully faithful and
<em>split</em> essentially surjective functor. In set-theoretic
mathematics (and indeed between <a href="Cat.Instances.StrictCat.html">strict categories</a>), the
splitting condition can not be lifted constructively: the statement
“every (ff, eso) functor between strict categories is an equivalence” is
equivalent to the axiom of choice.</p>
<p>However, between <a href="Cat.Univalent.html">univalent
categories</a>, the situation is different: Any essentially surjective
functor splits. In particular, any functor between univalent categories
has propositional <a href="Cat.Functor.Base.html#essential-fibres">essential fibres</a>, so a
“mere” essential surjection is automatically split. However, note that
<em>both</em> the domain <em>and</em> codomain have to be categories for
the argument to go through.</p>
<pre class="Agda"><a id="14307" class="Keyword">module</a>
  <a id="14316" href="Cat.Functor.Equivalence.html#14316" class="Module">_</a> <a id="14318" class="Symbol">(</a><a id="14319" href="Cat.Functor.Equivalence.html#14319" class="Bound">F</a> <a id="14321" class="Symbol">:</a> <a id="14323" href="Cat.Base.html#7198" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="14331" href="Cat.Functor.Equivalence.html#265" class="Generalizable">C</a> <a id="14333" href="Cat.Functor.Equivalence.html#267" class="Generalizable">D</a><a id="14334" class="Symbol">)</a> <a id="14336" class="Symbol">(</a><a id="14337" href="Cat.Functor.Equivalence.html#14337" class="Bound">ccat</a> <a id="14342" class="Symbol">:</a> <a id="14344" href="Cat.Univalent.html#946" data-type="(C : Precategory o h) → Type (o ⊔ h)" class="Function">is-category</a> <a id="14356" href="Cat.Functor.Equivalence.html#265" class="Generalizable">C</a><a id="14357" class="Symbol">)</a> <a id="14359" class="Symbol">(</a><a id="14360" href="Cat.Functor.Equivalence.html#14360" class="Bound">dcat</a> <a id="14365" class="Symbol">:</a> <a id="14367" href="Cat.Univalent.html#946" data-type="(C : Precategory o h) → Type (o ⊔ h)" class="Function">is-category</a> <a id="14379" href="Cat.Functor.Equivalence.html#267" class="Generalizable">D</a><a id="14380" class="Symbol">)</a>
    <a id="14386" class="Symbol">(</a><a id="14387" href="Cat.Functor.Equivalence.html#14387" class="Bound">ff</a> <a id="14390" class="Symbol">:</a> <a id="14392" href="Cat.Functor.Base.html#1110" data-type="Functor C D → Type (C.o ⊔ C.h ⊔ D.h)" class="Function">is-fully-faithful</a> <a id="14410" href="Cat.Functor.Equivalence.html#14319" class="Bound">F</a><a id="14411" class="Symbol">)</a>
  <a id="14415" class="Keyword">where</a>
  <a id="14423" class="Keyword">private</a>
    <a id="14435" class="Keyword">module</a> <a id="14442" href="Cat.Functor.Equivalence.html#14442" class="Module">C</a> <a id="14444" class="Symbol">=</a> <a id="14446" href="Cat.Reasoning.html" class="Module">Cat.Reasoning</a> <a id="14460" href="Cat.Functor.Equivalence.html#14331" class="Bound">C</a>
    <a id="14466" class="Keyword">module</a> <a id="14473" href="Cat.Functor.Equivalence.html#14473" class="Module">D</a> <a id="14475" class="Symbol">=</a> <a id="14477" href="Cat.Reasoning.html" class="Module">Cat.Reasoning</a> <a id="14491" href="Cat.Functor.Equivalence.html#14333" class="Bound">D</a>
</pre>
<p>So, suppose we have categories
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">\ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span>
and
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">\ca{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span>,</span>
together with a fully faithful functor
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>:</mo><mi mathvariant="script">C</mi><mo>→</mo><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">F : \ca{C} \to \ca{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span>.</span>
For any
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>:</mo><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">y : \ca{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span>,</span>
we’re given an inhabitant of
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∥</mi><msub><mo>∑</mo><mrow><mi>x</mi><mo>:</mo><mi mathvariant="script">C</mi></mrow></msub><mi>F</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>≅</mo><mi>y</mi><mi mathvariant="normal">∥</mi></mrow><annotation encoding="application/x-tex">\| \sum_{x : \ca{C}} F(x) \cong y \|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0497em;vertical-align:-0.2997em;"></span><span class="mord">∥</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1786em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mrel mtight">:</span><span class="mord mathcal mtight" style="margin-right:0.05834em;">C</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord">∥</span></span></span></span>,</span>
which we want to “get out” from under the truncation. For this, we’ll
show that the type being truncated is a proposition, so that we may
“untruncate” it.</p>
<pre class="Agda">  <a id="14873" href="Cat.Functor.Equivalence.html#14873" data-type="(F : Functor C D) →
is-category C →
is-category D →
is-fully-faithful F → (y : D .Ob) → is-prop (Essential-fibre F y)" class="Function">Essential-fibre-between-cats-is-prop</a> <a id="14910" class="Symbol">:</a> <a id="14912" class="Symbol">∀</a> <a id="14914" href="Cat.Functor.Equivalence.html#14914" class="Bound">y</a> <a id="14916" class="Symbol">→</a> <a id="14918" href="1Lab.HLevel.html#2597" data-type="Type ℓ → Type ℓ" class="Function">is-prop</a> <a id="14926" class="Symbol">(</a><a id="14927" href="Cat.Functor.Base.html#4625" data-type="Functor C D → D .Ob → Type (C.o ⊔ D.h)" class="Function">Essential-fibre</a> <a id="14943" href="Cat.Functor.Equivalence.html#14319" class="Bound">F</a> <a id="14945" href="Cat.Functor.Equivalence.html#14914" class="Bound">y</a><a id="14946" class="Symbol">)</a>
  <a id="14950" href="Cat.Functor.Equivalence.html#14873" data-type="(F : Functor C D) →
is-category C →
is-category D →
is-fully-faithful F → (y : D .Ob) → is-prop (Essential-fibre F y)" class="Function">Essential-fibre-between-cats-is-prop</a> <a id="14987" href="Cat.Functor.Equivalence.html#14987" class="Bound">z</a> <a id="14989" class="Symbol">(</a><a id="14990" href="Cat.Functor.Equivalence.html#14990" class="Bound">x</a> <a id="14992" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="14994" href="Cat.Functor.Equivalence.html#14994" class="Bound">i</a><a id="14995" class="Symbol">)</a> <a id="14997" class="Symbol">(</a><a id="14998" href="Cat.Functor.Equivalence.html#14998" class="Bound">y</a> <a id="15000" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="15002" href="Cat.Functor.Equivalence.html#15002" class="Bound">j</a><a id="15003" class="Symbol">)</a> <a id="15005" class="Symbol">=</a> <a id="15007" href="Cat.Functor.Equivalence.html#17321" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
(x , i) ≡ (y , j)" class="Function">they&#39;re-equal</a> <a id="15021" class="Keyword">where</a>
</pre>
<p>For this magic trick, assume we’re given a
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>:</mo><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">z : \ca{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span>,</span>
together with objects
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>:</mo><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">x, y : \ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span>
and isomorphisms
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>:</mo><mi>F</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>≅</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">i : F(x) \cong z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span>
and
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>:</mo><mi>F</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo>≅</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">j : F(y) \cong z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span>.</span>
We must show that
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≡</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \equiv y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4637em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>,</span>
and that over this path,
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i = j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>.</span>
Since
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span>
is fully faithful, we can
<span class="Agda"><a href="Cat.Functor.Base.html#3890" class="Function">find an isomorphism</a></span>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≅</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \cong y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.589em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>
in
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">\ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span>,</span>
which
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span>
sends back to
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>∘</mo><msup><mi>j</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">i \circ j^{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0085em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>.</span></p>
<pre class="Agda">    <a id="15432" href="Cat.Functor.Equivalence.html#15432" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
(D ≅ F₀ F x) (F₀ F y)" class="Function">Fx≅Fy</a> <a id="15438" class="Symbol">:</a> <a id="15440" href="Cat.Base.html#7988" data-type="Functor C D → C .Ob → Ob D" class="Field">F₀</a> <a id="15443" href="Cat.Functor.Equivalence.html#14319" class="Bound">F</a> <a id="15445" href="Cat.Functor.Equivalence.html#14990" class="Bound">x</a> <a id="15447" href="Cat.Morphism.html#2202" data-type="(C : Precategory o h) (a b : Ob C) → Type h" class="Record Operator">D.≅</a> <a id="15451" href="Cat.Base.html#7988" data-type="Functor C D → C .Ob → Ob D" class="Field">F₀</a> <a id="15454" href="Cat.Functor.Equivalence.html#14319" class="Bound">F</a> <a id="15456" href="Cat.Functor.Equivalence.html#14998" class="Bound">y</a>
    <a id="15462" href="Cat.Functor.Equivalence.html#15432" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
(D ≅ F₀ F x) (F₀ F y)" class="Function">Fx≅Fy</a> <a id="15468" class="Symbol">=</a> <a id="15470" href="Cat.Functor.Equivalence.html#14994" class="Bound">i</a> <a id="15472" href="Cat.Morphism.html#7585" data-type="(C : Precategory o h) → (C ≅ a) b → (C ≅ b) c → (C ≅ a) c" class="Function Operator">D.∘Iso</a> <a id="15479" class="Symbol">(</a><a id="15480" href="Cat.Functor.Equivalence.html#15002" class="Bound">j</a> <a id="15482" href="Cat.Morphism.html#7747" data-type="(C : Precategory o h) → (C ≅ a) b → (C ≅ b) a" class="Function Operator">D.Iso⁻¹</a><a id="15489" class="Symbol">)</a>

    <a id="15496" href="Cat.Functor.Equivalence.html#15496" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
(C ≅ x) y" class="Function">x≅y</a> <a id="15500" class="Symbol">:</a> <a id="15502" href="Cat.Functor.Equivalence.html#14990" class="Bound">x</a> <a id="15504" href="Cat.Morphism.html#2202" data-type="(C : Precategory o h) (a b : Ob C) → Type h" class="Record Operator">C.≅</a> <a id="15508" href="Cat.Functor.Equivalence.html#14998" class="Bound">y</a>
    <a id="15514" href="Cat.Functor.Equivalence.html#15496" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
(C ≅ x) y" class="Function">x≅y</a> <a id="15518" class="Symbol">=</a> <a id="15520" href="Cat.Functor.Base.html#3890" data-type="is-fully-faithful F → (D ≅ F₀ F X) (F₀ F Y) → (C ≅ X) Y" class="Function">is-ff→essentially-injective</a> <a id="15548" class="Symbol">{</a><a id="15549" class="Argument">F</a> <a id="15551" class="Symbol">=</a> <a id="15553" href="Cat.Functor.Equivalence.html#14319" class="Bound">F</a><a id="15554" class="Symbol">}</a> <a id="15556" href="Cat.Functor.Equivalence.html#14387" class="Bound">ff</a> <a id="15559" href="Cat.Functor.Equivalence.html#15432" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
(D ≅ F₀ F x) (F₀ F y)" class="Function">Fx≅Fy</a>
</pre>
<p>Furthermore, since we’re working with categories, these isomorphisms
restrict to <em>paths</em>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≡</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \equiv y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4637em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>
and
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>≡</mo><mi>F</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(x) \equiv F(y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>.</span>
We’re half-done: we’ve shown that some
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>:</mo><mi>x</mi><mo>≡</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">p : x \equiv y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4637em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>
exists, and it remains to show that over this path we have
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>≡</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i \equiv j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>.</span>
More specifically, we must give a path
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>≡</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i \equiv j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>
laying over
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">p</mi></mrow><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\id{ap}(F)(p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">ap</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span>.</span></p>
<pre class="Agda">    <a id="15919" href="Cat.Functor.Equivalence.html#15919" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
x ≡ y" class="Function">x≡y</a> <a id="15923" class="Symbol">:</a> <a id="15925" href="Cat.Functor.Equivalence.html#14990" class="Bound">x</a> <a id="15927" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="15929" href="Cat.Functor.Equivalence.html#14998" class="Bound">y</a>
    <a id="15935" href="Cat.Functor.Equivalence.html#15919" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
x ≡ y" class="Function">x≡y</a> <a id="15939" class="Symbol">=</a> <a id="15941" href="Cat.Univalent.html#2601" data-type="(C : Precategory o h) → is-category C → (C ≅ A) B₁ → A ≡ B₁" class="Function">iso→path</a> <a id="15950" href="Cat.Functor.Equivalence.html#14331" class="Bound">C</a> <a id="15952" href="Cat.Functor.Equivalence.html#14337" class="Bound">ccat</a> <a id="15957" href="Cat.Functor.Equivalence.html#15496" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
(C ≅ x) y" class="Function">x≅y</a>

    <a id="15966" href="Cat.Functor.Equivalence.html#15966" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
F₀ F x ≡ F₀ F y" class="Function">Fx≡Fy</a> <a id="15972" class="Symbol">:</a> <a id="15974" href="Cat.Base.html#7988" data-type="Functor C D → C .Ob → Ob D" class="Field">F₀</a> <a id="15977" href="Cat.Functor.Equivalence.html#14319" class="Bound">F</a> <a id="15979" href="Cat.Functor.Equivalence.html#14990" class="Bound">x</a> <a id="15981" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="15983" href="Cat.Base.html#7988" data-type="Functor C D → C .Ob → Ob D" class="Field">F₀</a> <a id="15986" href="Cat.Functor.Equivalence.html#14319" class="Bound">F</a> <a id="15988" href="Cat.Functor.Equivalence.html#14998" class="Bound">y</a>
    <a id="15994" href="Cat.Functor.Equivalence.html#15966" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
F₀ F x ≡ F₀ F y" class="Function">Fx≡Fy</a> <a id="16000" class="Symbol">=</a> <a id="16002" href="Cat.Univalent.html#2601" data-type="(C : Precategory o h) → is-category C → (C ≅ A) B₁ → A ≡ B₁" class="Function">iso→path</a> <a id="16011" href="Cat.Functor.Equivalence.html#14333" class="Bound">D</a> <a id="16013" href="Cat.Functor.Equivalence.html#14360" class="Bound">dcat</a> <a id="16018" href="Cat.Functor.Equivalence.html#15432" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
(D ≅ F₀ F x) (F₀ F y)" class="Function">Fx≅Fy</a>
</pre>
<p>Rather than showing it over
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>:</mo><mi>x</mi><mo>≡</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">p : x\equiv y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4637em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>
directly, we’ll show it over the path
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>≡</mo><mi>F</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(x) \equiv F(y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>
we constructed independently. This is because we can use the helper
<code class="sourceCode agda">Hom-pathp-reflr-iso</code> to establish
the result with far less computation:</p>
<pre class="Agda">    <a id="16291" href="Cat.Functor.Equivalence.html#16291" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
PathP (λ i₁ → (D ≅ Fx≡Fy F ccat dcat ff z x i y j i₁) z) i j" class="Function">over′</a> <a id="16297" class="Symbol">:</a> <a id="16299" href="Agda.Primitive.Cubical.html#2013" class="Postulate">PathP</a> <a id="16305" class="Symbol">(λ</a> <a id="16308" href="Cat.Functor.Equivalence.html#16308" class="Bound">i</a> <a id="16310" class="Symbol">→</a> <a id="16312" href="Cat.Functor.Equivalence.html#15966" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
F₀ F x ≡ F₀ F y" class="Function">Fx≡Fy</a> <a id="16318" href="Cat.Functor.Equivalence.html#16308" class="Bound">i</a> <a id="16320" href="Cat.Morphism.html#2202" data-type="(C : Precategory o h) (a b : Ob C) → Type h" class="Record Operator">D.≅</a> <a id="16324" href="Cat.Functor.Equivalence.html#14987" class="Bound">z</a><a id="16325" class="Symbol">)</a> <a id="16327" href="Cat.Functor.Equivalence.html#14994" class="Bound">i</a> <a id="16329" href="Cat.Functor.Equivalence.html#15002" class="Bound">j</a>
    <a id="16335" href="Cat.Functor.Equivalence.html#16291" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
PathP (λ i₁ → (D ≅ Fx≡Fy F ccat dcat ff z x i y j i₁) z) i j" class="Function">over′</a> <a id="16341" class="Symbol">=</a> <a id="16343" href="Cat.Morphism.html#6459" data-type="(C : Precategory o h) (p : a ≡ c) (q : b ≡ d) →
PathP (λ i → Hom C (p i) (q i)) (f .to) (g .to) →
PathP (λ i → (C ≅ p i) (q i)) f g" class="Function">D.≅-pathp</a> <a id="16353" href="Cat.Functor.Equivalence.html#15966" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
F₀ F x ≡ F₀ F y" class="Function">Fx≡Fy</a> <a id="16359" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
      <a id="16370" class="Symbol">(</a><a id="16371" href="Cat.Univalent.html#6036" data-type="(C : Precategory o h) (isc : is-category C) →
(C ∘ h) (p .from) ≡ h&#39; →
PathP (λ i → Hom C (iso→path C isc p i) B₁) h h&#39;" class="Function">Hom-pathp-refll-iso</a> <a id="16391" href="Cat.Functor.Equivalence.html#14333" class="Bound">D</a> <a id="16393" href="Cat.Functor.Equivalence.html#14360" class="Bound">dcat</a> <a id="16398" class="Symbol">(</a><a id="16399" href="Cat.Reasoning.html#2679" data-type="(C : Precategory o ℓ) → (C ∘ h) i ≡ id C → (C ∘ h) ((C ∘ i) f) ≡ f" class="Function">D.cancell</a> <a id="16409" class="Symbol">(</a><a id="16410" href="Cat.Functor.Equivalence.html#14994" class="Bound">i</a> <a id="16412" class="Symbol">.</a><a id="16413" href="Cat.Morphism.html#1867" data-type="Inverses C f g → (C ∘ f) g ≡ id C" class="Function">D._≅_.invl</a><a id="16423" class="Symbol">)))</a>
</pre>
<p>We must then connect
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">p</mi></mrow><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\id{ap}(F)(p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">ap</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span>
with this path
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>≅</mo><mi>F</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(x) \cong F(y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>.</span>
But since we originally got
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>
by full faithfulness of
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span>,</span>
they <em>are</em> indeed the same path:</p>
<pre class="Agda">    <a id="16610" class="Keyword">abstract</a>
      <a id="16625" href="Cat.Functor.Equivalence.html#16625" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
ap (F₀ F) (x≡y F ccat dcat ff z x i y j) ≡
Fx≡Fy F ccat dcat ff z x i y j" class="Function">square</a> <a id="16632" class="Symbol">:</a> <a id="16634" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="16637" class="Symbol">(</a><a id="16638" href="Cat.Base.html#7988" data-type="Functor C D → C .Ob → Ob D" class="Field">F₀</a> <a id="16641" href="Cat.Functor.Equivalence.html#14319" class="Bound">F</a><a id="16642" class="Symbol">)</a> <a id="16644" href="Cat.Functor.Equivalence.html#15919" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
x ≡ y" class="Function">x≡y</a> <a id="16648" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="16650" href="Cat.Functor.Equivalence.html#15966" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
F₀ F x ≡ F₀ F y" class="Function">Fx≡Fy</a>
      <a id="16662" href="Cat.Functor.Equivalence.html#16625" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
ap (F₀ F) (x≡y F ccat dcat ff z x i y j) ≡
Fx≡Fy F ccat dcat ff z x i y j" class="Function">square</a> <a id="16669" class="Symbol">=</a>
        <a id="16679" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="16682" class="Symbol">(</a><a id="16683" href="Cat.Base.html#7988" data-type="Functor C D → C .Ob → Ob D" class="Field">F₀</a> <a id="16686" href="Cat.Functor.Equivalence.html#14319" class="Bound">F</a><a id="16687" class="Symbol">)</a> <a id="16689" href="Cat.Functor.Equivalence.html#15919" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
x ≡ y" class="Function">x≡y</a>                       <span class="reasoning-step"><span class="as-written Function"><a id="16715" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="16718" href="Cat.Functor.Base.html#5618" data-type="(F : Functor C D) (i : (C ≅ x) y) (ccat : is-category C)
(dcat : is-category D) →
ap (F₀ F) (iso→path C ccat i) ≡ iso→path D dcat (F-map-iso F i)" class="Function">F-map-path</a> <a id="16729" href="Cat.Functor.Equivalence.html#14319" class="Bound">F</a> <a id="16731" href="Cat.Functor.Equivalence.html#15496" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
(C ≅ x) y" class="Function">x≅y</a> <a id="16735" href="Cat.Functor.Equivalence.html#14337" class="Bound">ccat</a> <a id="16740" href="Cat.Functor.Equivalence.html#14360" class="Bound">dcat</a> <a id="16745" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
        <a id="16755" href="Cat.Univalent.html#2601" data-type="(C : Precategory o h) → is-category C → (C ≅ A) B₁ → A ≡ B₁" class="Function">iso→path</a> <a id="16764" href="Cat.Functor.Equivalence.html#14333" class="Bound">D</a> <a id="16766" href="Cat.Functor.Equivalence.html#14360" class="Bound">dcat</a> <a id="16771" class="Symbol">(</a><a id="16772" href="Cat.Functor.Base.html#5322" data-type="(F : Functor C D) → (C ≅ x) y → (D ≅ F₀ F x) (F₀ F y)" class="Function">F-map-iso</a> <a id="16782" href="Cat.Functor.Equivalence.html#14319" class="Bound">F</a> <a id="16784" href="Cat.Functor.Equivalence.html#15496" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
(C ≅ x) y" class="Function">x≅y</a><a id="16787" class="Symbol">)</a>   <span class="reasoning-step"><span class="as-written Function"><a id="16791" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="16794" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="16797" class="Symbol">(</a><a id="16798" href="Cat.Univalent.html#2601" data-type="(C : Precategory o h) → is-category C → (C ≅ A) B₁ → A ≡ B₁" class="Function">iso→path</a> <a id="16807" href="Cat.Functor.Equivalence.html#14333" class="Bound">D</a> <a id="16809" href="Cat.Functor.Equivalence.html#14360" class="Bound">dcat</a><a id="16813" class="Symbol">)</a> <a id="16815" class="Symbol">(</a><a id="16816" href="1Lab.Equiv.html#6548" data-type="(eqv : is-equiv f) → is-right-inverse (equiv→inverse eqv) f" class="Function">equiv→section</a> <a id="16830" class="Symbol">(</a><a id="16831" href="Cat.Functor.Base.html#6484" data-type="is-fully-faithful F → is-equiv (F-map-iso F)" class="Function">is-ff→F-map-iso-is-equiv</a> <a id="16856" class="Symbol">{</a><a id="16857" class="Argument">F</a> <a id="16859" class="Symbol">=</a> <a id="16861" href="Cat.Functor.Equivalence.html#14319" class="Bound">F</a><a id="16862" class="Symbol">}</a> <a id="16864" href="Cat.Functor.Equivalence.html#14387" class="Bound">ff</a><a id="16866" class="Symbol">)</a> <a id="16868" class="Symbol">_)</a>  <a id="16872" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
        <a id="16882" href="Cat.Univalent.html#2601" data-type="(C : Precategory o h) → is-category C → (C ≅ A) B₁ → A ≡ B₁" class="Function">iso→path</a> <a id="16891" href="Cat.Functor.Equivalence.html#14333" class="Bound">D</a> <a id="16893" href="Cat.Functor.Equivalence.html#14360" class="Bound">dcat</a> <a id="16898" href="Cat.Functor.Equivalence.html#15432" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
(D ≅ F₀ F x) (F₀ F y)" class="Function">Fx≅Fy</a>               <a id="16918" href="1Lab.Path.html#46945" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>

    <a id="16925" href="Cat.Functor.Equivalence.html#16925" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
PathP (λ i₁ → (D ≅ F₀ F (x≡y F ccat dcat ff z x i y j i₁)) z) i j" class="Function">over</a> <a id="16930" class="Symbol">:</a> <a id="16932" href="Agda.Primitive.Cubical.html#2013" class="Postulate">PathP</a> <a id="16938" class="Symbol">(λ</a> <a id="16941" href="Cat.Functor.Equivalence.html#16941" class="Bound">i</a> <a id="16943" class="Symbol">→</a> <a id="16945" href="Cat.Base.html#7988" data-type="Functor C D → C .Ob → Ob D" class="Field">F₀</a> <a id="16948" href="Cat.Functor.Equivalence.html#14319" class="Bound">F</a> <a id="16950" class="Symbol">(</a><a id="16951" href="Cat.Functor.Equivalence.html#15919" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
x ≡ y" class="Function">x≡y</a> <a id="16955" href="Cat.Functor.Equivalence.html#16941" class="Bound">i</a><a id="16956" class="Symbol">)</a> <a id="16958" href="Cat.Morphism.html#2202" data-type="(C : Precategory o h) (a b : Ob C) → Type h" class="Record Operator">D.≅</a> <a id="16962" href="Cat.Functor.Equivalence.html#14987" class="Bound">z</a><a id="16963" class="Symbol">)</a> <a id="16965" href="Cat.Functor.Equivalence.html#14994" class="Bound">i</a> <a id="16967" href="Cat.Functor.Equivalence.html#15002" class="Bound">j</a>
    <a id="16973" href="Cat.Functor.Equivalence.html#16925" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
PathP (λ i₁ → (D ≅ F₀ F (x≡y F ccat dcat ff z x i y j i₁)) z) i j" class="Function">over</a> <a id="16978" class="Symbol">=</a> <a id="16980" href="1Lab.Path.html#11776" data-type="A ≡ B₁ → A → B₁" class="Function">transport</a> <a id="16990" class="Symbol">(λ</a> <a id="16993" href="Cat.Functor.Equivalence.html#16993" class="Bound">l</a> <a id="16995" class="Symbol">→</a> <a id="16997" href="Agda.Primitive.Cubical.html#2013" class="Postulate">PathP</a> <a id="17003" class="Symbol">(λ</a> <a id="17006" href="Cat.Functor.Equivalence.html#17006" class="Bound">m</a> <a id="17008" class="Symbol">→</a> <a id="17010" href="Cat.Functor.Equivalence.html#16625" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
ap (F₀ F) (x≡y F ccat dcat ff z x i y j) ≡
Fx≡Fy F ccat dcat ff z x i y j" class="Function">square</a> <a id="17017" class="Symbol">(</a><a id="17018" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="17020" href="Cat.Functor.Equivalence.html#16993" class="Bound">l</a><a id="17021" class="Symbol">)</a> <a id="17023" href="Cat.Functor.Equivalence.html#17006" class="Bound">m</a> <a id="17025" href="Cat.Morphism.html#2202" data-type="(C : Precategory o h) (a b : Ob C) → Type h" class="Record Operator">D.≅</a> <a id="17029" href="Cat.Functor.Equivalence.html#14987" class="Bound">z</a><a id="17030" class="Symbol">)</a> <a id="17032" href="Cat.Functor.Equivalence.html#14994" class="Bound">i</a> <a id="17034" href="Cat.Functor.Equivalence.html#15002" class="Bound">j</a><a id="17035" class="Symbol">)</a> <a id="17037" href="Cat.Functor.Equivalence.html#16291" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
PathP (λ i₁ → (D ≅ Fx≡Fy F ccat dcat ff z x i y j i₁) z) i j" class="Function">over′</a>
</pre>
<p>Hence — blink and you’ll miss it — the essential fibres of
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span>
over any
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>:</mo><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">z : \ca{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span>
are propositions, so it suffices for them to be merely inhabited for the
functor to be split eso. With tongue firmly in cheek we call this result
the <em>theorem of choice</em>.</p>
<pre class="Agda">    <a id="17321" href="Cat.Functor.Equivalence.html#17321" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
(x , i) ≡ (y , j)" class="Function">they&#39;re-equal</a> <a id="17335" class="Symbol">=</a> <a id="17337" href="1Lab.Path.html#57276" data-type="(p : x .fst ≡ y .fst) →
PathP (λ i → B₁ (p i)) (x .snd) (y .snd) → x ≡ y" class="Function">Σ-pathp</a> <a id="17345" href="Cat.Functor.Equivalence.html#15919" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
x ≡ y" class="Function">x≡y</a> <a id="17349" href="Cat.Functor.Equivalence.html#16925" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) (z : D .Ob) (x : C .Ob)
(i : (D ≅ F₀ F x) z) (y : C .Ob) (j : (D ≅ F₀ F y) z) →
PathP (λ i₁ → (D ≅ F₀ F (x≡y F ccat dcat ff z x i y j i₁)) z) i j" class="Function">over</a>

  <a id="17357" href="Cat.Functor.Equivalence.html#17357" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) →
is-eso F → is-split-eso F" class="Function">Theorem-of-choice</a> <a id="17375" class="Symbol">:</a> <a id="17377" href="Cat.Functor.Base.html#5109" data-type="Functor C D → Type (C.o ⊔ D.o ⊔ D.h)" class="Function">is-eso</a> <a id="17384" href="Cat.Functor.Equivalence.html#14319" class="Bound">F</a> <a id="17386" class="Symbol">→</a> <a id="17388" href="Cat.Functor.Base.html#5029" data-type="Functor C D → Type (C.o ⊔ D.o ⊔ D.h)" class="Function">is-split-eso</a> <a id="17401" href="Cat.Functor.Equivalence.html#14319" class="Bound">F</a>
  <a id="17405" href="Cat.Functor.Equivalence.html#17357" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) →
is-eso F → is-split-eso F" class="Function">Theorem-of-choice</a> <a id="17423" href="Cat.Functor.Equivalence.html#17423" class="Bound">eso</a> <a id="17427" href="Cat.Functor.Equivalence.html#17427" class="Bound">y</a> <a id="17429" class="Symbol">=</a>
    <a id="17435" href="1Lab.HIT.Truncation.html#1408" data-type="((x : ∥ A ∥) → is-prop (P x)) →
((x : A) → P (inc x)) → (x : ∥ A ∥) → P x" class="Function">∥-∥-elim</a> <a id="17444" class="Symbol">(λ</a> <a id="17447" href="Cat.Functor.Equivalence.html#17447" class="Bound">_</a> <a id="17449" class="Symbol">→</a> <a id="17451" href="Cat.Functor.Equivalence.html#14873" data-type="(F : Functor C D) →
is-category C →
is-category D →
is-fully-faithful F → (y : D .Ob) → is-prop (Essential-fibre F y)" class="Function">Essential-fibre-between-cats-is-prop</a> <a id="17488" href="Cat.Functor.Equivalence.html#17427" class="Bound">y</a><a id="17489" class="Symbol">)</a>
      <a id="17497" class="Symbol">(λ</a> <a id="17500" href="Cat.Functor.Equivalence.html#17500" class="Bound">x</a> <a id="17502" class="Symbol">→</a> <a id="17504" href="Cat.Functor.Equivalence.html#17500" class="Bound">x</a><a id="17505" class="Symbol">)</a> <a id="17507" class="Symbol">(</a><a id="17508" href="Cat.Functor.Equivalence.html#17423" class="Bound">eso</a> <a id="17512" href="Cat.Functor.Equivalence.html#17427" class="Bound">y</a><a id="17513" class="Symbol">)</a>
</pre>
<p>This theorem implies that any fully faithful, “merely” essentially
surjective functor between categories is an equivalence:</p>
<pre class="Agda">  <a id="17655" href="Cat.Functor.Equivalence.html#17655" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) →
is-eso F → is-equivalence F" class="Function">ff+eso→is-equivalence</a> <a id="17677" class="Symbol">:</a> <a id="17679" href="Cat.Functor.Base.html#5109" data-type="Functor C D → Type (C.o ⊔ D.o ⊔ D.h)" class="Function">is-eso</a> <a id="17686" href="Cat.Functor.Equivalence.html#14319" class="Bound">F</a> <a id="17688" class="Symbol">→</a> <a id="17690" href="Cat.Functor.Equivalence.html#804" data-type="(F : Functor C D) → Type (C.o ⊔ C.h ⊔ D.o ⊔ D.h)" class="Record">is-equivalence</a> <a id="17705" href="Cat.Functor.Equivalence.html#14319" class="Bound">F</a>
  <a id="17709" href="Cat.Functor.Equivalence.html#17655" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) →
is-eso F → is-equivalence F" class="Function">ff+eso→is-equivalence</a> <a id="17731" href="Cat.Functor.Equivalence.html#17731" class="Bound">eso</a> <a id="17735" class="Symbol">=</a> <a id="17737" href="Cat.Functor.Equivalence.html#11818" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
is-equivalence F" class="Function">ff+split-eso→is-equivalence</a> <a id="17765" href="Cat.Functor.Equivalence.html#14387" class="Bound">ff</a> <a id="17768" class="Symbol">(</a><a id="17769" href="Cat.Functor.Equivalence.html#17357" data-type="(F : Functor C D) (ccat : is-category C) (dcat : is-category D)
(ff : is-fully-faithful F) →
is-eso F → is-split-eso F" class="Function">Theorem-of-choice</a> <a id="17787" href="Cat.Functor.Equivalence.html#17731" class="Bound">eso</a><a id="17790" class="Symbol">)</a>
</pre>
<h2 id="isomorphisms"><a href="#isomorphisms" class="header-link">Isomorphisms<span class="header-link-emoji">🔗</span></a></h2>
<p>Another, more direct way of proving that a functor is an equivalence
of precategories is proving that it is an <strong>isomorphism of
precategories</strong>: It’s fully faithful, thus a typal equivalence of
morphisms, and in addition its action on objects is an equivalence of
types.</p>
<pre class="Agda"><a id="18094" class="Keyword">record</a> <a id="is-precat-iso"></a><a id="18101" href="Cat.Functor.Equivalence.html#18101" data-type="(F : Functor C D) → Type (C.o ⊔ C.h ⊔ D.o ⊔ D.h)" class="Record">is-precat-iso</a> <a id="18115" class="Symbol">(</a><a id="18116" href="Cat.Functor.Equivalence.html#18116" class="Bound">F</a> <a id="18118" class="Symbol">:</a> <a id="18120" href="Cat.Base.html#7198" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="18128" href="Cat.Functor.Equivalence.html#265" class="Generalizable">C</a> <a id="18130" href="Cat.Functor.Equivalence.html#267" class="Generalizable">D</a><a id="18131" class="Symbol">)</a> <a id="18133" class="Symbol">:</a> <a id="18135" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="18140" class="Symbol">(</a><a id="18141" href="Cat.Functor.Adjoint.html#549" data-type="Precategory o₁ h₁ → Precategory o₂ h₂ → Level" class="Function">adj-level</a> <a id="18151" href="Cat.Functor.Equivalence.html#18128" class="Bound">C</a> <a id="18153" href="Cat.Functor.Equivalence.html#18130" class="Bound">D</a><a id="18154" class="Symbol">)</a> <a id="18156" class="Keyword">where</a>
  <a id="18164" class="Keyword">field</a>
    <a id="is-precat-iso.has-is-ff"></a><a id="18174" href="Cat.Functor.Equivalence.html#18174" data-type="is-precat-iso F → is-fully-faithful F" class="Field">has-is-ff</a>  <a id="18185" class="Symbol">:</a> <a id="18187" href="Cat.Functor.Base.html#1110" data-type="Functor C D → Type (C.o ⊔ C.h ⊔ D.h)" class="Function">is-fully-faithful</a> <a id="18205" href="Cat.Functor.Equivalence.html#18116" class="Bound">F</a>
    <a id="is-precat-iso.has-is-iso"></a><a id="18211" href="Cat.Functor.Equivalence.html#18211" data-type="is-precat-iso F → is-equiv (F₀ F)" class="Field">has-is-iso</a> <a id="18222" class="Symbol">:</a> <a id="18224" href="1Lab.Equiv.html#2286" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-equiv</a> <a id="18233" class="Symbol">(</a><a id="18234" href="Cat.Base.html#7988" data-type="Functor C D → C .Ob → Ob D" class="Field">F₀</a> <a id="18237" href="Cat.Functor.Equivalence.html#18116" class="Bound">F</a><a id="18238" class="Symbol">)</a>
</pre>
<p>Such a functor is (immediately) fully faithful, and the inverse
<span class="Agda"><a href="Cat.Functor.Equivalence.html#18211" class="Field">has-is-iso</a></span>
means that it is split essentially surjective; For given
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>:</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">y : D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>,</span>
the inverse of
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">F_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
gives us an object
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>F</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F^{-1}(y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>;</span>
We must then provide an isomorphism
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><msup><mi>F</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>≅</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">F(F^{-1}(y)) \cong y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>,</span>
but those are identical, hence isomorphic.</p>
<pre class="Agda"><a id="18560" class="Keyword">module</a> <a id="18567" href="Cat.Functor.Equivalence.html#18567" class="Module">_</a> <a id="18569" class="Symbol">{</a><a id="18570" href="Cat.Functor.Equivalence.html#18570" class="Bound">F</a> <a id="18572" class="Symbol">:</a> <a id="18574" href="Cat.Base.html#7198" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="18582" href="Cat.Functor.Equivalence.html#265" class="Generalizable">C</a> <a id="18584" href="Cat.Functor.Equivalence.html#267" class="Generalizable">D</a><a id="18585" class="Symbol">}</a> <a id="18587" class="Symbol">(</a><a id="18588" href="Cat.Functor.Equivalence.html#18588" class="Bound">p</a> <a id="18590" class="Symbol">:</a> <a id="18592" href="Cat.Functor.Equivalence.html#18101" data-type="(F : Functor C D) → Type (C.o ⊔ C.h ⊔ D.o ⊔ D.h)" class="Record">is-precat-iso</a> <a id="18606" href="Cat.Functor.Equivalence.html#18570" class="Bound">F</a><a id="18607" class="Symbol">)</a> <a id="18609" class="Keyword">where</a>
  <a id="18617" class="Keyword">open</a> <a id="18622" href="Cat.Functor.Equivalence.html#18101" data-type="(F : Functor C D) → Type (C.o ⊔ C.h ⊔ D.o ⊔ D.h)" class="Module">is-precat-iso</a> <a id="18636" href="Cat.Functor.Equivalence.html#18588" class="Bound">p</a>

  <a id="18641" href="Cat.Functor.Equivalence.html#18641" data-type="(p : is-precat-iso F) → is-split-eso F" class="Function">is-precat-iso→is-split-eso</a> <a id="18668" class="Symbol">:</a> <a id="18670" href="Cat.Functor.Base.html#5029" data-type="Functor C D → Type (C.o ⊔ D.o ⊔ D.h)" class="Function">is-split-eso</a> <a id="18683" href="Cat.Functor.Equivalence.html#18570" class="Bound">F</a>
  <a id="18687" href="Cat.Functor.Equivalence.html#18641" data-type="(p : is-precat-iso F) → is-split-eso F" class="Function">is-precat-iso→is-split-eso</a> <a id="18714" href="Cat.Functor.Equivalence.html#18714" class="Bound">ob</a> <a id="18717" class="Symbol">=</a> <a id="18719" href="1Lab.Equiv.html#6449" data-type="is-equiv f → B₁ → A" class="Function">equiv→inverse</a> <a id="18733" href="Cat.Functor.Equivalence.html#18211" data-type="is-precat-iso F → is-equiv (F₀ F)" class="Field">has-is-iso</a> <a id="18744" href="Cat.Functor.Equivalence.html#18714" class="Bound">ob</a> <a id="18747" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="18749" href="Cat.Functor.Equivalence.html#18764" data-type="(p : is-precat-iso F) (ob : D .Ob) →
(D ≅ F₀ F (equiv→inverse (has-is-iso p) ob)) ob" class="Function">isom</a>
    <a id="18758" class="Keyword">where</a> <a id="18764" href="Cat.Functor.Equivalence.html#18764" data-type="(p : is-precat-iso F) (ob : D .Ob) →
(D ≅ F₀ F (equiv→inverse (has-is-iso p) ob)) ob" class="Function">isom</a> <a id="18769" class="Symbol">=</a> <a id="18771" href="Cat.Univalent.html#1379" data-type="(C : Precategory o h) → A ≡ B₁ → (C ≅ A) B₁" class="Function">path→iso</a> <a id="18780" href="Cat.Functor.Equivalence.html#18584" class="Bound">D</a> <a id="18782" class="Symbol">(</a><a id="18783" href="1Lab.Equiv.html#6548" data-type="(eqv : is-equiv f) → is-right-inverse (equiv→inverse eqv) f" class="Function">equiv→section</a> <a id="18797" href="Cat.Functor.Equivalence.html#18211" data-type="is-precat-iso F → is-equiv (F₀ F)" class="Field">has-is-iso</a> <a id="18808" class="Symbol">_)</a>
</pre>
<p>Thus, by the theorem above,
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span>
is an adjoint equivalence of precategories.</p>
<pre class="Agda">  <a id="18903" href="Cat.Functor.Equivalence.html#18903" data-type="(p : is-precat-iso F) → is-equivalence F" class="Function">is-precat-iso→is-equivalence</a> <a id="18932" class="Symbol">:</a> <a id="18934" href="Cat.Functor.Equivalence.html#804" data-type="(F : Functor C D) → Type (C.o ⊔ C.h ⊔ D.o ⊔ D.h)" class="Record">is-equivalence</a> <a id="18949" href="Cat.Functor.Equivalence.html#18570" class="Bound">F</a>
  <a id="18953" href="Cat.Functor.Equivalence.html#18903" data-type="(p : is-precat-iso F) → is-equivalence F" class="Function">is-precat-iso→is-equivalence</a> <a id="18982" class="Symbol">=</a>
    <a id="18988" href="Cat.Functor.Equivalence.html#11818" data-type="(ff : is-fully-faithful F) (eso : is-split-eso F) →
is-equivalence F" class="Function">ff+split-eso→is-equivalence</a> <a id="19016" href="Cat.Functor.Equivalence.html#18174" data-type="is-precat-iso F → is-fully-faithful F" class="Field">has-is-ff</a> <a id="19026" href="Cat.Functor.Equivalence.html#18641" data-type="(p : is-precat-iso F) → is-split-eso F" class="Function">is-precat-iso→is-split-eso</a>
</pre>
  </article>
</div>
</main>
</body>
</html>
