<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="keywords" content="Agda,categories,topos" />

  <title>Data.Fin.Base - 1Lab</title>

  <link rel="stylesheet" href="/css/default.css" />
  <link rel="stylesheet" href="/css/katex.min.css" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Data.Fin.Base - 1Lab" />
  <meta name="twitter:image" content="https://1lab.dev/static/cube-128x.png" />

  <meta name="og:title" content="Data.Fin.Base - 1Lab" />
  <meta name="og:image" content="https://1lab.dev/static/cube-128x.png" />
  <meta name="og:site-name" content="1Lab" />
  <meta name="og:type" content="website" />

    <meta name="og:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="twitter:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  
  <script defer src="/main.js"></script>

  <noscript>
    <style>
      body span.reasoning-step .as-written {
        display: inline;
      }

      body span.reasoning-step .alternate {
        display: none;
      }
    </style>
  </noscript>

  <!-- Google font embeds -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;0,800;1,400;1,500;1,600;1,700;1,800&amp;family=Inria+Sans:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&amp;display=swap" rel="stylesheet">
</head>

<body class="text-page">
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <!-- Table of contents (only if the page has a table of contents) -->
    <aside id="toc">
    <div id="toc-container" style="min-width: 10em; font-size: 15pt;">
      <!-- Title for the page -->
      <h3 class="Agda" style="margin-top: 0; margin-bottom: 0; white-space: pre;">
                <a class="Module">Data.Fin.Base</a>
              </h3>

      <!-- Cube logo -->
      <a id="logo" href="/">
        <img alt="1Lab" src="/static/cube-72x.png" style="display: block; margin-bottom: 1em; margin: auto;" width="32px" height="32px" />
      </a>

      <!-- Actual table of contents (separated from the rest by
      horizontal rules) -->
      <hr />
      <ul>
      <li><a href="#finite-sets"><a href="#finite-sets" class="header-link">Finite
      Sets<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#discreteness"><a href="#discreteness" class="header-link">Discreteness<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#ordering"><a href="#ordering" class="header-link">Ordering<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#as-a-subset"><a href="#as-a-subset" class="header-link">As
      a subset<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#arithmetic"><a href="#arithmetic" class="header-link">Arithmetic<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      </ul>
      <hr />

      <!-- Sidebar controls -->
      <div style="display: flex; gap: 0.25em; flex-flow: row wrap;">
        <!-- Sidebar equations control -->
        <span class="equations" style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-eqns" type="checkbox" class="equations" id="sidebar-eqns">
          <label for="sidebar-eqns">Equations</label>
        </span>

        <!-- Sidebar fonts control -->
        <span style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-font" type="checkbox" id="toggle-fonts">
          <label for="toggle-fonts">Serif Font</label>
        </span>

        <!-- Sidebar footnotes control -->
        <span class="inline-footnotes" style="display: none; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-fns" type="checkbox" class="inline-footnotes" id="sidebar-fns">
          <label for="sidebar-fns">Inline Footnotes</label>
        </span>
      </div>

      <hr />

      <!-- Navbar navigation (lol) -->
      <div id="return" style="white-space: nowrap;">
        <div class="search-form search-form-proxy" role="form">
          <input id="search-box-proxy" type_="text" placeholder="Search..." autocomplete="off" tabindex="0"></input>
        </div>

              <a href="/">back to index</a> <br />
              <a href="all-pages.html">view all pages</a> <br />
        <a href="https://github.com/plt-amy/cubical-1lab/blob/f5718bce12ff5bb893580cdce8b77c2e6c8f4c87/src/Data/Fin/Base.lagda.md">link to source</a> <br />
                <hr /> <div class="author-list">Written by Amélia Liao and Reed Mullanix</div> <br />
              </div>
    </div>
  </aside>
  
  <article>
    <!-- Article navigation (narrow screens only) -->
    <div class="narrow-only" id="article-nav">
      <!-- Index return anchor (only if the page is not the index) -->
            <div id="return">
        <a href="/">back to index</a>
      </div>
      
      <!-- Navbar equations control -->
      <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-eqns" type="checkbox" class="equations" id="navbar-eqns">
        <label for="navbar-eqns">Equations</label>
      </span>

      <!-- Navbar footnotes control -->
      <span class="inline-footnotes" style="display: none; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-fns" type="checkbox" class="inline-footnotes" id="navbar-fns">
        <label for="navbar-fns">Inline Footnotes</label>
      </span>
    </div>

<pre class="Agda"><a id="9" class="Keyword">open</a> <a id="14" class="Keyword">import</a> <a id="21" href="1Lab.Prelude.html" class="Module">1Lab.Prelude</a>

<a id="35" class="Keyword">open</a> <a id="40" class="Keyword">import</a> <a id="47" href="Data.Sum.html" class="Module">Data.Sum</a>

<a id="57" class="Keyword">import</a> <a id="64" href="Data.Nat.html" class="Module">Data.Nat</a> <a id="73" class="Symbol">as</a> <a id="76" class="Module">Nat</a>

<a id="81" class="Keyword">module</a> <a id="88" href="Data.Fin.Base.html" class="Module">Data.Fin.Base</a> <a id="102" class="Keyword">where</a>
</pre>
<h1 id="finite-sets"><a href="#finite-sets" class="header-link">Finite
Sets<span class="header-link-emoji">🔗</span></a></h1>
<p>The type
<span class="Agda"><a href="Data.Fin.Base.html#498" class="Datatype">Fin</a></span>
is the type of size <code>n</code>. These are defined as an inductive
family over
<span class="Agda"><a href="Agda.Builtin.Nat.html#177" class="Datatype">Nat</a></span>,
such that <code>Fin 0</code> has 0 elements, <code>Fin 1</code> has 1
element, and so on.</p>
<p>Another way to view
<span class="Agda"><a href="Data.Fin.Base.html#498" class="Datatype">Fin</a></span>
is that it’s the type of numbers less than some upper bound. For
instance, <code>fsuc fzero</code> is of type <code>Fin 3</code>, but
will <em>not</em> typecheck as a <code>Fin 1</code>!</p>
<pre class="Agda"><a id="493" class="Keyword">data</a> <a id="Fin"></a><a id="498" href="Data.Fin.Base.html#498" data-type="Nat → Type" class="Datatype">Fin</a> <a id="502" class="Symbol">:</a> <a id="504" href="Agda.Builtin.Nat.html#177" data-type="Type" class="Datatype">Nat</a> <a id="508" class="Symbol">→</a> <a id="510" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="515" class="Keyword">where</a>
  <a id="Fin.fzero"></a><a id="523" href="Data.Fin.Base.html#523" data-type="Fin (suc n)" class="InductiveConstructor">fzero</a> <a id="529" class="Symbol">:</a> <a id="531" class="Symbol">∀</a> <a id="533" class="Symbol">{</a><a id="534" href="Data.Fin.Base.html#534" class="Bound">n</a><a id="535" class="Symbol">}</a> <a id="537" class="Symbol">→</a> <a id="539" href="Data.Fin.Base.html#498" data-type="Nat → Type" class="Datatype">Fin</a> <a id="543" class="Symbol">(</a><a id="544" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="548" href="Data.Fin.Base.html#534" class="Bound">n</a><a id="549" class="Symbol">)</a>
  <a id="Fin.fsuc"></a><a id="553" href="Data.Fin.Base.html#553" data-type="Fin n → Fin (suc n)" class="InductiveConstructor">fsuc</a> <a id="558" class="Symbol">:</a> <a id="560" class="Symbol">∀</a> <a id="562" class="Symbol">{</a><a id="563" href="Data.Fin.Base.html#563" class="Bound">n</a><a id="564" class="Symbol">}</a> <a id="566" class="Symbol">→</a> <a id="568" href="Data.Fin.Base.html#498" data-type="Nat → Type" class="Datatype">Fin</a> <a id="572" href="Data.Fin.Base.html#563" class="Bound">n</a> <a id="574" class="Symbol">→</a> <a id="576" href="Data.Fin.Base.html#498" data-type="Nat → Type" class="Datatype">Fin</a> <a id="580" class="Symbol">(</a><a id="581" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="585" href="Data.Fin.Base.html#563" class="Bound">n</a><a id="586" class="Symbol">)</a>
</pre>
<p>Keeping with the perspective of
<span class="Agda"><a href="Data.Fin.Base.html#498" class="Datatype">Fin</a></span>
as a type of bounded natural numbers, we provide conversion functions
going back and forth.</p>
<pre class="Agda"><a id="from-nat"></a><a id="739" href="Data.Fin.Base.html#739" data-type="(n : Nat) → Fin (suc n)" class="Function">from-nat</a> <a id="748" class="Symbol">:</a> <a id="750" class="Symbol">∀</a> <a id="752" class="Symbol">(</a><a id="753" href="Data.Fin.Base.html#753" class="Bound">n</a> <a id="755" class="Symbol">:</a> <a id="757" href="Agda.Builtin.Nat.html#177" data-type="Type" class="Datatype">Nat</a><a id="760" class="Symbol">)</a> <a id="762" class="Symbol">→</a> <a id="764" href="Data.Fin.Base.html#498" data-type="Nat → Type" class="Datatype">Fin</a> <a id="768" class="Symbol">(</a><a id="769" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="773" href="Data.Fin.Base.html#753" class="Bound">n</a><a id="774" class="Symbol">)</a>
<a id="776" href="Data.Fin.Base.html#739" data-type="(n : Nat) → Fin (suc n)" class="Function">from-nat</a> <a id="785" href="Agda.Builtin.Nat.html#195" data-type="Nat" class="InductiveConstructor">zero</a> <a id="790" class="Symbol">=</a> <a id="792" href="Data.Fin.Base.html#523" data-type="Fin (suc n)" class="InductiveConstructor">fzero</a>
<a id="798" href="Data.Fin.Base.html#739" data-type="(n : Nat) → Fin (suc n)" class="Function">from-nat</a> <a id="807" class="Symbol">(</a><a id="808" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="812" href="Data.Fin.Base.html#812" class="Bound">n</a><a id="813" class="Symbol">)</a> <a id="815" class="Symbol">=</a> <a id="817" href="Data.Fin.Base.html#553" data-type="Fin n → Fin (suc n)" class="InductiveConstructor">fsuc</a> <a id="822" class="Symbol">(</a><a id="823" href="Data.Fin.Base.html#739" data-type="(n : Nat) → Fin (suc n)" class="Function">from-nat</a> <a id="832" href="Data.Fin.Base.html#812" class="Bound">n</a><a id="833" class="Symbol">)</a>

<a id="to-nat"></a><a id="836" href="Data.Fin.Base.html#836" data-type="Fin n → Nat" class="Function">to-nat</a> <a id="843" class="Symbol">:</a> <a id="845" class="Symbol">∀</a> <a id="847" class="Symbol">{</a><a id="848" href="Data.Fin.Base.html#848" class="Bound">n</a> <a id="850" class="Symbol">:</a> <a id="852" href="Agda.Builtin.Nat.html#177" data-type="Type" class="Datatype">Nat</a><a id="855" class="Symbol">}</a> <a id="857" class="Symbol">→</a> <a id="859" href="Data.Fin.Base.html#498" data-type="Nat → Type" class="Datatype">Fin</a> <a id="863" href="Data.Fin.Base.html#848" class="Bound">n</a> <a id="865" class="Symbol">→</a> <a id="867" href="Agda.Builtin.Nat.html#177" data-type="Type" class="Datatype">Nat</a>
<a id="871" href="Data.Fin.Base.html#836" data-type="Fin n → Nat" class="Function">to-nat</a> <a id="878" href="Data.Fin.Base.html#523" data-type="Fin (suc n)" class="InductiveConstructor">fzero</a> <a id="884" class="Symbol">=</a> <a id="886" href="Agda.Builtin.Nat.html#195" data-type="Nat" class="InductiveConstructor">zero</a>
<a id="891" href="Data.Fin.Base.html#836" data-type="Fin n → Nat" class="Function">to-nat</a> <a id="898" class="Symbol">(</a><a id="899" href="Data.Fin.Base.html#553" data-type="Fin n → Fin (suc n)" class="InductiveConstructor">fsuc</a> <a id="904" href="Data.Fin.Base.html#904" class="Bound">i</a><a id="905" class="Symbol">)</a> <a id="907" class="Symbol">=</a> <a id="909" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="913" class="Symbol">(</a><a id="914" href="Data.Fin.Base.html#836" data-type="Fin n → Nat" class="Function">to-nat</a> <a id="921" href="Data.Fin.Base.html#904" class="Bound">i</a><a id="922" class="Symbol">)</a>
</pre>
<p>A note of caution: because of some ✨technical reasons✨ cubical agda
cannot handle transports over indexed inductive types very well.
Instead, we define a function
<span class="Agda"><a href="Data.Fin.Base.html#1186" class="Function">cast</a></span>
that computes on the indices of
<span class="Agda"><a href="Data.Fin.Base.html#498" class="Datatype">Fin</a></span>,
rather than on the path.</p>
<pre class="Agda"><a id="cast"></a><a id="1186" href="Data.Fin.Base.html#1186" data-type="m ≡ n → Fin m → Fin n" class="Function">cast</a> <a id="1191" class="Symbol">:</a> <a id="1193" class="Symbol">∀</a> <a id="1195" class="Symbol">{</a><a id="1196" href="Data.Fin.Base.html#1196" class="Bound">m</a> <a id="1198" href="Data.Fin.Base.html#1198" class="Bound">n</a><a id="1199" class="Symbol">}</a> <a id="1201" class="Symbol">→</a> <a id="1203" href="Data.Fin.Base.html#1196" class="Bound">m</a> <a id="1205" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="1207" href="Data.Fin.Base.html#1198" class="Bound">n</a> <a id="1209" class="Symbol">→</a> <a id="1211" href="Data.Fin.Base.html#498" data-type="Nat → Type" class="Datatype">Fin</a> <a id="1215" href="Data.Fin.Base.html#1196" class="Bound">m</a> <a id="1217" class="Symbol">→</a> <a id="1219" href="Data.Fin.Base.html#498" data-type="Nat → Type" class="Datatype">Fin</a> <a id="1223" href="Data.Fin.Base.html#1198" class="Bound">n</a>
<a id="1225" href="Data.Fin.Base.html#1186" data-type="m ≡ n → Fin m → Fin n" class="Function">cast</a> <a id="1230" class="Symbol">{</a><a id="1231" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="1235" href="Data.Fin.Base.html#1235" class="Bound">m</a><a id="1236" class="Symbol">}</a> <a id="1238" class="Symbol">{</a><a id="1239" href="Agda.Builtin.Nat.html#195" data-type="Nat" class="InductiveConstructor">zero</a><a id="1243" class="Symbol">}</a> <a id="1245" href="Data.Fin.Base.html#1245" class="Bound">p</a> <a id="1247" href="Data.Fin.Base.html#523" data-type="Fin (suc n)" class="InductiveConstructor">fzero</a> <a id="1253" class="Symbol">=</a> <a id="1255" href="1Lab.Type.html#1352" data-type="⊥ → A" class="Function">absurd</a> <a id="1262" class="Symbol">(</a><a id="1263" href="Data.Nat.Base.html#1178" data-type="zero ≡ suc n → ⊥" class="Function">Nat.zero≠suc</a> <a id="1276" class="Symbol">(</a><a id="1277" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="1281" href="Data.Fin.Base.html#1245" class="Bound">p</a><a id="1282" class="Symbol">))</a>
<a id="1285" href="Data.Fin.Base.html#1186" data-type="m ≡ n → Fin m → Fin n" class="Function">cast</a> <a id="1290" class="Symbol">{</a><a id="1291" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="1295" href="Data.Fin.Base.html#1295" class="Bound">m</a><a id="1296" class="Symbol">}</a> <a id="1298" class="Symbol">{</a><a id="1299" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="1303" href="Data.Fin.Base.html#1303" class="Bound">n</a><a id="1304" class="Symbol">}</a> <a id="1306" href="Data.Fin.Base.html#1306" class="Bound">p</a> <a id="1308" href="Data.Fin.Base.html#523" data-type="Fin (suc n)" class="InductiveConstructor">fzero</a> <a id="1314" class="Symbol">=</a> <a id="1316" href="Data.Fin.Base.html#523" data-type="Fin (suc n)" class="InductiveConstructor">fzero</a>
<a id="1322" href="Data.Fin.Base.html#1186" data-type="m ≡ n → Fin m → Fin n" class="Function">cast</a> <a id="1327" class="Symbol">{</a><a id="1328" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="1332" href="Data.Fin.Base.html#1332" class="Bound">m</a><a id="1333" class="Symbol">}</a> <a id="1335" class="Symbol">{</a><a id="1336" href="Agda.Builtin.Nat.html#195" data-type="Nat" class="InductiveConstructor">zero</a><a id="1340" class="Symbol">}</a> <a id="1342" href="Data.Fin.Base.html#1342" class="Bound">p</a> <a id="1344" class="Symbol">(</a><a id="1345" href="Data.Fin.Base.html#553" data-type="Fin n → Fin (suc n)" class="InductiveConstructor">fsuc</a> <a id="1350" href="Data.Fin.Base.html#1350" class="Bound">i</a><a id="1351" class="Symbol">)</a> <a id="1353" class="Symbol">=</a> <a id="1355" href="1Lab.Type.html#1352" data-type="⊥ → A" class="Function">absurd</a> <a id="1362" class="Symbol">(</a><a id="1363" href="Data.Nat.Base.html#1178" data-type="zero ≡ suc n → ⊥" class="Function">Nat.zero≠suc</a> <a id="1376" class="Symbol">(</a><a id="1377" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="1381" href="Data.Fin.Base.html#1342" class="Bound">p</a><a id="1382" class="Symbol">))</a>
<a id="1385" href="Data.Fin.Base.html#1186" data-type="m ≡ n → Fin m → Fin n" class="Function">cast</a> <a id="1390" class="Symbol">{</a><a id="1391" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="1395" href="Data.Fin.Base.html#1395" class="Bound">m</a><a id="1396" class="Symbol">}</a> <a id="1398" class="Symbol">{</a><a id="1399" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="1403" href="Data.Fin.Base.html#1403" class="Bound">n</a><a id="1404" class="Symbol">}</a> <a id="1406" href="Data.Fin.Base.html#1406" class="Bound">p</a> <a id="1408" class="Symbol">(</a><a id="1409" href="Data.Fin.Base.html#553" data-type="Fin n → Fin (suc n)" class="InductiveConstructor">fsuc</a> <a id="1414" href="Data.Fin.Base.html#1414" class="Bound">i</a><a id="1415" class="Symbol">)</a> <a id="1417" class="Symbol">=</a> <a id="1419" href="Data.Fin.Base.html#553" data-type="Fin n → Fin (suc n)" class="InductiveConstructor">fsuc</a> <a id="1424" class="Symbol">(</a><a id="1425" href="Data.Fin.Base.html#1186" data-type="m ≡ n → Fin m → Fin n" class="Function">cast</a> <a id="1430" class="Symbol">(</a><a id="1431" href="Data.Nat.Base.html#1668" data-type="suc x ≡ suc y → x ≡ y" class="Function">Nat.suc-inj</a> <a id="1443" href="Data.Fin.Base.html#1406" class="Bound">p</a><a id="1444" class="Symbol">)</a> <a id="1446" href="Data.Fin.Base.html#1414" class="Bound">i</a><a id="1447" class="Symbol">)</a>
</pre>
<!--
<pre class="Agda"><a id="cast-is-equiv"></a><a id="1467" href="Data.Fin.Base.html#1467" data-type="(p : m ≡ n) → is-equiv (cast p)" class="Function">cast-is-equiv</a> <a id="1481" class="Symbol">:</a> <a id="1483" class="Symbol">∀</a> <a id="1485" class="Symbol">{</a><a id="1486" href="Data.Fin.Base.html#1486" class="Bound">m</a> <a id="1488" href="Data.Fin.Base.html#1488" class="Bound">n</a><a id="1489" class="Symbol">}</a> <a id="1491" class="Symbol">(</a><a id="1492" href="Data.Fin.Base.html#1492" class="Bound">p</a> <a id="1494" class="Symbol">:</a> <a id="1496" href="Data.Fin.Base.html#1486" class="Bound">m</a> <a id="1498" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="1500" href="Data.Fin.Base.html#1488" class="Bound">n</a><a id="1501" class="Symbol">)</a> <a id="1503" class="Symbol">→</a> <a id="1505" href="1Lab.Equiv.html#2286" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-equiv</a> <a id="1514" class="Symbol">(</a><a id="1515" href="Data.Fin.Base.html#1186" data-type="m ≡ n → Fin m → Fin n" class="Function">cast</a> <a id="1520" href="Data.Fin.Base.html#1492" class="Bound">p</a><a id="1521" class="Symbol">)</a>
<a id="1523" href="Data.Fin.Base.html#1467" data-type="(p : m ≡ n) → is-equiv (cast p)" class="Function">cast-is-equiv</a> <a id="1537" class="Symbol">=</a>
  <a id="1541" href="1Lab.Path.html#19544" data-type="(P : (y : A) → x ≡ y → Type ℓ₂) → P x refl → (p : x ≡ y) → P y p" class="Function">J</a> <a id="1543" class="Symbol">(λ</a> <a id="1546" href="Data.Fin.Base.html#1546" class="Bound">_</a> <a id="1548" href="Data.Fin.Base.html#1548" class="Bound">p</a> <a id="1550" class="Symbol">→</a> <a id="1552" href="1Lab.Equiv.html#2286" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-equiv</a> <a id="1561" class="Symbol">(</a><a id="1562" href="Data.Fin.Base.html#1186" data-type="m ≡ n → Fin m → Fin n" class="Function">cast</a> <a id="1567" href="Data.Fin.Base.html#1548" class="Bound">p</a><a id="1568" class="Symbol">))</a> <a id="1571" href="Data.Fin.Base.html#1786" data-type="is-equiv (cast (λ i → n))" class="Function">cast-refl-is-equiv</a>
  <a id="1592" class="Keyword">where</a>
    <a id="1602" href="Data.Fin.Base.html#1602" data-type="id ≡ cast (λ _ → n)" class="Function">id≡cast-refl</a> <a id="1615" class="Symbol">:</a> <a id="1617" class="Symbol">∀</a> <a id="1619" class="Symbol">{</a><a id="1620" href="Data.Fin.Base.html#1620" class="Bound">n</a><a id="1621" class="Symbol">}</a> <a id="1623" class="Symbol">→</a> <a id="1625" href="1Lab.Type.html#2424" data-type="A → A" class="Function">id</a> <a id="1628" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="1630" href="Data.Fin.Base.html#1186" data-type="m ≡ n → Fin m → Fin n" class="Function">cast</a> <a id="1635" class="Symbol">(λ</a> <a id="1638" href="Data.Fin.Base.html#1638" class="Bound">_</a> <a id="1640" class="Symbol">→</a> <a id="1642" href="Data.Fin.Base.html#1620" class="Bound">n</a><a id="1643" class="Symbol">)</a>
    <a id="1649" href="Data.Fin.Base.html#1602" data-type="id ≡ cast (λ _ → n)" class="Function">id≡cast-refl</a> <a id="1662" class="Symbol">{</a><a id="1663" href="Agda.Builtin.Nat.html#195" data-type="Nat" class="InductiveConstructor">zero</a><a id="1667" class="Symbol">}</a> <a id="1669" href="Data.Fin.Base.html#1669" class="Bound">i</a> <a id="1671" class="Symbol">()</a>
    <a id="1678" href="Data.Fin.Base.html#1602" data-type="id ≡ cast (λ _ → n)" class="Function">id≡cast-refl</a> <a id="1691" class="Symbol">{</a><a id="1692" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="1696" href="Data.Fin.Base.html#1696" class="Bound">n</a><a id="1697" class="Symbol">}</a> <a id="1699" href="Data.Fin.Base.html#1699" class="Bound">i</a> <a id="1701" href="Data.Fin.Base.html#523" data-type="Fin (suc n)" class="InductiveConstructor">fzero</a> <a id="1707" class="Symbol">=</a> <a id="1709" href="Data.Fin.Base.html#523" data-type="Fin (suc n)" class="InductiveConstructor">fzero</a>
    <a id="1719" href="Data.Fin.Base.html#1602" data-type="id ≡ cast (λ _ → n)" class="Function">id≡cast-refl</a> <a id="1732" class="Symbol">{</a><a id="1733" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="1737" href="Data.Fin.Base.html#1737" class="Bound">n</a><a id="1738" class="Symbol">}</a> <a id="1740" href="Data.Fin.Base.html#1740" class="Bound">i</a> <a id="1742" class="Symbol">(</a><a id="1743" href="Data.Fin.Base.html#553" data-type="Fin n → Fin (suc n)" class="InductiveConstructor">fsuc</a> <a id="1748" href="Data.Fin.Base.html#1748" class="Bound">x</a><a id="1749" class="Symbol">)</a> <a id="1751" class="Symbol">=</a> <a id="1753" href="Data.Fin.Base.html#553" data-type="Fin n → Fin (suc n)" class="InductiveConstructor">fsuc</a> <a id="1758" class="Symbol">(</a><a id="1759" href="Data.Fin.Base.html#1602" data-type="id ≡ cast (λ _ → n)" class="Function">id≡cast-refl</a> <a id="1772" class="Symbol">{</a><a id="1773" href="Data.Fin.Base.html#1737" class="Bound">n</a><a id="1774" class="Symbol">}</a> <a id="1776" href="Data.Fin.Base.html#1740" class="Bound">i</a> <a id="1778" href="Data.Fin.Base.html#1748" class="Bound">x</a><a id="1779" class="Symbol">)</a>

    <a id="1786" href="Data.Fin.Base.html#1786" data-type="is-equiv (cast (λ i → n))" class="Function">cast-refl-is-equiv</a> <a id="1805" class="Symbol">:</a> <a id="1807" class="Symbol">∀</a> <a id="1809" class="Symbol">{</a><a id="1810" href="Data.Fin.Base.html#1810" class="Bound">n</a><a id="1811" class="Symbol">}</a> <a id="1813" class="Symbol">→</a> <a id="1815" href="1Lab.Equiv.html#2286" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-equiv</a> <a id="1824" class="Symbol">(</a><a id="1825" href="Data.Fin.Base.html#1186" data-type="m ≡ n → Fin m → Fin n" class="Function">cast</a> <a id="1830" class="Symbol">(λ</a> <a id="1833" href="Data.Fin.Base.html#1833" class="Bound">i</a> <a id="1835" class="Symbol">→</a> <a id="1837" href="Data.Fin.Base.html#1810" class="Bound">n</a><a id="1838" class="Symbol">))</a>
    <a id="1845" href="Data.Fin.Base.html#1786" data-type="is-equiv (cast (λ i → n))" class="Function">cast-refl-is-equiv</a> <a id="1864" class="Symbol">=</a> <a id="1866" href="1Lab.Path.html#15309" data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" class="Function">subst</a> <a id="1872" href="1Lab.Equiv.html#2286" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-equiv</a> <a id="1881" href="Data.Fin.Base.html#1602" data-type="id ≡ cast (λ _ → n)" class="Function">id≡cast-refl</a> <a id="1894" href="1Lab.Equiv.html#2524" data-type="is-equiv (λ x → x)" class="Function">id-equiv</a>
</pre>-->
<p>Next, we move on to one of the most useful functions for
<span class="Agda"><a href="Data.Fin.Base.html#498" class="Datatype">Fin</a></span>:
<code>strength</code>. This allows us to (possibly) strengthen the upper
bound on some <code>Fin n</code>.</p>
<pre class="Agda"><a id="strengthen"></a><a id="2077" href="Data.Fin.Base.html#2077" data-type="Fin (suc n) → Fin (suc n) ⊎ Fin n" class="Function">strengthen</a> <a id="2088" class="Symbol">:</a> <a id="2090" class="Symbol">∀</a> <a id="2092" class="Symbol">{</a><a id="2093" href="Data.Fin.Base.html#2093" class="Bound">n</a><a id="2094" class="Symbol">}</a> <a id="2096" class="Symbol">→</a> <a id="2098" href="Data.Fin.Base.html#498" data-type="Nat → Type" class="Datatype">Fin</a> <a id="2102" class="Symbol">(</a><a id="2103" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="2107" href="Data.Fin.Base.html#2093" class="Bound">n</a><a id="2108" class="Symbol">)</a> <a id="2110" class="Symbol">→</a> <a id="2112" href="Data.Fin.Base.html#498" data-type="Nat → Type" class="Datatype">Fin</a> <a id="2116" class="Symbol">(</a><a id="2117" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="2121" href="Data.Fin.Base.html#2093" class="Bound">n</a><a id="2122" class="Symbol">)</a> <a id="2124" href="Data.Sum.html#610" data-type="Type a → Type b → Type (a ⊔ b)" class="Datatype Operator">⊎</a> <a id="2126" href="Data.Fin.Base.html#498" data-type="Nat → Type" class="Datatype">Fin</a> <a id="2130" href="Data.Fin.Base.html#2093" class="Bound">n</a>
<a id="2132" href="Data.Fin.Base.html#2077" data-type="Fin (suc n) → Fin (suc n) ⊎ Fin n" class="Function">strengthen</a> <a id="2143" class="Symbol">{</a><a id="2144" class="Argument">n</a> <a id="2146" class="Symbol">=</a> <a id="2148" href="Agda.Builtin.Nat.html#195" data-type="Nat" class="InductiveConstructor">zero</a><a id="2152" class="Symbol">}</a> <a id="2154" href="Data.Fin.Base.html#523" data-type="Fin (suc n)" class="InductiveConstructor">fzero</a> <a id="2160" class="Symbol">=</a> <a id="2162" href="Data.Sum.html#669" data-type="A → A ⊎ B₁" class="InductiveConstructor">inl</a> <a id="2166" href="Data.Fin.Base.html#523" data-type="Fin (suc n)" class="InductiveConstructor">fzero</a>
<a id="2172" href="Data.Fin.Base.html#2077" data-type="Fin (suc n) → Fin (suc n) ⊎ Fin n" class="Function">strengthen</a> <a id="2183" class="Symbol">{</a><a id="2184" class="Argument">n</a> <a id="2186" class="Symbol">=</a> <a id="2188" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="2192" href="Data.Fin.Base.html#2192" class="Bound">n</a><a id="2193" class="Symbol">}</a> <a id="2195" href="Data.Fin.Base.html#523" data-type="Fin (suc n)" class="InductiveConstructor">fzero</a> <a id="2201" class="Symbol">=</a> <a id="2203" href="Data.Sum.html#687" data-type="B₁ → A ⊎ B₁" class="InductiveConstructor">inr</a> <a id="2207" href="Data.Fin.Base.html#523" data-type="Fin (suc n)" class="InductiveConstructor">fzero</a>
<a id="2213" href="Data.Fin.Base.html#2077" data-type="Fin (suc n) → Fin (suc n) ⊎ Fin n" class="Function">strengthen</a> <a id="2224" class="Symbol">{</a><a id="2225" class="Argument">n</a> <a id="2227" class="Symbol">=</a> <a id="2229" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="2233" href="Data.Fin.Base.html#2233" class="Bound">n</a><a id="2234" class="Symbol">}</a> <a id="2236" class="Symbol">(</a><a id="2237" href="Data.Fin.Base.html#553" data-type="Fin n → Fin (suc n)" class="InductiveConstructor">fsuc</a> <a id="2242" href="Data.Fin.Base.html#2242" class="Bound">i</a><a id="2243" class="Symbol">)</a> <a id="2245" class="Symbol">=</a> <a id="2247" href="Data.Sum.html#3731" data-type="(A → C) → (B₁ → D) → A ⊎ B₁ → C ⊎ D" class="Function">⊎-map</a> <a id="2253" href="Data.Fin.Base.html#553" data-type="Fin n → Fin (suc n)" class="InductiveConstructor">fsuc</a> <a id="2258" href="Data.Fin.Base.html#553" data-type="Fin n → Fin (suc n)" class="InductiveConstructor">fsuc</a> <a id="2263" class="Symbol">(</a><a id="2264" href="Data.Fin.Base.html#2077" data-type="Fin (suc n) → Fin (suc n) ⊎ Fin n" class="Function">strengthen</a> <a id="2275" href="Data.Fin.Base.html#2242" class="Bound">i</a><a id="2276" class="Symbol">)</a>
</pre>
<p>On the other hand,
<span class="Agda"><a href="Data.Fin.Base.html#2435" class="Function">weaken</a></span>
does the opposite: it relaxes the upper bound on some
<code>Fin n</code>, allowing us to regard it as a
<code>Fin (suc n)</code>.</p>
<pre class="Agda"><a id="weaken"></a><a id="2435" href="Data.Fin.Base.html#2435" data-type="Fin n → Fin (suc n)" class="Function">weaken</a> <a id="2442" class="Symbol">:</a> <a id="2444" class="Symbol">∀</a> <a id="2446" class="Symbol">{</a><a id="2447" href="Data.Fin.Base.html#2447" class="Bound">n</a><a id="2448" class="Symbol">}</a> <a id="2450" class="Symbol">→</a> <a id="2452" href="Data.Fin.Base.html#498" data-type="Nat → Type" class="Datatype">Fin</a> <a id="2456" href="Data.Fin.Base.html#2447" class="Bound">n</a> <a id="2458" class="Symbol">→</a> <a id="2460" href="Data.Fin.Base.html#498" data-type="Nat → Type" class="Datatype">Fin</a> <a id="2464" class="Symbol">(</a><a id="2465" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="2469" href="Data.Fin.Base.html#2447" class="Bound">n</a><a id="2470" class="Symbol">)</a>
<a id="2472" href="Data.Fin.Base.html#2435" data-type="Fin n → Fin (suc n)" class="Function">weaken</a> <a id="2479" href="Data.Fin.Base.html#523" data-type="Fin (suc n)" class="InductiveConstructor">fzero</a> <a id="2485" class="Symbol">=</a> <a id="2487" href="Data.Fin.Base.html#523" data-type="Fin (suc n)" class="InductiveConstructor">fzero</a>
<a id="2493" href="Data.Fin.Base.html#2435" data-type="Fin n → Fin (suc n)" class="Function">weaken</a> <a id="2500" class="Symbol">(</a><a id="2501" href="Data.Fin.Base.html#553" data-type="Fin n → Fin (suc n)" class="InductiveConstructor">fsuc</a> <a id="2506" href="Data.Fin.Base.html#2506" class="Bound">i</a><a id="2507" class="Symbol">)</a> <a id="2509" class="Symbol">=</a> <a id="2511" href="Data.Fin.Base.html#553" data-type="Fin n → Fin (suc n)" class="InductiveConstructor">fsuc</a> <a id="2516" class="Symbol">(</a><a id="2517" href="Data.Fin.Base.html#2435" data-type="Fin n → Fin (suc n)" class="Function">weaken</a> <a id="2524" href="Data.Fin.Base.html#2506" class="Bound">i</a><a id="2525" class="Symbol">)</a>
</pre>
<p>We can also relax the upper bounds if <code>m ≤ n</code>.</p>
<pre class="Agda"><a id="inject"></a><a id="2588" href="Data.Fin.Base.html#2588" data-type="m ≤ n → Fin m → Fin n" class="Function">inject</a> <a id="2595" class="Symbol">:</a> <a id="2597" class="Symbol">∀</a> <a id="2599" class="Symbol">{</a><a id="2600" href="Data.Fin.Base.html#2600" class="Bound">m</a> <a id="2602" href="Data.Fin.Base.html#2602" class="Bound">n</a><a id="2603" class="Symbol">}</a> <a id="2605" class="Symbol">→</a> <a id="2607" href="Data.Fin.Base.html#2600" class="Bound">m</a> <a id="2609" href="Data.Nat.Base.html#3817" data-type="Nat → Nat → Type" class="Function Operator">Nat.≤</a> <a id="2615" href="Data.Fin.Base.html#2602" class="Bound">n</a> <a id="2617" class="Symbol">→</a> <a id="2619" href="Data.Fin.Base.html#498" data-type="Nat → Type" class="Datatype">Fin</a> <a id="2623" href="Data.Fin.Base.html#2600" class="Bound">m</a> <a id="2625" class="Symbol">→</a> <a id="2627" href="Data.Fin.Base.html#498" data-type="Nat → Type" class="Datatype">Fin</a> <a id="2631" href="Data.Fin.Base.html#2602" class="Bound">n</a>
<a id="2633" href="Data.Fin.Base.html#2588" data-type="m ≤ n → Fin m → Fin n" class="Function">inject</a> <a id="2640" class="Symbol">{_}</a> <a id="2644" class="Symbol">{</a><a id="2645" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="2649" href="Data.Fin.Base.html#2649" class="Bound">n</a><a id="2650" class="Symbol">}</a> <a id="2652" href="Data.Fin.Base.html#2652" class="Bound">le</a> <a id="2655" href="Data.Fin.Base.html#523" data-type="Fin (suc n)" class="InductiveConstructor">fzero</a> <a id="2661" class="Symbol">=</a> <a id="2663" href="Data.Fin.Base.html#523" data-type="Fin (suc n)" class="InductiveConstructor">fzero</a>
<a id="2669" href="Data.Fin.Base.html#2588" data-type="m ≤ n → Fin m → Fin n" class="Function">inject</a> <a id="2676" class="Symbol">{_}</a> <a id="2680" class="Symbol">{</a><a id="2681" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="2685" href="Data.Fin.Base.html#2685" class="Bound">n</a><a id="2686" class="Symbol">}</a> <a id="2688" href="Data.Fin.Base.html#2688" class="Bound">le</a> <a id="2691" class="Symbol">(</a><a id="2692" href="Data.Fin.Base.html#553" data-type="Fin n → Fin (suc n)" class="InductiveConstructor">fsuc</a> <a id="2697" href="Data.Fin.Base.html#2697" class="Bound">i</a><a id="2698" class="Symbol">)</a> <a id="2700" class="Symbol">=</a> <a id="2702" href="Data.Fin.Base.html#553" data-type="Fin n → Fin (suc n)" class="InductiveConstructor">fsuc</a> <a id="2707" class="Symbol">(</a><a id="2708" href="Data.Fin.Base.html#2588" data-type="m ≤ n → Fin m → Fin n" class="Function">inject</a> <a id="2715" href="Data.Fin.Base.html#2688" class="Bound">le</a> <a id="2718" href="Data.Fin.Base.html#2697" class="Bound">i</a><a id="2719" class="Symbol">)</a>
</pre>
<h2 id="discreteness"><a href="#discreteness" class="header-link">Discreteness<span class="header-link-emoji">🔗</span></a></h2>
<p>The proof here mirrors the one found in <a href="Data.Nat.Base.html"><code>Data.Nat.Base</code></a>, just with some
slight tweaks required to handle the indexing.</p>
<p>We begin by showing that one can
<span class="Agda"><a href="Data.Fin.Base.html#3105" class="Function">distinguish</a></span>
zero from successor:</p>
<pre class="Agda"><a id="fzero≠fsuc"></a><a id="2989" href="Data.Fin.Base.html#2989" data-type="fzero ≡ fsuc i → ⊥" class="Function">fzero≠fsuc</a> <a id="3000" class="Symbol">:</a> <a id="3002" class="Symbol">∀</a> <a id="3004" class="Symbol">{</a><a id="3005" href="Data.Fin.Base.html#3005" class="Bound">n</a><a id="3006" class="Symbol">}</a> <a id="3008" class="Symbol">{</a><a id="3009" href="Data.Fin.Base.html#3009" class="Bound">i</a> <a id="3011" class="Symbol">:</a> <a id="3013" href="Data.Fin.Base.html#498" data-type="Nat → Type" class="Datatype">Fin</a> <a id="3017" href="Data.Fin.Base.html#3005" class="Bound">n</a><a id="3018" class="Symbol">}</a> <a id="3020" class="Symbol">→</a> <a id="3022" href="Data.Fin.Base.html#523" data-type="Fin (suc n)" class="InductiveConstructor">fzero</a> <a id="3028" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="3030" href="Data.Fin.Base.html#553" data-type="Fin n → Fin (suc n)" class="InductiveConstructor">fsuc</a> <a id="3035" href="Data.Fin.Base.html#3009" class="Bound">i</a> <a id="3037" class="Symbol">→</a> <a id="3039" href="1Lab.Type.html#1336" data-type="Type" class="Datatype">⊥</a>
<a id="3041" href="Data.Fin.Base.html#2989" data-type="fzero ≡ fsuc i → ⊥" class="Function">fzero≠fsuc</a> <a id="3052" class="Symbol">{</a><a id="3053" class="Argument">n</a> <a id="3055" class="Symbol">=</a> <a id="3057" href="Data.Fin.Base.html#3057" class="Bound">n</a><a id="3058" class="Symbol">}</a> <a id="3060" href="Data.Fin.Base.html#3060" class="Bound">path</a> <a id="3065" class="Symbol">=</a> <a id="3067" href="1Lab.Path.html#15309" data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" class="Function">subst</a> <a id="3073" href="Data.Fin.Base.html#3105" data-type="(path₁ : fzero ≡ fsuc i) → Fin (suc n) → Type" class="Function">distinguish</a> <a id="3085" href="Data.Fin.Base.html#3060" class="Bound">path</a> <a id="3090" href="Agda.Builtin.Unit.html#186" data-type="⊤" class="InductiveConstructor">tt</a>
  <a id="3095" class="Keyword">where</a>
    <a id="3105" href="Data.Fin.Base.html#3105" data-type="(path₁ : fzero ≡ fsuc i) → Fin (suc n) → Type" class="Function">distinguish</a> <a id="3117" class="Symbol">:</a> <a id="3119" href="Data.Fin.Base.html#498" data-type="Nat → Type" class="Datatype">Fin</a> <a id="3123" class="Symbol">(</a><a id="3124" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="3128" href="Data.Fin.Base.html#3057" class="Bound">n</a><a id="3129" class="Symbol">)</a> <a id="3131" class="Symbol">→</a> <a id="3133" href="1Lab.Type.html#391" class="Primitive">Type</a>
    <a id="3142" href="Data.Fin.Base.html#3105" data-type="(path₁ : fzero ≡ fsuc i) → Fin (suc n) → Type" class="Function">distinguish</a> <a id="3154" href="Data.Fin.Base.html#523" data-type="Fin (suc n)" class="InductiveConstructor">fzero</a> <a id="3160" class="Symbol">=</a> <a id="3162" href="Agda.Builtin.Unit.html#149" data-type="Type" class="Record">⊤</a>
    <a id="3168" href="Data.Fin.Base.html#3105" data-type="(path₁ : fzero ≡ fsuc i) → Fin (suc n) → Type" class="Function">distinguish</a> <a id="3180" class="Symbol">(</a><a id="3181" href="Data.Fin.Base.html#553" data-type="Fin n → Fin (suc n)" class="InductiveConstructor">fsuc</a> <a id="3186" class="Symbol">_)</a> <a id="3189" class="Symbol">=</a> <a id="3191" href="1Lab.Type.html#1336" data-type="Type" class="Datatype">⊥</a>
</pre>
<p>Next, we show that <code>fsuc</code> is injective. This again follows
the proof in <a href="Data.Nat.Base.html"><code>Data.Nat.Base</code></a>, but some extra
care must be taken to ensure that
<span class="Agda"><a href="Data.Fin.Base.html#3519" class="Function">pred</a></span>
is well typed!</p>
<pre class="Agda"><a id="fsuc-inj"></a><a id="3415" href="Data.Fin.Base.html#3415" data-type="fsuc i ≡ fsuc j → i ≡ j" class="Function">fsuc-inj</a> <a id="3424" class="Symbol">:</a> <a id="3426" class="Symbol">∀</a> <a id="3428" class="Symbol">{</a><a id="3429" href="Data.Fin.Base.html#3429" class="Bound">n</a><a id="3430" class="Symbol">}</a> <a id="3432" class="Symbol">{</a><a id="3433" href="Data.Fin.Base.html#3433" class="Bound">i</a> <a id="3435" href="Data.Fin.Base.html#3435" class="Bound">j</a> <a id="3437" class="Symbol">:</a> <a id="3439" href="Data.Fin.Base.html#498" data-type="Nat → Type" class="Datatype">Fin</a> <a id="3443" href="Data.Fin.Base.html#3429" class="Bound">n</a><a id="3444" class="Symbol">}</a> <a id="3446" class="Symbol">→</a> <a id="3448" href="Data.Fin.Base.html#553" data-type="Fin n → Fin (suc n)" class="InductiveConstructor">fsuc</a> <a id="3453" href="Data.Fin.Base.html#3433" class="Bound">i</a> <a id="3455" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="3457" href="Data.Fin.Base.html#553" data-type="Fin n → Fin (suc n)" class="InductiveConstructor">fsuc</a> <a id="3462" href="Data.Fin.Base.html#3435" class="Bound">j</a> <a id="3464" class="Symbol">→</a> <a id="3466" href="Data.Fin.Base.html#3433" class="Bound">i</a> <a id="3468" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="3470" href="Data.Fin.Base.html#3435" class="Bound">j</a>
<a id="3472" href="Data.Fin.Base.html#3415" data-type="fsuc i ≡ fsuc j → i ≡ j" class="Function">fsuc-inj</a> <a id="3481" class="Symbol">{</a><a id="3482" class="Argument">n</a> <a id="3484" class="Symbol">=</a> <a id="3486" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="3490" href="Data.Fin.Base.html#3490" class="Bound">n</a><a id="3491" class="Symbol">}</a> <a id="3493" href="Data.Fin.Base.html#3493" class="Bound">p</a> <a id="3495" class="Symbol">=</a> <a id="3497" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="3500" href="Data.Fin.Base.html#3519" data-type="(n : Nat) (p : fsuc i ≡ fsuc j) → Fin (suc (suc n)) → Fin (suc n)" class="Function">pred</a> <a id="3505" href="Data.Fin.Base.html#3493" class="Bound">p</a>
  <a id="3509" class="Keyword">where</a>
    <a id="3519" href="Data.Fin.Base.html#3519" data-type="(n : Nat) (p : fsuc i ≡ fsuc j) → Fin (suc (suc n)) → Fin (suc n)" class="Function">pred</a> <a id="3524" class="Symbol">:</a> <a id="3526" href="Data.Fin.Base.html#498" data-type="Nat → Type" class="Datatype">Fin</a> <a id="3530" class="Symbol">(</a><a id="3531" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="3535" class="Symbol">(</a><a id="3536" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="3540" href="Data.Fin.Base.html#3490" class="Bound">n</a><a id="3541" class="Symbol">))</a> <a id="3544" class="Symbol">→</a> <a id="3546" href="Data.Fin.Base.html#498" data-type="Nat → Type" class="Datatype">Fin</a> <a id="3550" class="Symbol">(</a><a id="3551" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="3555" href="Data.Fin.Base.html#3490" class="Bound">n</a><a id="3556" class="Symbol">)</a>
    <a id="3562" href="Data.Fin.Base.html#3519" data-type="(n : Nat) (p : fsuc i ≡ fsuc j) → Fin (suc (suc n)) → Fin (suc n)" class="Function">pred</a> <a id="3567" href="Data.Fin.Base.html#523" data-type="Fin (suc n)" class="InductiveConstructor">fzero</a> <a id="3573" class="Symbol">=</a> <a id="3575" href="Data.Fin.Base.html#523" data-type="Fin (suc n)" class="InductiveConstructor">fzero</a>
    <a id="3585" href="Data.Fin.Base.html#3519" data-type="(n : Nat) (p : fsuc i ≡ fsuc j) → Fin (suc (suc n)) → Fin (suc n)" class="Function">pred</a> <a id="3590" class="Symbol">(</a><a id="3591" href="Data.Fin.Base.html#553" data-type="Fin n → Fin (suc n)" class="InductiveConstructor">fsuc</a> <a id="3596" href="Data.Fin.Base.html#3596" class="Bound">i</a><a id="3597" class="Symbol">)</a> <a id="3599" class="Symbol">=</a> <a id="3601" href="Data.Fin.Base.html#3596" class="Bound">i</a>
</pre>
<p>Finally, we pull everything together to show that
<span class="Agda"><a href="Data.Fin.Base.html#498" class="Datatype">Fin</a></span>
is Discrete. This is not exactly a shock (after all,
<span class="Agda"><a href="Agda.Builtin.Nat.html#177" class="Datatype">Nat</a></span>)
is discrete), but it’s useful nonetheless!</p>
<pre class="Agda"><a id="Discrete-Fin"></a><a id="3790" href="Data.Fin.Base.html#3790" data-type="Discrete (Fin n)" class="Function">Discrete-Fin</a> <a id="3803" class="Symbol">:</a> <a id="3805" class="Symbol">∀</a> <a id="3807" class="Symbol">{</a><a id="3808" href="Data.Fin.Base.html#3808" class="Bound">n</a><a id="3809" class="Symbol">}</a> <a id="3811" class="Symbol">→</a> <a id="3813" href="1Lab.Type.Dec.html#585" data-type="Type ℓ → Type ℓ" class="Function">Discrete</a> <a id="3822" class="Symbol">(</a><a id="3823" href="Data.Fin.Base.html#498" data-type="Nat → Type" class="Datatype">Fin</a> <a id="3827" href="Data.Fin.Base.html#3808" class="Bound">n</a><a id="3828" class="Symbol">)</a>
<a id="3830" href="Data.Fin.Base.html#3790" data-type="Discrete (Fin n)" class="Function">Discrete-Fin</a> <a id="3843" href="Data.Fin.Base.html#523" data-type="Fin (suc n)" class="InductiveConstructor">fzero</a> <a id="3849" href="Data.Fin.Base.html#523" data-type="Fin (suc n)" class="InductiveConstructor">fzero</a> <a id="3855" class="Symbol">=</a> <a id="3857" href="1Lab.Type.Dec.html#292" data-type="A → Dec A" class="InductiveConstructor">yes</a> <a id="3861" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
<a id="3866" href="Data.Fin.Base.html#3790" data-type="Discrete (Fin n)" class="Function">Discrete-Fin</a> <a id="3879" href="Data.Fin.Base.html#523" data-type="Fin (suc n)" class="InductiveConstructor">fzero</a> <a id="3885" class="Symbol">(</a><a id="3886" href="Data.Fin.Base.html#553" data-type="Fin n → Fin (suc n)" class="InductiveConstructor">fsuc</a> <a id="3891" href="Data.Fin.Base.html#3891" class="Bound">j</a><a id="3892" class="Symbol">)</a> <a id="3894" class="Symbol">=</a> <a id="3896" href="1Lab.Type.Dec.html#310" data-type="(A → ⊥) → Dec A" class="InductiveConstructor">no</a> <a id="3899" class="Symbol">λ</a> <a id="3901" href="Data.Fin.Base.html#3901" class="Bound">zero≡suc</a> <a id="3910" class="Symbol">→</a> <a id="3912" href="1Lab.Type.html#1352" data-type="⊥ → A" class="Function">absurd</a> <a id="3919" class="Symbol">(</a><a id="3920" href="Data.Fin.Base.html#2989" data-type="fzero ≡ fsuc i → ⊥" class="Function">fzero≠fsuc</a> <a id="3931" href="Data.Fin.Base.html#3901" class="Bound">zero≡suc</a><a id="3939" class="Symbol">)</a>
<a id="3941" href="Data.Fin.Base.html#3790" data-type="Discrete (Fin n)" class="Function">Discrete-Fin</a> <a id="3954" class="Symbol">(</a><a id="3955" href="Data.Fin.Base.html#553" data-type="Fin n → Fin (suc n)" class="InductiveConstructor">fsuc</a> <a id="3960" href="Data.Fin.Base.html#3960" class="Bound">i</a><a id="3961" class="Symbol">)</a> <a id="3963" href="Data.Fin.Base.html#523" data-type="Fin (suc n)" class="InductiveConstructor">fzero</a> <a id="3969" class="Symbol">=</a> <a id="3971" href="1Lab.Type.Dec.html#310" data-type="(A → ⊥) → Dec A" class="InductiveConstructor">no</a> <a id="3974" class="Symbol">λ</a> <a id="3976" href="Data.Fin.Base.html#3976" class="Bound">zero≡suc</a> <a id="3985" class="Symbol">→</a> <a id="3987" href="1Lab.Type.html#1352" data-type="⊥ → A" class="Function">absurd</a> <a id="3994" class="Symbol">(</a><a id="3995" href="Data.Fin.Base.html#2989" data-type="fzero ≡ fsuc i → ⊥" class="Function">fzero≠fsuc</a> <a id="4006" class="Symbol">(</a><a id="4007" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="4011" href="Data.Fin.Base.html#3976" class="Bound">zero≡suc</a><a id="4019" class="Symbol">))</a>
<a id="4022" href="Data.Fin.Base.html#3790" data-type="Discrete (Fin n)" class="Function">Discrete-Fin</a> <a id="4035" class="Symbol">(</a><a id="4036" href="Data.Fin.Base.html#553" data-type="Fin n → Fin (suc n)" class="InductiveConstructor">fsuc</a> <a id="4041" href="Data.Fin.Base.html#4041" class="Bound">i</a><a id="4042" class="Symbol">)</a> <a id="4044" class="Symbol">(</a><a id="4045" href="Data.Fin.Base.html#553" data-type="Fin n → Fin (suc n)" class="InductiveConstructor">fsuc</a> <a id="4050" href="Data.Fin.Base.html#4050" class="Bound">j</a><a id="4051" class="Symbol">)</a> <a id="4053" class="Keyword">with</a> <a id="4058" href="Data.Fin.Base.html#3790" data-type="Discrete (Fin n)" class="Function">Discrete-Fin</a> <a id="4071" href="Data.Fin.Base.html#4041" class="Bound">i</a> <a id="4073" href="Data.Fin.Base.html#4050" class="Bound">j</a>
<a id="4075" class="Symbol">...</a> <a id="4079" class="Symbol">|</a> <a id="4081" href="1Lab.Type.Dec.html#292" data-type="A → Dec A" class="InductiveConstructor">yes</a> <a id="4085" href="Data.Fin.Base.html#4085" class="Bound">i≡j</a> <a id="4089" class="Symbol">=</a> <a id="4091" href="1Lab.Type.Dec.html#292" data-type="A → Dec A" class="InductiveConstructor">yes</a> <a id="4095" class="Symbol">(</a><a id="4096" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="4099" href="Data.Fin.Base.html#553" data-type="Fin n → Fin (suc n)" class="InductiveConstructor">fsuc</a> <a id="4104" href="Data.Fin.Base.html#4085" class="Bound">i≡j</a><a id="4107" class="Symbol">)</a>
<a id="4109" class="Symbol">...</a> <a id="4113" class="Symbol">|</a> <a id="4115" href="1Lab.Type.Dec.html#310" data-type="(A → ⊥) → Dec A" class="InductiveConstructor">no</a> <a id="4118" href="Data.Fin.Base.html#4118" class="Bound">¬i≡j</a> <a id="4123" class="Symbol">=</a> <a id="4125" href="1Lab.Type.Dec.html#310" data-type="(A → ⊥) → Dec A" class="InductiveConstructor">no</a> <a id="4128" class="Symbol">λ</a> <a id="4130" href="Data.Fin.Base.html#4130" class="Bound">suci≡sucj</a> <a id="4140" class="Symbol">→</a> <a id="4142" href="Data.Fin.Base.html#4118" class="Bound">¬i≡j</a> <a id="4147" class="Symbol">(</a><a id="4148" href="Data.Fin.Base.html#3415" data-type="fsuc i ≡ fsuc j → i ≡ j" class="Function">fsuc-inj</a> <a id="4157" href="Data.Fin.Base.html#4130" class="Bound">suci≡sucj</a><a id="4166" class="Symbol">)</a>
</pre>
<p><a href="1Lab.HLevel.Sets.html#3231">Hedberg’s
theorem</a> implies that
<span class="Agda"><a href="Data.Fin.Base.html#498" class="Datatype">Fin</a></span>
is a <a href="1Lab.HLevel.html#3356">set</a>, i.e., it only has
trivial paths.</p>
<pre class="Agda"><a id="Fin-is-set"></a><a id="4368" href="Data.Fin.Base.html#4368" data-type="is-set (Fin n)" class="Function">Fin-is-set</a> <a id="4379" class="Symbol">:</a> <a id="4381" class="Symbol">∀</a> <a id="4383" class="Symbol">{</a><a id="4384" href="Data.Fin.Base.html#4384" class="Bound">n</a><a id="4385" class="Symbol">}</a> <a id="4387" class="Symbol">→</a> <a id="4389" href="1Lab.HLevel.html#3356" data-type="Type ℓ → Type ℓ" class="Function">is-set</a> <a id="4396" class="Symbol">(</a><a id="4397" href="Data.Fin.Base.html#498" data-type="Nat → Type" class="Datatype">Fin</a> <a id="4401" href="Data.Fin.Base.html#4384" class="Bound">n</a><a id="4402" class="Symbol">)</a>
<a id="4404" href="Data.Fin.Base.html#4368" data-type="is-set (Fin n)" class="Function">Fin-is-set</a> <a id="4415" class="Symbol">=</a> <a id="4417" href="1Lab.HLevel.Sets.html#3231" data-type="Discrete A → is-set A" class="Function">Discrete→is-set</a> <a id="4433" href="Data.Fin.Base.html#3790" data-type="Discrete (Fin n)" class="Function">Discrete-Fin</a>

<a id="4447" class="Keyword">instance</a>
  <a id="H-Level-Fin"></a><a id="4458" href="Data.Fin.Base.html#4458" data-type="H-Level (Fin n) (2 + k)" class="Function">H-Level-Fin</a> <a id="4470" class="Symbol">:</a> <a id="4472" class="Symbol">∀</a> <a id="4474" class="Symbol">{</a><a id="4475" href="Data.Fin.Base.html#4475" class="Bound">n</a> <a id="4477" href="Data.Fin.Base.html#4477" class="Bound">k</a><a id="4478" class="Symbol">}</a> <a id="4480" class="Symbol">→</a> <a id="4482" href="1Lab.HLevel.Retracts.html#7663" data-type="(T : Type ℓ) (n : Nat) → Type ℓ" class="Record">H-Level</a> <a id="4490" class="Symbol">(</a><a id="4491" href="Data.Fin.Base.html#498" data-type="Nat → Type" class="Datatype">Fin</a> <a id="4495" href="Data.Fin.Base.html#4475" class="Bound">n</a><a id="4496" class="Symbol">)</a> <a id="4498" class="Symbol">(</a><a id="4499" class="Number">2</a> <a id="4501" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="4503" href="Data.Fin.Base.html#4477" class="Bound">k</a><a id="4504" class="Symbol">)</a>
  <a id="4508" href="Data.Fin.Base.html#4458" data-type="H-Level (Fin n) (2 + k)" class="Function">H-Level-Fin</a> <a id="4520" class="Symbol">=</a> <a id="4522" href="1Lab.HLevel.Retracts.html#8750" data-type="(n : Nat) → is-hlevel T n → H-Level T (n + k)" class="Function">basic-instance</a> <a id="4537" class="Number">2</a> <a id="4539" href="Data.Fin.Base.html#4368" data-type="is-set (Fin n)" class="Function">Fin-is-set</a>
</pre>
<h2 id="ordering"><a href="#ordering" class="header-link">Ordering<span class="header-link-emoji">🔗</span></a></h2>
<p>Keeping with the view that
<span class="Agda"><a href="Data.Fin.Base.html#498" class="Datatype">Fin</a></span>
represents the type of bounded natural numbers, we can re-use the
ordering on
<span class="Agda"><a href="Agda.Builtin.Nat.html#177" class="Datatype">Nat</a></span>
to induce an ordering on
<span class="Agda"><a href="Data.Fin.Base.html#498" class="Datatype">Fin</a></span>.
This lets us repurpose any lemmas on <a href="Data.Nat.Base.html#3817"><code>≤</code></a> to also operate on
<span class="Agda"><a href="Data.Fin.Base.html#498" class="Datatype">Fin</a></span>.</p>
<pre class="Agda"><a id="_≤_"></a><a id="4856" href="Data.Fin.Base.html#4856" data-type="Fin n → Fin n → Type" class="Function Operator">_≤_</a> <a id="4860" class="Symbol">:</a> <a id="4862" class="Symbol">∀</a> <a id="4864" class="Symbol">{</a><a id="4865" href="Data.Fin.Base.html#4865" class="Bound">n</a><a id="4866" class="Symbol">}</a> <a id="4868" class="Symbol">→</a> <a id="4870" href="Data.Fin.Base.html#498" data-type="Nat → Type" class="Datatype">Fin</a> <a id="4874" href="Data.Fin.Base.html#4865" class="Bound">n</a> <a id="4876" class="Symbol">→</a> <a id="4878" href="Data.Fin.Base.html#498" data-type="Nat → Type" class="Datatype">Fin</a> <a id="4882" href="Data.Fin.Base.html#4865" class="Bound">n</a> <a id="4884" class="Symbol">→</a> <a id="4886" href="1Lab.Type.html#391" class="Primitive">Type</a>
<a id="4891" href="Data.Fin.Base.html#4891" class="Bound">i</a> <a id="4893" href="Data.Fin.Base.html#4856" data-type="Fin n → Fin n → Type" class="Function Operator">≤</a> <a id="4895" href="Data.Fin.Base.html#4895" class="Bound">j</a> <a id="4897" class="Symbol">=</a> <a id="4899" class="Symbol">(</a><a id="4900" href="Data.Fin.Base.html#836" data-type="Fin n → Nat" class="Function">to-nat</a> <a id="4907" href="Data.Fin.Base.html#4891" class="Bound">i</a><a id="4908" class="Symbol">)</a> <a id="4910" href="Data.Nat.Base.html#3817" data-type="Nat → Nat → Type" class="Function Operator">Nat.≤</a> <a id="4916" class="Symbol">(</a><a id="4917" href="Data.Fin.Base.html#836" data-type="Fin n → Nat" class="Function">to-nat</a> <a id="4924" href="Data.Fin.Base.html#4895" class="Bound">j</a><a id="4925" class="Symbol">)</a>
<a id="4927" class="Keyword">infix</a> <a id="4933" class="Number">3</a> <a id="4935" href="Data.Fin.Base.html#4856" data-type="Fin n → Fin n → Type" class="Function Operator">_≤_</a>

<a id="_&lt;_"></a><a id="4940" href="Data.Fin.Base.html#4940" data-type="Fin n → Fin n → Type" class="Function Operator">_&lt;_</a> <a id="4944" class="Symbol">:</a> <a id="4946" class="Symbol">∀</a> <a id="4948" class="Symbol">{</a><a id="4949" href="Data.Fin.Base.html#4949" class="Bound">n</a><a id="4950" class="Symbol">}</a> <a id="4952" class="Symbol">→</a> <a id="4954" href="Data.Fin.Base.html#498" data-type="Nat → Type" class="Datatype">Fin</a> <a id="4958" href="Data.Fin.Base.html#4949" class="Bound">n</a> <a id="4960" class="Symbol">→</a> <a id="4962" href="Data.Fin.Base.html#498" data-type="Nat → Type" class="Datatype">Fin</a> <a id="4966" href="Data.Fin.Base.html#4949" class="Bound">n</a> <a id="4968" class="Symbol">→</a> <a id="4970" href="1Lab.Type.html#391" class="Primitive">Type</a>
<a id="4975" href="Data.Fin.Base.html#4975" class="Bound">i</a> <a id="4977" href="Data.Fin.Base.html#4940" data-type="Fin n → Fin n → Type" class="Function Operator">&lt;</a> <a id="4979" href="Data.Fin.Base.html#4979" class="Bound">j</a> <a id="4981" class="Symbol">=</a> <a id="4983" class="Symbol">(</a><a id="4984" href="Data.Fin.Base.html#836" data-type="Fin n → Nat" class="Function">to-nat</a> <a id="4991" href="Data.Fin.Base.html#4975" class="Bound">i</a><a id="4992" class="Symbol">)</a> <a id="4994" href="Data.Nat.Base.html#4034" data-type="Nat → Nat → Type" class="Function Operator">Nat.&lt;</a> <a id="5000" class="Symbol">(</a><a id="5001" href="Data.Fin.Base.html#836" data-type="Fin n → Nat" class="Function">to-nat</a> <a id="5008" href="Data.Fin.Base.html#4979" class="Bound">j</a><a id="5009" class="Symbol">)</a>
<a id="5011" class="Keyword">infix</a> <a id="5017" class="Number">3</a> <a id="5019" href="Data.Fin.Base.html#4940" data-type="Fin n → Fin n → Type" class="Function Operator">_&lt;_</a>
</pre>
<p>Next, we define a pair of functions
<span class="Agda"><a href="Data.Fin.Base.html#5374" class="Function">squish</a></span>
and
<span class="Agda"><a href="Data.Fin.Base.html#5548" class="Function">skip</a></span>,
which are the building blocks for <em>all</em> monotone functions
between
<span class="Agda"><a href="Data.Fin.Base.html#498" class="Datatype">Fin</a></span>.
<code>squish i</code> takes a <code>j : Fin (suc n)</code> to a
<code>Fin n</code> by mapping both <code>i</code> and <code>i+1</code>
to <code>i</code>. Its counterpart <code>skip i</code> takes some
<code>j : Fin n</code> to a <code>Fin (suc n)</code> by skipping over
<code>i</code> instead.</p>
<pre class="Agda"><a id="squish"></a><a id="5374" href="Data.Fin.Base.html#5374" data-type="Fin n → Fin (suc n) → Fin n" class="Function">squish</a> <a id="5381" class="Symbol">:</a> <a id="5383" class="Symbol">∀</a> <a id="5385" class="Symbol">{</a><a id="5386" href="Data.Fin.Base.html#5386" class="Bound">n</a><a id="5387" class="Symbol">}</a> <a id="5389" class="Symbol">→</a> <a id="5391" href="Data.Fin.Base.html#498" data-type="Nat → Type" class="Datatype">Fin</a> <a id="5395" href="Data.Fin.Base.html#5386" class="Bound">n</a> <a id="5397" class="Symbol">→</a> <a id="5399" href="Data.Fin.Base.html#498" data-type="Nat → Type" class="Datatype">Fin</a> <a id="5403" class="Symbol">(</a><a id="5404" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="5408" href="Data.Fin.Base.html#5386" class="Bound">n</a><a id="5409" class="Symbol">)</a> <a id="5411" class="Symbol">→</a> <a id="5413" href="Data.Fin.Base.html#498" data-type="Nat → Type" class="Datatype">Fin</a> <a id="5417" href="Data.Fin.Base.html#5386" class="Bound">n</a>
<a id="5419" href="Data.Fin.Base.html#5374" data-type="Fin n → Fin (suc n) → Fin n" class="Function">squish</a> <a id="5426" href="Data.Fin.Base.html#523" data-type="Fin (suc n)" class="InductiveConstructor">fzero</a> <a id="5432" href="Data.Fin.Base.html#523" data-type="Fin (suc n)" class="InductiveConstructor">fzero</a> <a id="5438" class="Symbol">=</a> <a id="5440" href="Data.Fin.Base.html#523" data-type="Fin (suc n)" class="InductiveConstructor">fzero</a>
<a id="5446" href="Data.Fin.Base.html#5374" data-type="Fin n → Fin (suc n) → Fin n" class="Function">squish</a> <a id="5453" href="Data.Fin.Base.html#523" data-type="Fin (suc n)" class="InductiveConstructor">fzero</a> <a id="5459" class="Symbol">(</a><a id="5460" href="Data.Fin.Base.html#553" data-type="Fin n → Fin (suc n)" class="InductiveConstructor">fsuc</a> <a id="5465" href="Data.Fin.Base.html#5465" class="Bound">j</a><a id="5466" class="Symbol">)</a> <a id="5468" class="Symbol">=</a> <a id="5470" href="Data.Fin.Base.html#5465" class="Bound">j</a>
<a id="5472" href="Data.Fin.Base.html#5374" data-type="Fin n → Fin (suc n) → Fin n" class="Function">squish</a> <a id="5479" class="Symbol">(</a><a id="5480" href="Data.Fin.Base.html#553" data-type="Fin n → Fin (suc n)" class="InductiveConstructor">fsuc</a> <a id="5485" href="Data.Fin.Base.html#5485" class="Bound">i</a><a id="5486" class="Symbol">)</a> <a id="5488" href="Data.Fin.Base.html#523" data-type="Fin (suc n)" class="InductiveConstructor">fzero</a> <a id="5494" class="Symbol">=</a> <a id="5496" href="Data.Fin.Base.html#523" data-type="Fin (suc n)" class="InductiveConstructor">fzero</a>
<a id="5502" href="Data.Fin.Base.html#5374" data-type="Fin n → Fin (suc n) → Fin n" class="Function">squish</a> <a id="5509" class="Symbol">(</a><a id="5510" href="Data.Fin.Base.html#553" data-type="Fin n → Fin (suc n)" class="InductiveConstructor">fsuc</a> <a id="5515" href="Data.Fin.Base.html#5515" class="Bound">i</a><a id="5516" class="Symbol">)</a> <a id="5518" class="Symbol">(</a><a id="5519" href="Data.Fin.Base.html#553" data-type="Fin n → Fin (suc n)" class="InductiveConstructor">fsuc</a> <a id="5524" href="Data.Fin.Base.html#5524" class="Bound">j</a><a id="5525" class="Symbol">)</a> <a id="5527" class="Symbol">=</a> <a id="5529" href="Data.Fin.Base.html#553" data-type="Fin n → Fin (suc n)" class="InductiveConstructor">fsuc</a> <a id="5534" class="Symbol">(</a><a id="5535" href="Data.Fin.Base.html#5374" data-type="Fin n → Fin (suc n) → Fin n" class="Function">squish</a> <a id="5542" href="Data.Fin.Base.html#5515" class="Bound">i</a> <a id="5544" href="Data.Fin.Base.html#5524" class="Bound">j</a><a id="5545" class="Symbol">)</a>

<a id="skip"></a><a id="5548" href="Data.Fin.Base.html#5548" data-type="Fin (suc n) → Fin n → Fin (suc n)" class="Function">skip</a> <a id="5553" class="Symbol">:</a> <a id="5555" class="Symbol">∀</a> <a id="5557" class="Symbol">{</a><a id="5558" href="Data.Fin.Base.html#5558" class="Bound">n</a><a id="5559" class="Symbol">}</a> <a id="5561" class="Symbol">→</a> <a id="5563" href="Data.Fin.Base.html#498" data-type="Nat → Type" class="Datatype">Fin</a> <a id="5567" class="Symbol">(</a><a id="5568" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="5572" href="Data.Fin.Base.html#5558" class="Bound">n</a><a id="5573" class="Symbol">)</a> <a id="5575" class="Symbol">→</a> <a id="5577" href="Data.Fin.Base.html#498" data-type="Nat → Type" class="Datatype">Fin</a> <a id="5581" href="Data.Fin.Base.html#5558" class="Bound">n</a> <a id="5583" class="Symbol">→</a> <a id="5585" href="Data.Fin.Base.html#498" data-type="Nat → Type" class="Datatype">Fin</a> <a id="5589" class="Symbol">(</a><a id="5590" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="5594" href="Data.Fin.Base.html#5558" class="Bound">n</a><a id="5595" class="Symbol">)</a>
<a id="5597" href="Data.Fin.Base.html#5548" data-type="Fin (suc n) → Fin n → Fin (suc n)" class="Function">skip</a> <a id="5602" href="Data.Fin.Base.html#523" data-type="Fin (suc n)" class="InductiveConstructor">fzero</a> <a id="5608" href="Data.Fin.Base.html#5608" class="Bound">j</a> <a id="5610" class="Symbol">=</a> <a id="5612" href="Data.Fin.Base.html#553" data-type="Fin n → Fin (suc n)" class="InductiveConstructor">fsuc</a> <a id="5617" href="Data.Fin.Base.html#5608" class="Bound">j</a>
<a id="5619" href="Data.Fin.Base.html#5548" data-type="Fin (suc n) → Fin n → Fin (suc n)" class="Function">skip</a> <a id="5624" class="Symbol">(</a><a id="5625" href="Data.Fin.Base.html#553" data-type="Fin n → Fin (suc n)" class="InductiveConstructor">fsuc</a> <a id="5630" href="Data.Fin.Base.html#5630" class="Bound">i</a><a id="5631" class="Symbol">)</a> <a id="5633" href="Data.Fin.Base.html#523" data-type="Fin (suc n)" class="InductiveConstructor">fzero</a> <a id="5639" class="Symbol">=</a> <a id="5641" href="Data.Fin.Base.html#523" data-type="Fin (suc n)" class="InductiveConstructor">fzero</a>
<a id="5647" href="Data.Fin.Base.html#5548" data-type="Fin (suc n) → Fin n → Fin (suc n)" class="Function">skip</a> <a id="5652" class="Symbol">(</a><a id="5653" href="Data.Fin.Base.html#553" data-type="Fin n → Fin (suc n)" class="InductiveConstructor">fsuc</a> <a id="5658" href="Data.Fin.Base.html#5658" class="Bound">i</a><a id="5659" class="Symbol">)</a> <a id="5661" class="Symbol">(</a><a id="5662" href="Data.Fin.Base.html#553" data-type="Fin n → Fin (suc n)" class="InductiveConstructor">fsuc</a> <a id="5667" href="Data.Fin.Base.html#5667" class="Bound">j</a><a id="5668" class="Symbol">)</a> <a id="5670" class="Symbol">=</a> <a id="5672" href="Data.Fin.Base.html#553" data-type="Fin n → Fin (suc n)" class="InductiveConstructor">fsuc</a> <a id="5677" class="Symbol">(</a><a id="5678" href="Data.Fin.Base.html#5548" data-type="Fin (suc n) → Fin n → Fin (suc n)" class="Function">skip</a> <a id="5683" href="Data.Fin.Base.html#5658" class="Bound">i</a> <a id="5685" href="Data.Fin.Base.html#5667" class="Bound">j</a><a id="5686" class="Symbol">)</a>
</pre>
<h2 id="as-a-subset"><a href="#as-a-subset" class="header-link">As a
subset<span class="header-link-emoji">🔗</span></a></h2>
<p>While
<span class="Agda"><a href="Data.Fin.Base.html#498" class="Datatype">Fin</a></span>
is very conveniently defined as an indexed family of types, it can also
be defined as a subset of the natural numbers: Namely, the finite
ordinal
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span></span></span></span>
is the same type as as
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>x</mi><mo>:</mo><mi>x</mi><mo>&lt;</mo><mi>n</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{ x : x &lt; n \}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">}</span></span></span></span>.</span>
This makes sense! Any set with
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>
elements is equivalent to any other set with
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>
elements, and a very canonical choice is the first
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>
values of
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">\bb{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span></span></span></span>.</span></p>
<pre class="Agda"><a id="ℕ&lt;"></a><a id="6090" href="Data.Fin.Base.html#6090" data-type="Nat → Type" class="Function">ℕ&lt;</a> <a id="6093" class="Symbol">:</a> <a id="6095" href="Agda.Builtin.Nat.html#177" data-type="Type" class="Datatype">Nat</a> <a id="6099" class="Symbol">→</a> <a id="6101" href="1Lab.Type.html#391" class="Primitive">Type</a>
<a id="6106" href="Data.Fin.Base.html#6090" data-type="Nat → Type" class="Function">ℕ&lt;</a> <a id="6109" href="Data.Fin.Base.html#6109" class="Bound">x</a> <a id="6111" class="Symbol">=</a> <a id="6113" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">Σ[</a> <a id="6116" href="Data.Fin.Base.html#6116" class="Bound">n</a> <a id="6118" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">∈</a> <a id="6120" href="Agda.Builtin.Nat.html#177" data-type="Type" class="Datatype">Nat</a> <a id="6124" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">]</a> <a id="6126" class="Symbol">(</a><a id="6127" href="Data.Fin.Base.html#6116" class="Bound">n</a> <a id="6129" href="Data.Nat.Base.html#4034" data-type="Nat → Nat → Type" class="Function Operator">Nat.&lt;</a> <a id="6135" href="Data.Fin.Base.html#6109" class="Bound">x</a><a id="6136" class="Symbol">)</a>

<a id="from-ℕ&lt;"></a><a id="6139" href="Data.Fin.Base.html#6139" data-type="ℕ&lt; n → Fin n" class="Function">from-ℕ&lt;</a> <a id="6147" class="Symbol">:</a> <a id="6149" class="Symbol">∀</a> <a id="6151" class="Symbol">{</a><a id="6152" href="Data.Fin.Base.html#6152" class="Bound">n</a><a id="6153" class="Symbol">}</a> <a id="6155" class="Symbol">→</a> <a id="6157" href="Data.Fin.Base.html#6090" data-type="Nat → Type" class="Function">ℕ&lt;</a> <a id="6160" href="Data.Fin.Base.html#6152" class="Bound">n</a> <a id="6162" class="Symbol">→</a> <a id="6164" href="Data.Fin.Base.html#498" data-type="Nat → Type" class="Datatype">Fin</a> <a id="6168" href="Data.Fin.Base.html#6152" class="Bound">n</a>
<a id="6170" href="Data.Fin.Base.html#6139" data-type="ℕ&lt; n → Fin n" class="Function">from-ℕ&lt;</a> <a id="6178" class="Symbol">{</a><a id="6179" class="Argument">n</a> <a id="6181" class="Symbol">=</a> <a id="6183" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="6187" href="Data.Fin.Base.html#6187" class="Bound">n</a><a id="6188" class="Symbol">}</a> <a id="6190" class="Symbol">(</a><a id="6191" href="Agda.Builtin.Nat.html#195" data-type="Nat" class="InductiveConstructor">zero</a> <a id="6196" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="6198" href="Data.Fin.Base.html#6198" class="Bound">q</a><a id="6199" class="Symbol">)</a> <a id="6201" class="Symbol">=</a> <a id="6203" href="Data.Fin.Base.html#523" data-type="Fin (suc n)" class="InductiveConstructor">fzero</a>
<a id="6209" href="Data.Fin.Base.html#6139" data-type="ℕ&lt; n → Fin n" class="Function">from-ℕ&lt;</a> <a id="6217" class="Symbol">{</a><a id="6218" class="Argument">n</a> <a id="6220" class="Symbol">=</a> <a id="6222" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="6226" href="Data.Fin.Base.html#6226" class="Bound">n</a><a id="6227" class="Symbol">}</a> <a id="6229" class="Symbol">(</a><a id="6230" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="6234" href="Data.Fin.Base.html#6234" class="Bound">p</a> <a id="6236" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="6238" href="Data.Fin.Base.html#6238" class="Bound">q</a><a id="6239" class="Symbol">)</a> <a id="6241" class="Symbol">=</a> <a id="6243" href="Data.Fin.Base.html#553" data-type="Fin n → Fin (suc n)" class="InductiveConstructor">fsuc</a> <a id="6248" class="Symbol">(</a><a id="6249" href="Data.Fin.Base.html#6139" data-type="ℕ&lt; n → Fin n" class="Function">from-ℕ&lt;</a> <a id="6257" class="Symbol">(</a><a id="6258" href="Data.Fin.Base.html#6234" class="Bound">p</a> <a id="6260" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="6262" href="Data.Fin.Base.html#6238" class="Bound">q</a><a id="6263" class="Symbol">))</a>

<a id="to-ℕ&lt;"></a><a id="6267" href="Data.Fin.Base.html#6267" data-type="Fin n → ℕ&lt; n" class="Function">to-ℕ&lt;</a> <a id="6273" class="Symbol">:</a> <a id="6275" class="Symbol">∀</a> <a id="6277" class="Symbol">{</a><a id="6278" href="Data.Fin.Base.html#6278" class="Bound">n</a><a id="6279" class="Symbol">}</a> <a id="6281" class="Symbol">→</a> <a id="6283" href="Data.Fin.Base.html#498" data-type="Nat → Type" class="Datatype">Fin</a> <a id="6287" href="Data.Fin.Base.html#6278" class="Bound">n</a> <a id="6289" class="Symbol">→</a> <a id="6291" href="Data.Fin.Base.html#6090" data-type="Nat → Type" class="Function">ℕ&lt;</a> <a id="6294" href="Data.Fin.Base.html#6278" class="Bound">n</a>
<a id="6296" href="Data.Fin.Base.html#6267" data-type="Fin n → ℕ&lt; n" class="Function">to-ℕ&lt;</a> <a id="6302" href="Data.Fin.Base.html#6302" class="Bound">x</a> <a id="6304" class="Symbol">=</a> <a id="6306" href="Data.Fin.Base.html#836" data-type="Fin n → Nat" class="Function">to-nat</a> <a id="6313" href="Data.Fin.Base.html#6302" class="Bound">x</a> <a id="6315" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="6317" href="Data.Fin.Base.html#6329" data-type="Fin n → (x : Fin n) → suc (to-nat x) ≤ n" class="Function">p</a> <a id="6319" href="Data.Fin.Base.html#6302" class="Bound">x</a> <a id="6321" class="Keyword">where</a>
  <a id="6329" href="Data.Fin.Base.html#6329" data-type="Fin n → (x : Fin n) → suc (to-nat x) ≤ n" class="Function">p</a> <a id="6331" class="Symbol">:</a> <a id="6333" class="Symbol">∀</a> <a id="6335" class="Symbol">{</a><a id="6336" href="Data.Fin.Base.html#6336" class="Bound">n</a><a id="6337" class="Symbol">}</a> <a id="6339" class="Symbol">(</a><a id="6340" href="Data.Fin.Base.html#6340" class="Bound">x</a> <a id="6342" class="Symbol">:</a> <a id="6344" href="Data.Fin.Base.html#498" data-type="Nat → Type" class="Datatype">Fin</a> <a id="6348" href="Data.Fin.Base.html#6336" class="Bound">n</a><a id="6349" class="Symbol">)</a> <a id="6351" class="Symbol">→</a> <a id="6353" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="6357" class="Symbol">(</a><a id="6358" href="Data.Fin.Base.html#836" data-type="Fin n → Nat" class="Function">to-nat</a> <a id="6365" href="Data.Fin.Base.html#6340" class="Bound">x</a><a id="6366" class="Symbol">)</a> <a id="6368" href="Data.Nat.Base.html#3817" data-type="Nat → Nat → Type" class="Function Operator">Nat.≤</a> <a id="6374" href="Data.Fin.Base.html#6336" class="Bound">n</a>
  <a id="6378" href="Data.Fin.Base.html#6329" data-type="Fin n → (x : Fin n) → suc (to-nat x) ≤ n" class="Function">p</a> <a id="6380" class="Symbol">{</a><a id="6381" class="Argument">n</a> <a id="6383" class="Symbol">=</a> <a id="6385" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="6389" href="Data.Fin.Base.html#6389" class="Bound">n</a><a id="6390" class="Symbol">}</a> <a id="6392" href="Data.Fin.Base.html#523" data-type="Fin (suc n)" class="InductiveConstructor">fzero</a> <a id="6398" class="Symbol">=</a> <a id="6400" href="Data.Nat.Base.html#4308" data-type="(x : Nat) → zero ≤ x" class="Function">Nat.0≤x</a> <a id="6408" href="Data.Fin.Base.html#6389" class="Bound">n</a>
  <a id="6412" href="Data.Fin.Base.html#6329" data-type="Fin n → (x : Fin n) → suc (to-nat x) ≤ n" class="Function">p</a> <a id="6414" class="Symbol">{</a><a id="6415" class="Argument">n</a> <a id="6417" class="Symbol">=</a> <a id="6419" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="6423" href="Data.Fin.Base.html#6423" class="Bound">n</a><a id="6424" class="Symbol">}</a> <a id="6426" class="Symbol">(</a><a id="6427" href="Data.Fin.Base.html#553" data-type="Fin n → Fin (suc n)" class="InductiveConstructor">fsuc</a> <a id="6432" href="Data.Fin.Base.html#6432" class="Bound">x</a><a id="6433" class="Symbol">)</a> <a id="6435" class="Symbol">=</a> <a id="6437" href="Data.Fin.Base.html#6329" data-type="Fin n → (x : Fin n) → suc (to-nat x) ≤ n" class="Function">p</a> <a id="6439" href="Data.Fin.Base.html#6432" class="Bound">x</a>

<a id="to-from-ℕ&lt;"></a><a id="6442" href="Data.Fin.Base.html#6442" data-type="(x : ℕ&lt; n) → to-ℕ&lt; (from-ℕ&lt; x) ≡ x" class="Function">to-from-ℕ&lt;</a> <a id="6453" class="Symbol">:</a> <a id="6455" class="Symbol">∀</a> <a id="6457" class="Symbol">{</a><a id="6458" href="Data.Fin.Base.html#6458" class="Bound">n</a><a id="6459" class="Symbol">}</a> <a id="6461" class="Symbol">(</a><a id="6462" href="Data.Fin.Base.html#6462" class="Bound">x</a> <a id="6464" class="Symbol">:</a> <a id="6466" href="Data.Fin.Base.html#6090" data-type="Nat → Type" class="Function">ℕ&lt;</a> <a id="6469" href="Data.Fin.Base.html#6458" class="Bound">n</a><a id="6470" class="Symbol">)</a> <a id="6472" class="Symbol">→</a> <a id="6474" href="Data.Fin.Base.html#6267" data-type="Fin n → ℕ&lt; n" class="Function">to-ℕ&lt;</a> <a id="6480" class="Symbol">{</a><a id="6481" class="Argument">n</a> <a id="6483" class="Symbol">=</a> <a id="6485" href="Data.Fin.Base.html#6458" class="Bound">n</a><a id="6486" class="Symbol">}</a> <a id="6488" class="Symbol">(</a><a id="6489" href="Data.Fin.Base.html#6139" data-type="ℕ&lt; n → Fin n" class="Function">from-ℕ&lt;</a> <a id="6497" href="Data.Fin.Base.html#6462" class="Bound">x</a><a id="6498" class="Symbol">)</a> <a id="6500" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="6502" href="Data.Fin.Base.html#6462" class="Bound">x</a>
<a id="6504" href="Data.Fin.Base.html#6442" data-type="(x : ℕ&lt; n) → to-ℕ&lt; (from-ℕ&lt; x) ≡ x" class="Function">to-from-ℕ&lt;</a> <a id="6515" class="Symbol">{</a><a id="6516" class="Argument">n</a> <a id="6518" class="Symbol">=</a> <a id="6520" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="6524" href="Data.Fin.Base.html#6524" class="Bound">n</a><a id="6525" class="Symbol">}</a> <a id="6527" href="Data.Fin.Base.html#6527" class="Bound">x</a> <a id="6529" class="Symbol">=</a> <a id="6531" href="1Lab.Type.Sigma.html#5139" data-type="((x : A) → is-prop (B₁ x)) → x .fst ≡ y .fst → x ≡ y" class="Function">Σ-prop-path</a> <a id="6543" class="Symbol">(λ</a> <a id="6546" href="Data.Fin.Base.html#6546" class="Bound">k</a> <a id="6548" class="Symbol">→</a> <a id="6550" href="Data.Nat.Base.html#4913" data-type="(x y : Nat) → is-prop (x ≤ y)" class="Function">Nat.≤-prop</a> <a id="6561" href="Data.Fin.Base.html#6546" class="Bound">k</a> <a id="6563" href="Data.Fin.Base.html#6524" class="Bound">n</a><a id="6564" class="Symbol">)</a> <a id="6566" class="Symbol">(</a><a id="6567" href="Data.Fin.Base.html#6600" data-type="(n : Nat) → ℕ&lt; (suc n) → (x : ℕ&lt; n₁) → to-nat (from-ℕ&lt; x) ≡ x .fst" class="Function">to-from-ℕ</a> <a id="6577" class="Symbol">{</a><a id="6578" class="Argument">n</a> <a id="6580" class="Symbol">=</a> <a id="6582" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="6586" href="Data.Fin.Base.html#6524" class="Bound">n</a><a id="6587" class="Symbol">}</a> <a id="6589" href="Data.Fin.Base.html#6527" class="Bound">x</a><a id="6590" class="Symbol">)</a> <a id="6592" class="Keyword">where</a>
  <a id="6600" href="Data.Fin.Base.html#6600" data-type="(n : Nat) → ℕ&lt; (suc n) → (x : ℕ&lt; n₁) → to-nat (from-ℕ&lt; x) ≡ x .fst" class="Function">to-from-ℕ</a> <a id="6610" class="Symbol">:</a> <a id="6612" class="Symbol">∀</a> <a id="6614" class="Symbol">{</a><a id="6615" href="Data.Fin.Base.html#6615" class="Bound">n</a><a id="6616" class="Symbol">}</a> <a id="6618" href="Data.Fin.Base.html#6618" class="Bound">x</a> <a id="6620" class="Symbol">→</a> <a id="6622" href="Data.Fin.Base.html#836" data-type="Fin n → Nat" class="Function">to-nat</a> <a id="6629" class="Symbol">{</a><a id="6630" class="Argument">n</a> <a id="6632" class="Symbol">=</a> <a id="6634" href="Data.Fin.Base.html#6615" class="Bound">n</a><a id="6635" class="Symbol">}</a> <a id="6637" class="Symbol">(</a><a id="6638" href="Data.Fin.Base.html#6139" data-type="ℕ&lt; n → Fin n" class="Function">from-ℕ&lt;</a> <a id="6646" href="Data.Fin.Base.html#6618" class="Bound">x</a><a id="6647" class="Symbol">)</a> <a id="6649" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="6651" href="Data.Fin.Base.html#6618" class="Bound">x</a> <a id="6653" class="Symbol">.</a><a id="6654" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a>
  <a id="6660" href="Data.Fin.Base.html#6600" data-type="(n : Nat) → ℕ&lt; (suc n) → (x : ℕ&lt; n₁) → to-nat (from-ℕ&lt; x) ≡ x .fst" class="Function">to-from-ℕ</a> <a id="6670" class="Symbol">{</a><a id="6671" class="Argument">n</a> <a id="6673" class="Symbol">=</a> <a id="6675" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="6679" href="Data.Fin.Base.html#6679" class="Bound">n</a><a id="6680" class="Symbol">}</a> <a id="6682" class="Symbol">(</a><a id="6683" href="Agda.Builtin.Nat.html#195" data-type="Nat" class="InductiveConstructor">zero</a> <a id="6688" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="6690" href="Data.Fin.Base.html#6690" class="Bound">p</a><a id="6691" class="Symbol">)</a> <a id="6693" class="Symbol">=</a> <a id="6695" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
  <a id="6702" href="Data.Fin.Base.html#6600" data-type="(n : Nat) → ℕ&lt; (suc n) → (x : ℕ&lt; n₁) → to-nat (from-ℕ&lt; x) ≡ x .fst" class="Function">to-from-ℕ</a> <a id="6712" class="Symbol">{</a><a id="6713" class="Argument">n</a> <a id="6715" class="Symbol">=</a> <a id="6717" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="6721" href="Data.Fin.Base.html#6721" class="Bound">n</a><a id="6722" class="Symbol">}</a> <a id="6724" class="Symbol">(</a><a id="6725" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="6729" href="Data.Fin.Base.html#6729" class="Bound">x</a> <a id="6731" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="6733" href="Data.Fin.Base.html#6733" class="Bound">p</a><a id="6734" class="Symbol">)</a> <a id="6736" class="Symbol">=</a> <a id="6738" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="6741" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="6745" class="Symbol">(</a><a id="6746" href="Data.Fin.Base.html#6600" data-type="(n : Nat) → ℕ&lt; (suc n) → (x : ℕ&lt; n₁) → to-nat (from-ℕ&lt; x) ≡ x .fst" class="Function">to-from-ℕ</a> <a id="6756" class="Symbol">{</a><a id="6757" class="Argument">n</a> <a id="6759" class="Symbol">=</a> <a id="6761" href="Data.Fin.Base.html#6721" class="Bound">n</a><a id="6762" class="Symbol">}</a> <a id="6764" class="Symbol">(</a><a id="6765" href="Data.Fin.Base.html#6729" class="Bound">x</a> <a id="6767" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="6769" href="Data.Fin.Base.html#6733" class="Bound">p</a><a id="6770" class="Symbol">))</a>

<a id="from-to-ℕ&lt;"></a><a id="6774" href="Data.Fin.Base.html#6774" data-type="(x : Fin n) → from-ℕ&lt; (to-ℕ&lt; x) ≡ x" class="Function">from-to-ℕ&lt;</a> <a id="6785" class="Symbol">:</a> <a id="6787" class="Symbol">∀</a> <a id="6789" class="Symbol">{</a><a id="6790" href="Data.Fin.Base.html#6790" class="Bound">n</a><a id="6791" class="Symbol">}</a> <a id="6793" class="Symbol">(</a><a id="6794" href="Data.Fin.Base.html#6794" class="Bound">x</a> <a id="6796" class="Symbol">:</a> <a id="6798" href="Data.Fin.Base.html#498" data-type="Nat → Type" class="Datatype">Fin</a> <a id="6802" href="Data.Fin.Base.html#6790" class="Bound">n</a><a id="6803" class="Symbol">)</a> <a id="6805" class="Symbol">→</a> <a id="6807" href="Data.Fin.Base.html#6139" data-type="ℕ&lt; n → Fin n" class="Function">from-ℕ&lt;</a> <a id="6815" class="Symbol">(</a><a id="6816" href="Data.Fin.Base.html#6267" data-type="Fin n → ℕ&lt; n" class="Function">to-ℕ&lt;</a> <a id="6822" href="Data.Fin.Base.html#6794" class="Bound">x</a><a id="6823" class="Symbol">)</a> <a id="6825" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="6827" href="Data.Fin.Base.html#6794" class="Bound">x</a>
<a id="6829" href="Data.Fin.Base.html#6774" data-type="(x : Fin n) → from-ℕ&lt; (to-ℕ&lt; x) ≡ x" class="Function">from-to-ℕ&lt;</a> <a id="6840" href="Data.Fin.Base.html#523" data-type="Fin (suc n)" class="InductiveConstructor">fzero</a> <a id="6846" class="Symbol">=</a> <a id="6848" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
<a id="6853" href="Data.Fin.Base.html#6774" data-type="(x : Fin n) → from-ℕ&lt; (to-ℕ&lt; x) ≡ x" class="Function">from-to-ℕ&lt;</a> <a id="6864" class="Symbol">(</a><a id="6865" href="Data.Fin.Base.html#553" data-type="Fin n → Fin (suc n)" class="InductiveConstructor">fsuc</a> <a id="6870" href="Data.Fin.Base.html#6870" class="Bound">x</a><a id="6871" class="Symbol">)</a> <a id="6873" class="Symbol">=</a> <a id="6875" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="6878" href="Data.Fin.Base.html#553" data-type="Fin n → Fin (suc n)" class="InductiveConstructor">fsuc</a> <a id="6883" class="Symbol">(</a><a id="6884" href="Data.Fin.Base.html#6774" data-type="(x : Fin n) → from-ℕ&lt; (to-ℕ&lt; x) ≡ x" class="Function">from-to-ℕ&lt;</a> <a id="6895" href="Data.Fin.Base.html#6870" class="Bound">x</a><a id="6896" class="Symbol">)</a>

<a id="Fin≃ℕ&lt;"></a><a id="6899" href="Data.Fin.Base.html#6899" data-type="Fin n ≃ ℕ&lt; n" class="Function">Fin≃ℕ&lt;</a> <a id="6906" class="Symbol">:</a> <a id="6908" class="Symbol">∀</a> <a id="6910" class="Symbol">{</a><a id="6911" href="Data.Fin.Base.html#6911" class="Bound">n</a><a id="6912" class="Symbol">}</a> <a id="6914" class="Symbol">→</a> <a id="6916" href="Data.Fin.Base.html#498" data-type="Nat → Type" class="Datatype">Fin</a> <a id="6920" href="Data.Fin.Base.html#6911" class="Bound">n</a> <a id="6922" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="6924" href="Data.Fin.Base.html#6090" data-type="Nat → Type" class="Function">ℕ&lt;</a> <a id="6927" href="Data.Fin.Base.html#6911" class="Bound">n</a>
<a id="6929" href="Data.Fin.Base.html#6899" data-type="Fin n ≃ ℕ&lt; n" class="Function">Fin≃ℕ&lt;</a> <a id="6936" class="Symbol">{</a><a id="6937" href="Data.Fin.Base.html#6937" class="Bound">n</a><a id="6938" class="Symbol">}</a> <a id="6940" class="Symbol">=</a> <a id="6942" href="Data.Fin.Base.html#6267" data-type="Fin n → ℕ&lt; n" class="Function">to-ℕ&lt;</a> <a id="6948" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="6950" href="1Lab.Equiv.html#19815" data-type="(i : is-iso f) → is-equiv f" class="Function">is-iso→is-equiv</a> <a id="6966" class="Symbol">(</a><a id="6967" href="1Lab.Equiv.html#6116" data-type="(inv₁ : B₁ → A) (rinv₁ : is-right-inverse inv₁ f)
(linv₁ : is-left-inverse inv₁ f) →
is-iso f" class="InductiveConstructor">iso</a> <a id="6971" href="Data.Fin.Base.html#6139" data-type="ℕ&lt; n → Fin n" class="Function">from-ℕ&lt;</a> <a id="6979" class="Symbol">(</a><a id="6980" href="Data.Fin.Base.html#6442" data-type="(x : ℕ&lt; n) → to-ℕ&lt; (from-ℕ&lt; x) ≡ x" class="Function">to-from-ℕ&lt;</a> <a id="6991" class="Symbol">{</a><a id="6992" href="Data.Fin.Base.html#6937" class="Bound">n</a><a id="6993" class="Symbol">})</a> <a id="6996" href="Data.Fin.Base.html#6774" data-type="(x : Fin n) → from-ℕ&lt; (to-ℕ&lt; x) ≡ x" class="Function">from-to-ℕ&lt;</a><a id="7006" class="Symbol">)</a>
</pre>
<h2 id="arithmetic"><a href="#arithmetic" class="header-link">Arithmetic<span class="header-link-emoji">🔗</span></a></h2>
<pre class="Agda"><a id="weaken-≤"></a><a id="7036" href="Data.Fin.Base.html#7036" data-type="m ≤ n → Fin m → Fin n" class="Function">weaken-≤</a> <a id="7045" class="Symbol">:</a> <a id="7047" class="Symbol">∀</a> <a id="7049" class="Symbol">{</a><a id="7050" href="Data.Fin.Base.html#7050" class="Bound">m</a> <a id="7052" href="Data.Fin.Base.html#7052" class="Bound">n</a><a id="7053" class="Symbol">}</a> <a id="7055" class="Symbol">→</a> <a id="7057" href="Data.Fin.Base.html#7050" class="Bound">m</a> <a id="7059" href="Data.Nat.Base.html#3817" data-type="Nat → Nat → Type" class="Function Operator">Nat.≤</a> <a id="7065" href="Data.Fin.Base.html#7052" class="Bound">n</a> <a id="7067" class="Symbol">→</a> <a id="7069" href="Data.Fin.Base.html#498" data-type="Nat → Type" class="Datatype">Fin</a> <a id="7073" href="Data.Fin.Base.html#7050" class="Bound">m</a> <a id="7075" class="Symbol">→</a> <a id="7077" href="Data.Fin.Base.html#498" data-type="Nat → Type" class="Datatype">Fin</a> <a id="7081" href="Data.Fin.Base.html#7052" class="Bound">n</a>
<a id="7083" href="Data.Fin.Base.html#7036" data-type="m ≤ n → Fin m → Fin n" class="Function">weaken-≤</a> <a id="7092" class="Symbol">{</a><a id="7093" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="7097" href="Data.Fin.Base.html#7097" class="Bound">m</a><a id="7098" class="Symbol">}</a> <a id="7100" class="Symbol">{</a><a id="7101" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="7105" href="Data.Fin.Base.html#7105" class="Bound">n</a><a id="7106" class="Symbol">}</a> <a id="7108" href="Data.Fin.Base.html#7108" class="Bound">m≤n</a> <a id="7112" href="Data.Fin.Base.html#523" data-type="Fin (suc n)" class="InductiveConstructor">fzero</a> <a id="7118" class="Symbol">=</a> <a id="7120" href="Data.Fin.Base.html#523" data-type="Fin (suc n)" class="InductiveConstructor">fzero</a>
<a id="7126" href="Data.Fin.Base.html#7036" data-type="m ≤ n → Fin m → Fin n" class="Function">weaken-≤</a> <a id="7135" class="Symbol">{</a><a id="7136" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="7140" href="Data.Fin.Base.html#7140" class="Bound">m</a><a id="7141" class="Symbol">}</a> <a id="7143" class="Symbol">{</a><a id="7144" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="7148" href="Data.Fin.Base.html#7148" class="Bound">n</a><a id="7149" class="Symbol">}</a> <a id="7151" href="Data.Fin.Base.html#7151" class="Bound">m≤n</a> <a id="7155" class="Symbol">(</a><a id="7156" href="Data.Fin.Base.html#553" data-type="Fin n → Fin (suc n)" class="InductiveConstructor">fsuc</a> <a id="7161" href="Data.Fin.Base.html#7161" class="Bound">i</a><a id="7162" class="Symbol">)</a> <a id="7164" class="Symbol">=</a> <a id="7166" href="Data.Fin.Base.html#553" data-type="Fin n → Fin (suc n)" class="InductiveConstructor">fsuc</a> <a id="7171" class="Symbol">(</a><a id="7172" href="Data.Fin.Base.html#7036" data-type="m ≤ n → Fin m → Fin n" class="Function">weaken-≤</a> <a id="7181" href="Data.Fin.Base.html#7151" class="Bound">m≤n</a> <a id="7185" href="Data.Fin.Base.html#7161" class="Bound">i</a><a id="7186" class="Symbol">)</a>

<a id="fshift"></a><a id="7189" href="Data.Fin.Base.html#7189" data-type="(m : Nat) → Fin n → Fin (m + n)" class="Function">fshift</a> <a id="7196" class="Symbol">:</a> <a id="7198" class="Symbol">∀</a> <a id="7200" class="Symbol">{</a><a id="7201" href="Data.Fin.Base.html#7201" class="Bound">n</a><a id="7202" class="Symbol">}</a> <a id="7204" class="Symbol">(</a><a id="7205" href="Data.Fin.Base.html#7205" class="Bound">m</a> <a id="7207" class="Symbol">:</a> <a id="7209" href="Agda.Builtin.Nat.html#177" data-type="Type" class="Datatype">Nat</a><a id="7212" class="Symbol">)</a> <a id="7214" class="Symbol">→</a> <a id="7216" href="Data.Fin.Base.html#498" data-type="Nat → Type" class="Datatype">Fin</a> <a id="7220" href="Data.Fin.Base.html#7201" class="Bound">n</a> <a id="7222" class="Symbol">→</a> <a id="7224" href="Data.Fin.Base.html#498" data-type="Nat → Type" class="Datatype">Fin</a> <a id="7228" class="Symbol">(</a><a id="7229" href="Data.Fin.Base.html#7205" class="Bound">m</a> <a id="7231" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="7233" href="Data.Fin.Base.html#7201" class="Bound">n</a><a id="7234" class="Symbol">)</a>
<a id="7236" href="Data.Fin.Base.html#7189" data-type="(m : Nat) → Fin n → Fin (m + n)" class="Function">fshift</a> <a id="7243" href="Agda.Builtin.Nat.html#195" data-type="Nat" class="InductiveConstructor">zero</a> <a id="7248" href="Data.Fin.Base.html#7248" class="Bound">i</a> <a id="7250" class="Symbol">=</a> <a id="7252" href="Data.Fin.Base.html#7248" class="Bound">i</a>
<a id="7254" href="Data.Fin.Base.html#7189" data-type="(m : Nat) → Fin n → Fin (m + n)" class="Function">fshift</a> <a id="7261" class="Symbol">(</a><a id="7262" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="7266" href="Data.Fin.Base.html#7266" class="Bound">m</a><a id="7267" class="Symbol">)</a> <a id="7269" href="Data.Fin.Base.html#7269" class="Bound">i</a> <a id="7271" class="Symbol">=</a> <a id="7273" href="Data.Fin.Base.html#553" data-type="Fin n → Fin (suc n)" class="InductiveConstructor">fsuc</a> <a id="7278" class="Symbol">(</a><a id="7279" href="Data.Fin.Base.html#7189" data-type="(m : Nat) → Fin n → Fin (m + n)" class="Function">fshift</a> <a id="7286" href="Data.Fin.Base.html#7266" class="Bound">m</a> <a id="7288" href="Data.Fin.Base.html#7269" class="Bound">i</a><a id="7289" class="Symbol">)</a>

<a id="opposite"></a><a id="7292" href="Data.Fin.Base.html#7292" data-type="Fin n → Fin n" class="Function">opposite</a> <a id="7301" class="Symbol">:</a> <a id="7303" class="Symbol">∀</a> <a id="7305" class="Symbol">{</a><a id="7306" href="Data.Fin.Base.html#7306" class="Bound">n</a><a id="7307" class="Symbol">}</a> <a id="7309" class="Symbol">→</a> <a id="7311" href="Data.Fin.Base.html#498" data-type="Nat → Type" class="Datatype">Fin</a> <a id="7315" href="Data.Fin.Base.html#7306" class="Bound">n</a> <a id="7317" class="Symbol">→</a> <a id="7319" href="Data.Fin.Base.html#498" data-type="Nat → Type" class="Datatype">Fin</a> <a id="7323" href="Data.Fin.Base.html#7306" class="Bound">n</a>
<a id="7325" href="Data.Fin.Base.html#7292" data-type="Fin n → Fin n" class="Function">opposite</a> <a id="7334" class="Symbol">{</a><a id="7335" class="Argument">n</a> <a id="7337" class="Symbol">=</a> <a id="7339" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="7343" href="Data.Fin.Base.html#7343" class="Bound">n</a><a id="7344" class="Symbol">}</a> <a id="7346" href="Data.Fin.Base.html#523" data-type="Fin (suc n)" class="InductiveConstructor">fzero</a> <a id="7352" class="Symbol">=</a> <a id="7354" href="Data.Fin.Base.html#739" data-type="(n : Nat) → Fin (suc n)" class="Function">from-nat</a> <a id="7363" href="Data.Fin.Base.html#7343" class="Bound">n</a>
<a id="7365" href="Data.Fin.Base.html#7292" data-type="Fin n → Fin n" class="Function">opposite</a> <a id="7374" class="Symbol">{</a><a id="7375" class="Argument">n</a> <a id="7377" class="Symbol">=</a> <a id="7379" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="7383" href="Data.Fin.Base.html#7383" class="Bound">n</a><a id="7384" class="Symbol">}</a> <a id="7386" class="Symbol">(</a><a id="7387" href="Data.Fin.Base.html#553" data-type="Fin n → Fin (suc n)" class="InductiveConstructor">fsuc</a> <a id="7392" href="Data.Fin.Base.html#7392" class="Bound">i</a><a id="7393" class="Symbol">)</a> <a id="7395" class="Symbol">=</a> <a id="7397" href="Data.Fin.Base.html#2435" data-type="Fin n → Fin (suc n)" class="Function">weaken</a> <a id="7404" class="Symbol">(</a><a id="7405" href="Data.Fin.Base.html#7292" data-type="Fin n → Fin n" class="Function">opposite</a> <a id="7414" href="Data.Fin.Base.html#7392" class="Bound">i</a><a id="7415" class="Symbol">)</a>
</pre>
  </article>
</div>
</main>
</body>
<style>.equations { display: none !important; }</style></html>
