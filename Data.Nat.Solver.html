<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="keywords" content="Agda,categories,topos" />

  <title>Data.Nat.Solver - 1Lab</title>

  <link rel="stylesheet" href="/css/default.css" />
  <link rel="stylesheet" href="/css/katex.min.css" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Data.Nat.Solver - 1Lab" />
  <meta name="twitter:image" content="https://1lab.dev/static/cube-128x.png" />

  <meta name="og:title" content="Data.Nat.Solver - 1Lab" />
  <meta name="og:image" content="https://1lab.dev/static/cube-128x.png" />
  <meta name="og:site-name" content="1Lab" />
  <meta name="og:type" content="website" />

    <meta name="og:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="twitter:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  
  <script defer src="/main.js"></script>

  <noscript>
    <style>
      body span.reasoning-step .as-written {
        display: inline;
      }

      body span.reasoning-step .alternate {
        display: none;
      }
    </style>
  </noscript>

  <!-- Google font embeds -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;0,800;1,400;1,500;1,600;1,700;1,800&amp;family=Inria+Sans:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&amp;display=swap" rel="stylesheet">
</head>

<body class="text-page">
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <!-- Table of contents (only if the page has a table of contents) -->
    <aside id="toc">
    <div id="toc-container" style="min-width: 10em; font-size: 15pt;">
      <!-- Title for the page -->
      <h3 class="Agda" style="margin-top: 0; margin-bottom: 0; white-space: pre;">
                <a class="Module">Data.Nat.Solver</a>
              </h3>

      <!-- Cube logo -->
      <a id="logo" href="/">
        <img alt="1Lab" src="/static/cube-72x.png" style="display: block; margin-bottom: 1em; margin: auto;" width="32px" height="32px" />
      </a>

      <!-- Actual table of contents (separated from the rest by
      horizontal rules) -->
      <hr />
      <ul>
      <li><a href="#the-nat-solver"><a href="#the-nat-solver" class="header-link">The
      Nat Solver<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#horner-normal-forms"><a href="#horner-normal-forms" class="header-link">Horner
      Normal Forms<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#operations-on-horner-normal-forms"><a href="#operations-on-horner-normal-forms" class="header-link">Operations
      on Horner Normal
      Forms<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#evaluation-of-horner-normal-forms"><a href="#evaluation-of-horner-normal-forms" class="header-link">Evaluation
      of Horner Normal
      Forms<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#soundness-of-the-operations"><a href="#soundness-of-the-operations" class="header-link">Soundness
      of the
      Operations<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      <li><a href="#evaluation-into-polynomials"><a href="#evaluation-into-polynomials" class="header-link">Evaluation
      into Polynomials<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#soundness-of-evaluation"><a href="#soundness-of-evaluation" class="header-link">Soundness
      of
      Evaluation<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      <li><a href="#reflection"><a href="#reflection" class="header-link">Reflection<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#the-actual-macros"><a href="#the-actual-macros" class="header-link">The
      Actual
      Macros<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      </ul></li>
      <li><a href="#examples"><a href="#examples" class="header-link">Examples<span class="header-link-emoji">🔗</span></a></a></li>
      </ul>
      <hr />

      <!-- Sidebar controls -->
      <div style="display: flex; gap: 0.25em; flex-flow: row wrap;">
        <!-- Sidebar equations control -->
        <span class="equations" style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-eqns" type="checkbox" class="equations" id="sidebar-eqns">
          <label for="sidebar-eqns">Equations</label>
        </span>

        <!-- Sidebar fonts control -->
        <span style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-font" type="checkbox" id="toggle-fonts">
          <label for="toggle-fonts">Serif Font</label>
        </span>

        <!-- Sidebar footnotes control -->
        <span class="inline-footnotes" style="display: none; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-fns" type="checkbox" class="inline-footnotes" id="sidebar-fns">
          <label for="sidebar-fns">Inline Footnotes</label>
        </span>
      </div>

      <hr />

      <!-- Navbar navigation (lol) -->
      <div id="return" style="white-space: nowrap;">
        <div class="search-form search-form-proxy" role="form">
          <input id="search-box-proxy" type_="text" placeholder="Search..." autocomplete="off" tabindex="0"></input>
        </div>

              <a href="/">back to index</a> <br />
              <a href="all-pages.html">view all pages</a> <br />
        <a href="https://github.com/plt-amy/cubical-1lab/blob/0314252b340347699f8ef2dd771f1e57f7458b23/src/Data/Nat/Solver.lagda.md">link to source</a> <br />
                <hr /> <div class="author-list">Written by Amélia Liao and Reed Mullanix</div> <br />
              </div>
    </div>
  </aside>
  
  <article>
    <!-- Article navigation (narrow screens only) -->
    <div class="narrow-only" id="article-nav">
      <!-- Index return anchor (only if the page is not the index) -->
            <div id="return">
        <a href="/">back to index</a>
      </div>
      
      <!-- Navbar equations control -->
      <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-eqns" type="checkbox" class="equations" id="navbar-eqns">
        <label for="navbar-eqns">Equations</label>
      </span>

      <!-- Navbar footnotes control -->
      <span class="inline-footnotes" style="display: none; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-fns" type="checkbox" class="inline-footnotes" id="navbar-fns">
        <label for="navbar-fns">Inline Footnotes</label>
      </span>
    </div>

<pre class="Agda"><a id="9" class="Keyword">module</a> <a id="16" href="Data.Nat.Solver.html" class="Module">Data.Nat.Solver</a> <a id="32" class="Keyword">where</a>

<a id="39" class="Keyword">open</a> <a id="44" class="Keyword">import</a> <a id="51" href="1Lab.Type.html" class="Module">1Lab.Type</a>
<a id="61" class="Keyword">open</a> <a id="66" class="Keyword">import</a> <a id="73" href="1Lab.Path.html" class="Module">1Lab.Path</a>
<a id="83" class="Keyword">open</a> <a id="88" class="Keyword">import</a> <a id="95" href="Data.Nat.Base.html" class="Module">Data.Nat.Base</a>
<a id="109" class="Keyword">open</a> <a id="114" class="Keyword">import</a> <a id="121" href="Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a>
<a id="141" class="Keyword">open</a> <a id="146" class="Keyword">import</a> <a id="153" href="Data.Fin.Base.html" class="Module">Data.Fin.Base</a>
<a id="167" class="Keyword">open</a> <a id="172" class="Keyword">import</a> <a id="179" href="Data.Bool.html" class="Module">Data.Bool</a>

<a id="190" class="Keyword">open</a> <a id="195" class="Keyword">import</a> <a id="202" href="1Lab.Reflection.html" class="Module">1Lab.Reflection</a>
<a id="218" class="Keyword">open</a> <a id="223" class="Keyword">import</a> <a id="230" href="1Lab.Reflection.Variables.html" class="Module">1Lab.Reflection.Variables</a>
</pre>
<h1 id="the-nat-solver"><a href="#the-nat-solver" class="header-link">The
Nat Solver<span class="header-link-emoji">🔗</span></a></h1>
<p>This module defines a solver for equations in the commutative
semiring of <a href="Data.Nat.Base.html">natural numbers</a>. Our
approach splits cleanly into 3 distinct parts:</p>
<ul>
<li>Horner normal forms for polynomials</li>
<li>Evaluation of reflected terms into polynomials</li>
<li>The reflection interface</li>
</ul>
<h2 id="horner-normal-forms"><a href="#horner-normal-forms" class="header-link">Horner
Normal Forms<span class="header-link-emoji">🔗</span></a></h2>
<p>If we ignore the
<span class="Agda"><a href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a></span>
and
<span class="Agda"><a href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a></span>
constructors, and their respective equations, the core problem at hand
is trying to compute normal forms for polynomials. Luckily, like most
problems involving polynomials, this has been thoroughly studied! There
are many possible normal forms to choose from, but the most useful for
our task is <em>Horner normal form</em>, as it admits a particularly
nice inductive characterization.</p>
<p>The core idea is that we can rewrite a (univariate) polynomial of the
form
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>a</mi><mn>0</mn></msub><mo>+</mo><msub><mi>a</mi><mn>1</mn></msub><mi>x</mi><mo>+</mo><msub><mi>a</mi><mn>2</mn></msub><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msub><mi>a</mi><mn>3</mn></msub><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><mo>⋯</mo><mo>+</mo><msub><mi>a</mi><mi>n</mi></msub><msup><mi>x</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex"> a_0 + a_1 x + a_2 x^2 + a_3 x^3 + \cdots + a_n x^n </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0141em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0141em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8644em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span>
into the following form:
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>a</mi><mn>0</mn></msub><mo>+</mo><mi>x</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo>+</mo><mi>x</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mn>2</mn></msub><mo>+</mo><mi>x</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mn>3</mn></msub><mo>+</mo><mo>⋯</mo><mo>+</mo><mi>x</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><mi>x</mi><msub><mi>a</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> a_0 + x ( a_1 + x ( a_2 + x ( a_3 + \cdots + x ( a_{n-1} + x a_n ) ) ) ) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">))))</span></span></span></span></span></p>
<p>However, we need <em>multivariate</em> polynomials, not just
univariate! To do this, we exploit the isomorphism between
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">[</mo><msub><mi>X</mi><mn>0</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>X</mi><mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">A[X_0, \cdots, X_n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>
and
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">[</mo><msub><mi>X</mi><mn>0</mn></msub><mo stretchy="false">]</mo><mo stretchy="false">[</mo><msub><mi>X</mi><mn>1</mn></msub><mo stretchy="false">]</mo><mo>⋯</mo><mo stretchy="false">[</mo><msub><mi>X</mi><mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">A[X_0][X_1]\cdots[X_n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>.</span>
This allows us to define the normal form of a multivariate polynomial as
(essentially) a product of univariate ones.</p>
<p>We start by defining the type of n-ary multivariate polynomials.</p>
<pre class="Agda"><a id="1624" class="Keyword">data</a> <a id="Poly"></a><a id="1629" href="Data.Nat.Solver.html#1629" data-type="Type a → Nat → Type a" class="Datatype">Poly</a> <a id="1634" class="Symbol">{</a><a id="1635" href="Data.Nat.Solver.html#1635" class="Bound">a</a><a id="1636" class="Symbol">}</a> <a id="1638" class="Symbol">(</a><a id="1639" href="Data.Nat.Solver.html#1639" class="Bound">A</a> <a id="1641" class="Symbol">:</a> <a id="1643" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="1648" href="Data.Nat.Solver.html#1635" class="Bound">a</a><a id="1649" class="Symbol">)</a> <a id="1651" class="Symbol">:</a> <a id="1653" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="1657" class="Symbol">→</a> <a id="1659" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="1664" href="Data.Nat.Solver.html#1635" class="Bound">a</a> <a id="1666" class="Keyword">where</a>
</pre>
<p>The first polynomial we define is the constant polynomial
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>∈</mo><mi>A</mi><mo stretchy="false">[</mo><msub><mi>X</mi><mn>0</mn></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">c \in A[X_0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>.</span></p>
<pre class="Agda">  <a id="Poly.const"></a><a id="1762" href="Data.Nat.Solver.html#1762" data-type="A → Poly A 0" class="InductiveConstructor">const</a> <a id="1768" class="Symbol">:</a> <a id="1770" class="Symbol">(</a><a id="1771" href="Data.Nat.Solver.html#1771" class="Bound">c</a> <a id="1773" class="Symbol">:</a> <a id="1775" href="Data.Nat.Solver.html#1639" class="Bound">A</a><a id="1776" class="Symbol">)</a> <a id="1778" class="Symbol">→</a> <a id="1780" href="Data.Nat.Solver.html#1629" data-type="Type a → Nat → Type a" class="Datatype">Poly</a> <a id="1785" href="Data.Nat.Solver.html#1639" class="Bound">A</a> <a id="1787" class="Number">0</a>
</pre>
<p>Next, we define the 0 polynomial
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>∈</mo><mi>A</mi><mo stretchy="false">[</mo><msub><mi>X</mi><mn>0</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>X</mi><mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">0 \in A[X_0, \cdots, X_n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6835em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>.</span>
Note that we do _not. include
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">[</mo><msub><mi>X</mi><mn>0</mn></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">A[X_0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>
here! This is important for ensuring that our data type defines a
(somewhat) <em>unique</em> normal form. If we had instead chosen
<code>Poly A n</code>, we could represent the
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>
polynomial using either <code>const 0</code> or <code>zerop</code>,
which complicates matters somewhat.</p>
<pre class="Agda">  <a id="Poly.zerop"></a><a id="2151" href="Data.Nat.Solver.html#2151" data-type="Poly A (suc n)" class="InductiveConstructor">zerop</a>  <a id="2158" class="Symbol">:</a> <a id="2160" class="Symbol">∀</a> <a id="2162" class="Symbol">{</a><a id="2163" href="Data.Nat.Solver.html#2163" class="Bound">n</a><a id="2164" class="Symbol">}</a> <a id="2166" class="Symbol">→</a> <a id="2168" href="Data.Nat.Solver.html#1629" data-type="Type a → Nat → Type a" class="Datatype">Poly</a> <a id="2173" href="Data.Nat.Solver.html#1639" class="Bound">A</a> <a id="2175" class="Symbol">(</a><a id="2176" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="2180" href="Data.Nat.Solver.html#2163" class="Bound">n</a><a id="2181" class="Symbol">)</a>
</pre>
<p>Finally, we define both addition and multiplication by
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">X_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
in one fell swoop. This constructor represents the polynomial
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>∗</mo><msub><mi>X</mi><mn>0</mn></msub><mo>+</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">p * X_0 + q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6597em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span>,</span>
where
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>∈</mo><mi>A</mi><mo stretchy="false">[</mo><msub><mi>X</mi><mn>0</mn></msub><mo stretchy="false">]</mo><mo>⋯</mo><mo stretchy="false">[</mo><msub><mi>X</mi><mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">p \in A[X_0]\cdots[X_n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>,</span>
and
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo>∈</mo><mi>A</mi><mo stretchy="false">[</mo><msub><mi>X</mi><mn>1</mn></msub><mo stretchy="false">]</mo><mo>⋯</mo><mo stretchy="false">[</mo><msub><mi>X</mi><mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">q \in A[X_1]\cdots[X_n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>.</span></p>
<p>This flipping of the index may seem confusing at first, but it serves
an important purpose: it makes evaluation <em>really</em> easy! When
evaluating, we will need some environment <code>Vec A n</code> which
assigns values to the various indeterminates
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">X_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</span>
In the variable case, the indexing will ensure that our environment is
non-empty, whence we can use the tail of the vector to evaluate
<code>q</code>! In this sense, not only does this constructor handle
addition and multiplication by
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">X_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,</span>
it <em>also</em> handles weakening.</p>
<pre class="Agda">  <a id="Poly._*X+_"></a><a id="2904" href="Data.Nat.Solver.html#2904" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">_*X+_</a> <a id="2910" class="Symbol">:</a> <a id="2912" class="Symbol">∀</a> <a id="2914" class="Symbol">{</a><a id="2915" href="Data.Nat.Solver.html#2915" class="Bound">n</a><a id="2916" class="Symbol">}</a> <a id="2918" class="Symbol">→</a> <a id="2920" class="Symbol">(</a><a id="2921" href="Data.Nat.Solver.html#2921" class="Bound">p</a> <a id="2923" class="Symbol">:</a> <a id="2925" href="Data.Nat.Solver.html#1629" data-type="Type a → Nat → Type a" class="Datatype">Poly</a> <a id="2930" href="Data.Nat.Solver.html#1639" class="Bound">A</a> <a id="2932" class="Symbol">(</a><a id="2933" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="2937" href="Data.Nat.Solver.html#2915" class="Bound">n</a><a id="2938" class="Symbol">))</a> <a id="2941" class="Symbol">→</a> <a id="2943" class="Symbol">(</a><a id="2944" href="Data.Nat.Solver.html#2944" class="Bound">q</a> <a id="2946" class="Symbol">:</a> <a id="2948" href="Data.Nat.Solver.html#1629" data-type="Type a → Nat → Type a" class="Datatype">Poly</a> <a id="2953" href="Data.Nat.Solver.html#1639" class="Bound">A</a> <a id="2955" href="Data.Nat.Solver.html#2915" class="Bound">n</a><a id="2956" class="Symbol">)</a> <a id="2958" class="Symbol">→</a> <a id="2960" href="Data.Nat.Solver.html#1629" data-type="Type a → Nat → Type a" class="Datatype">Poly</a> <a id="2965" href="Data.Nat.Solver.html#1639" class="Bound">A</a> <a id="2967" class="Symbol">(</a><a id="2968" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="2972" href="Data.Nat.Solver.html#2915" class="Bound">n</a><a id="2973" class="Symbol">)</a>
</pre>
<!--
<pre class="Agda"><a id="2989" class="Keyword">infixl</a> <a id="2996" class="Number">2</a> <a id="2998" href="Data.Nat.Solver.html#2904" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">_*X+_</a>

<a id="3005" class="Keyword">private</a> <a id="3013" class="Keyword">variable</a>
  <a id="3024" href="Data.Nat.Solver.html#3024" class="Generalizable">a</a> <a id="3026" class="Symbol">:</a> <a id="3028" href="Agda.Primitive.html#597" data-type="Type" class="Postulate">Level</a>
  <a id="3036" href="Data.Nat.Solver.html#3036" class="Generalizable">A</a> <a id="3038" class="Symbol">:</a> <a id="3040" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="3045" href="Data.Nat.Solver.html#3024" class="Generalizable">a</a>
  <a id="3049" href="Data.Nat.Solver.html#3049" class="Generalizable">n</a> <a id="3051" class="Symbol">:</a> <a id="3053" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a>

<a id="lookup"></a><a id="3058" href="Data.Nat.Solver.html#3058" data-type="Vec A n → Fin n → A" class="Function">lookup</a> <a id="3065" class="Symbol">:</a> <a id="3067" href="1Lab.Reflection.html#1792" data-type="Type ℓ → Nat → Type ℓ" class="Datatype">Vec</a> <a id="3071" href="Data.Nat.Solver.html#3036" class="Generalizable">A</a> <a id="3073" href="Data.Nat.Solver.html#3049" class="Generalizable">n</a> <a id="3075" class="Symbol">→</a> <a id="3077" href="Data.Fin.Base.html#498" data-type="Nat → Type" class="Datatype">Fin</a> <a id="3081" href="Data.Nat.Solver.html#3049" class="Generalizable">n</a> <a id="3083" class="Symbol">→</a> <a id="3085" href="Data.Nat.Solver.html#3036" class="Generalizable">A</a>
<a id="3087" href="Data.Nat.Solver.html#3058" data-type="Vec A n → Fin n → A" class="Function">lookup</a> <a id="3094" class="Symbol">(</a><a id="3095" href="Data.Nat.Solver.html#3095" class="Bound">x</a> <a id="3097" href="1Lab.Reflection.html#1854" data-type="A → Vec A n → Vec A (suc n)" class="InductiveConstructor Operator">∷</a> <a id="3099" href="Data.Nat.Solver.html#3099" class="Bound">xs</a><a id="3101" class="Symbol">)</a> <a id="3103" href="Data.Fin.Base.html#523" data-type="Fin (suc n)" class="InductiveConstructor">fzero</a> <a id="3109" class="Symbol">=</a> <a id="3111" href="Data.Nat.Solver.html#3095" class="Bound">x</a>
<a id="3113" href="Data.Nat.Solver.html#3058" data-type="Vec A n → Fin n → A" class="Function">lookup</a> <a id="3120" class="Symbol">(</a><a id="3121" href="Data.Nat.Solver.html#3121" class="Bound">x</a> <a id="3123" href="1Lab.Reflection.html#1854" data-type="A → Vec A n → Vec A (suc n)" class="InductiveConstructor Operator">∷</a> <a id="3125" href="Data.Nat.Solver.html#3125" class="Bound">xs</a><a id="3127" class="Symbol">)</a> <a id="3129" class="Symbol">(</a><a id="3130" href="Data.Fin.Base.html#553" data-type="Fin n → Fin (suc n)" class="InductiveConstructor">fsuc</a> <a id="3135" href="Data.Nat.Solver.html#3135" class="Bound">i</a><a id="3136" class="Symbol">)</a> <a id="3138" class="Symbol">=</a> <a id="3140" href="Data.Nat.Solver.html#3058" data-type="Vec A n → Fin n → A" class="Function">lookup</a> <a id="3147" href="Data.Nat.Solver.html#3125" class="Bound">xs</a> <a id="3150" href="Data.Nat.Solver.html#3135" class="Bound">i</a>

<a id="3153" class="Comment">-- NOTE: These little helper lemmas become very useful, and make</a>
<a id="3218" class="Comment">-- some of the really involved proofs a lot less painful.</a>
<a id="commute-inner"></a><a id="3276" href="Data.Nat.Solver.html#3276" data-type="(w x y z : Nat) → w + x + (y + z) ≡ w + y + (x + z)" class="Function">commute-inner</a> <a id="3290" class="Symbol">:</a> <a id="3292" class="Symbol">∀</a> <a id="3294" href="Data.Nat.Solver.html#3294" class="Bound">w</a> <a id="3296" href="Data.Nat.Solver.html#3296" class="Bound">x</a> <a id="3298" href="Data.Nat.Solver.html#3298" class="Bound">y</a> <a id="3300" href="Data.Nat.Solver.html#3300" class="Bound">z</a> <a id="3302" class="Symbol">→</a> <a id="3304" class="Symbol">(</a><a id="3305" href="Data.Nat.Solver.html#3294" class="Bound">w</a> <a id="3307" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3309" href="Data.Nat.Solver.html#3296" class="Bound">x</a><a id="3310" class="Symbol">)</a> <a id="3312" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3314" class="Symbol">(</a><a id="3315" href="Data.Nat.Solver.html#3298" class="Bound">y</a> <a id="3317" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3319" href="Data.Nat.Solver.html#3300" class="Bound">z</a><a id="3320" class="Symbol">)</a> <a id="3322" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="3324" class="Symbol">(</a><a id="3325" href="Data.Nat.Solver.html#3294" class="Bound">w</a> <a id="3327" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3329" href="Data.Nat.Solver.html#3298" class="Bound">y</a><a id="3330" class="Symbol">)</a> <a id="3332" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3334" class="Symbol">(</a><a id="3335" href="Data.Nat.Solver.html#3296" class="Bound">x</a> <a id="3337" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3339" href="Data.Nat.Solver.html#3300" class="Bound">z</a><a id="3340" class="Symbol">)</a>
<a id="3342" href="Data.Nat.Solver.html#3276" data-type="(w x y z : Nat) → w + x + (y + z) ≡ w + y + (x + z)" class="Function">commute-inner</a> <a id="3356" href="Data.Nat.Solver.html#3356" class="Bound">w</a> <a id="3358" href="Data.Nat.Solver.html#3358" class="Bound">x</a> <a id="3360" href="Data.Nat.Solver.html#3360" class="Bound">y</a> <a id="3362" href="Data.Nat.Solver.html#3362" class="Bound">z</a> <a id="3364" class="Symbol">=</a>
  <a id="3368" class="Symbol">(</a><a id="3369" href="Data.Nat.Solver.html#3356" class="Bound">w</a> <a id="3371" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3373" href="Data.Nat.Solver.html#3358" class="Bound">x</a><a id="3374" class="Symbol">)</a> <a id="3376" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3378" class="Symbol">(</a><a id="3379" href="Data.Nat.Solver.html#3360" class="Bound">y</a> <a id="3381" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3383" href="Data.Nat.Solver.html#3362" class="Bound">z</a><a id="3384" class="Symbol">)</a> <a id="3386" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="3389" href="Data.Nat.Properties.html#553" data-type="(x y z : Nat) → x + y + z ≡ x + (y + z)" class="Function">+-associative</a> <a id="3403" href="Data.Nat.Solver.html#3356" class="Bound">w</a> <a id="3405" href="Data.Nat.Solver.html#3358" class="Bound">x</a> <a id="3407" class="Symbol">(</a><a id="3408" href="Data.Nat.Solver.html#3360" class="Bound">y</a> <a id="3410" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3412" href="Data.Nat.Solver.html#3362" class="Bound">z</a><a id="3413" class="Symbol">)</a> <a id="3415" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
  <a id="3419" href="Data.Nat.Solver.html#3356" class="Bound">w</a> <a id="3421" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3423" class="Symbol">(</a><a id="3424" href="Data.Nat.Solver.html#3358" class="Bound">x</a> <a id="3426" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3428" class="Symbol">(</a><a id="3429" href="Data.Nat.Solver.html#3360" class="Bound">y</a> <a id="3431" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3433" href="Data.Nat.Solver.html#3362" class="Bound">z</a><a id="3434" class="Symbol">))</a> <a id="3437" href="1Lab.Path.html#46783" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">≡˘⟨</a> <a id="3441" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="3444" class="Symbol">(</a><a id="3445" href="Data.Nat.Solver.html#3356" class="Bound">w</a> <a id="3447" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+_</a><a id="3449" class="Symbol">)</a> <a id="3451" class="Symbol">(</a><a id="3452" href="Data.Nat.Properties.html#553" data-type="(x y z : Nat) → x + y + z ≡ x + (y + z)" class="Function">+-associative</a> <a id="3466" href="Data.Nat.Solver.html#3358" class="Bound">x</a> <a id="3468" href="Data.Nat.Solver.html#3360" class="Bound">y</a> <a id="3470" href="Data.Nat.Solver.html#3362" class="Bound">z</a><a id="3471" class="Symbol">)</a> <a id="3473" href="1Lab.Path.html#46783" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">⟩</a>
  <a id="3477" href="Data.Nat.Solver.html#3356" class="Bound">w</a> <a id="3479" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3481" class="Symbol">((</a><a id="3483" href="Data.Nat.Solver.html#3358" class="Bound">x</a> <a id="3485" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3487" href="Data.Nat.Solver.html#3360" class="Bound">y</a><a id="3488" class="Symbol">)</a> <a id="3490" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3492" href="Data.Nat.Solver.html#3362" class="Bound">z</a><a id="3493" class="Symbol">)</a> <a id="3495" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="3498" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="3501" class="Symbol">(λ</a> <a id="3504" href="Data.Nat.Solver.html#3504" class="Bound">ϕ</a> <a id="3506" class="Symbol">→</a> <a id="3508" href="Data.Nat.Solver.html#3356" class="Bound">w</a> <a id="3510" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3512" class="Symbol">(</a><a id="3513" href="Data.Nat.Solver.html#3504" class="Bound">ϕ</a> <a id="3515" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3517" href="Data.Nat.Solver.html#3362" class="Bound">z</a><a id="3518" class="Symbol">))</a> <a id="3521" class="Symbol">(</a><a id="3522" href="Data.Nat.Properties.html#979" data-type="(x y : Nat) → x + y ≡ y + x" class="Function">+-commutative</a> <a id="3536" href="Data.Nat.Solver.html#3358" class="Bound">x</a> <a id="3538" href="Data.Nat.Solver.html#3360" class="Bound">y</a><a id="3539" class="Symbol">)</a> <a id="3541" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
  <a id="3545" href="Data.Nat.Solver.html#3356" class="Bound">w</a> <a id="3547" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3549" class="Symbol">(</a><a id="3550" href="Data.Nat.Solver.html#3360" class="Bound">y</a> <a id="3552" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3554" href="Data.Nat.Solver.html#3358" class="Bound">x</a> <a id="3556" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3558" href="Data.Nat.Solver.html#3362" class="Bound">z</a><a id="3559" class="Symbol">)</a>   <a id="3563" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="3566" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="3569" class="Symbol">(</a><a id="3570" href="Data.Nat.Solver.html#3356" class="Bound">w</a> <a id="3572" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+_</a><a id="3574" class="Symbol">)</a> <a id="3576" class="Symbol">(</a><a id="3577" href="Data.Nat.Properties.html#553" data-type="(x y z : Nat) → x + y + z ≡ x + (y + z)" class="Function">+-associative</a> <a id="3591" href="Data.Nat.Solver.html#3360" class="Bound">y</a> <a id="3593" href="Data.Nat.Solver.html#3358" class="Bound">x</a> <a id="3595" href="Data.Nat.Solver.html#3362" class="Bound">z</a><a id="3596" class="Symbol">)</a> <a id="3598" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
  <a id="3602" href="Data.Nat.Solver.html#3356" class="Bound">w</a> <a id="3604" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3606" class="Symbol">(</a><a id="3607" href="Data.Nat.Solver.html#3360" class="Bound">y</a> <a id="3609" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3611" class="Symbol">(</a><a id="3612" href="Data.Nat.Solver.html#3358" class="Bound">x</a> <a id="3614" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3616" href="Data.Nat.Solver.html#3362" class="Bound">z</a><a id="3617" class="Symbol">))</a> <a id="3620" href="1Lab.Path.html#46783" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">≡˘⟨</a>  <a id="3625" href="Data.Nat.Properties.html#553" data-type="(x y z : Nat) → x + y + z ≡ x + (y + z)" class="Function">+-associative</a> <a id="3639" href="Data.Nat.Solver.html#3356" class="Bound">w</a> <a id="3641" href="Data.Nat.Solver.html#3360" class="Bound">y</a> <a id="3643" class="Symbol">(</a><a id="3644" href="Data.Nat.Solver.html#3358" class="Bound">x</a> <a id="3646" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3648" href="Data.Nat.Solver.html#3362" class="Bound">z</a><a id="3649" class="Symbol">)</a> <a id="3651" href="1Lab.Path.html#46783" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">⟩</a>
  <a id="3655" class="Symbol">(</a><a id="3656" href="Data.Nat.Solver.html#3356" class="Bound">w</a> <a id="3658" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3660" href="Data.Nat.Solver.html#3360" class="Bound">y</a><a id="3661" class="Symbol">)</a> <a id="3663" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3665" class="Symbol">(</a><a id="3666" href="Data.Nat.Solver.html#3358" class="Bound">x</a> <a id="3668" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3670" href="Data.Nat.Solver.html#3362" class="Bound">z</a><a id="3671" class="Symbol">)</a> <a id="3673" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>

<a id="commute-last"></a><a id="3676" href="Data.Nat.Solver.html#3676" data-type="(x y z : Nat) → x * y * z ≡ x * z * y" class="Function">commute-last</a> <a id="3689" class="Symbol">:</a> <a id="3691" class="Symbol">∀</a> <a id="3693" href="Data.Nat.Solver.html#3693" class="Bound">x</a> <a id="3695" href="Data.Nat.Solver.html#3695" class="Bound">y</a> <a id="3697" href="Data.Nat.Solver.html#3697" class="Bound">z</a> <a id="3699" class="Symbol">→</a> <a id="3701" class="Symbol">(</a><a id="3702" href="Data.Nat.Solver.html#3693" class="Bound">x</a> <a id="3704" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="3706" href="Data.Nat.Solver.html#3695" class="Bound">y</a><a id="3707" class="Symbol">)</a> <a id="3709" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="3711" href="Data.Nat.Solver.html#3697" class="Bound">z</a> <a id="3713" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="3715" class="Symbol">(</a><a id="3716" href="Data.Nat.Solver.html#3693" class="Bound">x</a> <a id="3718" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="3720" href="Data.Nat.Solver.html#3697" class="Bound">z</a><a id="3721" class="Symbol">)</a> <a id="3723" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="3725" href="Data.Nat.Solver.html#3695" class="Bound">y</a>
<a id="3727" href="Data.Nat.Solver.html#3676" data-type="(x y z : Nat) → x * y * z ≡ x * z * y" class="Function">commute-last</a> <a id="3740" href="Data.Nat.Solver.html#3740" class="Bound">x</a> <a id="3742" href="Data.Nat.Solver.html#3742" class="Bound">y</a> <a id="3744" href="Data.Nat.Solver.html#3744" class="Bound">z</a> <a id="3746" class="Symbol">=</a>
  <a id="3750" href="Data.Nat.Solver.html#3740" class="Bound">x</a> <a id="3752" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="3754" href="Data.Nat.Solver.html#3742" class="Bound">y</a> <a id="3756" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="3758" href="Data.Nat.Solver.html#3744" class="Bound">z</a>   <a id="3762" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="3765" href="Data.Nat.Properties.html#2667" data-type="(x y z : Nat) → x * y * z ≡ x * (y * z)" class="Function">*-associative</a> <a id="3779" href="Data.Nat.Solver.html#3740" class="Bound">x</a> <a id="3781" href="Data.Nat.Solver.html#3742" class="Bound">y</a> <a id="3783" href="Data.Nat.Solver.html#3744" class="Bound">z</a> <a id="3785" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
  <a id="3789" href="Data.Nat.Solver.html#3740" class="Bound">x</a> <a id="3791" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="3793" class="Symbol">(</a><a id="3794" href="Data.Nat.Solver.html#3742" class="Bound">y</a> <a id="3796" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="3798" href="Data.Nat.Solver.html#3744" class="Bound">z</a><a id="3799" class="Symbol">)</a> <a id="3801" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="3804" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="3807" class="Symbol">(</a><a id="3808" href="Data.Nat.Solver.html#3740" class="Bound">x</a> <a id="3810" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*_</a><a id="3812" class="Symbol">)</a> <a id="3814" class="Symbol">(</a><a id="3815" href="Data.Nat.Properties.html#2203" data-type="(x y : Nat) → x * y ≡ y * x" class="Function">*-commutative</a> <a id="3829" href="Data.Nat.Solver.html#3742" class="Bound">y</a> <a id="3831" href="Data.Nat.Solver.html#3744" class="Bound">z</a><a id="3832" class="Symbol">)</a> <a id="3834" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
  <a id="3838" href="Data.Nat.Solver.html#3740" class="Bound">x</a> <a id="3840" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="3842" class="Symbol">(</a><a id="3843" href="Data.Nat.Solver.html#3744" class="Bound">z</a> <a id="3845" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="3847" href="Data.Nat.Solver.html#3742" class="Bound">y</a><a id="3848" class="Symbol">)</a> <a id="3850" href="1Lab.Path.html#46783" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">≡˘⟨</a> <a id="3854" href="Data.Nat.Properties.html#2667" data-type="(x y z : Nat) → x * y * z ≡ x * (y * z)" class="Function">*-associative</a> <a id="3868" href="Data.Nat.Solver.html#3740" class="Bound">x</a> <a id="3870" href="Data.Nat.Solver.html#3744" class="Bound">z</a> <a id="3872" href="Data.Nat.Solver.html#3742" class="Bound">y</a> <a id="3874" href="1Lab.Path.html#46783" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">⟩</a>
  <a id="3878" href="Data.Nat.Solver.html#3740" class="Bound">x</a> <a id="3880" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="3882" href="Data.Nat.Solver.html#3744" class="Bound">z</a> <a id="3884" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="3886" href="Data.Nat.Solver.html#3742" class="Bound">y</a> <a id="3888" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
</pre>-->
<p>Note that this representation, while convienent, does pose some
problems. We pay for the (relative) uniqueness by having larger terms:
For instance, the polynomial
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>X</mi><mn>4</mn></msup><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">X^4 + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>
is represented as</p>
<pre class="Agda"><a id="4100" class="Keyword">private</a>
  <a id="x⁴+1"></a><a id="4110" href="Data.Nat.Solver.html#4110" class="Function">x⁴+1</a> <a id="4115" class="Symbol">:</a> <a id="4117" href="Data.Nat.Solver.html#1629" data-type="Type a → Nat → Type a" class="Datatype">Poly</a> <a id="4122" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="4126" class="Number">1</a>
  <a id="4130" href="Data.Nat.Solver.html#4110" class="Function">x⁴+1</a> <a id="4135" class="Symbol">=</a> <a id="4137" href="Data.Nat.Solver.html#2151" data-type="Poly A (suc n)" class="InductiveConstructor">zerop</a> <a id="4143" href="Data.Nat.Solver.html#2904" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="4147" href="Data.Nat.Solver.html#1762" data-type="A → Poly A 0" class="InductiveConstructor">const</a> <a id="4153" class="Number">1</a> <a id="4155" href="Data.Nat.Solver.html#2904" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="4159" href="Data.Nat.Solver.html#1762" data-type="A → Poly A 0" class="InductiveConstructor">const</a> <a id="4165" class="Number">0</a> <a id="4167" href="Data.Nat.Solver.html#2904" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="4171" href="Data.Nat.Solver.html#1762" data-type="A → Poly A 0" class="InductiveConstructor">const</a> <a id="4177" class="Number">0</a> <a id="4179" href="Data.Nat.Solver.html#2904" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="4183" href="Data.Nat.Solver.html#1762" data-type="A → Poly A 0" class="InductiveConstructor">const</a> <a id="4189" class="Number">0</a> <a id="4191" href="Data.Nat.Solver.html#2904" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="4195" href="Data.Nat.Solver.html#1762" data-type="A → Poly A 0" class="InductiveConstructor">const</a> <a id="4201" class="Number">0</a>
</pre>
<p>This could be alieviated by using a <em>sparse</em> representation,
but this is decidedly more difficult. As the solver is not expected to
deal with polynomials with large degrees, this term blow-up will not be
a problem in practice.</p>
<h3 id="operations-on-horner-normal-forms"><a href="#operations-on-horner-normal-forms" class="header-link">Operations
on Horner Normal Forms<span class="header-link-emoji">🔗</span></a></h3>
<p>Now, let’s define a handful of functions for constructing and
combining polynomials. The naming here can get a bit confusing, so let’s
stick with the convention of adding a subscript <code>p</code> to denote
an operation on polynomials. As a further note, the entire following
section could be generalized work over an arbitrary semiring, but this
would complicate the dependency graph somewhat, so we stick to natural
numbers.</p>
<p>As previously mentioned, we have different representations of the
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>
polynomial depending on if we are working with <code>Poly A zero</code>
or <code>Poly A (suc n)</code>. This is somewhat annoying, so we define
a small helper for picking the correct representation.</p>
<pre class="Agda"><a id="0ₚ"></a><a id="5150" href="Data.Nat.Solver.html#5150" data-type="Poly Nat n" class="Function">0ₚ</a> <a id="5153" class="Symbol">:</a> <a id="5155" href="Data.Nat.Solver.html#1629" data-type="Type a → Nat → Type a" class="Datatype">Poly</a> <a id="5160" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="5164" href="Data.Nat.Solver.html#3049" class="Generalizable">n</a>
<a id="5166" href="Data.Nat.Solver.html#5150" data-type="Poly Nat n" class="Function">0ₚ</a> <a id="5169" class="Symbol">{</a><a id="5170" class="Argument">n</a> <a id="5172" class="Symbol">=</a> <a id="5174" href="Agda.Builtin.Nat.html#210" data-type="Nat" class="InductiveConstructor">zero</a><a id="5178" class="Symbol">}</a>  <a id="5181" class="Symbol">=</a> <a id="5183" href="Data.Nat.Solver.html#1762" data-type="A → Poly A 0" class="InductiveConstructor">const</a> <a id="5189" href="Agda.Builtin.Nat.html#210" data-type="Nat" class="InductiveConstructor">zero</a>
<a id="5194" href="Data.Nat.Solver.html#5150" data-type="Poly Nat n" class="Function">0ₚ</a> <a id="5197" class="Symbol">{</a><a id="5198" class="Argument">n</a> <a id="5200" class="Symbol">=</a> <a id="5202" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="5206" href="Data.Nat.Solver.html#5206" class="Bound">n</a><a id="5207" class="Symbol">}</a> <a id="5209" class="Symbol">=</a> <a id="5211" href="Data.Nat.Solver.html#2151" data-type="Poly A (suc n)" class="InductiveConstructor">zerop</a>
</pre>
<p>While we are at it, we also define the polynomial that represents,
given a constant
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span>,</span>
the constant polynomial
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>∈</mo><mi>A</mi><mo stretchy="false">[</mo><msub><mi>X</mi><mn>0</mn></msub><mo stretchy="false">]</mo><mo>⋯</mo><mo stretchy="false">[</mo><msub><mi>X</mi><mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">c \in A[X_0]\cdots[X_n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>.</span></p>
<pre class="Agda"><a id="constₚ"></a><a id="5371" href="Data.Nat.Solver.html#5371" data-type="Nat → Poly Nat n" class="Function">constₚ</a> <a id="5378" class="Symbol">:</a> <a id="5380" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="5384" class="Symbol">→</a> <a id="5386" href="Data.Nat.Solver.html#1629" data-type="Type a → Nat → Type a" class="Datatype">Poly</a> <a id="5391" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="5395" href="Data.Nat.Solver.html#3049" class="Generalizable">n</a>
<a id="5397" href="Data.Nat.Solver.html#5371" data-type="Nat → Poly Nat n" class="Function">constₚ</a> <a id="5404" class="Symbol">{</a><a id="5405" class="Argument">n</a> <a id="5407" class="Symbol">=</a> <a id="5409" href="Agda.Builtin.Nat.html#210" data-type="Nat" class="InductiveConstructor">zero</a><a id="5413" class="Symbol">}</a>  <a id="5416" href="Data.Nat.Solver.html#5416" class="Bound">c</a> <a id="5418" class="Symbol">=</a> <a id="5420" href="Data.Nat.Solver.html#1762" data-type="A → Poly A 0" class="InductiveConstructor">const</a> <a id="5426" href="Data.Nat.Solver.html#5416" class="Bound">c</a>
<a id="5428" href="Data.Nat.Solver.html#5371" data-type="Nat → Poly Nat n" class="Function">constₚ</a> <a id="5435" class="Symbol">{</a><a id="5436" class="Argument">n</a> <a id="5438" class="Symbol">=</a> <a id="5440" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="5444" href="Data.Nat.Solver.html#5444" class="Bound">n</a><a id="5445" class="Symbol">}</a> <a id="5447" href="Data.Nat.Solver.html#5447" class="Bound">c</a> <a id="5449" class="Symbol">=</a> <a id="5451" href="Data.Nat.Solver.html#5150" data-type="Poly Nat n" class="Function">0ₚ</a> <a id="5454" href="Data.Nat.Solver.html#2904" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="5458" href="Data.Nat.Solver.html#5371" data-type="Nat → Poly Nat n" class="Function">constₚ</a> <a id="5465" href="Data.Nat.Solver.html#5447" class="Bound">c</a>
</pre>
<p>The constant 1 is important enough that it deserves its own
syntax.</p>
<pre class="Agda"><a id="1ₚ"></a><a id="5549" href="Data.Nat.Solver.html#5549" data-type="Poly Nat n" class="Function">1ₚ</a> <a id="5552" class="Symbol">:</a> <a id="5554" href="Data.Nat.Solver.html#1629" data-type="Type a → Nat → Type a" class="Datatype">Poly</a> <a id="5559" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="5563" href="Data.Nat.Solver.html#3049" class="Generalizable">n</a>
<a id="5565" href="Data.Nat.Solver.html#5549" data-type="Poly Nat n" class="Function">1ₚ</a> <a id="5568" class="Symbol">=</a> <a id="5570" href="Data.Nat.Solver.html#5371" data-type="Nat → Poly Nat n" class="Function">constₚ</a> <a id="5577" class="Number">1</a>
</pre>
<p>We also define the identity monomials
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub><mo>∈</mo><mi>A</mi><mo stretchy="false">[</mo><msub><mi>X</mi><mn>0</mn></msub><mo stretchy="false">]</mo><mo>⋯</mo><mo stretchy="false">[</mo><msub><mi>X</mi><mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">X_i \in A[X_0]\cdots[X_n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>.</span></p>
<pre class="Agda"><a id="X[_]"></a><a id="5660" href="Data.Nat.Solver.html#5660" data-type="Fin n → Poly Nat n" class="Function Operator">X[_]</a> <a id="5665" class="Symbol">:</a> <a id="5667" href="Data.Fin.Base.html#498" data-type="Nat → Type" class="Datatype">Fin</a> <a id="5671" href="Data.Nat.Solver.html#3049" class="Generalizable">n</a> <a id="5673" class="Symbol">→</a> <a id="5675" href="Data.Nat.Solver.html#1629" data-type="Type a → Nat → Type a" class="Datatype">Poly</a> <a id="5680" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="5684" href="Data.Nat.Solver.html#3049" class="Generalizable">n</a>
<a id="5686" href="Data.Nat.Solver.html#5660" data-type="Fin n → Poly Nat n" class="Function Operator">X[_]</a> <a id="5691" href="Data.Fin.Base.html#523" data-type="Fin (suc n)" class="InductiveConstructor">fzero</a>    <a id="5700" class="Symbol">=</a> <a id="5702" href="Data.Nat.Solver.html#5549" data-type="Poly Nat n" class="Function">1ₚ</a> <a id="5705" href="Data.Nat.Solver.html#2904" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="5709" href="Data.Nat.Solver.html#5150" data-type="Poly Nat n" class="Function">0ₚ</a>
<a id="5712" href="Data.Nat.Solver.html#5660" data-type="Fin n → Poly Nat n" class="Function Operator">X[_]</a> <a id="5717" class="Symbol">(</a><a id="5718" href="Data.Fin.Base.html#553" data-type="Fin n → Fin (suc n)" class="InductiveConstructor">fsuc</a> <a id="5723" href="Data.Nat.Solver.html#5723" class="Bound">i</a><a id="5724" class="Symbol">)</a> <a id="5726" class="Symbol">=</a> <a id="5728" href="Data.Nat.Solver.html#5150" data-type="Poly Nat n" class="Function">0ₚ</a> <a id="5731" href="Data.Nat.Solver.html#2904" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="5735" href="Data.Nat.Solver.html#5660" data-type="Fin n → Poly Nat n" class="Function Operator">X[</a> <a id="5738" href="Data.Nat.Solver.html#5723" class="Bound">i</a> <a id="5740" href="Data.Nat.Solver.html#5660" data-type="Fin n → Poly Nat n" class="Function Operator">]</a>
</pre>
<p>Now, onto addition of polynomials. This is more or less what one
would expect if they wrote out the polynomials and did the addition by
hand.</p>
<pre class="Agda"><a id="5898" class="Keyword">infixl</a> <a id="5905" class="Number">6</a> <a id="5907" href="Data.Nat.Solver.html#5927" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">_+ₚ_</a>
<a id="5912" class="Keyword">infixl</a> <a id="5919" class="Number">7</a> <a id="5921" href="Data.Nat.Solver.html#6444" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">_*ₚ_</a>

<a id="_+ₚ_"></a><a id="5927" href="Data.Nat.Solver.html#5927" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">_+ₚ_</a> <a id="5932" class="Symbol">:</a> <a id="5934" href="Data.Nat.Solver.html#1629" data-type="Type a → Nat → Type a" class="Datatype">Poly</a> <a id="5939" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="5943" href="Data.Nat.Solver.html#3049" class="Generalizable">n</a> <a id="5945" class="Symbol">→</a> <a id="5947" href="Data.Nat.Solver.html#1629" data-type="Type a → Nat → Type a" class="Datatype">Poly</a> <a id="5952" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="5956" href="Data.Nat.Solver.html#3049" class="Generalizable">n</a> <a id="5958" class="Symbol">→</a> <a id="5960" href="Data.Nat.Solver.html#1629" data-type="Type a → Nat → Type a" class="Datatype">Poly</a> <a id="5965" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="5969" href="Data.Nat.Solver.html#3049" class="Generalizable">n</a>
<a id="5971" href="Data.Nat.Solver.html#1762" data-type="A → Poly A 0" class="InductiveConstructor">const</a> <a id="5977" href="Data.Nat.Solver.html#5977" class="Bound">c₁</a> <a id="5980" href="Data.Nat.Solver.html#5927" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">+ₚ</a> <a id="5983" href="Data.Nat.Solver.html#1762" data-type="A → Poly A 0" class="InductiveConstructor">const</a> <a id="5989" href="Data.Nat.Solver.html#5989" class="Bound">c₂</a> <a id="5992" class="Symbol">=</a> <a id="5994" href="Data.Nat.Solver.html#1762" data-type="A → Poly A 0" class="InductiveConstructor">const</a> <a id="6000" class="Symbol">(</a><a id="6001" href="Data.Nat.Solver.html#5977" class="Bound">c₁</a> <a id="6004" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="6006" href="Data.Nat.Solver.html#5989" class="Bound">c₂</a><a id="6008" class="Symbol">)</a>
<a id="6010" href="Data.Nat.Solver.html#2151" data-type="Poly A (suc n)" class="InductiveConstructor">zerop</a> <a id="6016" href="Data.Nat.Solver.html#5927" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">+ₚ</a> <a id="6019" href="Data.Nat.Solver.html#6019" class="Bound">q</a> <a id="6021" class="Symbol">=</a> <a id="6023" href="Data.Nat.Solver.html#6019" class="Bound">q</a>
<a id="6025" class="Symbol">(</a><a id="6026" href="Data.Nat.Solver.html#6026" class="Bound">p</a> <a id="6028" href="Data.Nat.Solver.html#2904" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="6032" href="Data.Nat.Solver.html#6032" class="Bound">q</a><a id="6033" class="Symbol">)</a> <a id="6035" href="Data.Nat.Solver.html#5927" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">+ₚ</a> <a id="6038" href="Data.Nat.Solver.html#2151" data-type="Poly A (suc n)" class="InductiveConstructor">zerop</a> <a id="6044" class="Symbol">=</a> <a id="6046" href="Data.Nat.Solver.html#6026" class="Bound">p</a> <a id="6048" href="Data.Nat.Solver.html#2904" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="6052" href="Data.Nat.Solver.html#6032" class="Bound">q</a>
<a id="6054" class="Symbol">(</a><a id="6055" href="Data.Nat.Solver.html#6055" class="Bound">p</a> <a id="6057" href="Data.Nat.Solver.html#2904" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="6061" href="Data.Nat.Solver.html#6061" class="Bound">r</a><a id="6062" class="Symbol">)</a> <a id="6064" href="Data.Nat.Solver.html#5927" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">+ₚ</a> <a id="6067" class="Symbol">(</a><a id="6068" href="Data.Nat.Solver.html#6068" class="Bound">q</a> <a id="6070" href="Data.Nat.Solver.html#2904" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="6074" href="Data.Nat.Solver.html#6074" class="Bound">s</a><a id="6075" class="Symbol">)</a> <a id="6077" class="Symbol">=</a> <a id="6079" class="Symbol">(</a><a id="6080" href="Data.Nat.Solver.html#6055" class="Bound">p</a> <a id="6082" href="Data.Nat.Solver.html#5927" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">+ₚ</a> <a id="6085" href="Data.Nat.Solver.html#6068" class="Bound">q</a><a id="6086" class="Symbol">)</a> <a id="6088" href="Data.Nat.Solver.html#2904" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="6092" class="Symbol">(</a><a id="6093" href="Data.Nat.Solver.html#6061" class="Bound">r</a> <a id="6095" href="Data.Nat.Solver.html#5927" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">+ₚ</a> <a id="6098" href="Data.Nat.Solver.html#6074" class="Bound">s</a><a id="6099" class="Symbol">)</a>
</pre>
<p>Multiplication, however, is somewhat trickier. The problem is that
during the course of recursion, we will need to multiply a
<code>Poly A n</code> by a <code>Poly A (suc n)</code> — for which we
will need mutual recursion, since that multiplication will fall back to
the “homogeneous” case eventually. We predeclare their types to make
Agda happy:</p>
<pre class="Agda"><a id="_*ₚ_"></a><a id="6444" href="Data.Nat.Solver.html#6444" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">_*ₚ_</a> <a id="6449" class="Symbol">:</a> <a id="6451" href="Data.Nat.Solver.html#1629" data-type="Type a → Nat → Type a" class="Datatype">Poly</a> <a id="6456" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="6460" href="Data.Nat.Solver.html#3049" class="Generalizable">n</a> <a id="6462" class="Symbol">→</a> <a id="6464" href="Data.Nat.Solver.html#1629" data-type="Type a → Nat → Type a" class="Datatype">Poly</a> <a id="6469" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="6473" href="Data.Nat.Solver.html#3049" class="Generalizable">n</a> <a id="6475" class="Symbol">→</a> <a id="6477" href="Data.Nat.Solver.html#1629" data-type="Type a → Nat → Type a" class="Datatype">Poly</a> <a id="6482" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="6486" href="Data.Nat.Solver.html#3049" class="Generalizable">n</a>
<a id="_*ₚ′_"></a><a id="6488" href="Data.Nat.Solver.html#6488" data-type="Poly Nat n → Poly Nat (suc n) → Poly Nat (suc n)" class="Function Operator">_*ₚ′_</a> <a id="6494" class="Symbol">:</a> <a id="6496" href="Data.Nat.Solver.html#1629" data-type="Type a → Nat → Type a" class="Datatype">Poly</a> <a id="6501" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="6505" href="Data.Nat.Solver.html#3049" class="Generalizable">n</a> <a id="6507" class="Symbol">→</a> <a id="6509" href="Data.Nat.Solver.html#1629" data-type="Type a → Nat → Type a" class="Datatype">Poly</a> <a id="6514" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="6518" class="Symbol">(</a><a id="6519" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="6523" href="Data.Nat.Solver.html#3049" class="Generalizable">n</a><a id="6524" class="Symbol">)</a> <a id="6526" class="Symbol">→</a> <a id="6528" href="Data.Nat.Solver.html#1629" data-type="Type a → Nat → Type a" class="Datatype">Poly</a> <a id="6533" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="6537" class="Symbol">(</a><a id="6538" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="6542" href="Data.Nat.Solver.html#3049" class="Generalizable">n</a><a id="6543" class="Symbol">)</a>
</pre>
<p>First, the homogeneous multiplication. The first two cases are pretty
straightforward, but the final one is decidedly less so. To start, we
can distribute the multiplication of <code>r</code> over the addition,
invoking
<span class="Agda"><a href="Data.Nat.Solver.html#5927" class="Function Operator">_+ₚ_</a></span>
to add the results together. When multiplying <code>q</code> and
<code>r</code>, we need to use the aforementioned heterogeneous
multiplication, as
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo>∈</mo><mi>A</mi><mo stretchy="false">[</mo><msub><mi>X</mi><mn>1</mn></msub><mo stretchy="false">]</mo><mo>⋯</mo><mo stretchy="false">[</mo><msub><mi>X</mi><mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">q \in A[X_1]\cdots[X_n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>
— note that the index is off by one
(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">X_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
vs
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">X_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>).</span>
When multiplying <code>p</code> and <code>r</code>, we need to add on a
<code>0ₚ</code> under the <code>*X</code>, as this is the only way of
multiplying by
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">X_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</span></p>
<pre class="Agda"><a id="7110" href="Data.Nat.Solver.html#1762" data-type="A → Poly A 0" class="InductiveConstructor">const</a> <a id="7116" href="Data.Nat.Solver.html#7116" class="Bound">c₁</a>  <a id="7120" href="Data.Nat.Solver.html#6444" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">*ₚ</a> <a id="7123" href="Data.Nat.Solver.html#1762" data-type="A → Poly A 0" class="InductiveConstructor">const</a> <a id="7129" href="Data.Nat.Solver.html#7129" class="Bound">c₂</a> <a id="7132" class="Symbol">=</a> <a id="7134" href="Data.Nat.Solver.html#1762" data-type="A → Poly A 0" class="InductiveConstructor">const</a> <a id="7140" class="Symbol">(</a><a id="7141" href="Data.Nat.Solver.html#7116" class="Bound">c₁</a> <a id="7144" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="7146" href="Data.Nat.Solver.html#7129" class="Bound">c₂</a><a id="7148" class="Symbol">)</a>
<a id="7150" href="Data.Nat.Solver.html#2151" data-type="Poly A (suc n)" class="InductiveConstructor">zerop</a>     <a id="7160" href="Data.Nat.Solver.html#6444" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">*ₚ</a> <a id="7163" href="Data.Nat.Solver.html#7163" class="Bound">q</a>        <a id="7172" class="Symbol">=</a> <a id="7174" href="Data.Nat.Solver.html#2151" data-type="Poly A (suc n)" class="InductiveConstructor">zerop</a>
<a id="7180" class="Symbol">(</a><a id="7181" href="Data.Nat.Solver.html#7181" class="Bound">p</a> <a id="7183" href="Data.Nat.Solver.html#2904" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="7187" href="Data.Nat.Solver.html#7187" class="Bound">q</a><a id="7188" class="Symbol">)</a> <a id="7190" href="Data.Nat.Solver.html#6444" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">*ₚ</a> <a id="7193" href="Data.Nat.Solver.html#7193" class="Bound">r</a>        <a id="7202" class="Symbol">=</a> <a id="7204" class="Symbol">((</a><a id="7206" href="Data.Nat.Solver.html#7181" class="Bound">p</a> <a id="7208" href="Data.Nat.Solver.html#6444" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">*ₚ</a> <a id="7211" href="Data.Nat.Solver.html#7193" class="Bound">r</a><a id="7212" class="Symbol">)</a> <a id="7214" href="Data.Nat.Solver.html#2904" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="7218" href="Data.Nat.Solver.html#5150" data-type="Poly Nat n" class="Function">0ₚ</a><a id="7220" class="Symbol">)</a> <a id="7222" href="Data.Nat.Solver.html#5927" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">+ₚ</a> <a id="7225" class="Symbol">(</a><a id="7226" href="Data.Nat.Solver.html#7187" class="Bound">q</a> <a id="7228" href="Data.Nat.Solver.html#6488" data-type="Poly Nat n → Poly Nat (suc n) → Poly Nat (suc n)" class="Function Operator">*ₚ′</a> <a id="7232" href="Data.Nat.Solver.html#7193" class="Bound">r</a><a id="7233" class="Symbol">)</a>
</pre>
<p>For the heterogeneous case, the call graph is simpler, as we can fall
back to the homogeneous operator.</p>
<pre class="Agda"><a id="7353" href="Data.Nat.Solver.html#7353" class="Bound">r</a> <a id="7355" href="Data.Nat.Solver.html#6488" data-type="Poly Nat n → Poly Nat (suc n) → Poly Nat (suc n)" class="Function Operator">*ₚ′</a> <a id="7359" href="Data.Nat.Solver.html#2151" data-type="Poly A (suc n)" class="InductiveConstructor">zerop</a>     <a id="7369" class="Symbol">=</a> <a id="7371" href="Data.Nat.Solver.html#2151" data-type="Poly A (suc n)" class="InductiveConstructor">zerop</a>
<a id="7377" href="Data.Nat.Solver.html#7377" class="Bound">r</a> <a id="7379" href="Data.Nat.Solver.html#6488" data-type="Poly Nat n → Poly Nat (suc n) → Poly Nat (suc n)" class="Function Operator">*ₚ′</a> <a id="7383" class="Symbol">(</a><a id="7384" href="Data.Nat.Solver.html#7384" class="Bound">p</a> <a id="7386" href="Data.Nat.Solver.html#2904" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="7390" href="Data.Nat.Solver.html#7390" class="Bound">q</a><a id="7391" class="Symbol">)</a> <a id="7393" class="Symbol">=</a> <a id="7395" class="Symbol">(</a><a id="7396" href="Data.Nat.Solver.html#7377" class="Bound">r</a> <a id="7398" href="Data.Nat.Solver.html#6488" data-type="Poly Nat n → Poly Nat (suc n) → Poly Nat (suc n)" class="Function Operator">*ₚ′</a> <a id="7402" href="Data.Nat.Solver.html#7384" class="Bound">p</a><a id="7403" class="Symbol">)</a> <a id="7405" href="Data.Nat.Solver.html#2904" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="7409" class="Symbol">(</a><a id="7410" href="Data.Nat.Solver.html#7377" class="Bound">r</a> <a id="7412" href="Data.Nat.Solver.html#6444" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">*ₚ</a> <a id="7415" href="Data.Nat.Solver.html#7390" class="Bound">q</a><a id="7416" class="Symbol">)</a>
</pre>
<h3 id="evaluation-of-horner-normal-forms"><a href="#evaluation-of-horner-normal-forms" class="header-link">Evaluation
of Horner Normal Forms<span class="header-link-emoji">🔗</span></a></h3>
<p>Multivariate polynomials represent functions
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi>n</mi></msup><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">A^n \to A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>,</span>
so we should be able to interpret them as such. Luckily, Horner Normal
Forms are extremely easy to evaluate. As a historical note, this is why
this representation was created in first place! In this light, they
should probably be called “<a href="https://en.wikipedia.org/wiki/Sharaf_al-Din_al-Tusi">Sharaf al-Din
al-Tusi</a> normal forms”.</p>
<pre class="Agda"><a id="block"></a><a id="7884" href="Data.Nat.Solver.html#7884" data-type="Nat → Nat" class="Function">block</a> <a id="7890" class="Symbol">:</a> <a id="7892" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="7896" class="Symbol">→</a> <a id="7898" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a>
<a id="7902" href="Data.Nat.Solver.html#7884" data-type="Nat → Nat" class="Function">block</a> <a id="7908" href="Data.Nat.Solver.html#7908" class="Bound">x</a> <a id="7910" class="Symbol">=</a> <a id="7912" href="Data.Nat.Solver.html#7908" class="Bound">x</a>
</pre>
<pre class="Agda"><a id="⟦_⟧ₚ"></a><a id="7927" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦_⟧ₚ</a> <a id="7932" class="Symbol">:</a> <a id="7934" href="Data.Nat.Solver.html#1629" data-type="Type a → Nat → Type a" class="Datatype">Poly</a> <a id="7939" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="7943" href="Data.Nat.Solver.html#3049" class="Generalizable">n</a> <a id="7945" class="Symbol">→</a> <a id="7947" href="1Lab.Reflection.html#1792" data-type="Type ℓ → Nat → Type ℓ" class="Datatype">Vec</a> <a id="7951" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="7955" href="Data.Nat.Solver.html#3049" class="Generalizable">n</a> <a id="7957" class="Symbol">→</a> <a id="7959" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a>
<a id="7963" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="7965" href="Data.Nat.Solver.html#1762" data-type="A → Poly A 0" class="InductiveConstructor">const</a> <a id="7971" href="Data.Nat.Solver.html#7971" class="Bound">c</a> <a id="7973" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="7976" href="Data.Nat.Solver.html#7976" class="Bound">env</a>        <a id="7987" class="Symbol">=</a> <a id="7989" href="Data.Nat.Solver.html#7971" class="Bound">c</a>
<a id="7991" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="7993" href="Data.Nat.Solver.html#2151" data-type="Poly A (suc n)" class="InductiveConstructor">zerop</a> <a id="7999" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a>   <a id="8004" href="Data.Nat.Solver.html#8004" class="Bound">env</a>        <a id="8015" class="Symbol">=</a> <a id="8017" class="Number">0</a>
<a id="8019" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="8021" href="Data.Nat.Solver.html#8021" class="Bound">p</a> <a id="8023" href="Data.Nat.Solver.html#2904" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="8027" href="Data.Nat.Solver.html#8027" class="Bound">q</a> <a id="8029" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="8032" class="Symbol">(</a><a id="8033" href="Data.Nat.Solver.html#8033" class="Bound">x₀</a> <a id="8036" href="1Lab.Reflection.html#1854" data-type="A → Vec A n → Vec A (suc n)" class="InductiveConstructor Operator">∷</a> <a id="8038" href="Data.Nat.Solver.html#8038" class="Bound">env</a><a id="8041" class="Symbol">)</a> <a id="8043" class="Symbol">=</a> <a id="8045" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="8047" href="Data.Nat.Solver.html#8021" class="Bound">p</a> <a id="8049" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="8052" class="Symbol">(</a><a id="8053" href="Data.Nat.Solver.html#8033" class="Bound">x₀</a> <a id="8056" href="1Lab.Reflection.html#1854" data-type="A → Vec A n → Vec A (suc n)" class="InductiveConstructor Operator">∷</a> <a id="8058" href="Data.Nat.Solver.html#8038" class="Bound">env</a><a id="8061" class="Symbol">)</a> <a id="8063" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="8065" href="Data.Nat.Solver.html#8033" class="Bound">x₀</a> <a id="8068" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="8070" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="8072" href="Data.Nat.Solver.html#8027" class="Bound">q</a> <a id="8074" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="8077" href="Data.Nat.Solver.html#8038" class="Bound">env</a>
</pre>
<h3 id="soundness-of-the-operations"><a href="#soundness-of-the-operations" class="header-link">Soundness
of the Operations<span class="header-link-emoji">🔗</span></a></h3>
<p>Now, it’s important that the operations we defined actually denote
the correct operations on natural numbers. As a warm up, let’s show that
the zero polynomial really represents the function
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f(x_0, \cdots, x_n) = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>.</span></p>
<pre class="Agda"><a id="sound-0ₚ"></a><a id="8346" href="Data.Nat.Solver.html#8346" data-type="(env : Vec Nat n) → ⟦ 0ₚ ⟧ₚ env ≡ 0" class="Function">sound-0ₚ</a> <a id="8355" class="Symbol">:</a> <a id="8357" class="Symbol">∀</a> <a id="8359" class="Symbol">(</a><a id="8360" href="Data.Nat.Solver.html#8360" class="Bound">env</a> <a id="8364" class="Symbol">:</a> <a id="8366" href="1Lab.Reflection.html#1792" data-type="Type ℓ → Nat → Type ℓ" class="Datatype">Vec</a> <a id="8370" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="8374" href="Data.Nat.Solver.html#3049" class="Generalizable">n</a><a id="8375" class="Symbol">)</a> <a id="8377" class="Symbol">→</a> <a id="8379" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="8381" href="Data.Nat.Solver.html#5150" data-type="Poly Nat n" class="Function">0ₚ</a> <a id="8384" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="8387" href="Data.Nat.Solver.html#8360" class="Bound">env</a> <a id="8391" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="8393" class="Number">0</a>
<a id="8395" href="Data.Nat.Solver.html#8346" data-type="(env : Vec Nat n) → ⟦ 0ₚ ⟧ₚ env ≡ 0" class="Function">sound-0ₚ</a> <a id="8404" href="1Lab.Reflection.html#1836" data-type="Vec A zero" class="InductiveConstructor">[]</a>        <a id="8414" class="Symbol">=</a> <a id="8416" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
<a id="8421" href="Data.Nat.Solver.html#8346" data-type="(env : Vec Nat n) → ⟦ 0ₚ ⟧ₚ env ≡ 0" class="Function">sound-0ₚ</a> <a id="8430" class="Symbol">(</a><a id="8431" href="Data.Nat.Solver.html#8431" class="Bound">x</a> <a id="8433" href="1Lab.Reflection.html#1854" data-type="A → Vec A n → Vec A (suc n)" class="InductiveConstructor Operator">∷</a> <a id="8435" href="Data.Nat.Solver.html#8435" class="Bound">env</a><a id="8438" class="Symbol">)</a> <a id="8440" class="Symbol">=</a> <a id="8442" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
</pre>
<p>We do the same for the constant polynomials:</p>
<pre class="Agda"><a id="sound-constₚ"></a><a id="8506" href="Data.Nat.Solver.html#8506" data-type="(c : Nat) (env : Vec Nat n) → ⟦ constₚ c ⟧ₚ env ≡ c" class="Function">sound-constₚ</a> <a id="8519" class="Symbol">:</a> <a id="8521" class="Symbol">∀</a> <a id="8523" href="Data.Nat.Solver.html#8523" class="Bound">c</a> <a id="8525" class="Symbol">→</a> <a id="8527" class="Symbol">(</a><a id="8528" href="Data.Nat.Solver.html#8528" class="Bound">env</a> <a id="8532" class="Symbol">:</a> <a id="8534" href="1Lab.Reflection.html#1792" data-type="Type ℓ → Nat → Type ℓ" class="Datatype">Vec</a> <a id="8538" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="8542" href="Data.Nat.Solver.html#3049" class="Generalizable">n</a><a id="8543" class="Symbol">)</a> <a id="8545" class="Symbol">→</a> <a id="8547" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="8549" href="Data.Nat.Solver.html#5371" data-type="Nat → Poly Nat n" class="Function">constₚ</a> <a id="8556" href="Data.Nat.Solver.html#8523" class="Bound">c</a> <a id="8558" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="8561" href="Data.Nat.Solver.html#8528" class="Bound">env</a> <a id="8565" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="8567" href="Data.Nat.Solver.html#8523" class="Bound">c</a>
<a id="8569" href="Data.Nat.Solver.html#8506" data-type="(c : Nat) (env : Vec Nat n) → ⟦ constₚ c ⟧ₚ env ≡ c" class="Function">sound-constₚ</a> <a id="8582" href="Data.Nat.Solver.html#8582" class="Bound">c</a> <a id="8584" href="1Lab.Reflection.html#1836" data-type="Vec A zero" class="InductiveConstructor">[]</a> <a id="8587" class="Symbol">=</a> <a id="8589" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
<a id="8594" href="Data.Nat.Solver.html#8506" data-type="(c : Nat) (env : Vec Nat n) → ⟦ constₚ c ⟧ₚ env ≡ c" class="Function">sound-constₚ</a> <a id="8607" href="Data.Nat.Solver.html#8607" class="Bound">c</a> <a id="8609" class="Symbol">(</a><a id="8610" href="Data.Nat.Solver.html#8610" class="Bound">x</a> <a id="8612" href="1Lab.Reflection.html#1854" data-type="A → Vec A n → Vec A (suc n)" class="InductiveConstructor Operator">∷</a> <a id="8614" href="Data.Nat.Solver.html#8614" class="Bound">env</a><a id="8617" class="Symbol">)</a> <a id="8619" class="Symbol">=</a> <a id="8621" href="Data.Nat.Solver.html#8506" data-type="(c : Nat) (env : Vec Nat n) → ⟦ constₚ c ⟧ₚ env ≡ c" class="Function">sound-constₚ</a> <a id="8634" href="Data.Nat.Solver.html#8607" class="Bound">c</a> <a id="8636" href="Data.Nat.Solver.html#8614" class="Bound">env</a>
</pre>
<p>At the risk of repeating ourselves, we also show the same for the
monomial
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">X_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</span></p>
<pre class="Agda"><a id="sound-X[_]"></a><a id="8736" href="Data.Nat.Solver.html#8736" data-type="(i : Fin n) (env : Vec Nat n) → ⟦ X[ i ] ⟧ₚ env ≡ lookup env i" class="Function Operator">sound-X[_]</a> <a id="8747" class="Symbol">:</a> <a id="8749" class="Symbol">∀</a> <a id="8751" href="Data.Nat.Solver.html#8751" class="Bound">i</a> <a id="8753" class="Symbol">→</a> <a id="8755" class="Symbol">(</a><a id="8756" href="Data.Nat.Solver.html#8756" class="Bound">env</a> <a id="8760" class="Symbol">:</a> <a id="8762" href="1Lab.Reflection.html#1792" data-type="Type ℓ → Nat → Type ℓ" class="Datatype">Vec</a> <a id="8766" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="8770" href="Data.Nat.Solver.html#3049" class="Generalizable">n</a><a id="8771" class="Symbol">)</a> <a id="8773" class="Symbol">→</a> <a id="8775" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="8777" href="Data.Nat.Solver.html#5660" data-type="Fin n → Poly Nat n" class="Function Operator">X[</a> <a id="8780" href="Data.Nat.Solver.html#8751" class="Bound">i</a> <a id="8782" href="Data.Nat.Solver.html#5660" data-type="Fin n → Poly Nat n" class="Function Operator">]</a> <a id="8784" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="8787" href="Data.Nat.Solver.html#8756" class="Bound">env</a> <a id="8791" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="8793" href="Data.Nat.Solver.html#3058" data-type="Vec A n → Fin n → A" class="Function">lookup</a> <a id="8800" href="Data.Nat.Solver.html#8756" class="Bound">env</a> <a id="8804" href="Data.Nat.Solver.html#8751" class="Bound">i</a>
<a id="8806" href="Data.Nat.Solver.html#8736" data-type="(i : Fin n) (env : Vec Nat n) → ⟦ X[ i ] ⟧ₚ env ≡ lookup env i" class="Function Operator">sound-X[</a> <a id="8815" href="Data.Fin.Base.html#523" data-type="Fin (suc n)" class="InductiveConstructor">fzero</a> <a id="8821" href="Data.Nat.Solver.html#8736" data-type="(i : Fin n) (env : Vec Nat n) → ⟦ X[ i ] ⟧ₚ env ≡ lookup env i" class="Function Operator">]</a> <a id="8823" class="Symbol">(</a><a id="8824" href="Data.Nat.Solver.html#8824" class="Bound">x₀</a> <a id="8827" href="1Lab.Reflection.html#1854" data-type="A → Vec A n → Vec A (suc n)" class="InductiveConstructor Operator">∷</a> <a id="8829" href="Data.Nat.Solver.html#8829" class="Bound">env</a><a id="8832" class="Symbol">)</a> <a id="8834" class="Symbol">=</a>
  <a id="8838" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="8840" href="Data.Nat.Solver.html#5371" data-type="Nat → Poly Nat n" class="Function">constₚ</a> <a id="8847" class="Number">1</a> <a id="8849" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="8852" href="Data.Nat.Solver.html#8829" class="Bound">env</a> <a id="8856" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="8858" href="Data.Nat.Solver.html#8824" class="Bound">x₀</a> <a id="8861" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="8863" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="8865" href="Data.Nat.Solver.html#5150" data-type="Poly Nat n" class="Function">0ₚ</a> <a id="8868" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="8871" href="Data.Nat.Solver.html#8829" class="Bound">env</a> <span class="reasoning-step"><span class="as-written Function"><a id="8875" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="8878" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="8882" class="Symbol">(λ</a> <a id="8885" href="Data.Nat.Solver.html#8885" class="Bound">ϕ</a> <a id="8887" href="Data.Nat.Solver.html#8887" class="Bound">ψ</a> <a id="8889" class="Symbol">→</a> <a id="8891" href="Data.Nat.Solver.html#8885" class="Bound">ϕ</a> <a id="8893" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="8895" href="Data.Nat.Solver.html#8824" class="Bound">x₀</a> <a id="8898" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="8900" href="Data.Nat.Solver.html#8887" class="Bound">ψ</a><a id="8901" class="Symbol">)</a> <a id="8903" class="Symbol">(</a><a id="8904" href="Data.Nat.Solver.html#8506" data-type="(c : Nat) (env : Vec Nat n) → ⟦ constₚ c ⟧ₚ env ≡ c" class="Function">sound-constₚ</a> <a id="8917" class="Number">1</a> <a id="8919" href="Data.Nat.Solver.html#8829" class="Bound">env</a><a id="8922" class="Symbol">)</a> <a id="8924" class="Symbol">(</a><a id="8925" href="Data.Nat.Solver.html#8346" data-type="(env : Vec Nat n) → ⟦ 0ₚ ⟧ₚ env ≡ 0" class="Function">sound-0ₚ</a> <a id="8934" href="Data.Nat.Solver.html#8829" class="Bound">env</a><a id="8937" class="Symbol">)</a> <a id="8939" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
  <a id="8943" class="Number">1</a> <a id="8945" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="8947" href="Data.Nat.Solver.html#8824" class="Bound">x₀</a> <a id="8950" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="8952" class="Number">0</a>                           <span class="reasoning-step"><span class="as-written Function"><a id="8980" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="8983" href="Data.Nat.Properties.html#746" data-type="(x : Nat) → x + 0 ≡ x" class="Function">+-zeror</a> <a id="8991" class="Symbol">(</a><a id="8992" class="Number">1</a> <a id="8994" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="8996" href="Data.Nat.Solver.html#8824" class="Bound">x₀</a><a id="8998" class="Symbol">)</a> <a id="9000" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
  <a id="9004" class="Number">1</a> <a id="9006" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="9008" href="Data.Nat.Solver.html#8824" class="Bound">x₀</a>                               <span class="reasoning-step"><span class="as-written Function"><a id="9041" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="9044" href="Data.Nat.Properties.html#1948" data-type="(x : Nat) → 1 * x ≡ x" class="Function">*-onel</a> <a id="9051" href="Data.Nat.Solver.html#8824" class="Bound">x₀</a> <a id="9054" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
  <a id="9058" href="Data.Nat.Solver.html#8824" class="Bound">x₀</a> <a id="9061" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
<a id="9063" href="Data.Nat.Solver.html#8736" data-type="(i : Fin n) (env : Vec Nat n) → ⟦ X[ i ] ⟧ₚ env ≡ lookup env i" class="Function Operator">sound-X[</a> <a id="9072" href="Data.Fin.Base.html#553" data-type="Fin n → Fin (suc n)" class="InductiveConstructor">fsuc</a> <a id="9077" href="Data.Nat.Solver.html#9077" class="Bound">i</a> <a id="9079" href="Data.Nat.Solver.html#8736" data-type="(i : Fin n) (env : Vec Nat n) → ⟦ X[ i ] ⟧ₚ env ≡ lookup env i" class="Function Operator">]</a> <a id="9081" class="Symbol">(_</a> <a id="9084" href="1Lab.Reflection.html#1854" data-type="A → Vec A n → Vec A (suc n)" class="InductiveConstructor Operator">∷</a> <a id="9086" href="Data.Nat.Solver.html#9086" class="Bound">env</a><a id="9089" class="Symbol">)</a> <a id="9091" class="Symbol">=</a> <a id="9093" href="Data.Nat.Solver.html#8736" data-type="(i : Fin n) (env : Vec Nat n) → ⟦ X[ i ] ⟧ₚ env ≡ lookup env i" class="Function Operator">sound-X[</a> <a id="9102" href="Data.Nat.Solver.html#9077" class="Bound">i</a> <a id="9104" href="Data.Nat.Solver.html#8736" data-type="(i : Fin n) (env : Vec Nat n) → ⟦ X[ i ] ⟧ₚ env ≡ lookup env i" class="Function Operator">]</a> <a id="9106" href="Data.Nat.Solver.html#9086" class="Bound">env</a>
</pre>
<p>Now, for something more involved: let’s show that addition of
polynomials really deserves the name “addition” — under the semantics
mapping
<span class="Agda"><a href="Data.Nat.Solver.html#7927" class="Function Operator">⟦_⟧ₚ</a></span>,
adding two polynomials then evaluating is the same thing as evaluating
each then adding the results.</p>
<pre class="Agda"><a id="sound-+ₚ"></a><a id="9382" href="Data.Nat.Solver.html#9382" data-type="(p q : Poly Nat n) (env : Vec Nat n) →
⟦ p +ₚ q ⟧ₚ env ≡ ⟦ p ⟧ₚ env + ⟦ q ⟧ₚ env" class="Function">sound-+ₚ</a> <a id="9391" class="Symbol">:</a> <a id="9393" class="Symbol">∀</a> <a id="9395" href="Data.Nat.Solver.html#9395" class="Bound">p</a> <a id="9397" href="Data.Nat.Solver.html#9397" class="Bound">q</a> <a id="9399" class="Symbol">→</a> <a id="9401" class="Symbol">(</a><a id="9402" href="Data.Nat.Solver.html#9402" class="Bound">env</a> <a id="9406" class="Symbol">:</a> <a id="9408" href="1Lab.Reflection.html#1792" data-type="Type ℓ → Nat → Type ℓ" class="Datatype">Vec</a> <a id="9412" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="9416" href="Data.Nat.Solver.html#3049" class="Generalizable">n</a><a id="9417" class="Symbol">)</a>
           <a id="9430" class="Symbol">→</a> <a id="9432" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="9434" href="Data.Nat.Solver.html#9395" class="Bound">p</a> <a id="9436" href="Data.Nat.Solver.html#5927" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">+ₚ</a> <a id="9439" href="Data.Nat.Solver.html#9397" class="Bound">q</a> <a id="9441" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="9444" href="Data.Nat.Solver.html#9402" class="Bound">env</a> <a id="9448" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="9450" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="9452" href="Data.Nat.Solver.html#9395" class="Bound">p</a> <a id="9454" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="9457" href="Data.Nat.Solver.html#9402" class="Bound">env</a> <a id="9461" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="9463" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="9465" href="Data.Nat.Solver.html#9397" class="Bound">q</a> <a id="9467" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="9470" href="Data.Nat.Solver.html#9402" class="Bound">env</a>
<a id="9474" href="Data.Nat.Solver.html#9382" data-type="(p q : Poly Nat n) (env : Vec Nat n) →
⟦ p +ₚ q ⟧ₚ env ≡ ⟦ p ⟧ₚ env + ⟦ q ⟧ₚ env" class="Function">sound-+ₚ</a> <a id="9483" class="Symbol">(</a><a id="9484" href="Data.Nat.Solver.html#1762" data-type="A → Poly A 0" class="InductiveConstructor">const</a> <a id="9490" href="Data.Nat.Solver.html#9490" class="Bound">c1</a><a id="9492" class="Symbol">)</a> <a id="9494" class="Symbol">(</a><a id="9495" href="Data.Nat.Solver.html#1762" data-type="A → Poly A 0" class="InductiveConstructor">const</a> <a id="9501" href="Data.Nat.Solver.html#9501" class="Bound">c2</a><a id="9503" class="Symbol">)</a> <a id="9505" href="Data.Nat.Solver.html#9505" class="Bound">env</a> <a id="9509" class="Symbol">=</a> <a id="9511" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
<a id="9516" href="Data.Nat.Solver.html#9382" data-type="(p q : Poly Nat n) (env : Vec Nat n) →
⟦ p +ₚ q ⟧ₚ env ≡ ⟦ p ⟧ₚ env + ⟦ q ⟧ₚ env" class="Function">sound-+ₚ</a> <a id="9525" href="Data.Nat.Solver.html#2151" data-type="Poly A (suc n)" class="InductiveConstructor">zerop</a> <a id="9531" href="Data.Nat.Solver.html#9531" class="Bound">q</a> <a id="9533" href="Data.Nat.Solver.html#9533" class="Bound">env</a> <a id="9537" class="Symbol">=</a> <a id="9539" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
<a id="9544" href="Data.Nat.Solver.html#9382" data-type="(p q : Poly Nat n) (env : Vec Nat n) →
⟦ p +ₚ q ⟧ₚ env ≡ ⟦ p ⟧ₚ env + ⟦ q ⟧ₚ env" class="Function">sound-+ₚ</a> <a id="9553" class="Symbol">(</a><a id="9554" href="Data.Nat.Solver.html#9554" class="Bound">p</a> <a id="9556" href="Data.Nat.Solver.html#2904" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="9560" href="Data.Nat.Solver.html#9560" class="Bound">r</a><a id="9561" class="Symbol">)</a> <a id="9563" href="Data.Nat.Solver.html#2151" data-type="Poly A (suc n)" class="InductiveConstructor">zerop</a> <a id="9569" href="Data.Nat.Solver.html#9569" class="Bound">env</a> <a id="9573" class="Symbol">=</a>
  <a id="9577" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="9581" class="Symbol">(</a><a id="9582" href="Data.Nat.Properties.html#746" data-type="(x : Nat) → x + 0 ≡ x" class="Function">+-zeror</a> <a id="9590" class="Symbol">(</a><a id="9591" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="9593" class="Symbol">(</a><a id="9594" href="Data.Nat.Solver.html#9554" class="Bound">p</a> <a id="9596" href="Data.Nat.Solver.html#2904" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="9600" href="Data.Nat.Solver.html#9560" class="Bound">r</a><a id="9601" class="Symbol">)</a> <a id="9603" href="Data.Nat.Solver.html#5927" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">+ₚ</a> <a id="9606" href="Data.Nat.Solver.html#2151" data-type="Poly A (suc n)" class="InductiveConstructor">zerop</a> <a id="9612" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="9615" href="Data.Nat.Solver.html#9569" class="Bound">env</a><a id="9618" class="Symbol">))</a>
<a id="9621" href="Data.Nat.Solver.html#9382" data-type="(p q : Poly Nat n) (env : Vec Nat n) →
⟦ p +ₚ q ⟧ₚ env ≡ ⟦ p ⟧ₚ env + ⟦ q ⟧ₚ env" class="Function">sound-+ₚ</a> <a id="9630" class="Symbol">(</a><a id="9631" href="Data.Nat.Solver.html#9631" class="Bound">p</a> <a id="9633" href="Data.Nat.Solver.html#2904" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="9637" href="Data.Nat.Solver.html#9637" class="Bound">r</a><a id="9638" class="Symbol">)</a> <a id="9640" class="Symbol">(</a><a id="9641" href="Data.Nat.Solver.html#9641" class="Bound">q</a> <a id="9643" href="Data.Nat.Solver.html#2904" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="9647" href="Data.Nat.Solver.html#9647" class="Bound">s</a><a id="9648" class="Symbol">)</a> <a id="9650" class="Symbol">(</a><a id="9651" href="Data.Nat.Solver.html#9651" class="Bound">x₀</a> <a id="9654" href="1Lab.Reflection.html#1854" data-type="A → Vec A n → Vec A (suc n)" class="InductiveConstructor Operator">∷</a> <a id="9656" href="Data.Nat.Solver.html#9656" class="Bound">env</a><a id="9659" class="Symbol">)</a> <a id="9661" class="Symbol">=</a>
  <a id="9665" href="Data.Nat.Solver.html#10003" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p+q⟧</a> <a id="9671" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="9673" href="Data.Nat.Solver.html#9651" class="Bound">x₀</a> <a id="9676" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="9678" href="Data.Nat.Solver.html#10038" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r+s⟧</a>                <span class="reasoning-step"><span class="as-written Function"><a id="9699" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="9702" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="9706" class="Symbol">(λ</a> <a id="9709" href="Data.Nat.Solver.html#9709" class="Bound">ϕ</a> <a id="9711" href="Data.Nat.Solver.html#9711" class="Bound">ψ</a> <a id="9713" class="Symbol">→</a> <a id="9715" href="Data.Nat.Solver.html#9709" class="Bound">ϕ</a> <a id="9717" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="9719" href="Data.Nat.Solver.html#9651" class="Bound">x₀</a> <a id="9722" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="9724" href="Data.Nat.Solver.html#9711" class="Bound">ψ</a><a id="9725" class="Symbol">)</a> <a id="9727" class="Symbol">(</a><a id="9728" href="Data.Nat.Solver.html#9382" data-type="(p q : Poly Nat n) (env : Vec Nat n) →
⟦ p +ₚ q ⟧ₚ env ≡ ⟦ p ⟧ₚ env + ⟦ q ⟧ₚ env" class="Function">sound-+ₚ</a> <a id="9737" href="Data.Nat.Solver.html#9631" class="Bound">p</a> <a id="9739" href="Data.Nat.Solver.html#9641" class="Bound">q</a> <a id="9741" class="Symbol">(</a><a id="9742" href="Data.Nat.Solver.html#9651" class="Bound">x₀</a> <a id="9745" href="1Lab.Reflection.html#1854" data-type="A → Vec A n → Vec A (suc n)" class="InductiveConstructor Operator">∷</a> <a id="9747" href="Data.Nat.Solver.html#9656" class="Bound">env</a><a id="9750" class="Symbol">))</a> <a id="9753" class="Symbol">(</a><a id="9754" href="Data.Nat.Solver.html#9382" data-type="(p q : Poly Nat n) (env : Vec Nat n) →
⟦ p +ₚ q ⟧ₚ env ≡ ⟦ p ⟧ₚ env + ⟦ q ⟧ₚ env" class="Function">sound-+ₚ</a> <a id="9763" href="Data.Nat.Solver.html#9637" class="Bound">r</a> <a id="9765" href="Data.Nat.Solver.html#9647" class="Bound">s</a> <a id="9767" href="Data.Nat.Solver.html#9656" class="Bound">env</a><a id="9770" class="Symbol">)</a> <a id="9772" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
  <a id="9776" class="Symbol">(</a><a id="9777" href="Data.Nat.Solver.html#10066" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="9781" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="9783" href="Data.Nat.Solver.html#10115" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a><a id="9786" class="Symbol">)</a> <a id="9788" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="9790" href="Data.Nat.Solver.html#9651" class="Bound">x₀</a> <a id="9793" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="9795" class="Symbol">(</a><a id="9796" href="Data.Nat.Solver.html#10094" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="9800" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="9802" href="Data.Nat.Solver.html#10143" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a><a id="9805" class="Symbol">)</a>    <span class="reasoning-step"><span class="as-written Function"><a id="9810" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="9813" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="9816" class="Symbol">(λ</a> <a id="9819" href="Data.Nat.Solver.html#9819" class="Bound">ϕ</a> <a id="9821" class="Symbol">→</a> <a id="9823" href="Data.Nat.Solver.html#9819" class="Bound">ϕ</a> <a id="9825" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="9827" class="Symbol">(</a><a id="9828" href="Data.Nat.Solver.html#10094" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="9832" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="9834" href="Data.Nat.Solver.html#10143" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a><a id="9837" class="Symbol">))</a> <a id="9840" class="Symbol">(</a><a id="9841" href="Data.Nat.Properties.html#1218" data-type="(x y z : Nat) → (x + y) * z ≡ x * z + y * z" class="Function">*-distrib-+r</a> <a id="9854" href="Data.Nat.Solver.html#10066" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="9858" href="Data.Nat.Solver.html#10115" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="9862" href="Data.Nat.Solver.html#9651" class="Bound">x₀</a><a id="9864" class="Symbol">)</a> <a id="9866" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
  <a id="9870" href="Data.Nat.Solver.html#10066" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="9874" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="9876" href="Data.Nat.Solver.html#9651" class="Bound">x₀</a> <a id="9879" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="9881" href="Data.Nat.Solver.html#10115" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="9885" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="9887" href="Data.Nat.Solver.html#9651" class="Bound">x₀</a> <a id="9890" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="9892" class="Symbol">(</a><a id="9893" href="Data.Nat.Solver.html#10094" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="9897" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="9899" href="Data.Nat.Solver.html#10143" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a><a id="9902" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function"><a id="9904" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="9907" href="Data.Nat.Solver.html#3276" data-type="(w x y z : Nat) → w + x + (y + z) ≡ w + y + (x + z)" class="Function">commute-inner</a> <a id="9921" class="Symbol">(</a><a id="9922" href="Data.Nat.Solver.html#10066" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="9926" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="9928" href="Data.Nat.Solver.html#9651" class="Bound">x₀</a><a id="9930" class="Symbol">)</a> <a id="9932" class="Symbol">(</a><a id="9933" href="Data.Nat.Solver.html#10115" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="9937" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="9939" href="Data.Nat.Solver.html#9651" class="Bound">x₀</a><a id="9941" class="Symbol">)</a> <a id="9943" href="Data.Nat.Solver.html#10094" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="9947" href="Data.Nat.Solver.html#10143" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a> <a id="9951" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
  <a id="9955" href="Data.Nat.Solver.html#10066" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="9959" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="9961" href="Data.Nat.Solver.html#9651" class="Bound">x₀</a> <a id="9964" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="9966" href="Data.Nat.Solver.html#10094" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="9970" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="9972" class="Symbol">(</a><a id="9973" href="Data.Nat.Solver.html#10115" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="9977" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="9979" href="Data.Nat.Solver.html#9651" class="Bound">x₀</a> <a id="9982" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="9984" href="Data.Nat.Solver.html#10143" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a><a id="9987" class="Symbol">)</a> <a id="9989" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
  <a id="9993" class="Keyword">where</a>
    <a id="10003" href="Data.Nat.Solver.html#10003" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p+q⟧</a> <a id="10009" class="Symbol">=</a> <a id="10011" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="10013" href="Data.Nat.Solver.html#9631" class="Bound">p</a> <a id="10015" href="Data.Nat.Solver.html#5927" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">+ₚ</a> <a id="10018" href="Data.Nat.Solver.html#9641" class="Bound">q</a> <a id="10020" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="10023" class="Symbol">(</a><a id="10024" href="Data.Nat.Solver.html#9651" class="Bound">x₀</a> <a id="10027" href="1Lab.Reflection.html#1854" data-type="A → Vec A n → Vec A (suc n)" class="InductiveConstructor Operator">∷</a> <a id="10029" href="Data.Nat.Solver.html#9656" class="Bound">env</a><a id="10032" class="Symbol">)</a>
    <a id="10038" href="Data.Nat.Solver.html#10038" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r+s⟧</a> <a id="10044" class="Symbol">=</a> <a id="10046" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="10048" href="Data.Nat.Solver.html#9637" class="Bound">r</a> <a id="10050" href="Data.Nat.Solver.html#5927" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">+ₚ</a> <a id="10053" href="Data.Nat.Solver.html#9647" class="Bound">s</a> <a id="10055" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="10058" href="Data.Nat.Solver.html#9656" class="Bound">env</a>
    <a id="10066" href="Data.Nat.Solver.html#10066" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="10070" class="Symbol">=</a> <a id="10072" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="10074" href="Data.Nat.Solver.html#9631" class="Bound">p</a> <a id="10076" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="10079" class="Symbol">(</a><a id="10080" href="Data.Nat.Solver.html#9651" class="Bound">x₀</a> <a id="10083" href="1Lab.Reflection.html#1854" data-type="A → Vec A n → Vec A (suc n)" class="InductiveConstructor Operator">∷</a> <a id="10085" href="Data.Nat.Solver.html#9656" class="Bound">env</a><a id="10088" class="Symbol">)</a>
    <a id="10094" href="Data.Nat.Solver.html#10094" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="10098" class="Symbol">=</a> <a id="10100" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="10102" href="Data.Nat.Solver.html#9637" class="Bound">r</a> <a id="10104" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="10107" href="Data.Nat.Solver.html#9656" class="Bound">env</a>
    <a id="10115" href="Data.Nat.Solver.html#10115" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="10119" class="Symbol">=</a> <a id="10121" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="10123" href="Data.Nat.Solver.html#9641" class="Bound">q</a> <a id="10125" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="10128" class="Symbol">(</a><a id="10129" href="Data.Nat.Solver.html#9651" class="Bound">x₀</a> <a id="10132" href="1Lab.Reflection.html#1854" data-type="A → Vec A n → Vec A (suc n)" class="InductiveConstructor Operator">∷</a> <a id="10134" href="Data.Nat.Solver.html#9656" class="Bound">env</a><a id="10137" class="Symbol">)</a>
    <a id="10143" href="Data.Nat.Solver.html#10143" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a> <a id="10147" class="Symbol">=</a> <a id="10149" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="10151" href="Data.Nat.Solver.html#9647" class="Bound">s</a> <a id="10153" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="10156" href="Data.Nat.Solver.html#9656" class="Bound">env</a>
</pre>
<p>Wow, that was a bit painful! This is a common theme when writing
proof automation: it distills down a lot of the annoying proofs we need
to write across the entire codebase into one <em>extremely</em> painful
proof. Thus, conservation of frustration is preserved.</p>
<p>Philisophical reflections aside, let’s move onto multiplication of
polynomials. As the homogenous and heterogeneous multiplication were
defined in a mutually recursive manner, we must do so for their proofs
of soundness as well.</p>
<pre class="Agda"><a id="sound-*ₚ"></a><a id="10662" href="Data.Nat.Solver.html#10662" data-type="(p q : Poly Nat n) (env : Vec Nat n) →
⟦ p *ₚ q ⟧ₚ env ≡ ⟦ p ⟧ₚ env * ⟦ q ⟧ₚ env" class="Function">sound-*ₚ</a>
  <a id="10673" class="Symbol">:</a> <a id="10675" class="Symbol">∀</a> <a id="10677" href="Data.Nat.Solver.html#10677" class="Bound">p</a> <a id="10679" href="Data.Nat.Solver.html#10679" class="Bound">q</a> <a id="10681" class="Symbol">→</a> <a id="10683" class="Symbol">(</a><a id="10684" href="Data.Nat.Solver.html#10684" class="Bound">env</a> <a id="10688" class="Symbol">:</a> <a id="10690" href="1Lab.Reflection.html#1792" data-type="Type ℓ → Nat → Type ℓ" class="Datatype">Vec</a> <a id="10694" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="10698" href="Data.Nat.Solver.html#3049" class="Generalizable">n</a><a id="10699" class="Symbol">)</a>
  <a id="10703" class="Symbol">→</a> <a id="10705" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="10707" href="Data.Nat.Solver.html#10677" class="Bound">p</a> <a id="10709" href="Data.Nat.Solver.html#6444" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">*ₚ</a> <a id="10712" href="Data.Nat.Solver.html#10679" class="Bound">q</a> <a id="10714" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="10717" href="Data.Nat.Solver.html#10684" class="Bound">env</a> <a id="10721" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="10723" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="10725" href="Data.Nat.Solver.html#10677" class="Bound">p</a> <a id="10727" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="10730" href="Data.Nat.Solver.html#10684" class="Bound">env</a> <a id="10734" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="10736" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="10738" href="Data.Nat.Solver.html#10679" class="Bound">q</a> <a id="10740" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="10743" href="Data.Nat.Solver.html#10684" class="Bound">env</a>
<a id="sound-*ₚ′"></a><a id="10747" href="Data.Nat.Solver.html#10747" data-type="(p : Poly Nat n) (q : Poly Nat (suc n)) (x₀ : Nat)
(env : Vec Nat n) →
⟦ p *ₚ′ q ⟧ₚ (x₀ ∷ env) ≡ ⟦ p ⟧ₚ env * ⟦ q ⟧ₚ (x₀ ∷ env)" class="Function">sound-*ₚ′</a>
  <a id="10759" class="Symbol">:</a> <a id="10761" class="Symbol">∀</a> <a id="10763" href="Data.Nat.Solver.html#10763" class="Bound">p</a> <a id="10765" href="Data.Nat.Solver.html#10765" class="Bound">q</a> <a id="10767" class="Symbol">→</a> <a id="10769" class="Symbol">(</a><a id="10770" href="Data.Nat.Solver.html#10770" class="Bound">x₀</a> <a id="10773" class="Symbol">:</a> <a id="10775" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a><a id="10778" class="Symbol">)</a> <a id="10780" class="Symbol">→</a> <a id="10782" class="Symbol">(</a><a id="10783" href="Data.Nat.Solver.html#10783" class="Bound">env</a> <a id="10787" class="Symbol">:</a> <a id="10789" href="1Lab.Reflection.html#1792" data-type="Type ℓ → Nat → Type ℓ" class="Datatype">Vec</a> <a id="10793" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="10797" href="Data.Nat.Solver.html#3049" class="Generalizable">n</a><a id="10798" class="Symbol">)</a>
  <a id="10802" class="Symbol">→</a> <a id="10804" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="10806" href="Data.Nat.Solver.html#10763" class="Bound">p</a> <a id="10808" href="Data.Nat.Solver.html#6488" data-type="Poly Nat n → Poly Nat (suc n) → Poly Nat (suc n)" class="Function Operator">*ₚ′</a> <a id="10812" href="Data.Nat.Solver.html#10765" class="Bound">q</a> <a id="10814" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="10817" class="Symbol">(</a><a id="10818" href="Data.Nat.Solver.html#10770" class="Bound">x₀</a> <a id="10821" class="InductiveConstructor Operator">∷</a> <a id="10823" href="Data.Nat.Solver.html#10783" class="Bound">env</a><a id="10826" class="Symbol">)</a> <a id="10828" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="10830" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="10832" href="Data.Nat.Solver.html#10763" class="Bound">p</a> <a id="10834" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="10837" href="Data.Nat.Solver.html#10783" class="Bound">env</a> <a id="10841" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="10843" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="10845" href="Data.Nat.Solver.html#10765" class="Bound">q</a> <a id="10847" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="10850" class="Symbol">(</a><a id="10851" href="Data.Nat.Solver.html#10770" class="Bound">x₀</a> <a id="10854" class="InductiveConstructor Operator">∷</a> <a id="10856" href="Data.Nat.Solver.html#10783" class="Bound">env</a><a id="10859" class="Symbol">)</a>
</pre>
<p>The first couple of cases of homogenous multiplication don’t look so
bad…</p>
<pre class="Agda"><a id="10951" href="Data.Nat.Solver.html#10662" data-type="(p q : Poly Nat n) (env : Vec Nat n) →
⟦ p *ₚ q ⟧ₚ env ≡ ⟦ p ⟧ₚ env * ⟦ q ⟧ₚ env" class="Function">sound-*ₚ</a> <a id="10960" class="Symbol">(</a><a id="10961" href="Data.Nat.Solver.html#1762" data-type="A → Poly A 0" class="InductiveConstructor">const</a> <a id="10967" href="Data.Nat.Solver.html#10967" class="Bound">c1</a><a id="10969" class="Symbol">)</a> <a id="10971" class="Symbol">(</a><a id="10972" href="Data.Nat.Solver.html#1762" data-type="A → Poly A 0" class="InductiveConstructor">const</a> <a id="10978" href="Data.Nat.Solver.html#10978" class="Bound">c2</a><a id="10980" class="Symbol">)</a> <a id="10982" href="Data.Nat.Solver.html#10982" class="Bound">env</a> <a id="10986" class="Symbol">=</a> <a id="10988" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
<a id="10993" href="Data.Nat.Solver.html#10662" data-type="(p q : Poly Nat n) (env : Vec Nat n) →
⟦ p *ₚ q ⟧ₚ env ≡ ⟦ p ⟧ₚ env * ⟦ q ⟧ₚ env" class="Function">sound-*ₚ</a> <a id="11002" href="Data.Nat.Solver.html#2151" data-type="Poly A (suc n)" class="InductiveConstructor">zerop</a> <a id="11008" href="Data.Nat.Solver.html#11008" class="Bound">q</a> <a id="11010" href="Data.Nat.Solver.html#11010" class="Bound">env</a> <a id="11014" class="Symbol">=</a> <a id="11016" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
<a id="11021" href="Data.Nat.Solver.html#10662" data-type="(p q : Poly Nat n) (env : Vec Nat n) →
⟦ p *ₚ q ⟧ₚ env ≡ ⟦ p ⟧ₚ env * ⟦ q ⟧ₚ env" class="Function">sound-*ₚ</a> <a id="11030" class="Symbol">(</a><a id="11031" href="Data.Nat.Solver.html#11031" class="Bound">p</a> <a id="11033" href="Data.Nat.Solver.html#2904" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="11037" href="Data.Nat.Solver.html#11037" class="Bound">r</a><a id="11038" class="Symbol">)</a> <a id="11040" href="Data.Nat.Solver.html#2151" data-type="Poly A (suc n)" class="InductiveConstructor">zerop</a> <a id="11046" class="Symbol">(</a><a id="11047" href="Data.Nat.Solver.html#11047" class="Bound">x₀</a> <a id="11050" href="1Lab.Reflection.html#1854" data-type="A → Vec A n → Vec A (suc n)" class="InductiveConstructor Operator">∷</a> <a id="11052" href="Data.Nat.Solver.html#11052" class="Bound">env</a><a id="11055" class="Symbol">)</a> <a id="11057" class="Symbol">=</a>
  <a id="11061" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="11063" href="Data.Nat.Solver.html#11031" class="Bound">p</a> <a id="11065" href="Data.Nat.Solver.html#6444" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">*ₚ</a> <a id="11068" href="Data.Nat.Solver.html#2151" data-type="Poly A (suc n)" class="InductiveConstructor">zerop</a> <a id="11074" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="11077" class="Symbol">(</a><a id="11078" href="Data.Nat.Solver.html#11047" class="Bound">x₀</a> <a id="11081" href="1Lab.Reflection.html#1854" data-type="A → Vec A n → Vec A (suc n)" class="InductiveConstructor Operator">∷</a> <a id="11083" href="Data.Nat.Solver.html#11052" class="Bound">env</a><a id="11086" class="Symbol">)</a> <a id="11088" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="11090" href="Data.Nat.Solver.html#11047" class="Bound">x₀</a> <a id="11093" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="11095" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="11097" href="Data.Nat.Solver.html#5150" data-type="Poly Nat n" class="Function">0ₚ</a> <a id="11100" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="11103" href="Data.Nat.Solver.html#11052" class="Bound">env</a> <span class="reasoning-step"><span class="as-written Function"><a id="11107" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="11110" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="11114" class="Symbol">(λ</a> <a id="11117" href="Data.Nat.Solver.html#11117" class="Bound">ϕ</a> <a id="11119" href="Data.Nat.Solver.html#11119" class="Bound">ψ</a> <a id="11121" class="Symbol">→</a> <a id="11123" href="Data.Nat.Solver.html#11117" class="Bound">ϕ</a> <a id="11125" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="11127" href="Data.Nat.Solver.html#11047" class="Bound">x₀</a> <a id="11130" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="11132" href="Data.Nat.Solver.html#11119" class="Bound">ψ</a><a id="11133" class="Symbol">)</a> <a id="11135" class="Symbol">(</a><a id="11136" href="Data.Nat.Solver.html#10662" data-type="(p q : Poly Nat n) (env : Vec Nat n) →
⟦ p *ₚ q ⟧ₚ env ≡ ⟦ p ⟧ₚ env * ⟦ q ⟧ₚ env" class="Function">sound-*ₚ</a> <a id="11145" href="Data.Nat.Solver.html#11031" class="Bound">p</a> <a id="11147" href="Data.Nat.Solver.html#2151" data-type="Poly A (suc n)" class="InductiveConstructor">zerop</a> <a id="11153" class="Symbol">(</a><a id="11154" href="Data.Nat.Solver.html#11047" class="Bound">x₀</a> <a id="11157" href="1Lab.Reflection.html#1854" data-type="A → Vec A n → Vec A (suc n)" class="InductiveConstructor Operator">∷</a> <a id="11159" href="Data.Nat.Solver.html#11052" class="Bound">env</a><a id="11162" class="Symbol">))</a> <a id="11165" class="Symbol">(</a><a id="11166" href="Data.Nat.Solver.html#8346" data-type="(env : Vec Nat n) → ⟦ 0ₚ ⟧ₚ env ≡ 0" class="Function">sound-0ₚ</a> <a id="11175" href="Data.Nat.Solver.html#11052" class="Bound">env</a><a id="11178" class="Symbol">)</a> <a id="11180" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
  <a id="11184" href="Data.Nat.Solver.html#11389" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="11188" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="11190" class="Number">0</a> <a id="11192" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="11194" href="Data.Nat.Solver.html#11047" class="Bound">x₀</a> <a id="11197" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="11199" class="Number">0</a>                              <span class="reasoning-step"><span class="as-written Function"><a id="11230" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="11233" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="11236" class="Symbol">(λ</a> <a id="11239" href="Data.Nat.Solver.html#11239" class="Bound">ϕ</a> <a id="11241" class="Symbol">→</a> <a id="11243" class="Symbol">(</a><a id="11244" href="Data.Nat.Solver.html#11239" class="Bound">ϕ</a> <a id="11246" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="11248" href="Data.Nat.Solver.html#11047" class="Bound">x₀</a><a id="11250" class="Symbol">)</a> <a id="11252" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="11254" class="Number">0</a><a id="11255" class="Symbol">)</a> <a id="11257" class="Symbol">(</a><a id="11258" href="Data.Nat.Properties.html#2122" data-type="(x : Nat) → x * 0 ≡ 0" class="Function">*-zeror</a> <a id="11266" href="Data.Nat.Solver.html#11389" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a><a id="11269" class="Symbol">)</a> <a id="11271" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
  <a id="11275" class="Number">0</a>                                             <span class="reasoning-step"><span class="as-written Function Operator"><a id="11321" href="1Lab.Path.html#46783" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">≡˘⟨</a> <a id="11325" href="Data.Nat.Properties.html#2122" data-type="(x : Nat) → x * 0 ≡ 0" class="Function">*-zeror</a> <a id="11333" class="Symbol">(</a><a id="11334" href="Data.Nat.Solver.html#11389" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="11338" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="11340" href="Data.Nat.Solver.html#11047" class="Bound">x₀</a> <a id="11343" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="11345" href="Data.Nat.Solver.html#11417" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a><a id="11348" class="Symbol">)</a> <a id="11350" href="1Lab.Path.html#46783" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡˘</span></span>
  <a id="11354" class="Symbol">(</a><a id="11355" href="Data.Nat.Solver.html#11389" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="11359" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="11361" href="Data.Nat.Solver.html#11047" class="Bound">x₀</a> <a id="11364" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="11366" href="Data.Nat.Solver.html#11417" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a><a id="11369" class="Symbol">)</a> <a id="11371" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="11373" class="Number">0</a> <a id="11375" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
  <a id="11379" class="Keyword">where</a>
    <a id="11389" href="Data.Nat.Solver.html#11389" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="11393" class="Symbol">=</a> <a id="11395" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="11397" href="Data.Nat.Solver.html#11031" class="Bound">p</a> <a id="11399" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="11402" class="Symbol">(</a><a id="11403" href="Data.Nat.Solver.html#11047" class="Bound">x₀</a> <a id="11406" href="1Lab.Reflection.html#1854" data-type="A → Vec A n → Vec A (suc n)" class="InductiveConstructor Operator">∷</a> <a id="11408" href="Data.Nat.Solver.html#11052" class="Bound">env</a><a id="11411" class="Symbol">)</a>
    <a id="11417" href="Data.Nat.Solver.html#11417" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="11421" class="Symbol">=</a> <a id="11423" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="11425" href="Data.Nat.Solver.html#11037" class="Bound">r</a> <a id="11427" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="11430" href="Data.Nat.Solver.html#11052" class="Bound">env</a>
</pre>
<p>However, the case where we need to distribute is not so easy. The
consists of repeatedly expanding out the polynomial operations into
those on natural numbers, then doing a brutal bit of symbol shuffling.
There’s not too much to be gained from dwelling on this, so let’s move
on.</p>
<pre class="Agda"><a id="11728" href="Data.Nat.Solver.html#10662" data-type="(p q : Poly Nat n) (env : Vec Nat n) →
⟦ p *ₚ q ⟧ₚ env ≡ ⟦ p ⟧ₚ env * ⟦ q ⟧ₚ env" class="Function">sound-*ₚ</a> <a id="11737" class="Symbol">(</a><a id="11738" href="Data.Nat.Solver.html#11738" class="Bound">p</a> <a id="11740" href="Data.Nat.Solver.html#2904" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="11744" href="Data.Nat.Solver.html#11744" class="Bound">r</a><a id="11745" class="Symbol">)</a> <a id="11747" class="Symbol">(</a><a id="11748" href="Data.Nat.Solver.html#11748" class="Bound">q</a> <a id="11750" href="Data.Nat.Solver.html#2904" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="11754" href="Data.Nat.Solver.html#11754" class="Bound">s</a><a id="11755" class="Symbol">)</a> <a id="11757" class="Symbol">(</a><a id="11758" href="Data.Nat.Solver.html#11758" class="Bound">x₀</a> <a id="11761" href="1Lab.Reflection.html#1854" data-type="A → Vec A n → Vec A (suc n)" class="InductiveConstructor Operator">∷</a> <a id="11763" href="Data.Nat.Solver.html#11763" class="Bound">env</a><a id="11766" class="Symbol">)</a> <a id="11768" class="Symbol">=</a>
  <a id="11772" href="Data.Nat.Solver.html#13281" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p*⟨qx+s⟩+r*q⟧</a> <a id="11787" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="11789" href="Data.Nat.Solver.html#11758" class="Bound">x₀</a> <a id="11792" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="11794" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="11796" href="Data.Nat.Solver.html#5150" data-type="Poly Nat n" class="Function">0ₚ</a> <a id="11799" href="Data.Nat.Solver.html#5927" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">+ₚ</a> <a id="11802" class="Symbol">(</a><a id="11803" href="Data.Nat.Solver.html#11744" class="Bound">r</a> <a id="11805" href="Data.Nat.Solver.html#6444" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">*ₚ</a> <a id="11808" href="Data.Nat.Solver.html#11754" class="Bound">s</a><a id="11809" class="Symbol">)</a> <a id="11811" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="11814" href="Data.Nat.Solver.html#11763" class="Bound">env</a>                <span class="reasoning-step"><span class="as-written Function"><a id="11833" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="11836" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="11839" class="Symbol">(λ</a> <a id="11842" href="Data.Nat.Solver.html#11842" class="Bound">ϕ</a> <a id="11844" class="Symbol">→</a> <a id="11846" href="Data.Nat.Solver.html#13281" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p*⟨qx+s⟩+r*q⟧</a> <a id="11861" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="11863" href="Data.Nat.Solver.html#11758" class="Bound">x₀</a> <a id="11866" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="11868" href="Data.Nat.Solver.html#11842" class="Bound">ϕ</a><a id="11869" class="Symbol">)</a> <a id="11871" class="Symbol">(</a><a id="11872" href="Data.Nat.Solver.html#9382" data-type="(p q : Poly Nat n) (env : Vec Nat n) →
⟦ p +ₚ q ⟧ₚ env ≡ ⟦ p ⟧ₚ env + ⟦ q ⟧ₚ env" class="Function">sound-+ₚ</a> <a id="11881" href="Data.Nat.Solver.html#5150" data-type="Poly Nat n" class="Function">0ₚ</a> <a id="11884" class="Symbol">(</a><a id="11885" href="Data.Nat.Solver.html#11744" class="Bound">r</a> <a id="11887" href="Data.Nat.Solver.html#6444" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">*ₚ</a> <a id="11890" href="Data.Nat.Solver.html#11754" class="Bound">s</a><a id="11891" class="Symbol">)</a> <a id="11893" href="Data.Nat.Solver.html#11763" class="Bound">env</a><a id="11896" class="Symbol">)</a> <a id="11898" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
  <a id="11902" href="Data.Nat.Solver.html#13281" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p*⟨qx+s⟩+r*q⟧</a> <a id="11917" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="11919" href="Data.Nat.Solver.html#11758" class="Bound">x₀</a> <a id="11922" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="11924" class="Symbol">(</a><a id="11925" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="11927" href="Data.Nat.Solver.html#5150" data-type="Poly Nat n" class="Function">0ₚ</a> <a id="11930" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="11933" href="Data.Nat.Solver.html#11763" class="Bound">env</a> <a id="11937" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="11939" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="11941" href="Data.Nat.Solver.html#11744" class="Bound">r</a> <a id="11943" href="Data.Nat.Solver.html#6444" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">*ₚ</a> <a id="11946" href="Data.Nat.Solver.html#11754" class="Bound">s</a> <a id="11948" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="11951" href="Data.Nat.Solver.html#11763" class="Bound">env</a><a id="11954" class="Symbol">)</a>        <span class="reasoning-step"><span class="as-written Function"><a id="11963" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="11966" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="11970" class="Symbol">(λ</a> <a id="11973" href="Data.Nat.Solver.html#11973" class="Bound">ϕ</a> <a id="11975" href="Data.Nat.Solver.html#11975" class="Bound">ψ</a> <a id="11977" class="Symbol">→</a> <a id="11979" href="Data.Nat.Solver.html#13281" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p*⟨qx+s⟩+r*q⟧</a> <a id="11994" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="11996" href="Data.Nat.Solver.html#11758" class="Bound">x₀</a> <a id="11999" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12001" class="Symbol">(</a><a id="12002" href="Data.Nat.Solver.html#11973" class="Bound">ϕ</a> <a id="12004" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12006" href="Data.Nat.Solver.html#11975" class="Bound">ψ</a><a id="12007" class="Symbol">))</a> <a id="12010" class="Symbol">(</a><a id="12011" href="Data.Nat.Solver.html#8346" data-type="(env : Vec Nat n) → ⟦ 0ₚ ⟧ₚ env ≡ 0" class="Function">sound-0ₚ</a> <a id="12020" href="Data.Nat.Solver.html#11763" class="Bound">env</a><a id="12023" class="Symbol">)</a> <a id="12025" class="Symbol">(</a><a id="12026" href="Data.Nat.Solver.html#10662" data-type="(p q : Poly Nat n) (env : Vec Nat n) →
⟦ p *ₚ q ⟧ₚ env ≡ ⟦ p ⟧ₚ env * ⟦ q ⟧ₚ env" class="Function">sound-*ₚ</a> <a id="12035" href="Data.Nat.Solver.html#11744" class="Bound">r</a> <a id="12037" href="Data.Nat.Solver.html#11754" class="Bound">s</a> <a id="12039" href="Data.Nat.Solver.html#11763" class="Bound">env</a><a id="12042" class="Symbol">)</a> <a id="12044" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
  <a id="12048" href="Data.Nat.Solver.html#13281" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p*⟨qx+s⟩+r*q⟧</a> <a id="12063" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12065" href="Data.Nat.Solver.html#11758" class="Bound">x₀</a> <a id="12068" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12070" class="Symbol">(</a><a id="12071" href="Data.Nat.Solver.html#13460" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="12075" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12077" href="Data.Nat.Solver.html#13509" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a><a id="12080" class="Symbol">)</a>                            <span class="reasoning-step"><span class="as-written Function"><a id="12109" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="12112" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="12115" class="Symbol">(λ</a> <a id="12118" href="Data.Nat.Solver.html#12118" class="Bound">ϕ</a> <a id="12120" class="Symbol">→</a> <a id="12122" href="Data.Nat.Solver.html#12118" class="Bound">ϕ</a> <a id="12124" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12126" href="Data.Nat.Solver.html#11758" class="Bound">x₀</a> <a id="12129" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12131" href="Data.Nat.Solver.html#13460" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="12135" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12137" href="Data.Nat.Solver.html#13509" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a><a id="12140" class="Symbol">)</a> <a id="12142" class="Symbol">(</a><a id="12143" href="Data.Nat.Solver.html#9382" data-type="(p q : Poly Nat n) (env : Vec Nat n) →
⟦ p +ₚ q ⟧ₚ env ≡ ⟦ p ⟧ₚ env + ⟦ q ⟧ₚ env" class="Function">sound-+ₚ</a> <a id="12152" class="Symbol">(</a><a id="12153" href="Data.Nat.Solver.html#11738" class="Bound">p</a> <a id="12155" href="Data.Nat.Solver.html#6444" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">*ₚ</a> <a id="12158" class="Symbol">(</a><a id="12159" href="Data.Nat.Solver.html#11748" class="Bound">q</a> <a id="12161" href="Data.Nat.Solver.html#2904" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="12165" href="Data.Nat.Solver.html#11754" class="Bound">s</a><a id="12166" class="Symbol">))</a> <a id="12169" class="Symbol">(</a><a id="12170" href="Data.Nat.Solver.html#11744" class="Bound">r</a> <a id="12172" href="Data.Nat.Solver.html#6488" data-type="Poly Nat n → Poly Nat (suc n) → Poly Nat (suc n)" class="Function Operator">*ₚ′</a> <a id="12176" href="Data.Nat.Solver.html#11748" class="Bound">q</a><a id="12177" class="Symbol">)</a> <a id="12179" class="Symbol">(</a><a id="12180" href="Data.Nat.Solver.html#11758" class="Bound">x₀</a> <a id="12183" href="1Lab.Reflection.html#1854" data-type="A → Vec A n → Vec A (suc n)" class="InductiveConstructor Operator">∷</a> <a id="12185" href="Data.Nat.Solver.html#11763" class="Bound">env</a><a id="12188" class="Symbol">))</a> <a id="12191" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
  <a id="12195" class="Symbol">(</a><a id="12196" href="Data.Nat.Solver.html#13348" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p*⟨qx+s⟩⟧</a> <a id="12207" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12209" href="Data.Nat.Solver.html#13396" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r*q⟧</a><a id="12214" class="Symbol">)</a> <a id="12216" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12218" href="Data.Nat.Solver.html#11758" class="Bound">x₀</a> <a id="12221" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12223" href="Data.Nat.Solver.html#13460" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="12227" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12229" href="Data.Nat.Solver.html#13509" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a>                        <span class="reasoning-step"><span class="as-written Function"><a id="12256" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="12259" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="12263" class="Symbol">(λ</a> <a id="12266" href="Data.Nat.Solver.html#12266" class="Bound">ϕ</a> <a id="12268" href="Data.Nat.Solver.html#12268" class="Bound">ψ</a> <a id="12270" class="Symbol">→</a> <a id="12272" class="Symbol">(</a><a id="12273" href="Data.Nat.Solver.html#12266" class="Bound">ϕ</a> <a id="12275" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12277" href="Data.Nat.Solver.html#12268" class="Bound">ψ</a><a id="12278" class="Symbol">)</a> <a id="12280" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12282" href="Data.Nat.Solver.html#11758" class="Bound">x₀</a> <a id="12285" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12287" href="Data.Nat.Solver.html#13460" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="12291" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12293" href="Data.Nat.Solver.html#13509" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a><a id="12296" class="Symbol">)</a> <a id="12298" class="Symbol">(</a><a id="12299" href="Data.Nat.Solver.html#10662" data-type="(p q : Poly Nat n) (env : Vec Nat n) →
⟦ p *ₚ q ⟧ₚ env ≡ ⟦ p ⟧ₚ env * ⟦ q ⟧ₚ env" class="Function">sound-*ₚ</a> <a id="12308" href="Data.Nat.Solver.html#11738" class="Bound">p</a> <a id="12310" class="Symbol">(</a><a id="12311" href="Data.Nat.Solver.html#11748" class="Bound">q</a> <a id="12313" href="Data.Nat.Solver.html#2904" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="12317" href="Data.Nat.Solver.html#11754" class="Bound">s</a><a id="12318" class="Symbol">)</a> <a id="12320" class="Symbol">(</a><a id="12321" href="Data.Nat.Solver.html#11758" class="Bound">x₀</a> <a id="12324" href="1Lab.Reflection.html#1854" data-type="A → Vec A n → Vec A (suc n)" class="InductiveConstructor Operator">∷</a> <a id="12326" href="Data.Nat.Solver.html#11763" class="Bound">env</a><a id="12329" class="Symbol">))</a> <a id="12332" class="Symbol">(</a><a id="12333" href="Data.Nat.Solver.html#10747" data-type="(p : Poly Nat n) (q : Poly Nat (suc n)) (x₀ : Nat)
(env : Vec Nat n) →
⟦ p *ₚ′ q ⟧ₚ (x₀ ∷ env) ≡ ⟦ p ⟧ₚ env * ⟦ q ⟧ₚ (x₀ ∷ env)" class="Function">sound-*ₚ′</a> <a id="12343" href="Data.Nat.Solver.html#11744" class="Bound">r</a> <a id="12345" href="Data.Nat.Solver.html#11748" class="Bound">q</a> <a id="12347" href="Data.Nat.Solver.html#11758" class="Bound">x₀</a> <a id="12350" href="Data.Nat.Solver.html#11763" class="Bound">env</a><a id="12353" class="Symbol">)</a> <a id="12355" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
  <a id="12359" class="Symbol">(</a><a id="12360" href="Data.Nat.Solver.html#13432" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="12364" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12366" class="Symbol">(</a><a id="12367" href="Data.Nat.Solver.html#13481" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="12371" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12373" href="Data.Nat.Solver.html#11758" class="Bound">x₀</a> <a id="12376" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12378" href="Data.Nat.Solver.html#13509" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a><a id="12381" class="Symbol">)</a> <a id="12383" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12385" href="Data.Nat.Solver.html#13460" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="12389" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12391" href="Data.Nat.Solver.html#13481" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a><a id="12394" class="Symbol">)</a> <a id="12396" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12398" href="Data.Nat.Solver.html#11758" class="Bound">x₀</a> <a id="12401" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12403" href="Data.Nat.Solver.html#13460" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="12407" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12409" href="Data.Nat.Solver.html#13509" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a>        <span class="reasoning-step"><span class="as-written Function"><a id="12420" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="12423" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="12426" class="Symbol">(λ</a> <a id="12429" href="Data.Nat.Solver.html#12429" class="Bound">ϕ</a> <a id="12431" class="Symbol">→</a> <a id="12433" href="Data.Nat.Solver.html#12429" class="Bound">ϕ</a> <a id="12435" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12437" href="Data.Nat.Solver.html#13460" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="12441" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12443" href="Data.Nat.Solver.html#13509" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a><a id="12446" class="Symbol">)</a> <a id="12448" class="Symbol">(</a><a id="12449" href="Data.Nat.Properties.html#1218" data-type="(x y z : Nat) → (x + y) * z ≡ x * z + y * z" class="Function">*-distrib-+r</a> <a id="12462" class="Symbol">(</a><a id="12463" href="Data.Nat.Solver.html#13432" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="12467" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12469" class="Symbol">(</a><a id="12470" href="Data.Nat.Solver.html#13481" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="12474" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12476" href="Data.Nat.Solver.html#11758" class="Bound">x₀</a> <a id="12479" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12481" href="Data.Nat.Solver.html#13509" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a><a id="12484" class="Symbol">))</a> <a id="12487" class="Symbol">(</a><a id="12488" href="Data.Nat.Solver.html#13460" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="12492" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12494" href="Data.Nat.Solver.html#13481" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a><a id="12497" class="Symbol">)</a> <a id="12499" href="Data.Nat.Solver.html#11758" class="Bound">x₀</a><a id="12501" class="Symbol">)</a> <a id="12503" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
  <a id="12507" href="Data.Nat.Solver.html#13432" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="12511" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12513" class="Symbol">(</a><a id="12514" href="Data.Nat.Solver.html#13481" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="12518" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12520" href="Data.Nat.Solver.html#11758" class="Bound">x₀</a> <a id="12523" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12525" href="Data.Nat.Solver.html#13509" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a><a id="12528" class="Symbol">)</a> <a id="12530" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12532" href="Data.Nat.Solver.html#11758" class="Bound">x₀</a> <a id="12535" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12537" href="Data.Nat.Solver.html#13460" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="12541" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12543" href="Data.Nat.Solver.html#13481" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="12547" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12549" href="Data.Nat.Solver.html#11758" class="Bound">x₀</a> <a id="12552" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12554" href="Data.Nat.Solver.html#13460" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="12558" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12560" href="Data.Nat.Solver.html#13509" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a>     <span class="reasoning-step"><span class="as-written Function"><a id="12568" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="12571" href="Data.Nat.Properties.html#553" data-type="(x y z : Nat) → x + y + z ≡ x + (y + z)" class="Function">+-associative</a> <a id="12585" class="Symbol">(</a><a id="12586" href="Data.Nat.Solver.html#13432" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="12590" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12592" class="Symbol">(</a><a id="12593" href="Data.Nat.Solver.html#13481" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="12597" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12599" href="Data.Nat.Solver.html#11758" class="Bound">x₀</a> <a id="12602" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12604" href="Data.Nat.Solver.html#13509" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a><a id="12607" class="Symbol">)</a> <a id="12609" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12611" href="Data.Nat.Solver.html#11758" class="Bound">x₀</a><a id="12613" class="Symbol">)</a> <a id="12615" class="Symbol">(</a><a id="12616" href="Data.Nat.Solver.html#13460" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="12620" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12622" href="Data.Nat.Solver.html#13481" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="12626" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12628" href="Data.Nat.Solver.html#11758" class="Bound">x₀</a><a id="12630" class="Symbol">)</a> <a id="12632" class="Symbol">(</a><a id="12633" href="Data.Nat.Solver.html#13460" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="12637" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12639" href="Data.Nat.Solver.html#13509" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a><a id="12642" class="Symbol">)</a> <a id="12644" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
  <a id="12648" href="Data.Nat.Solver.html#13432" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="12652" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12654" class="Symbol">(</a><a id="12655" href="Data.Nat.Solver.html#13481" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="12659" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12661" href="Data.Nat.Solver.html#11758" class="Bound">x₀</a> <a id="12664" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12666" href="Data.Nat.Solver.html#13509" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a><a id="12669" class="Symbol">)</a> <a id="12671" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12673" href="Data.Nat.Solver.html#11758" class="Bound">x₀</a> <a id="12676" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12678" class="Symbol">(</a><a id="12679" href="Data.Nat.Solver.html#13460" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="12683" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12685" href="Data.Nat.Solver.html#13481" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="12689" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12691" href="Data.Nat.Solver.html#11758" class="Bound">x₀</a> <a id="12694" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12696" href="Data.Nat.Solver.html#13460" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="12700" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12702" href="Data.Nat.Solver.html#13509" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a><a id="12705" class="Symbol">)</a>   <span class="reasoning-step"><span class="as-written Function"><a id="12709" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="12712" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="12715" class="Symbol">(λ</a> <a id="12718" href="Data.Nat.Solver.html#12718" class="Bound">ϕ</a> <a id="12720" class="Symbol">→</a>  <a id="12723" href="Data.Nat.Solver.html#13432" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="12727" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12729" class="Symbol">(</a><a id="12730" href="Data.Nat.Solver.html#13481" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="12734" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12736" href="Data.Nat.Solver.html#11758" class="Bound">x₀</a> <a id="12739" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12741" href="Data.Nat.Solver.html#13509" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a><a id="12744" class="Symbol">)</a> <a id="12746" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12748" href="Data.Nat.Solver.html#11758" class="Bound">x₀</a> <a id="12751" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12753" class="Symbol">(</a><a id="12754" href="Data.Nat.Solver.html#12718" class="Bound">ϕ</a> <a id="12756" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12758" href="Data.Nat.Solver.html#13460" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="12762" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12764" href="Data.Nat.Solver.html#13509" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a><a id="12767" class="Symbol">))</a> <a id="12770" class="Symbol">(</a><a id="12771" href="Data.Nat.Properties.html#2667" data-type="(x y z : Nat) → x * y * z ≡ x * (y * z)" class="Function">*-associative</a> <a id="12785" href="Data.Nat.Solver.html#13460" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="12789" href="Data.Nat.Solver.html#13481" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="12793" href="Data.Nat.Solver.html#11758" class="Bound">x₀</a><a id="12795" class="Symbol">)</a> <a id="12797" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
  <a id="12801" href="Data.Nat.Solver.html#13432" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="12805" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12807" class="Symbol">(</a><a id="12808" href="Data.Nat.Solver.html#13481" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="12812" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12814" href="Data.Nat.Solver.html#11758" class="Bound">x₀</a> <a id="12817" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12819" href="Data.Nat.Solver.html#13509" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a><a id="12822" class="Symbol">)</a> <a id="12824" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12826" href="Data.Nat.Solver.html#11758" class="Bound">x₀</a> <a id="12829" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12831" class="Symbol">(</a><a id="12832" href="Data.Nat.Solver.html#13460" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="12836" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12838" class="Symbol">(</a><a id="12839" href="Data.Nat.Solver.html#13481" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="12843" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12845" href="Data.Nat.Solver.html#11758" class="Bound">x₀</a><a id="12847" class="Symbol">)</a> <a id="12849" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12851" href="Data.Nat.Solver.html#13460" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="12855" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12857" href="Data.Nat.Solver.html#13509" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a><a id="12860" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function Operator"><a id="12862" href="1Lab.Path.html#46783" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">≡˘⟨</a> <a id="12866" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="12869" class="Symbol">(λ</a> <a id="12872" href="Data.Nat.Solver.html#12872" class="Bound">ϕ</a> <a id="12874" class="Symbol">→</a> <a id="12876" href="Data.Nat.Solver.html#13432" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="12880" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12882" class="Symbol">(</a><a id="12883" href="Data.Nat.Solver.html#13481" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="12887" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12889" href="Data.Nat.Solver.html#11758" class="Bound">x₀</a> <a id="12892" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12894" href="Data.Nat.Solver.html#13509" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a><a id="12897" class="Symbol">)</a> <a id="12899" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12901" href="Data.Nat.Solver.html#11758" class="Bound">x₀</a> <a id="12904" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12906" href="Data.Nat.Solver.html#12872" class="Bound">ϕ</a><a id="12907" class="Symbol">)</a> <a id="12909" class="Symbol">(</a><a id="12910" href="Data.Nat.Properties.html#2414" data-type="(x y z : Nat) → z * (x + y) ≡ z * x + z * y" class="Function">*-distrib-+l</a> <a id="12923" class="Symbol">(</a><a id="12924" href="Data.Nat.Solver.html#13481" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="12928" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12930" href="Data.Nat.Solver.html#11758" class="Bound">x₀</a><a id="12932" class="Symbol">)</a> <a id="12934" href="Data.Nat.Solver.html#13509" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a> <a id="12938" href="Data.Nat.Solver.html#13460" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a><a id="12941" class="Symbol">)</a> <a id="12943" href="1Lab.Path.html#46783" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡˘</span></span>
  <a id="12947" href="Data.Nat.Solver.html#13432" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="12951" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12953" class="Symbol">(</a><a id="12954" href="Data.Nat.Solver.html#13481" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="12958" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12960" href="Data.Nat.Solver.html#11758" class="Bound">x₀</a> <a id="12963" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12965" href="Data.Nat.Solver.html#13509" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a><a id="12968" class="Symbol">)</a> <a id="12970" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12972" href="Data.Nat.Solver.html#11758" class="Bound">x₀</a> <a id="12975" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12977" href="Data.Nat.Solver.html#13460" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="12981" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12983" class="Symbol">(</a><a id="12984" href="Data.Nat.Solver.html#13481" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="12988" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12990" href="Data.Nat.Solver.html#11758" class="Bound">x₀</a> <a id="12993" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12995" href="Data.Nat.Solver.html#13509" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a><a id="12998" class="Symbol">)</a>         <span class="reasoning-step"><span class="as-written Function"><a id="13008" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="13011" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="13014" class="Symbol">(λ</a> <a id="13017" href="Data.Nat.Solver.html#13017" class="Bound">ϕ</a> <a id="13019" class="Symbol">→</a> <a id="13021" href="Data.Nat.Solver.html#13017" class="Bound">ϕ</a> <a id="13023" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="13025" href="Data.Nat.Solver.html#13460" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="13029" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="13031" class="Symbol">(</a><a id="13032" href="Data.Nat.Solver.html#13481" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="13036" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="13038" href="Data.Nat.Solver.html#11758" class="Bound">x₀</a> <a id="13041" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="13043" href="Data.Nat.Solver.html#13509" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a><a id="13046" class="Symbol">))</a> <a id="13049" class="Symbol">(</a><a id="13050" href="Data.Nat.Solver.html#3676" data-type="(x y z : Nat) → x * y * z ≡ x * z * y" class="Function">commute-last</a> <a id="13063" href="Data.Nat.Solver.html#13432" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="13067" class="Symbol">(</a><a id="13068" href="Data.Nat.Solver.html#13481" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="13072" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="13074" href="Data.Nat.Solver.html#11758" class="Bound">x₀</a> <a id="13077" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="13079" href="Data.Nat.Solver.html#13509" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a><a id="13082" class="Symbol">)</a> <a id="13084" href="Data.Nat.Solver.html#11758" class="Bound">x₀</a><a id="13086" class="Symbol">)</a> <a id="13088" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
  <a id="13092" href="Data.Nat.Solver.html#13432" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="13096" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="13098" href="Data.Nat.Solver.html#11758" class="Bound">x₀</a> <a id="13101" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="13103" class="Symbol">(</a><a id="13104" href="Data.Nat.Solver.html#13481" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="13108" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="13110" href="Data.Nat.Solver.html#11758" class="Bound">x₀</a> <a id="13113" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="13115" href="Data.Nat.Solver.html#13509" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a><a id="13118" class="Symbol">)</a> <a id="13120" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="13122" href="Data.Nat.Solver.html#13460" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="13126" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="13128" class="Symbol">(</a><a id="13129" href="Data.Nat.Solver.html#13481" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="13133" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="13135" href="Data.Nat.Solver.html#11758" class="Bound">x₀</a> <a id="13138" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="13140" href="Data.Nat.Solver.html#13509" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a><a id="13143" class="Symbol">)</a>         <span class="reasoning-step"><span class="as-written Function Operator"><a id="13153" href="1Lab.Path.html#46783" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">≡˘⟨</a> <a id="13157" href="Data.Nat.Properties.html#1218" data-type="(x y z : Nat) → (x + y) * z ≡ x * z + y * z" class="Function">*-distrib-+r</a> <a id="13170" class="Symbol">(</a><a id="13171" href="Data.Nat.Solver.html#13432" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="13175" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="13177" href="Data.Nat.Solver.html#11758" class="Bound">x₀</a><a id="13179" class="Symbol">)</a> <a id="13181" href="Data.Nat.Solver.html#13460" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="13185" class="Symbol">(</a><a id="13186" href="Data.Nat.Solver.html#13481" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="13190" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="13192" href="Data.Nat.Solver.html#11758" class="Bound">x₀</a> <a id="13195" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="13197" href="Data.Nat.Solver.html#13509" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a><a id="13200" class="Symbol">)</a> <a id="13202" href="1Lab.Path.html#46783" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡˘</span></span>
  <a id="13206" class="Symbol">(</a><a id="13207" href="Data.Nat.Solver.html#13432" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="13211" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="13213" href="Data.Nat.Solver.html#11758" class="Bound">x₀</a> <a id="13216" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="13218" href="Data.Nat.Solver.html#13460" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a><a id="13221" class="Symbol">)</a> <a id="13223" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="13225" class="Symbol">(</a><a id="13226" href="Data.Nat.Solver.html#13481" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="13230" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="13232" href="Data.Nat.Solver.html#11758" class="Bound">x₀</a> <a id="13235" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="13237" href="Data.Nat.Solver.html#13509" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a><a id="13240" class="Symbol">)</a>                          <a id="13267" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
  <a id="13271" class="Keyword">where</a>
    <a id="13281" href="Data.Nat.Solver.html#13281" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p*⟨qx+s⟩+r*q⟧</a> <a id="13296" class="Symbol">=</a> <a id="13298" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="13300" class="Symbol">(</a><a id="13301" href="Data.Nat.Solver.html#11738" class="Bound">p</a> <a id="13303" href="Data.Nat.Solver.html#6444" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">*ₚ</a> <a id="13306" class="Symbol">(</a><a id="13307" href="Data.Nat.Solver.html#11748" class="Bound">q</a> <a id="13309" href="Data.Nat.Solver.html#2904" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="13313" href="Data.Nat.Solver.html#11754" class="Bound">s</a><a id="13314" class="Symbol">))</a> <a id="13317" href="Data.Nat.Solver.html#5927" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">+ₚ</a> <a id="13320" class="Symbol">(</a><a id="13321" href="Data.Nat.Solver.html#11744" class="Bound">r</a> <a id="13323" href="Data.Nat.Solver.html#6488" data-type="Poly Nat n → Poly Nat (suc n) → Poly Nat (suc n)" class="Function Operator">*ₚ′</a> <a id="13327" href="Data.Nat.Solver.html#11748" class="Bound">q</a><a id="13328" class="Symbol">)</a> <a id="13330" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="13333" class="Symbol">(</a><a id="13334" href="Data.Nat.Solver.html#11758" class="Bound">x₀</a> <a id="13337" href="1Lab.Reflection.html#1854" data-type="A → Vec A n → Vec A (suc n)" class="InductiveConstructor Operator">∷</a> <a id="13339" href="Data.Nat.Solver.html#11763" class="Bound">env</a><a id="13342" class="Symbol">)</a>
    <a id="13348" href="Data.Nat.Solver.html#13348" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p*⟨qx+s⟩⟧</a> <a id="13359" class="Symbol">=</a> <a id="13361" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="13363" href="Data.Nat.Solver.html#11738" class="Bound">p</a> <a id="13365" href="Data.Nat.Solver.html#6444" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">*ₚ</a> <a id="13368" class="Symbol">(</a><a id="13369" href="Data.Nat.Solver.html#11748" class="Bound">q</a> <a id="13371" href="Data.Nat.Solver.html#2904" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="13375" href="Data.Nat.Solver.html#11754" class="Bound">s</a><a id="13376" class="Symbol">)</a> <a id="13378" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="13381" class="Symbol">(</a><a id="13382" href="Data.Nat.Solver.html#11758" class="Bound">x₀</a> <a id="13385" href="1Lab.Reflection.html#1854" data-type="A → Vec A n → Vec A (suc n)" class="InductiveConstructor Operator">∷</a> <a id="13387" href="Data.Nat.Solver.html#11763" class="Bound">env</a><a id="13390" class="Symbol">)</a>
    <a id="13396" href="Data.Nat.Solver.html#13396" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r*q⟧</a> <a id="13402" class="Symbol">=</a> <a id="13404" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="13406" href="Data.Nat.Solver.html#11744" class="Bound">r</a> <a id="13408" href="Data.Nat.Solver.html#6488" data-type="Poly Nat n → Poly Nat (suc n) → Poly Nat (suc n)" class="Function Operator">*ₚ′</a> <a id="13412" href="Data.Nat.Solver.html#11748" class="Bound">q</a> <a id="13414" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="13417" class="Symbol">(</a><a id="13418" href="Data.Nat.Solver.html#11758" class="Bound">x₀</a> <a id="13421" href="1Lab.Reflection.html#1854" data-type="A → Vec A n → Vec A (suc n)" class="InductiveConstructor Operator">∷</a> <a id="13423" href="Data.Nat.Solver.html#11763" class="Bound">env</a><a id="13426" class="Symbol">)</a>
    <a id="13432" href="Data.Nat.Solver.html#13432" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="13436" class="Symbol">=</a> <a id="13438" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="13440" href="Data.Nat.Solver.html#11738" class="Bound">p</a> <a id="13442" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="13445" class="Symbol">(</a><a id="13446" href="Data.Nat.Solver.html#11758" class="Bound">x₀</a> <a id="13449" href="1Lab.Reflection.html#1854" data-type="A → Vec A n → Vec A (suc n)" class="InductiveConstructor Operator">∷</a> <a id="13451" href="Data.Nat.Solver.html#11763" class="Bound">env</a><a id="13454" class="Symbol">)</a>
    <a id="13460" href="Data.Nat.Solver.html#13460" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="13464" class="Symbol">=</a> <a id="13466" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="13468" href="Data.Nat.Solver.html#11744" class="Bound">r</a> <a id="13470" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="13473" href="Data.Nat.Solver.html#11763" class="Bound">env</a>
    <a id="13481" href="Data.Nat.Solver.html#13481" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="13485" class="Symbol">=</a> <a id="13487" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="13489" href="Data.Nat.Solver.html#11748" class="Bound">q</a> <a id="13491" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="13494" class="Symbol">(</a><a id="13495" href="Data.Nat.Solver.html#11758" class="Bound">x₀</a> <a id="13498" href="1Lab.Reflection.html#1854" data-type="A → Vec A n → Vec A (suc n)" class="InductiveConstructor Operator">∷</a> <a id="13500" href="Data.Nat.Solver.html#11763" class="Bound">env</a><a id="13503" class="Symbol">)</a>
    <a id="13509" href="Data.Nat.Solver.html#13509" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a> <a id="13513" class="Symbol">=</a> <a id="13515" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="13517" href="Data.Nat.Solver.html#11754" class="Bound">s</a> <a id="13519" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="13522" href="Data.Nat.Solver.html#11763" class="Bound">env</a>
</pre>
<p>As a nice pallate cleanser, the proofs for heterogeneous
multiplication are nowhere near as bad.</p>
<pre class="Agda"><a id="13637" href="Data.Nat.Solver.html#10747" data-type="(p : Poly Nat n) (q : Poly Nat (suc n)) (x₀ : Nat)
(env : Vec Nat n) →
⟦ p *ₚ′ q ⟧ₚ (x₀ ∷ env) ≡ ⟦ p ⟧ₚ env * ⟦ q ⟧ₚ (x₀ ∷ env)" class="Function">sound-*ₚ′</a> <a id="13647" href="Data.Nat.Solver.html#13647" class="Bound">p</a> <a id="13649" href="Data.Nat.Solver.html#2151" data-type="Poly A (suc n)" class="InductiveConstructor">zerop</a> <a id="13655" href="Data.Nat.Solver.html#13655" class="Bound">x₀</a> <a id="13658" href="Data.Nat.Solver.html#13658" class="Bound">env</a> <a id="13662" class="Symbol">=</a> <a id="13664" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="13668" class="Symbol">(</a><a id="13669" href="Data.Nat.Properties.html#2122" data-type="(x : Nat) → x * 0 ≡ 0" class="Function">*-zeror</a> <a id="13677" class="Symbol">(</a><a id="13678" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="13680" href="Data.Nat.Solver.html#13647" class="Bound">p</a> <a id="13682" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="13685" href="Data.Nat.Solver.html#13658" class="Bound">env</a><a id="13688" class="Symbol">))</a>
<a id="13691" href="Data.Nat.Solver.html#10747" data-type="(p : Poly Nat n) (q : Poly Nat (suc n)) (x₀ : Nat)
(env : Vec Nat n) →
⟦ p *ₚ′ q ⟧ₚ (x₀ ∷ env) ≡ ⟦ p ⟧ₚ env * ⟦ q ⟧ₚ (x₀ ∷ env)" class="Function">sound-*ₚ′</a> <a id="13701" href="Data.Nat.Solver.html#13701" class="Bound">r</a> <a id="13703" class="Symbol">(</a><a id="13704" href="Data.Nat.Solver.html#13704" class="Bound">p</a> <a id="13706" href="Data.Nat.Solver.html#2904" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="13710" href="Data.Nat.Solver.html#13710" class="Bound">q</a><a id="13711" class="Symbol">)</a> <a id="13713" href="Data.Nat.Solver.html#13713" class="Bound">x₀</a> <a id="13716" href="Data.Nat.Solver.html#13716" class="Bound">env</a> <a id="13720" class="Symbol">=</a>
  <a id="13724" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="13726" href="Data.Nat.Solver.html#13701" class="Bound">r</a> <a id="13728" href="Data.Nat.Solver.html#6488" data-type="Poly Nat n → Poly Nat (suc n) → Poly Nat (suc n)" class="Function Operator">*ₚ′</a> <a id="13732" href="Data.Nat.Solver.html#13704" class="Bound">p</a> <a id="13734" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="13737" class="Symbol">(</a><a id="13738" href="Data.Nat.Solver.html#13713" class="Bound">x₀</a> <a id="13741" href="1Lab.Reflection.html#1854" data-type="A → Vec A n → Vec A (suc n)" class="InductiveConstructor Operator">∷</a> <a id="13743" href="Data.Nat.Solver.html#13716" class="Bound">env</a><a id="13746" class="Symbol">)</a> <a id="13748" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="13750" href="Data.Nat.Solver.html#13713" class="Bound">x₀</a> <a id="13753" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="13755" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="13757" href="Data.Nat.Solver.html#13701" class="Bound">r</a> <a id="13759" href="Data.Nat.Solver.html#6444" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">*ₚ</a> <a id="13762" href="Data.Nat.Solver.html#13710" class="Bound">q</a> <a id="13764" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="13767" href="Data.Nat.Solver.html#13716" class="Bound">env</a> <span class="reasoning-step"><span class="as-written Function"><a id="13771" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a>  <a id="13775" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="13779" class="Symbol">(λ</a> <a id="13782" href="Data.Nat.Solver.html#13782" class="Bound">ϕ</a> <a id="13784" href="Data.Nat.Solver.html#13784" class="Bound">ψ</a> <a id="13786" class="Symbol">→</a> <a id="13788" href="Data.Nat.Solver.html#13782" class="Bound">ϕ</a> <a id="13790" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="13792" href="Data.Nat.Solver.html#13713" class="Bound">x₀</a> <a id="13795" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="13797" href="Data.Nat.Solver.html#13784" class="Bound">ψ</a><a id="13798" class="Symbol">)</a> <a id="13800" class="Symbol">(</a><a id="13801" href="Data.Nat.Solver.html#10747" data-type="(p : Poly Nat n) (q : Poly Nat (suc n)) (x₀ : Nat)
(env : Vec Nat n) →
⟦ p *ₚ′ q ⟧ₚ (x₀ ∷ env) ≡ ⟦ p ⟧ₚ env * ⟦ q ⟧ₚ (x₀ ∷ env)" class="Function">sound-*ₚ′</a> <a id="13811" href="Data.Nat.Solver.html#13701" class="Bound">r</a> <a id="13813" href="Data.Nat.Solver.html#13704" class="Bound">p</a> <a id="13815" href="Data.Nat.Solver.html#13713" class="Bound">x₀</a> <a id="13818" href="Data.Nat.Solver.html#13716" class="Bound">env</a><a id="13821" class="Symbol">)</a> <a id="13823" class="Symbol">(</a><a id="13824" href="Data.Nat.Solver.html#10662" data-type="(p q : Poly Nat n) (env : Vec Nat n) →
⟦ p *ₚ q ⟧ₚ env ≡ ⟦ p ⟧ₚ env * ⟦ q ⟧ₚ env" class="Function">sound-*ₚ</a> <a id="13833" href="Data.Nat.Solver.html#13701" class="Bound">r</a> <a id="13835" href="Data.Nat.Solver.html#13710" class="Bound">q</a> <a id="13837" href="Data.Nat.Solver.html#13716" class="Bound">env</a><a id="13840" class="Symbol">)</a> <a id="13842" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
  <a id="13846" href="Data.Nat.Solver.html#14101" data-type="(r : Poly Nat n) (p : Poly Nat (suc n)) (q : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="13850" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="13852" href="Data.Nat.Solver.html#14122" data-type="(r : Poly Nat n) (p : Poly Nat (suc n)) (q : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="13856" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="13858" href="Data.Nat.Solver.html#13713" class="Bound">x₀</a> <a id="13861" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="13863" href="Data.Nat.Solver.html#14101" data-type="(r : Poly Nat n) (p : Poly Nat (suc n)) (q : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="13867" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="13869" href="Data.Nat.Solver.html#14150" data-type="(r : Poly Nat n) (p : Poly Nat (suc n)) (q : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a>                     <span class="reasoning-step"><span class="as-written Function"><a id="13893" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="13896" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="13899" class="Symbol">(λ</a> <a id="13902" href="Data.Nat.Solver.html#13902" class="Bound">ϕ</a> <a id="13904" class="Symbol">→</a> <a id="13906" href="Data.Nat.Solver.html#13902" class="Bound">ϕ</a> <a id="13908" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="13910" href="Data.Nat.Solver.html#14101" data-type="(r : Poly Nat n) (p : Poly Nat (suc n)) (q : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="13914" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="13916" href="Data.Nat.Solver.html#14150" data-type="(r : Poly Nat n) (p : Poly Nat (suc n)) (q : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a><a id="13919" class="Symbol">)</a> <a id="13921" class="Symbol">(</a><a id="13922" href="Data.Nat.Properties.html#2667" data-type="(x y z : Nat) → x * y * z ≡ x * (y * z)" class="Function">*-associative</a> <a id="13936" href="Data.Nat.Solver.html#14101" data-type="(r : Poly Nat n) (p : Poly Nat (suc n)) (q : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="13940" href="Data.Nat.Solver.html#14122" data-type="(r : Poly Nat n) (p : Poly Nat (suc n)) (q : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="13944" href="Data.Nat.Solver.html#13713" class="Bound">x₀</a><a id="13946" class="Symbol">)</a> <a id="13948" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
  <a id="13952" href="Data.Nat.Solver.html#14101" data-type="(r : Poly Nat n) (p : Poly Nat (suc n)) (q : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="13956" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="13958" class="Symbol">(</a><a id="13959" href="Data.Nat.Solver.html#14122" data-type="(r : Poly Nat n) (p : Poly Nat (suc n)) (q : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="13963" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="13965" href="Data.Nat.Solver.html#13713" class="Bound">x₀</a><a id="13967" class="Symbol">)</a> <a id="13969" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="13971" href="Data.Nat.Solver.html#14101" data-type="(r : Poly Nat n) (p : Poly Nat (suc n)) (q : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="13975" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="13977" href="Data.Nat.Solver.html#14150" data-type="(r : Poly Nat n) (p : Poly Nat (suc n)) (q : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a>                   <span class="reasoning-step"><span class="as-written Function Operator"><a id="13999" href="1Lab.Path.html#46783" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">≡˘⟨</a> <a id="14003" href="Data.Nat.Properties.html#2414" data-type="(x y z : Nat) → z * (x + y) ≡ z * x + z * y" class="Function">*-distrib-+l</a>  <a id="14017" class="Symbol">(</a><a id="14018" href="Data.Nat.Solver.html#14122" data-type="(r : Poly Nat n) (p : Poly Nat (suc n)) (q : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="14022" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="14024" href="Data.Nat.Solver.html#13713" class="Bound">x₀</a><a id="14026" class="Symbol">)</a> <a id="14028" href="Data.Nat.Solver.html#14150" data-type="(r : Poly Nat n) (p : Poly Nat (suc n)) (q : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="14032" href="Data.Nat.Solver.html#14101" data-type="(r : Poly Nat n) (p : Poly Nat (suc n)) (q : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="14036" href="1Lab.Path.html#46783" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡˘</span></span>
  <a id="14040" href="Data.Nat.Solver.html#14101" data-type="(r : Poly Nat n) (p : Poly Nat (suc n)) (q : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="14044" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="14046" class="Symbol">(</a><a id="14047" href="Data.Nat.Solver.html#14122" data-type="(r : Poly Nat n) (p : Poly Nat (suc n)) (q : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="14051" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="14053" href="Data.Nat.Solver.html#13713" class="Bound">x₀</a> <a id="14056" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="14058" href="Data.Nat.Solver.html#14150" data-type="(r : Poly Nat n) (p : Poly Nat (suc n)) (q : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a><a id="14061" class="Symbol">)</a>                         <a id="14087" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
  <a id="14091" class="Keyword">where</a>
    <a id="14101" href="Data.Nat.Solver.html#14101" data-type="(r : Poly Nat n) (p : Poly Nat (suc n)) (q : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="14105" class="Symbol">=</a> <a id="14107" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="14109" href="Data.Nat.Solver.html#13701" class="Bound">r</a> <a id="14111" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="14114" href="Data.Nat.Solver.html#13716" class="Bound">env</a>
    <a id="14122" href="Data.Nat.Solver.html#14122" data-type="(r : Poly Nat n) (p : Poly Nat (suc n)) (q : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="14126" class="Symbol">=</a> <a id="14128" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="14130" href="Data.Nat.Solver.html#13704" class="Bound">p</a> <a id="14132" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="14135" class="Symbol">(</a><a id="14136" href="Data.Nat.Solver.html#13713" class="Bound">x₀</a> <a id="14139" href="1Lab.Reflection.html#1854" data-type="A → Vec A n → Vec A (suc n)" class="InductiveConstructor Operator">∷</a> <a id="14141" href="Data.Nat.Solver.html#13716" class="Bound">env</a><a id="14144" class="Symbol">)</a>
    <a id="14150" href="Data.Nat.Solver.html#14150" data-type="(r : Poly Nat n) (p : Poly Nat (suc n)) (q : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="14154" class="Symbol">=</a> <a id="14156" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="14158" href="Data.Nat.Solver.html#13710" class="Bound">q</a> <a id="14160" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="14163" href="Data.Nat.Solver.html#13716" class="Bound">env</a>
</pre>
<p>This concludes phase one of the solver.</p>
<h2 id="evaluation-into-polynomials"><a href="#evaluation-into-polynomials" class="header-link">Evaluation
into Polynomials<span class="header-link-emoji">🔗</span></a></h2>
<p>Now that we’ve gotten the first phase of the solver done, let’s move
on to expressions in the language of natural numbers. Our first move
shall be defining expressions in the equational theory of natural
numbers.</p>
<p>However, there is an efficiency problem we need to take care of here.
If we naively expand out
<span class="Agda"><a href="Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a></span>
and
<span class="Agda"><a href="Agda.Builtin.Nat.html#528" class="Primitive Operator">_*_</a></span>
during reflection, we could end up in a situation where we need to
contend with a <em>huge</em> amount of
<span class="Agda"><a href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a></span>
constructors when large literals get involved. Therefore, we prevent
reduction of such functions, but this means this phase of the solver
needs to be aware of nat literals.</p>
<p>With that in mind, let’s define our expressions. Note that things
that the solver is unable to deal with (for instance, functions that
aren’t
<span class="Agda"><a href="Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a></span>
or
<span class="Agda"><a href="Agda.Builtin.Nat.html#528" class="Primitive Operator">_*_</a></span>)
are represented as variables, and will be replaced during
evaluation.</p>
<pre class="Agda"><a id="15121" class="Keyword">data</a> <a id="Expr"></a><a id="15126" href="Data.Nat.Solver.html#15126" data-type="Nat → Type" class="Datatype">Expr</a> <a id="15131" class="Symbol">:</a> <a id="15133" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="15137" class="Symbol">→</a> <a id="15139" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="15144" class="Keyword">where</a>
  <a id="Expr.‵0"></a><a id="15152" href="Data.Nat.Solver.html#15152" data-type="Expr n" class="InductiveConstructor">‵0</a>   <a id="15157" class="Symbol">:</a> <a id="15159" class="Symbol">∀</a> <a id="15161" class="Symbol">{</a><a id="15162" href="Data.Nat.Solver.html#15162" class="Bound">n</a><a id="15163" class="Symbol">}</a> <a id="15165" class="Symbol">→</a> <a id="15167" href="Data.Nat.Solver.html#15126" data-type="Nat → Type" class="Datatype">Expr</a> <a id="15172" href="Data.Nat.Solver.html#15162" class="Bound">n</a>
  <a id="Expr.‵lit"></a><a id="15176" href="Data.Nat.Solver.html#15176" data-type="Nat → Expr n" class="InductiveConstructor">‵lit</a> <a id="15181" class="Symbol">:</a> <a id="15183" class="Symbol">∀</a> <a id="15185" class="Symbol">{</a><a id="15186" href="Data.Nat.Solver.html#15186" class="Bound">n</a><a id="15187" class="Symbol">}</a> <a id="15189" class="Symbol">→</a> <a id="15191" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a>    <a id="15198" class="Symbol">→</a> <a id="15200" href="Data.Nat.Solver.html#15126" data-type="Nat → Type" class="Datatype">Expr</a> <a id="15205" href="Data.Nat.Solver.html#15186" class="Bound">n</a>
  <a id="Expr.‵_"></a><a id="15209" href="Data.Nat.Solver.html#15209" data-type="Fin n → Expr n" class="InductiveConstructor Operator">‵_</a>   <a id="15214" class="Symbol">:</a> <a id="15216" class="Symbol">∀</a> <a id="15218" class="Symbol">{</a><a id="15219" href="Data.Nat.Solver.html#15219" class="Bound">n</a><a id="15220" class="Symbol">}</a> <a id="15222" class="Symbol">→</a> <a id="15224" href="Data.Fin.Base.html#498" data-type="Nat → Type" class="Datatype">Fin</a> <a id="15228" href="Data.Nat.Solver.html#15219" class="Bound">n</a>  <a id="15231" class="Symbol">→</a> <a id="15233" href="Data.Nat.Solver.html#15126" data-type="Nat → Type" class="Datatype">Expr</a> <a id="15238" href="Data.Nat.Solver.html#15219" class="Bound">n</a>
  <a id="Expr.‵1+_"></a><a id="15242" href="Data.Nat.Solver.html#15242" data-type="Expr n → Expr n" class="InductiveConstructor Operator">‵1+_</a> <a id="15247" class="Symbol">:</a> <a id="15249" class="Symbol">∀</a> <a id="15251" class="Symbol">{</a><a id="15252" href="Data.Nat.Solver.html#15252" class="Bound">n</a><a id="15253" class="Symbol">}</a> <a id="15255" class="Symbol">→</a> <a id="15257" href="Data.Nat.Solver.html#15126" data-type="Nat → Type" class="Datatype">Expr</a> <a id="15262" href="Data.Nat.Solver.html#15252" class="Bound">n</a> <a id="15264" class="Symbol">→</a> <a id="15266" href="Data.Nat.Solver.html#15126" data-type="Nat → Type" class="Datatype">Expr</a> <a id="15271" href="Data.Nat.Solver.html#15252" class="Bound">n</a>
  <a id="Expr._‵+_"></a><a id="15275" href="Data.Nat.Solver.html#15275" data-type="Expr n → Expr n → Expr n" class="InductiveConstructor Operator">_‵+_</a> <a id="15280" class="Symbol">:</a> <a id="15282" class="Symbol">∀</a> <a id="15284" class="Symbol">{</a><a id="15285" href="Data.Nat.Solver.html#15285" class="Bound">n</a><a id="15286" class="Symbol">}</a> <a id="15288" class="Symbol">→</a> <a id="15290" href="Data.Nat.Solver.html#15126" data-type="Nat → Type" class="Datatype">Expr</a> <a id="15295" href="Data.Nat.Solver.html#15285" class="Bound">n</a> <a id="15297" class="Symbol">→</a> <a id="15299" href="Data.Nat.Solver.html#15126" data-type="Nat → Type" class="Datatype">Expr</a> <a id="15304" href="Data.Nat.Solver.html#15285" class="Bound">n</a> <a id="15306" class="Symbol">→</a> <a id="15308" href="Data.Nat.Solver.html#15126" data-type="Nat → Type" class="Datatype">Expr</a> <a id="15313" href="Data.Nat.Solver.html#15285" class="Bound">n</a>
  <a id="Expr._‵*_"></a><a id="15317" href="Data.Nat.Solver.html#15317" data-type="Expr n → Expr n → Expr n" class="InductiveConstructor Operator">_‵*_</a> <a id="15322" class="Symbol">:</a> <a id="15324" class="Symbol">∀</a> <a id="15326" class="Symbol">{</a><a id="15327" href="Data.Nat.Solver.html#15327" class="Bound">n</a><a id="15328" class="Symbol">}</a> <a id="15330" class="Symbol">→</a> <a id="15332" href="Data.Nat.Solver.html#15126" data-type="Nat → Type" class="Datatype">Expr</a> <a id="15337" href="Data.Nat.Solver.html#15327" class="Bound">n</a> <a id="15339" class="Symbol">→</a> <a id="15341" href="Data.Nat.Solver.html#15126" data-type="Nat → Type" class="Datatype">Expr</a> <a id="15346" href="Data.Nat.Solver.html#15327" class="Bound">n</a> <a id="15348" class="Symbol">→</a> <a id="15350" href="Data.Nat.Solver.html#15126" data-type="Nat → Type" class="Datatype">Expr</a> <a id="15355" href="Data.Nat.Solver.html#15327" class="Bound">n</a>
</pre>
<p>We also define an interpretation of expressions into functions
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="double-struck">N</mi><mi>n</mi></msup><mo>→</mo><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">\mathbb{N}^n \to \mathbb{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord"><span class="mord mathbb">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span></span></span></span>.</span></p>
<pre class="Agda"><a id="⟦_⟧ₑ"></a><a id="15466" href="Data.Nat.Solver.html#15466" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟦_⟧ₑ</a> <a id="15471" class="Symbol">:</a> <a id="15473" href="Data.Nat.Solver.html#15126" data-type="Nat → Type" class="Datatype">Expr</a> <a id="15478" href="Data.Nat.Solver.html#3049" class="Generalizable">n</a> <a id="15480" class="Symbol">→</a> <a id="15482" href="1Lab.Reflection.html#1792" data-type="Type ℓ → Nat → Type ℓ" class="Datatype">Vec</a> <a id="15486" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="15490" href="Data.Nat.Solver.html#3049" class="Generalizable">n</a> <a id="15492" class="Symbol">→</a> <a id="15494" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a>
<a id="15498" href="Data.Nat.Solver.html#15466" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="15500" href="Data.Nat.Solver.html#15209" data-type="Fin n → Expr n" class="InductiveConstructor Operator">‵</a> <a id="15502" href="Data.Nat.Solver.html#15502" class="Bound">i</a>      <a id="15509" href="Data.Nat.Solver.html#15466" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟧ₑ</a> <a id="15512" href="Data.Nat.Solver.html#15512" class="Bound">env</a> <a id="15516" class="Symbol">=</a> <a id="15518" href="Data.Nat.Solver.html#3058" data-type="Vec A n → Fin n → A" class="Function">lookup</a> <a id="15525" href="Data.Nat.Solver.html#15512" class="Bound">env</a> <a id="15529" href="Data.Nat.Solver.html#15502" class="Bound">i</a>
<a id="15531" href="Data.Nat.Solver.html#15466" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="15533" href="Data.Nat.Solver.html#15152" data-type="Expr n" class="InductiveConstructor">‵0</a>       <a id="15542" href="Data.Nat.Solver.html#15466" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟧ₑ</a> <a id="15545" href="Data.Nat.Solver.html#15545" class="Bound">env</a> <a id="15549" class="Symbol">=</a> <a id="15551" class="Number">0</a>
<a id="15553" href="Data.Nat.Solver.html#15466" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="15555" href="Data.Nat.Solver.html#15242" data-type="Expr n → Expr n" class="InductiveConstructor Operator">‵1+</a> <a id="15559" href="Data.Nat.Solver.html#15559" class="Bound">e</a>    <a id="15564" href="Data.Nat.Solver.html#15466" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟧ₑ</a> <a id="15567" href="Data.Nat.Solver.html#15567" class="Bound">env</a> <a id="15571" class="Symbol">=</a> <a id="15573" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="15577" class="Symbol">(</a><a id="15578" href="Data.Nat.Solver.html#15466" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="15580" href="Data.Nat.Solver.html#15559" class="Bound">e</a> <a id="15582" href="Data.Nat.Solver.html#15466" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟧ₑ</a> <a id="15585" href="Data.Nat.Solver.html#15567" class="Bound">env</a><a id="15588" class="Symbol">)</a>
<a id="15590" href="Data.Nat.Solver.html#15466" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="15592" href="Data.Nat.Solver.html#15176" data-type="Nat → Expr n" class="InductiveConstructor">‵lit</a> <a id="15597" href="Data.Nat.Solver.html#15597" class="Bound">k</a>   <a id="15601" href="Data.Nat.Solver.html#15466" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟧ₑ</a> <a id="15604" href="Data.Nat.Solver.html#15604" class="Bound">env</a> <a id="15608" class="Symbol">=</a> <a id="15610" href="Data.Nat.Solver.html#15597" class="Bound">k</a>
<a id="15612" href="Data.Nat.Solver.html#15466" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="15614" href="Data.Nat.Solver.html#15614" class="Bound">e1</a> <a id="15617" href="Data.Nat.Solver.html#15275" data-type="Expr n → Expr n → Expr n" class="InductiveConstructor Operator">‵+</a> <a id="15620" href="Data.Nat.Solver.html#15620" class="Bound">e2</a> <a id="15623" href="Data.Nat.Solver.html#15466" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟧ₑ</a> <a id="15626" href="Data.Nat.Solver.html#15626" class="Bound">env</a> <a id="15630" class="Symbol">=</a> <a id="15632" href="Data.Nat.Solver.html#15466" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="15634" href="Data.Nat.Solver.html#15614" class="Bound">e1</a> <a id="15637" href="Data.Nat.Solver.html#15466" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟧ₑ</a> <a id="15640" href="Data.Nat.Solver.html#15626" class="Bound">env</a> <a id="15644" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="15646" href="Data.Nat.Solver.html#15466" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="15648" href="Data.Nat.Solver.html#15620" class="Bound">e2</a> <a id="15651" href="Data.Nat.Solver.html#15466" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟧ₑ</a> <a id="15654" href="Data.Nat.Solver.html#15626" class="Bound">env</a>
<a id="15658" href="Data.Nat.Solver.html#15466" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="15660" href="Data.Nat.Solver.html#15660" class="Bound">e1</a> <a id="15663" href="Data.Nat.Solver.html#15317" data-type="Expr n → Expr n → Expr n" class="InductiveConstructor Operator">‵*</a> <a id="15666" href="Data.Nat.Solver.html#15666" class="Bound">e2</a> <a id="15669" href="Data.Nat.Solver.html#15466" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟧ₑ</a> <a id="15672" href="Data.Nat.Solver.html#15672" class="Bound">env</a> <a id="15676" class="Symbol">=</a> <a id="15678" href="Data.Nat.Solver.html#15466" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="15680" href="Data.Nat.Solver.html#15660" class="Bound">e1</a> <a id="15683" href="Data.Nat.Solver.html#15466" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟧ₑ</a> <a id="15686" href="Data.Nat.Solver.html#15672" class="Bound">env</a> <a id="15690" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="15692" href="Data.Nat.Solver.html#15466" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="15694" href="Data.Nat.Solver.html#15666" class="Bound">e2</a> <a id="15697" href="Data.Nat.Solver.html#15466" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟧ₑ</a> <a id="15700" href="Data.Nat.Solver.html#15672" class="Bound">env</a>
</pre>
<p>We also define an evaluation of expressions into polynomials. The
only thing to note here is the evaluation of quoted
<span class="Agda"><a href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a></span>
constructors as polynomial addition. This is somewhat inneficient, but
in practice we rarely have too many
<span class="Agda"><a href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a></span>
constructors to deal with, as we handle literals separately.</p>
<pre class="Agda"><a id="↓_"></a><a id="16030" href="Data.Nat.Solver.html#16030" data-type="Expr n → Poly Nat n" class="Function Operator">↓_</a> <a id="16033" class="Symbol">:</a> <a id="16035" href="Data.Nat.Solver.html#15126" data-type="Nat → Type" class="Datatype">Expr</a> <a id="16040" href="Data.Nat.Solver.html#3049" class="Generalizable">n</a> <a id="16042" class="Symbol">→</a> <a id="16044" href="Data.Nat.Solver.html#1629" data-type="Type a → Nat → Type a" class="Datatype">Poly</a> <a id="16049" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="16053" href="Data.Nat.Solver.html#3049" class="Generalizable">n</a>
<a id="16055" href="Data.Nat.Solver.html#16030" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="16057" class="Symbol">(</a><a id="16058" href="Data.Nat.Solver.html#15209" data-type="Fin n → Expr n" class="InductiveConstructor Operator">‵</a> <a id="16060" href="Data.Nat.Solver.html#16060" class="Bound">i</a><a id="16061" class="Symbol">)</a>      <a id="16068" class="Symbol">=</a> <a id="16070" href="Data.Nat.Solver.html#5660" data-type="Fin n → Poly Nat n" class="Function Operator">X[</a> <a id="16073" href="Data.Nat.Solver.html#16060" class="Bound">i</a> <a id="16075" href="Data.Nat.Solver.html#5660" data-type="Fin n → Poly Nat n" class="Function Operator">]</a>
<a id="16077" href="Data.Nat.Solver.html#16030" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="16079" href="Data.Nat.Solver.html#15152" data-type="Expr n" class="InductiveConstructor">‵0</a>         <a id="16090" class="Symbol">=</a> <a id="16092" href="Data.Nat.Solver.html#5150" data-type="Poly Nat n" class="Function">0ₚ</a>
<a id="16095" href="Data.Nat.Solver.html#16030" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="16097" class="Symbol">(</a><a id="16098" href="Data.Nat.Solver.html#15242" data-type="Expr n → Expr n" class="InductiveConstructor Operator">‵1+</a> <a id="16102" href="Data.Nat.Solver.html#16102" class="Bound">e</a><a id="16103" class="Symbol">)</a>    <a id="16108" class="Symbol">=</a> <a id="16110" href="Data.Nat.Solver.html#5371" data-type="Nat → Poly Nat n" class="Function">constₚ</a> <a id="16117" class="Number">1</a> <a id="16119" href="Data.Nat.Solver.html#5927" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">+ₚ</a> <a id="16122" href="Data.Nat.Solver.html#16030" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="16124" href="Data.Nat.Solver.html#16102" class="Bound">e</a>
<a id="16126" href="Data.Nat.Solver.html#16030" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="16128" href="Data.Nat.Solver.html#15176" data-type="Nat → Expr n" class="InductiveConstructor">‵lit</a> <a id="16133" href="Data.Nat.Solver.html#16133" class="Bound">k</a>     <a id="16139" class="Symbol">=</a> <a id="16141" href="Data.Nat.Solver.html#5371" data-type="Nat → Poly Nat n" class="Function">constₚ</a> <a id="16148" href="Data.Nat.Solver.html#16133" class="Bound">k</a>
<a id="16150" href="Data.Nat.Solver.html#16030" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="16152" class="Symbol">(</a><a id="16153" href="Data.Nat.Solver.html#16153" class="Bound">e₁</a> <a id="16156" href="Data.Nat.Solver.html#15275" data-type="Expr n → Expr n → Expr n" class="InductiveConstructor Operator">‵+</a> <a id="16159" href="Data.Nat.Solver.html#16159" class="Bound">e₂</a><a id="16161" class="Symbol">)</a> <a id="16163" class="Symbol">=</a> <a id="16165" class="Symbol">(</a><a id="16166" href="Data.Nat.Solver.html#16030" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="16168" href="Data.Nat.Solver.html#16153" class="Bound">e₁</a><a id="16170" class="Symbol">)</a> <a id="16172" href="Data.Nat.Solver.html#5927" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">+ₚ</a> <a id="16175" class="Symbol">(</a><a id="16176" href="Data.Nat.Solver.html#16030" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="16178" href="Data.Nat.Solver.html#16159" class="Bound">e₂</a><a id="16180" class="Symbol">)</a>
<a id="16182" href="Data.Nat.Solver.html#16030" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="16184" class="Symbol">(</a><a id="16185" href="Data.Nat.Solver.html#16185" class="Bound">e₁</a> <a id="16188" href="Data.Nat.Solver.html#15317" data-type="Expr n → Expr n → Expr n" class="InductiveConstructor Operator">‵*</a> <a id="16191" href="Data.Nat.Solver.html#16191" class="Bound">e₂</a><a id="16193" class="Symbol">)</a> <a id="16195" class="Symbol">=</a> <a id="16197" class="Symbol">(</a><a id="16198" href="Data.Nat.Solver.html#16030" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="16200" href="Data.Nat.Solver.html#16185" class="Bound">e₁</a><a id="16202" class="Symbol">)</a> <a id="16204" href="Data.Nat.Solver.html#6444" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">*ₚ</a> <a id="16207" class="Symbol">(</a><a id="16208" href="Data.Nat.Solver.html#16030" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="16210" href="Data.Nat.Solver.html#16191" class="Bound">e₂</a><a id="16212" class="Symbol">)</a>
</pre>
<h3 id="soundness-of-evaluation"><a href="#soundness-of-evaluation" class="header-link">Soundness
of Evaluation<span class="header-link-emoji">🔗</span></a></h3>
<p>With all of that machinery in place, our final proof shall be to show
that evaluating an expression into a polynomial has the same semantics
as the original expression. Luckily, most of the legwork is already
done, so we can sit back and enjoy the fruits of our labour.</p>
<pre class="Agda"><a id="sound"></a><a id="16527" href="Data.Nat.Solver.html#16527" data-type="(e : Expr n) (env : Vec Nat n) → ⟦ ↓ e ⟧ₚ env ≡ ⟦ e ⟧ₑ env" class="Function">sound</a> <a id="16533" class="Symbol">:</a> <a id="16535" class="Symbol">∀</a> <a id="16537" href="Data.Nat.Solver.html#16537" class="Bound">e</a> <a id="16539" class="Symbol">→</a> <a id="16541" class="Symbol">(</a><a id="16542" href="Data.Nat.Solver.html#16542" class="Bound">env</a> <a id="16546" class="Symbol">:</a> <a id="16548" href="1Lab.Reflection.html#1792" data-type="Type ℓ → Nat → Type ℓ" class="Datatype">Vec</a> <a id="16552" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="16556" href="Data.Nat.Solver.html#3049" class="Generalizable">n</a><a id="16557" class="Symbol">)</a> <a id="16559" class="Symbol">→</a> <a id="16561" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="16563" href="Data.Nat.Solver.html#16030" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="16565" href="Data.Nat.Solver.html#16537" class="Bound">e</a> <a id="16567" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="16570" href="Data.Nat.Solver.html#16542" class="Bound">env</a> <a id="16574" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="16576" href="Data.Nat.Solver.html#15466" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="16578" href="Data.Nat.Solver.html#16537" class="Bound">e</a> <a id="16580" href="Data.Nat.Solver.html#15466" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟧ₑ</a> <a id="16583" href="Data.Nat.Solver.html#16542" class="Bound">env</a>
<a id="16587" href="Data.Nat.Solver.html#16527" data-type="(e : Expr n) (env : Vec Nat n) → ⟦ ↓ e ⟧ₚ env ≡ ⟦ e ⟧ₑ env" class="Function">sound</a> <a id="16593" class="Symbol">(</a><a id="16594" href="Data.Nat.Solver.html#15209" data-type="Fin n → Expr n" class="InductiveConstructor Operator">‵</a> <a id="16596" href="Data.Nat.Solver.html#16596" class="Bound">i</a><a id="16597" class="Symbol">)</a> <a id="16599" href="Data.Nat.Solver.html#16599" class="Bound">env</a> <a id="16603" class="Symbol">=</a> <a id="16605" href="Data.Nat.Solver.html#8736" data-type="(i : Fin n) (env : Vec Nat n) → ⟦ X[ i ] ⟧ₚ env ≡ lookup env i" class="Function Operator">sound-X[</a> <a id="16614" href="Data.Nat.Solver.html#16596" class="Bound">i</a> <a id="16616" href="Data.Nat.Solver.html#8736" data-type="(i : Fin n) (env : Vec Nat n) → ⟦ X[ i ] ⟧ₚ env ≡ lookup env i" class="Function Operator">]</a> <a id="16618" href="Data.Nat.Solver.html#16599" class="Bound">env</a>
<a id="16622" href="Data.Nat.Solver.html#16527" data-type="(e : Expr n) (env : Vec Nat n) → ⟦ ↓ e ⟧ₚ env ≡ ⟦ e ⟧ₑ env" class="Function">sound</a> <a id="16628" href="Data.Nat.Solver.html#15152" data-type="Expr n" class="InductiveConstructor">‵0</a> <a id="16631" href="Data.Nat.Solver.html#16631" class="Bound">env</a> <a id="16635" class="Symbol">=</a> <a id="16637" href="Data.Nat.Solver.html#8346" data-type="(env : Vec Nat n) → ⟦ 0ₚ ⟧ₚ env ≡ 0" class="Function">sound-0ₚ</a> <a id="16646" href="Data.Nat.Solver.html#16631" class="Bound">env</a>
<a id="16650" href="Data.Nat.Solver.html#16527" data-type="(e : Expr n) (env : Vec Nat n) → ⟦ ↓ e ⟧ₚ env ≡ ⟦ e ⟧ₑ env" class="Function">sound</a> <a id="16656" class="Symbol">(</a><a id="16657" href="Data.Nat.Solver.html#15242" data-type="Expr n → Expr n" class="InductiveConstructor Operator">‵1+</a> <a id="16661" href="Data.Nat.Solver.html#16661" class="Bound">e</a><a id="16662" class="Symbol">)</a> <a id="16664" href="Data.Nat.Solver.html#16664" class="Bound">env</a> <a id="16668" class="Symbol">=</a>
  <a id="16672" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="16674" href="Data.Nat.Solver.html#5371" data-type="Nat → Poly Nat n" class="Function">constₚ</a> <a id="16681" class="Number">1</a> <a id="16683" href="Data.Nat.Solver.html#5927" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">+ₚ</a> <a id="16686" class="Symbol">(</a><a id="16687" href="Data.Nat.Solver.html#16030" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="16689" href="Data.Nat.Solver.html#16661" class="Bound">e</a><a id="16690" class="Symbol">)</a> <a id="16692" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="16695" href="Data.Nat.Solver.html#16664" class="Bound">env</a>       <span class="reasoning-step"><span class="as-written Function"><a id="16705" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="16708" href="Data.Nat.Solver.html#9382" data-type="(p q : Poly Nat n) (env : Vec Nat n) →
⟦ p +ₚ q ⟧ₚ env ≡ ⟦ p ⟧ₚ env + ⟦ q ⟧ₚ env" class="Function">sound-+ₚ</a> <a id="16717" class="Symbol">(</a><a id="16718" href="Data.Nat.Solver.html#5371" data-type="Nat → Poly Nat n" class="Function">constₚ</a> <a id="16725" class="Number">1</a><a id="16726" class="Symbol">)</a> <a id="16728" class="Symbol">(</a><a id="16729" href="Data.Nat.Solver.html#16030" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="16731" href="Data.Nat.Solver.html#16661" class="Bound">e</a><a id="16732" class="Symbol">)</a> <a id="16734" href="Data.Nat.Solver.html#16664" class="Bound">env</a> <a id="16738" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
  <a id="16742" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="16744" href="Data.Nat.Solver.html#5371" data-type="Nat → Poly Nat n" class="Function">constₚ</a> <a id="16751" class="Number">1</a> <a id="16753" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="16756" href="Data.Nat.Solver.html#16664" class="Bound">env</a> <a id="16760" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="16762" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="16764" href="Data.Nat.Solver.html#16030" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="16766" href="Data.Nat.Solver.html#16661" class="Bound">e</a> <a id="16768" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="16771" href="Data.Nat.Solver.html#16664" class="Bound">env</a> <span class="reasoning-step"><span class="as-written Function"><a id="16775" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="16778" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="16781" class="Symbol">(λ</a> <a id="16784" href="Data.Nat.Solver.html#16784" class="Bound">ϕ</a> <a id="16786" class="Symbol">→</a> <a id="16788" href="Data.Nat.Solver.html#16784" class="Bound">ϕ</a> <a id="16790" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="16792" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="16794" href="Data.Nat.Solver.html#16030" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="16796" href="Data.Nat.Solver.html#16661" class="Bound">e</a> <a id="16798" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="16801" href="Data.Nat.Solver.html#16664" class="Bound">env</a> <a id="16805" class="Symbol">)</a> <a id="16807" class="Symbol">(</a><a id="16808" href="Data.Nat.Solver.html#8506" data-type="(c : Nat) (env : Vec Nat n) → ⟦ constₚ c ⟧ₚ env ≡ c" class="Function">sound-constₚ</a> <a id="16821" class="Number">1</a> <a id="16823" href="Data.Nat.Solver.html#16664" class="Bound">env</a><a id="16826" class="Symbol">)</a> <a id="16828" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
  <a id="16832" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="16836" class="Symbol">(</a><a id="16837" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="16839" href="Data.Nat.Solver.html#16030" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="16841" href="Data.Nat.Solver.html#16661" class="Bound">e</a> <a id="16843" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="16846" href="Data.Nat.Solver.html#16664" class="Bound">env</a><a id="16849" class="Symbol">)</a>               <span class="reasoning-step"><span class="as-written Function"><a id="16865" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="16868" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="16871" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="16875" class="Symbol">(</a><a id="16876" href="Data.Nat.Solver.html#16527" data-type="(e : Expr n) (env : Vec Nat n) → ⟦ ↓ e ⟧ₚ env ≡ ⟦ e ⟧ₑ env" class="Function">sound</a> <a id="16882" href="Data.Nat.Solver.html#16661" class="Bound">e</a> <a id="16884" href="Data.Nat.Solver.html#16664" class="Bound">env</a><a id="16887" class="Symbol">)</a> <a id="16889" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
  <a id="16893" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="16897" class="Symbol">(</a><a id="16898" href="Data.Nat.Solver.html#15466" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="16900" href="Data.Nat.Solver.html#16661" class="Bound">e</a> <a id="16902" href="Data.Nat.Solver.html#15466" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟧ₑ</a> <a id="16905" href="Data.Nat.Solver.html#16664" class="Bound">env</a><a id="16908" class="Symbol">)</a> <a id="16910" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
<a id="16912" href="Data.Nat.Solver.html#16527" data-type="(e : Expr n) (env : Vec Nat n) → ⟦ ↓ e ⟧ₚ env ≡ ⟦ e ⟧ₑ env" class="Function">sound</a> <a id="16918" class="Symbol">(</a><a id="16919" href="Data.Nat.Solver.html#15176" data-type="Nat → Expr n" class="InductiveConstructor">‵lit</a> <a id="16924" href="Data.Nat.Solver.html#16924" class="Bound">k</a><a id="16925" class="Symbol">)</a> <a id="16927" href="Data.Nat.Solver.html#16927" class="Bound">env</a> <a id="16931" class="Symbol">=</a> <a id="16933" href="Data.Nat.Solver.html#8506" data-type="(c : Nat) (env : Vec Nat n) → ⟦ constₚ c ⟧ₚ env ≡ c" class="Function">sound-constₚ</a> <a id="16946" href="Data.Nat.Solver.html#16924" class="Bound">k</a> <a id="16948" href="Data.Nat.Solver.html#16927" class="Bound">env</a>
<a id="16952" href="Data.Nat.Solver.html#16527" data-type="(e : Expr n) (env : Vec Nat n) → ⟦ ↓ e ⟧ₚ env ≡ ⟦ e ⟧ₑ env" class="Function">sound</a> <a id="16958" class="Symbol">(</a><a id="16959" href="Data.Nat.Solver.html#16959" class="Bound">e₁</a> <a id="16962" href="Data.Nat.Solver.html#15275" data-type="Expr n → Expr n → Expr n" class="InductiveConstructor Operator">‵+</a> <a id="16965" href="Data.Nat.Solver.html#16965" class="Bound">e₂</a><a id="16967" class="Symbol">)</a> <a id="16969" href="Data.Nat.Solver.html#16969" class="Bound">env</a> <a id="16973" class="Symbol">=</a>
  <a id="16977" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="16979" class="Symbol">(</a><a id="16980" href="Data.Nat.Solver.html#16030" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="16982" href="Data.Nat.Solver.html#16959" class="Bound">e₁</a><a id="16984" class="Symbol">)</a> <a id="16986" href="Data.Nat.Solver.html#5927" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">+ₚ</a> <a id="16989" class="Symbol">(</a><a id="16990" href="Data.Nat.Solver.html#16030" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="16992" href="Data.Nat.Solver.html#16965" class="Bound">e₂</a><a id="16994" class="Symbol">)</a> <a id="16996" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="16999" href="Data.Nat.Solver.html#16969" class="Bound">env</a>     <span class="reasoning-step"><span class="as-written Function"><a id="17007" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="17010" href="Data.Nat.Solver.html#9382" data-type="(p q : Poly Nat n) (env : Vec Nat n) →
⟦ p +ₚ q ⟧ₚ env ≡ ⟦ p ⟧ₚ env + ⟦ q ⟧ₚ env" class="Function">sound-+ₚ</a> <a id="17019" class="Symbol">(</a><a id="17020" href="Data.Nat.Solver.html#16030" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="17022" href="Data.Nat.Solver.html#16959" class="Bound">e₁</a><a id="17024" class="Symbol">)</a> <a id="17026" class="Symbol">(</a><a id="17027" href="Data.Nat.Solver.html#16030" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="17029" href="Data.Nat.Solver.html#16965" class="Bound">e₂</a><a id="17031" class="Symbol">)</a> <a id="17033" href="Data.Nat.Solver.html#16969" class="Bound">env</a> <a id="17037" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
  <a id="17041" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="17043" href="Data.Nat.Solver.html#16030" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="17045" href="Data.Nat.Solver.html#16959" class="Bound">e₁</a> <a id="17048" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="17051" href="Data.Nat.Solver.html#16969" class="Bound">env</a> <a id="17055" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="17057" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="17059" href="Data.Nat.Solver.html#16030" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="17061" href="Data.Nat.Solver.html#16965" class="Bound">e₂</a> <a id="17064" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="17067" href="Data.Nat.Solver.html#16969" class="Bound">env</a> <span class="reasoning-step"><span class="as-written Function"><a id="17071" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="17074" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="17078" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">_+_</a> <a id="17082" class="Symbol">(</a><a id="17083" href="Data.Nat.Solver.html#16527" data-type="(e : Expr n) (env : Vec Nat n) → ⟦ ↓ e ⟧ₚ env ≡ ⟦ e ⟧ₑ env" class="Function">sound</a> <a id="17089" href="Data.Nat.Solver.html#16959" class="Bound">e₁</a> <a id="17092" href="Data.Nat.Solver.html#16969" class="Bound">env</a><a id="17095" class="Symbol">)</a> <a id="17097" class="Symbol">(</a><a id="17098" href="Data.Nat.Solver.html#16527" data-type="(e : Expr n) (env : Vec Nat n) → ⟦ ↓ e ⟧ₚ env ≡ ⟦ e ⟧ₑ env" class="Function">sound</a> <a id="17104" href="Data.Nat.Solver.html#16965" class="Bound">e₂</a> <a id="17107" href="Data.Nat.Solver.html#16969" class="Bound">env</a><a id="17110" class="Symbol">)</a> <a id="17112" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
  <a id="17116" href="Data.Nat.Solver.html#15466" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="17118" href="Data.Nat.Solver.html#16959" class="Bound">e₁</a> <a id="17121" href="Data.Nat.Solver.html#15466" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟧ₑ</a> <a id="17124" href="Data.Nat.Solver.html#16969" class="Bound">env</a> <a id="17128" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="17130" href="Data.Nat.Solver.html#15466" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="17132" href="Data.Nat.Solver.html#16965" class="Bound">e₂</a> <a id="17135" href="Data.Nat.Solver.html#15466" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟧ₑ</a> <a id="17138" href="Data.Nat.Solver.html#16969" class="Bound">env</a>     <a id="17146" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
<a id="17148" href="Data.Nat.Solver.html#16527" data-type="(e : Expr n) (env : Vec Nat n) → ⟦ ↓ e ⟧ₚ env ≡ ⟦ e ⟧ₑ env" class="Function">sound</a> <a id="17154" class="Symbol">(</a><a id="17155" href="Data.Nat.Solver.html#17155" class="Bound">e₁</a> <a id="17158" href="Data.Nat.Solver.html#15317" data-type="Expr n → Expr n → Expr n" class="InductiveConstructor Operator">‵*</a> <a id="17161" href="Data.Nat.Solver.html#17161" class="Bound">e₂</a><a id="17163" class="Symbol">)</a> <a id="17165" href="Data.Nat.Solver.html#17165" class="Bound">env</a> <a id="17169" class="Symbol">=</a>
  <a id="17173" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="17175" class="Symbol">(</a><a id="17176" href="Data.Nat.Solver.html#16030" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="17178" href="Data.Nat.Solver.html#17155" class="Bound">e₁</a><a id="17180" class="Symbol">)</a> <a id="17182" href="Data.Nat.Solver.html#6444" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">*ₚ</a> <a id="17185" class="Symbol">(</a><a id="17186" href="Data.Nat.Solver.html#16030" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="17188" href="Data.Nat.Solver.html#17161" class="Bound">e₂</a><a id="17190" class="Symbol">)</a> <a id="17192" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="17195" href="Data.Nat.Solver.html#17165" class="Bound">env</a>     <span class="reasoning-step"><span class="as-written Function"><a id="17203" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="17206" href="Data.Nat.Solver.html#10662" data-type="(p q : Poly Nat n) (env : Vec Nat n) →
⟦ p *ₚ q ⟧ₚ env ≡ ⟦ p ⟧ₚ env * ⟦ q ⟧ₚ env" class="Function">sound-*ₚ</a> <a id="17215" class="Symbol">(</a><a id="17216" href="Data.Nat.Solver.html#16030" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="17218" href="Data.Nat.Solver.html#17155" class="Bound">e₁</a><a id="17220" class="Symbol">)</a> <a id="17222" class="Symbol">(</a><a id="17223" href="Data.Nat.Solver.html#16030" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="17225" href="Data.Nat.Solver.html#17161" class="Bound">e₂</a><a id="17227" class="Symbol">)</a> <a id="17229" href="Data.Nat.Solver.html#17165" class="Bound">env</a> <a id="17233" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
  <a id="17237" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="17239" href="Data.Nat.Solver.html#16030" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="17241" href="Data.Nat.Solver.html#17155" class="Bound">e₁</a> <a id="17244" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="17247" href="Data.Nat.Solver.html#17165" class="Bound">env</a> <a id="17251" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="17253" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="17255" href="Data.Nat.Solver.html#16030" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="17257" href="Data.Nat.Solver.html#17161" class="Bound">e₂</a> <a id="17260" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="17263" href="Data.Nat.Solver.html#17165" class="Bound">env</a> <span class="reasoning-step"><span class="as-written Function"><a id="17267" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="17270" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="17274" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">_*_</a> <a id="17278" class="Symbol">(</a><a id="17279" href="Data.Nat.Solver.html#16527" data-type="(e : Expr n) (env : Vec Nat n) → ⟦ ↓ e ⟧ₚ env ≡ ⟦ e ⟧ₑ env" class="Function">sound</a> <a id="17285" href="Data.Nat.Solver.html#17155" class="Bound">e₁</a> <a id="17288" href="Data.Nat.Solver.html#17165" class="Bound">env</a><a id="17291" class="Symbol">)</a> <a id="17293" class="Symbol">(</a><a id="17294" href="Data.Nat.Solver.html#16527" data-type="(e : Expr n) (env : Vec Nat n) → ⟦ ↓ e ⟧ₚ env ≡ ⟦ e ⟧ₑ env" class="Function">sound</a> <a id="17300" href="Data.Nat.Solver.html#17161" class="Bound">e₂</a> <a id="17303" href="Data.Nat.Solver.html#17165" class="Bound">env</a><a id="17306" class="Symbol">)</a> <a id="17308" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
  <a id="17312" href="Data.Nat.Solver.html#15466" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="17314" href="Data.Nat.Solver.html#17155" class="Bound">e₁</a> <a id="17317" href="Data.Nat.Solver.html#15466" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟧ₑ</a> <a id="17320" href="Data.Nat.Solver.html#17165" class="Bound">env</a> <a id="17324" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="17326" href="Data.Nat.Solver.html#15466" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="17328" href="Data.Nat.Solver.html#17161" class="Bound">e₂</a> <a id="17331" href="Data.Nat.Solver.html#15466" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟧ₑ</a> <a id="17334" href="Data.Nat.Solver.html#17165" class="Bound">env</a>     <a id="17342" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>

</pre>
<p>Now, all we need to do is expose an interface for the reflection
portion of the solver. The <code>abstract</code> here is VERY IMPORTANT,
as it prevents the proof from unfolding into an enourmous term that
kills our compile times.</p>
<pre class="Agda"><a id="17579" class="Keyword">abstract</a>
  <a id="solve"></a><a id="17590" href="Data.Nat.Solver.html#17590" data-type="(e₁ e₂ : Expr n) (env : Vec Nat n) →
⟦ ↓ e₁ ⟧ₚ env ≡ ⟦ ↓ e₂ ⟧ₚ env → ⟦ e₁ ⟧ₑ env ≡ ⟦ e₂ ⟧ₑ env" class="Function">solve</a> <a id="17596" class="Symbol">:</a> <a id="17598" class="Symbol">∀</a> <a id="17600" href="Data.Nat.Solver.html#17600" class="Bound">e₁</a> <a id="17603" href="Data.Nat.Solver.html#17603" class="Bound">e₂</a> <a id="17606" class="Symbol">→</a> <a id="17608" class="Symbol">(</a><a id="17609" href="Data.Nat.Solver.html#17609" class="Bound">env</a> <a id="17613" class="Symbol">:</a> <a id="17615" href="1Lab.Reflection.html#1792" data-type="Type ℓ → Nat → Type ℓ" class="Datatype">Vec</a> <a id="17619" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="17623" href="Data.Nat.Solver.html#3049" class="Generalizable">n</a><a id="17624" class="Symbol">)</a>
        <a id="17634" class="Symbol">→</a> <a id="17636" class="Symbol">(</a><a id="17637" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="17639" href="Data.Nat.Solver.html#16030" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="17641" href="Data.Nat.Solver.html#17600" class="Bound">e₁</a> <a id="17644" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="17647" href="Data.Nat.Solver.html#17609" class="Bound">env</a> <a id="17651" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="17653" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="17655" href="Data.Nat.Solver.html#16030" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="17657" href="Data.Nat.Solver.html#17603" class="Bound">e₂</a> <a id="17660" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="17663" href="Data.Nat.Solver.html#17609" class="Bound">env</a><a id="17666" class="Symbol">)</a>
        <a id="17676" class="Symbol">→</a> <a id="17678" href="Data.Nat.Solver.html#15466" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="17680" href="Data.Nat.Solver.html#17600" class="Bound">e₁</a> <a id="17683" href="Data.Nat.Solver.html#15466" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟧ₑ</a> <a id="17686" href="Data.Nat.Solver.html#17609" class="Bound">env</a>    <a id="17693" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="17695" href="Data.Nat.Solver.html#15466" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="17697" href="Data.Nat.Solver.html#17603" class="Bound">e₂</a> <a id="17700" href="Data.Nat.Solver.html#15466" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟧ₑ</a> <a id="17703" href="Data.Nat.Solver.html#17609" class="Bound">env</a>
  <a id="17709" href="Data.Nat.Solver.html#17590" data-type="(e₁ e₂ : Expr n) (env : Vec Nat n) →
⟦ ↓ e₁ ⟧ₚ env ≡ ⟦ ↓ e₂ ⟧ₚ env → ⟦ e₁ ⟧ₑ env ≡ ⟦ e₂ ⟧ₑ env" class="Function">solve</a> <a id="17715" href="Data.Nat.Solver.html#17715" class="Bound">e₁</a> <a id="17718" href="Data.Nat.Solver.html#17718" class="Bound">e₂</a> <a id="17721" href="Data.Nat.Solver.html#17721" class="Bound">env</a> <a id="17725" href="Data.Nat.Solver.html#17725" class="Bound">p</a> <a id="17727" class="Symbol">=</a> <a id="17729" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="17733" class="Symbol">(</a><a id="17734" href="Data.Nat.Solver.html#16527" data-type="(e : Expr n) (env : Vec Nat n) → ⟦ ↓ e ⟧ₚ env ≡ ⟦ e ⟧ₑ env" class="Function">sound</a> <a id="17740" href="Data.Nat.Solver.html#17715" class="Bound">e₁</a> <a id="17743" href="Data.Nat.Solver.html#17721" class="Bound">env</a><a id="17746" class="Symbol">)</a> <a id="17748" href="1Lab.Path.html#38305" data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" class="Function Operator">··</a> <a id="17751" href="Data.Nat.Solver.html#17725" class="Bound">p</a> <a id="17753" href="1Lab.Path.html#38305" data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" class="Function Operator">··</a> <a id="17756" href="Data.Nat.Solver.html#16527" data-type="(e : Expr n) (env : Vec Nat n) → ⟦ ↓ e ⟧ₚ env ≡ ⟦ e ⟧ₑ env" class="Function">sound</a> <a id="17762" href="Data.Nat.Solver.html#17718" class="Bound">e₂</a> <a id="17765" href="Data.Nat.Solver.html#17721" class="Bound">env</a>
</pre>
<p>We also expose a function for “simplifying” expressions. In reality
this will almost always make the term more complicated, but it’s useful
for debugging purposes.</p>
<pre class="Agda"><a id="expand"></a><a id="17947" href="Data.Nat.Solver.html#17947" data-type="Expr n → Vec Nat n → Nat" class="Function">expand</a> <a id="17954" class="Symbol">:</a> <a id="17956" class="Symbol">(</a><a id="17957" href="Data.Nat.Solver.html#17957" class="Bound">e</a> <a id="17959" class="Symbol">:</a> <a id="17961" href="Data.Nat.Solver.html#15126" data-type="Nat → Type" class="Datatype">Expr</a> <a id="17966" href="Data.Nat.Solver.html#3049" class="Generalizable">n</a><a id="17967" class="Symbol">)</a> <a id="17969" class="Symbol">→</a> <a id="17971" class="Symbol">(</a><a id="17972" href="Data.Nat.Solver.html#17972" class="Bound">env</a> <a id="17976" class="Symbol">:</a> <a id="17978" href="1Lab.Reflection.html#1792" data-type="Type ℓ → Nat → Type ℓ" class="Datatype">Vec</a> <a id="17982" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="17986" href="Data.Nat.Solver.html#3049" class="Generalizable">n</a><a id="17987" class="Symbol">)</a> <a id="17989" class="Symbol">→</a> <a id="17991" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a>
<a id="17995" href="Data.Nat.Solver.html#17947" data-type="Expr n → Vec Nat n → Nat" class="Function">expand</a> <a id="18002" href="Data.Nat.Solver.html#18002" class="Bound">e</a> <a id="18004" href="Data.Nat.Solver.html#18004" class="Bound">env</a> <a id="18008" class="Symbol">=</a> <a id="18010" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="18012" href="Data.Nat.Solver.html#16030" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="18014" href="Data.Nat.Solver.html#18002" class="Bound">e</a> <a id="18016" href="Data.Nat.Solver.html#7927" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="18019" href="Data.Nat.Solver.html#18004" class="Bound">env</a>
</pre>
<h2 id="reflection"><a href="#reflection" class="header-link">Reflection<span class="header-link-emoji">🔗</span></a></h2>
<p>Now, for the <em>truly</em> difficult part: the reflection interface.
We begin by defining some pattern synonyms for expressions we want to
reflect into our
<span class="Agda"><a href="Data.Nat.Solver.html#15126" class="Datatype">Expr</a></span>
type.</p>
<pre class="Agda"><a id="18222" class="Keyword">private</a>
  <a id="18232" class="Keyword">pattern</a> <a id="nat-lit"></a><a id="18240" href="Data.Nat.Solver.html#18240" class="InductiveConstructor">nat-lit</a> <a id="18248" href="Data.Nat.Solver.html#18309" class="Bound">n</a> <a id="18250" class="Symbol">=</a>
    <a id="18256" href="Agda.Builtin.Reflection.html#4903" data-type="Name → List (Arg Term) → Term" class="InductiveConstructor">def</a> <a id="18260" class="Symbol">(</a><a id="18261" class="Keyword">quote</a> <a id="18267" href="Agda.Builtin.FromNat.html#282" data-type="(r : Number A) (n : Nat) ⦃ _ : Constraint r n ⦄ → A" class="Field">Number.fromNat</a><a id="18281" class="Symbol">)</a> <a id="18283" class="Symbol">(_</a> <a id="18286" href="1Lab.Reflection.html#1330" class="InductiveConstructor Operator">h∷</a> <a id="18289" class="Symbol">_</a> <a id="18291" href="1Lab.Reflection.html#1330" class="InductiveConstructor Operator">h∷</a> <a id="18294" class="Symbol">_</a> <a id="18296" href="1Lab.Reflection.html#1249" class="InductiveConstructor Operator">v∷</a> <a id="18299" class="Symbol">(</a><a id="18300" class="InductiveConstructor">lit</a> <a id="18304" class="Symbol">(</a><a id="18305" href="Agda.Builtin.Reflection.html#4114" data-type="Nat → Literal" class="InductiveConstructor">nat</a> <a id="18309" href="Data.Nat.Solver.html#18309" class="Bound">n</a><a id="18310" class="Symbol">))</a> <a id="18313" href="1Lab.Reflection.html#1249" class="InductiveConstructor Operator">v∷</a> <a id="18316" class="Symbol">_)</a>
  <a id="18321" class="Keyword">pattern</a> <a id="″zero″"></a><a id="18329" href="Data.Nat.Solver.html#18329" class="InductiveConstructor">″zero″</a> <a id="18336" class="Symbol">=</a>
    <a id="18342" class="InductiveConstructor">con</a> <a id="18346" class="Symbol">(</a><a id="18347" class="Keyword">quote</a> <a id="18353" href="Agda.Builtin.Nat.html#210" data-type="Nat" class="InductiveConstructor">zero</a><a id="18357" class="Symbol">)</a> <a id="18359" class="InductiveConstructor">[]</a>
  <a id="18364" class="Keyword">pattern</a> <a id="″suc″"></a><a id="18372" href="Data.Nat.Solver.html#18372" class="InductiveConstructor">″suc″</a> <a id="18378" href="Data.Nat.Solver.html#18403" class="Bound">x</a> <a id="18380" class="Symbol">=</a>
    <a id="18386" class="InductiveConstructor">con</a> <a id="18390" class="Symbol">(</a><a id="18391" class="Keyword">quote</a> <a id="18397" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a><a id="18400" class="Symbol">)</a> <a id="18402" class="Symbol">(</a><a id="18403" href="Data.Nat.Solver.html#18403" class="Bound">x</a> <a id="18405" href="1Lab.Reflection.html#1249" class="InductiveConstructor Operator">v∷</a> <a id="18408" class="InductiveConstructor">[]</a><a id="18410" class="Symbol">)</a>
  <a id="18414" class="Keyword">pattern</a> <a id="_″+″_"></a><a id="18422" href="Data.Nat.Solver.html#18422" class="InductiveConstructor Operator">_″+″_</a> <a id="18428" href="Data.Nat.Solver.html#18455" class="Bound">x</a> <a id="18430" href="Data.Nat.Solver.html#18460" class="Bound">y</a> <a id="18432" class="Symbol">=</a>
    <a id="18438" href="Agda.Builtin.Reflection.html#4903" data-type="Name → List (Arg Term) → Term" class="InductiveConstructor">def</a> <a id="18442" class="Symbol">(</a><a id="18443" class="Keyword">quote</a> <a id="18449" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">_+_</a><a id="18452" class="Symbol">)</a> <a id="18454" class="Symbol">(</a><a id="18455" href="Data.Nat.Solver.html#18455" class="Bound">x</a> <a id="18457" href="1Lab.Reflection.html#1249" class="InductiveConstructor Operator">v∷</a> <a id="18460" href="Data.Nat.Solver.html#18460" class="Bound">y</a> <a id="18462" href="1Lab.Reflection.html#1249" class="InductiveConstructor Operator">v∷</a> <a id="18465" class="Symbol">_)</a>
  <a id="18470" class="Keyword">pattern</a> <a id="_″*″_"></a><a id="18478" href="Data.Nat.Solver.html#18478" class="InductiveConstructor Operator">_″*″_</a> <a id="18484" href="Data.Nat.Solver.html#18511" class="Bound">x</a> <a id="18486" href="Data.Nat.Solver.html#18516" class="Bound">y</a> <a id="18488" class="Symbol">=</a>
    <a id="18494" href="Agda.Builtin.Reflection.html#4903" data-type="Name → List (Arg Term) → Term" class="InductiveConstructor">def</a> <a id="18498" class="Symbol">(</a><a id="18499" class="Keyword">quote</a> <a id="18505" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">_*_</a><a id="18508" class="Symbol">)</a> <a id="18510" class="Symbol">(</a><a id="18511" href="Data.Nat.Solver.html#18511" class="Bound">x</a> <a id="18513" href="1Lab.Reflection.html#1249" class="InductiveConstructor Operator">v∷</a> <a id="18516" href="Data.Nat.Solver.html#18516" class="Bound">y</a> <a id="18518" href="1Lab.Reflection.html#1249" class="InductiveConstructor Operator">v∷</a> <a id="18521" class="Symbol">_)</a>
</pre>
<p>Next, we construct quoted a
<span class="Agda"><a href="Data.Nat.Solver.html#15126" class="Datatype">Expr</a></span>
from a term, replacing any unknown
<span class="Agda"><a href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a></span>
nodes with variables. This uses the <code>Variable</code> interface for
managing the <code>Fin</code> variables and the environment. A
discussion of the internals of this is out of scope of this solver; we
have already looked into the abyss too deeply.</p>
<pre class="Agda"><a id="18860" class="Keyword">private</a>
  <a id="build-expr"></a><a id="18870" href="Data.Nat.Solver.html#18870" data-type="Variables Nat → Term → TC (Term × Variables Nat)" class="Function">build-expr</a> <a id="18881" class="Symbol">:</a> <a id="18883" href="1Lab.Reflection.Variables.html#1713" data-type="(A : Type a) → Type a" class="Record">Variables</a> <a id="18893" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="18897" class="Symbol">→</a> <a id="18899" href="Agda.Builtin.Reflection.html#4688" data-type="Type" class="Datatype">Term</a> <a id="18904" class="Symbol">→</a> <a id="18906" href="Agda.Builtin.Reflection.html#8218" data-type="Type a → Type a" class="Postulate">TC</a> <a id="18909" class="Symbol">(</a><a id="18910" href="Agda.Builtin.Reflection.html#4688" data-type="Type" class="Datatype">Term</a> <a id="18915" href="1Lab.Type.html#1846" data-type="Type a → Type b → Type (a ⊔ b)" class="Function Operator">×</a> <a id="18917" href="1Lab.Reflection.Variables.html#1713" data-type="(A : Type a) → Type a" class="Record">Variables</a> <a id="18927" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a><a id="18930" class="Symbol">)</a>
  <a id="18934" href="Data.Nat.Solver.html#18870" data-type="Variables Nat → Term → TC (Term × Variables Nat)" class="Function">build-expr</a> <a id="18945" href="Data.Nat.Solver.html#18945" class="Bound">vs</a> <a id="18948" class="Symbol">(</a><a id="18949" href="Data.Nat.Solver.html#18240" class="InductiveConstructor">nat-lit</a> <a id="18957" href="Data.Nat.Solver.html#18957" class="Bound">n</a><a id="18958" class="Symbol">)</a> <a id="18960" class="Symbol">=</a> <a id="18962" class="Keyword">do</a>
    <a id="18969" href="Data.Nat.Solver.html#18969" class="Bound">‵n</a> <a id="18972" href="Agda.Builtin.Reflection.html#8311" data-type="TC A → (A → TC B₁) → TC B₁" class="Postulate Operator">←</a> <a id="18974" href="Agda.Builtin.Reflection.html#8705" data-type="A → TC Term" class="Postulate">quoteTC</a> <a id="18982" href="Data.Nat.Solver.html#18957" class="Bound">n</a>
    <a id="18988" href="Agda.Builtin.Reflection.html#8261" data-type="A → TC A" class="Postulate">returnTC</a> <a id="18997" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="18999" href="Agda.Builtin.Reflection.html#4846" data-type="Name → List (Arg Term) → Term" class="InductiveConstructor">con</a> <a id="19003" class="Symbol">(</a><a id="19004" class="Keyword">quote</a> <a id="19010" href="Data.Nat.Solver.html#15176" data-type="Nat → Expr n" class="InductiveConstructor">‵lit</a><a id="19014" class="Symbol">)</a> <a id="19016" class="Symbol">(</a><a id="19017" href="Data.Nat.Solver.html#18969" class="Bound">‵n</a> <a id="19020" href="1Lab.Reflection.html#1249" class="InductiveConstructor Operator">v∷</a> <a id="19023" href="Agda.Builtin.List.html#185" data-type="List A" class="InductiveConstructor">[]</a><a id="19025" class="Symbol">)</a> <a id="19027" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="19029" href="Data.Nat.Solver.html#18945" class="Bound">vs</a>
  <a id="19034" href="Data.Nat.Solver.html#18870" data-type="Variables Nat → Term → TC (Term × Variables Nat)" class="Function">build-expr</a> <a id="19045" href="Data.Nat.Solver.html#19045" class="Bound">vs</a> <a id="19048" href="Data.Nat.Solver.html#18329" class="InductiveConstructor">″zero″</a> <a id="19055" class="Symbol">=</a> <a id="19057" class="Keyword">do</a>
    <a id="19064" href="Agda.Builtin.Reflection.html#8261" data-type="A → TC A" class="Postulate">returnTC</a> <a id="19073" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="19075" href="Agda.Builtin.Reflection.html#4846" data-type="Name → List (Arg Term) → Term" class="InductiveConstructor">con</a> <a id="19079" class="Symbol">(</a><a id="19080" class="Keyword">quote</a> <a id="19086" href="Data.Nat.Solver.html#15152" data-type="Expr n" class="InductiveConstructor">‵0</a><a id="19088" class="Symbol">)</a> <a id="19090" class="Symbol">(</a><a id="19091" href="Agda.Builtin.Reflection.html#5246" data-type="Term" class="InductiveConstructor">unknown</a> <a id="19099" href="1Lab.Reflection.html#1330" class="InductiveConstructor Operator">h∷</a> <a id="19102" href="Agda.Builtin.List.html#185" data-type="List A" class="InductiveConstructor">[]</a><a id="19104" class="Symbol">)</a> <a id="19106" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="19108" href="Data.Nat.Solver.html#19045" class="Bound">vs</a>
  <a id="19113" href="Data.Nat.Solver.html#18870" data-type="Variables Nat → Term → TC (Term × Variables Nat)" class="Function">build-expr</a> <a id="19124" href="Data.Nat.Solver.html#19124" class="Bound">vs</a> <a id="19127" class="Symbol">(</a><a id="19128" href="Data.Nat.Solver.html#18372" class="InductiveConstructor">″suc″</a> <a id="19134" href="Data.Nat.Solver.html#19134" class="Bound">t</a><a id="19135" class="Symbol">)</a> <a id="19137" class="Symbol">=</a> <a id="19139" class="Keyword">do</a>
    <a id="19146" href="Data.Nat.Solver.html#19146" class="Bound">e</a> <a id="19148" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="19150" href="Data.Nat.Solver.html#19150" class="Bound">vs</a> <a id="19153" href="Agda.Builtin.Reflection.html#8311" data-type="TC A → (A → TC B₁) → TC B₁" class="Postulate Operator">←</a> <a id="19155" href="Data.Nat.Solver.html#18870" data-type="Variables Nat → Term → TC (Term × Variables Nat)" class="Function">build-expr</a> <a id="19166" href="Data.Nat.Solver.html#19124" class="Bound">vs</a> <a id="19169" href="Data.Nat.Solver.html#19134" class="Bound">t</a>
    <a id="19175" href="Agda.Builtin.Reflection.html#8261" data-type="A → TC A" class="Postulate">returnTC</a> <a id="19184" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="19186" href="Agda.Builtin.Reflection.html#4846" data-type="Name → List (Arg Term) → Term" class="InductiveConstructor">con</a> <a id="19190" class="Symbol">(</a><a id="19191" class="Keyword">quote</a> <a id="19197" href="Data.Nat.Solver.html#15242" data-type="Expr n → Expr n" class="InductiveConstructor Operator">‵1+_</a><a id="19201" class="Symbol">)</a> <a id="19203" class="Symbol">(</a><a id="19204" href="Agda.Builtin.Reflection.html#5246" data-type="Term" class="InductiveConstructor">unknown</a> <a id="19212" href="1Lab.Reflection.html#1330" class="InductiveConstructor Operator">h∷</a> <a id="19215" href="Data.Nat.Solver.html#19146" class="Bound">e</a> <a id="19217" href="1Lab.Reflection.html#1249" class="InductiveConstructor Operator">v∷</a> <a id="19220" href="Agda.Builtin.List.html#185" data-type="List A" class="InductiveConstructor">[]</a><a id="19222" class="Symbol">)</a> <a id="19224" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="19226" href="Data.Nat.Solver.html#19150" class="Bound">vs</a>
  <a id="19231" href="Data.Nat.Solver.html#18870" data-type="Variables Nat → Term → TC (Term × Variables Nat)" class="Function">build-expr</a> <a id="19242" href="Data.Nat.Solver.html#19242" class="Bound">vs</a> <a id="19245" class="Symbol">(</a><a id="19246" href="Data.Nat.Solver.html#19246" class="Bound">t₁</a> <a id="19249" href="Data.Nat.Solver.html#18422" class="InductiveConstructor Operator">″+″</a> <a id="19253" href="Data.Nat.Solver.html#19253" class="Bound">t₂</a><a id="19255" class="Symbol">)</a> <a id="19257" class="Symbol">=</a> <a id="19259" class="Keyword">do</a>
    <a id="19266" href="Data.Nat.Solver.html#19266" class="Bound">e₁</a> <a id="19269" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="19271" href="Data.Nat.Solver.html#19271" class="Bound">vs</a> <a id="19274" href="Agda.Builtin.Reflection.html#8311" data-type="TC A → (A → TC B₁) → TC B₁" class="Postulate Operator">←</a> <a id="19276" href="Data.Nat.Solver.html#18870" data-type="Variables Nat → Term → TC (Term × Variables Nat)" class="Function">build-expr</a> <a id="19287" href="Data.Nat.Solver.html#19242" class="Bound">vs</a> <a id="19290" href="Data.Nat.Solver.html#19246" class="Bound">t₁</a>
    <a id="19297" href="Data.Nat.Solver.html#19297" class="Bound">e₂</a> <a id="19300" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="19302" href="Data.Nat.Solver.html#19302" class="Bound">vs</a> <a id="19305" href="Agda.Builtin.Reflection.html#8311" data-type="TC A → (A → TC B₁) → TC B₁" class="Postulate Operator">←</a> <a id="19307" href="Data.Nat.Solver.html#18870" data-type="Variables Nat → Term → TC (Term × Variables Nat)" class="Function">build-expr</a> <a id="19318" href="Data.Nat.Solver.html#19271" class="Bound">vs</a> <a id="19321" href="Data.Nat.Solver.html#19253" class="Bound">t₂</a>
    <a id="19328" href="Agda.Builtin.Reflection.html#8261" data-type="A → TC A" class="Postulate">returnTC</a> <a id="19337" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="19339" href="Agda.Builtin.Reflection.html#4846" data-type="Name → List (Arg Term) → Term" class="InductiveConstructor">con</a> <a id="19343" class="Symbol">(</a><a id="19344" class="Keyword">quote</a> <a id="19350" href="Data.Nat.Solver.html#15275" data-type="Expr n → Expr n → Expr n" class="InductiveConstructor Operator">_‵+_</a><a id="19354" class="Symbol">)</a> <a id="19356" class="Symbol">(</a><a id="19357" href="Agda.Builtin.Reflection.html#5246" data-type="Term" class="InductiveConstructor">unknown</a> <a id="19365" href="1Lab.Reflection.html#1330" class="InductiveConstructor Operator">h∷</a> <a id="19368" href="Data.Nat.Solver.html#19266" class="Bound">e₁</a> <a id="19371" href="1Lab.Reflection.html#1249" class="InductiveConstructor Operator">v∷</a> <a id="19374" href="Data.Nat.Solver.html#19297" class="Bound">e₂</a> <a id="19377" href="1Lab.Reflection.html#1249" class="InductiveConstructor Operator">v∷</a> <a id="19380" href="Agda.Builtin.List.html#185" data-type="List A" class="InductiveConstructor">[]</a><a id="19382" class="Symbol">)</a> <a id="19384" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="19386" href="Data.Nat.Solver.html#19302" class="Bound">vs</a>
  <a id="19391" href="Data.Nat.Solver.html#18870" data-type="Variables Nat → Term → TC (Term × Variables Nat)" class="Function">build-expr</a> <a id="19402" href="Data.Nat.Solver.html#19402" class="Bound">vs</a> <a id="19405" class="Symbol">(</a><a id="19406" href="Data.Nat.Solver.html#19406" class="Bound">t₁</a> <a id="19409" href="Data.Nat.Solver.html#18478" class="InductiveConstructor Operator">″*″</a> <a id="19413" href="Data.Nat.Solver.html#19413" class="Bound">t₂</a><a id="19415" class="Symbol">)</a> <a id="19417" class="Symbol">=</a> <a id="19419" class="Keyword">do</a>
    <a id="19426" href="Data.Nat.Solver.html#19426" class="Bound">e₁</a> <a id="19429" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="19431" href="Data.Nat.Solver.html#19431" class="Bound">vs</a> <a id="19434" href="Agda.Builtin.Reflection.html#8311" data-type="TC A → (A → TC B₁) → TC B₁" class="Postulate Operator">←</a> <a id="19436" href="Data.Nat.Solver.html#18870" data-type="Variables Nat → Term → TC (Term × Variables Nat)" class="Function">build-expr</a> <a id="19447" href="Data.Nat.Solver.html#19402" class="Bound">vs</a> <a id="19450" href="Data.Nat.Solver.html#19406" class="Bound">t₁</a>
    <a id="19457" href="Data.Nat.Solver.html#19457" class="Bound">e₂</a> <a id="19460" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="19462" href="Data.Nat.Solver.html#19462" class="Bound">vs</a> <a id="19465" href="Agda.Builtin.Reflection.html#8311" data-type="TC A → (A → TC B₁) → TC B₁" class="Postulate Operator">←</a> <a id="19467" href="Data.Nat.Solver.html#18870" data-type="Variables Nat → Term → TC (Term × Variables Nat)" class="Function">build-expr</a> <a id="19478" href="Data.Nat.Solver.html#19431" class="Bound">vs</a> <a id="19481" href="Data.Nat.Solver.html#19413" class="Bound">t₂</a>
    <a id="19488" href="Agda.Builtin.Reflection.html#8261" data-type="A → TC A" class="Postulate">returnTC</a> <a id="19497" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="19499" href="Agda.Builtin.Reflection.html#4846" data-type="Name → List (Arg Term) → Term" class="InductiveConstructor">con</a> <a id="19503" class="Symbol">(</a><a id="19504" class="Keyword">quote</a> <a id="19510" href="Data.Nat.Solver.html#15317" data-type="Expr n → Expr n → Expr n" class="InductiveConstructor Operator">_‵*_</a><a id="19514" class="Symbol">)</a> <a id="19516" class="Symbol">(</a><a id="19517" href="Agda.Builtin.Reflection.html#5246" data-type="Term" class="InductiveConstructor">unknown</a> <a id="19525" href="1Lab.Reflection.html#1330" class="InductiveConstructor Operator">h∷</a> <a id="19528" href="Data.Nat.Solver.html#19426" class="Bound">e₁</a> <a id="19531" href="1Lab.Reflection.html#1249" class="InductiveConstructor Operator">v∷</a> <a id="19534" href="Data.Nat.Solver.html#19457" class="Bound">e₂</a> <a id="19537" href="1Lab.Reflection.html#1249" class="InductiveConstructor Operator">v∷</a> <a id="19540" href="Agda.Builtin.List.html#185" data-type="List A" class="InductiveConstructor">[]</a><a id="19542" class="Symbol">)</a> <a id="19544" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="19546" href="Data.Nat.Solver.html#19462" class="Bound">vs</a>
  <a id="19551" href="Data.Nat.Solver.html#18870" data-type="Variables Nat → Term → TC (Term × Variables Nat)" class="CatchallClause Function">build-expr</a><a id="19561" class="CatchallClause"> </a><a id="19562" href="Data.Nat.Solver.html#19562" class="CatchallClause Bound">vs</a><a id="19564" class="CatchallClause"> </a><a id="19565" href="Data.Nat.Solver.html#19565" class="CatchallClause Bound">tm</a> <a id="19568" class="Symbol">=</a> <a id="19570" class="Keyword">do</a>
    <a id="19577" class="Symbol">(</a><a id="19578" href="Data.Nat.Solver.html#19578" class="Bound">v</a> <a id="19580" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="19582" href="Data.Nat.Solver.html#19582" class="Bound">vs′</a><a id="19585" class="Symbol">)</a> <a id="19587" href="Agda.Builtin.Reflection.html#8311" data-type="TC A → (A → TC B₁) → TC B₁" class="Postulate Operator">←</a> <a id="19589" href="1Lab.Reflection.Variables.html#2967" data-type="Variables A → Term → TC (Term × Variables A)" class="Function">bind-var</a> <a id="19598" href="Data.Nat.Solver.html#19562" class="Bound">vs</a> <a id="19601" href="Data.Nat.Solver.html#19565" class="Bound">tm</a>
    <a id="19608" href="Agda.Builtin.Reflection.html#8261" data-type="A → TC A" class="Postulate">returnTC</a> <a id="19617" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="19619" href="Agda.Builtin.Reflection.html#4846" data-type="Name → List (Arg Term) → Term" class="InductiveConstructor">con</a> <a id="19623" class="Symbol">(</a><a id="19624" class="Keyword">quote</a> <a id="19630" href="Data.Nat.Solver.html#15209" data-type="Fin n → Expr n" class="InductiveConstructor Operator">‵_</a><a id="19632" class="Symbol">)</a> <a id="19634" class="Symbol">(</a><a id="19635" href="Data.Nat.Solver.html#19578" class="Bound">v</a> <a id="19637" href="1Lab.Reflection.html#1249" class="InductiveConstructor Operator">v∷</a> <a id="19640" href="Agda.Builtin.List.html#185" data-type="List A" class="InductiveConstructor">[]</a><a id="19642" class="Symbol">)</a> <a id="19644" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="19646" href="Data.Nat.Solver.html#19582" class="Bound">vs′</a>
</pre>
<p>Next, a quick helper for getting the endpoints of an equality.</p>
<pre class="Agda"><a id="19727" class="Keyword">private</a>
  <a id="get-boundary"></a><a id="19737" href="Data.Nat.Solver.html#19737" data-type="Term → TC (Maybe (Term × Term))" class="Function">get-boundary</a> <a id="19750" class="Symbol">:</a> <a id="19752" href="Agda.Builtin.Reflection.html#4688" data-type="Type" class="Datatype">Term</a> <a id="19757" class="Symbol">→</a> <a id="19759" href="Agda.Builtin.Reflection.html#8218" data-type="Type a → Type a" class="Postulate">TC</a> <a id="19762" class="Symbol">(</a><a id="19763" href="Agda.Builtin.Maybe.html#136" data-type="Type a → Type a" class="Datatype">Maybe</a> <a id="19769" class="Symbol">(</a><a id="19770" href="Agda.Builtin.Reflection.html#4688" data-type="Type" class="Datatype">Term</a> <a id="19775" href="1Lab.Type.html#1846" data-type="Type a → Type b → Type (a ⊔ b)" class="Function Operator">×</a> <a id="19777" href="Agda.Builtin.Reflection.html#4688" data-type="Type" class="Datatype">Term</a><a id="19781" class="Symbol">))</a>
  <a id="19786" href="Data.Nat.Solver.html#19737" data-type="Term → TC (Maybe (Term × Term))" class="Function">get-boundary</a> <a id="19799" href="Data.Nat.Solver.html#19799" class="Bound">tm</a><a id="19801" class="Symbol">@(</a><a id="19803" href="Agda.Builtin.Reflection.html#4903" data-type="Name → List (Arg Term) → Term" class="InductiveConstructor">def</a> <a id="19807" class="Symbol">(</a><a id="19808" class="Keyword">quote</a> <a id="19814" href="Agda.Builtin.Cubical.Path.html#197" data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" class="Postulate">PathP</a><a id="19819" class="Symbol">)</a> <a id="19821" class="Symbol">(_</a> <a id="19824" href="1Lab.Reflection.html#1330" class="InductiveConstructor Operator">h∷</a> <a id="19827" href="Data.Nat.Solver.html#19827" class="Bound">T</a> <a id="19829" href="1Lab.Reflection.html#1249" class="InductiveConstructor Operator">v∷</a> <a id="19832" href="Data.Nat.Solver.html#19832" class="Bound">x</a> <a id="19834" href="1Lab.Reflection.html#1249" class="InductiveConstructor Operator">v∷</a> <a id="19837" href="Data.Nat.Solver.html#19837" class="Bound">y</a> <a id="19839" href="1Lab.Reflection.html#1249" class="InductiveConstructor Operator">v∷</a> <a id="19842" href="Agda.Builtin.List.html#185" data-type="List A" class="InductiveConstructor">[]</a><a id="19844" class="Symbol">))</a> <a id="19847" class="Symbol">=</a> <a id="19849" class="Keyword">do</a>
    <a id="19856" href="Agda.Builtin.Reflection.html#8391" data-type="Term → Term → TC ⊤" class="Postulate">unify</a> <a id="19862" href="Data.Nat.Solver.html#19799" class="Bound">tm</a> <a id="19865" class="Symbol">(</a><a id="19866" href="Agda.Builtin.Reflection.html#4903" data-type="Name → List (Arg Term) → Term" class="InductiveConstructor">def</a> <a id="19870" class="Symbol">(</a><a id="19871" class="Keyword">quote</a> <a id="19877" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">_≡_</a><a id="19880" class="Symbol">)</a> <a id="19882" class="Symbol">(</a><a id="19883" href="Data.Nat.Solver.html#19832" class="Bound">x</a> <a id="19885" href="1Lab.Reflection.html#1249" class="InductiveConstructor Operator">v∷</a> <a id="19888" href="Data.Nat.Solver.html#19837" class="Bound">y</a> <a id="19890" href="1Lab.Reflection.html#1249" class="InductiveConstructor Operator">v∷</a> <a id="19893" href="Agda.Builtin.List.html#185" data-type="List A" class="InductiveConstructor">[]</a><a id="19895" class="Symbol">))</a>
    <a id="19902" href="Agda.Builtin.Reflection.html#8261" data-type="A → TC A" class="Postulate">returnTC</a> <a id="19911" class="Symbol">(</a><a id="19912" href="Agda.Builtin.Maybe.html#174" data-type="A → Maybe A" class="InductiveConstructor">just</a> <a id="19917" class="Symbol">(</a><a id="19918" href="Data.Nat.Solver.html#19832" class="Bound">x</a> <a id="19920" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="19922" href="Data.Nat.Solver.html#19837" class="Bound">y</a><a id="19923" class="Symbol">))</a>
  <a id="19928" href="Data.Nat.Solver.html#19737" data-type="Term → TC (Maybe (Term × Term))" class="Function">get-boundary</a> <a id="19941" class="Symbol">(</a><a id="19942" href="Agda.Builtin.Reflection.html#5196" data-type="Meta → List (Arg Term) → Term" class="InductiveConstructor">meta</a> <a id="19947" href="Data.Nat.Solver.html#19947" class="Bound">m</a> <a id="19949" class="Symbol">_)</a> <a id="19952" class="Symbol">=</a> <a id="19954" href="Agda.Builtin.Reflection.html#9287" data-type="Meta → TC A" class="Postulate">blockOnMeta</a> <a id="19966" href="Data.Nat.Solver.html#19947" class="Bound">m</a>
  <a id="19970" href="Data.Nat.Solver.html#19737" data-type="Term → TC (Maybe (Term × Term))" class="CatchallClause Function">get-boundary</a><a id="19982" class="CatchallClause"> </a><a id="19983" class="CatchallClause Symbol">_</a> <a id="19985" class="Symbol">=</a> <a id="19987" href="Agda.Builtin.Reflection.html#8261" data-type="A → TC A" class="Postulate">returnTC</a> <a id="19996" href="Agda.Builtin.Maybe.html#195" data-type="Maybe A" class="InductiveConstructor">nothing</a>
</pre>
<p>Next, let’s define the quoted forms of some terms that we will use to
interface with the solver.</p>
<pre class="Agda"><a id="20115" class="Keyword">private</a>
  <a id="″expand″"></a><a id="20125" href="Data.Nat.Solver.html#20125" data-type="Term → Term → Term" class="Function">″expand″</a> <a id="20134" class="Symbol">:</a> <a id="20136" href="Agda.Builtin.Reflection.html#4688" data-type="Type" class="Datatype">Term</a> <a id="20141" class="Symbol">→</a> <a id="20143" href="Agda.Builtin.Reflection.html#4688" data-type="Type" class="Datatype">Term</a> <a id="20148" class="Symbol">→</a> <a id="20150" href="Agda.Builtin.Reflection.html#4688" data-type="Type" class="Datatype">Term</a>
  <a id="20157" href="Data.Nat.Solver.html#20125" data-type="Term → Term → Term" class="Function">″expand″</a> <a id="20166" href="Data.Nat.Solver.html#20166" class="Bound">e</a> <a id="20168" href="Data.Nat.Solver.html#20168" class="Bound">env</a> <a id="20172" class="Symbol">=</a> <a id="20174" href="Agda.Builtin.Reflection.html#4903" data-type="Name → List (Arg Term) → Term" class="InductiveConstructor">def</a> <a id="20178" class="Symbol">(</a><a id="20179" class="Keyword">quote</a> <a id="20185" href="Data.Nat.Solver.html#17947" data-type="Expr n → Vec Nat n → Nat" class="Function">expand</a><a id="20191" class="Symbol">)</a> <a id="20193" class="Symbol">(</a><a id="20194" href="Agda.Builtin.Reflection.html#5246" data-type="Term" class="InductiveConstructor">unknown</a> <a id="20202" href="1Lab.Reflection.html#1330" class="InductiveConstructor Operator">h∷</a> <a id="20205" href="Data.Nat.Solver.html#20166" class="Bound">e</a> <a id="20207" href="1Lab.Reflection.html#1249" class="InductiveConstructor Operator">v∷</a> <a id="20210" href="Data.Nat.Solver.html#20168" class="Bound">env</a> <a id="20214" href="1Lab.Reflection.html#1249" class="InductiveConstructor Operator">v∷</a> <a id="20217" href="Agda.Builtin.List.html#185" data-type="List A" class="InductiveConstructor">[]</a><a id="20219" class="Symbol">)</a>

  <a id="″solve″"></a><a id="20224" href="Data.Nat.Solver.html#20224" data-type="Term → Term → Term → Term" class="Function">″solve″</a> <a id="20232" class="Symbol">:</a> <a id="20234" href="Agda.Builtin.Reflection.html#4688" data-type="Type" class="Datatype">Term</a> <a id="20239" class="Symbol">→</a> <a id="20241" href="Agda.Builtin.Reflection.html#4688" data-type="Type" class="Datatype">Term</a> <a id="20246" class="Symbol">→</a> <a id="20248" href="Agda.Builtin.Reflection.html#4688" data-type="Type" class="Datatype">Term</a> <a id="20253" class="Symbol">→</a> <a id="20255" href="Agda.Builtin.Reflection.html#4688" data-type="Type" class="Datatype">Term</a>
  <a id="20262" href="Data.Nat.Solver.html#20224" data-type="Term → Term → Term → Term" class="Function">″solve″</a> <a id="20270" href="Data.Nat.Solver.html#20270" class="Bound">lhs</a> <a id="20274" href="Data.Nat.Solver.html#20274" class="Bound">rhs</a> <a id="20278" href="Data.Nat.Solver.html#20278" class="Bound">env</a> <a id="20282" class="Symbol">=</a>
    <a id="20288" href="Agda.Builtin.Reflection.html#4903" data-type="Name → List (Arg Term) → Term" class="InductiveConstructor">def</a> <a id="20292" class="Symbol">(</a><a id="20293" class="Keyword">quote</a> <a id="20299" href="Data.Nat.Solver.html#17590" data-type="(e₁ e₂ : Expr n) (env : Vec Nat n) →
⟦ ↓ e₁ ⟧ₚ env ≡ ⟦ ↓ e₂ ⟧ₚ env → ⟦ e₁ ⟧ₑ env ≡ ⟦ e₂ ⟧ₑ env" class="Function">solve</a><a id="20304" class="Symbol">)</a>
        <a id="20314" class="Symbol">(</a><a id="20315" href="Agda.Builtin.Reflection.html#5246" data-type="Term" class="InductiveConstructor">unknown</a> <a id="20323" href="1Lab.Reflection.html#1330" class="InductiveConstructor Operator">h∷</a> <a id="20326" href="Data.Nat.Solver.html#20270" class="Bound">lhs</a> <a id="20330" href="1Lab.Reflection.html#1249" class="InductiveConstructor Operator">v∷</a> <a id="20333" href="Data.Nat.Solver.html#20274" class="Bound">rhs</a> <a id="20337" href="1Lab.Reflection.html#1249" class="InductiveConstructor Operator">v∷</a> <a id="20340" href="Data.Nat.Solver.html#20278" class="Bound">env</a> <a id="20344" href="1Lab.Reflection.html#1249" class="InductiveConstructor Operator">v∷</a> <a id="20347" href="Agda.Builtin.Reflection.html#4903" data-type="Name → List (Arg Term) → Term" class="InductiveConstructor">def</a> <a id="20351" class="Symbol">(</a><a id="20352" class="Keyword">quote</a> <a id="20358" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a><a id="20362" class="Symbol">)</a> <a id="20364" href="Agda.Builtin.List.html#185" data-type="List A" class="InductiveConstructor">[]</a> <a id="20367" href="1Lab.Reflection.html#1249" class="InductiveConstructor Operator">v∷</a> <a id="20370" href="Agda.Builtin.List.html#185" data-type="List A" class="InductiveConstructor">[]</a><a id="20372" class="Symbol">)</a>
</pre>
<h3 id="the-actual-macros"><a href="#the-actual-macros" class="header-link">The
Actual Macros<span class="header-link-emoji">🔗</span></a></h3>
<p>Now, the actual reflection API calls. In order to keep drawing this
file out, we start by defining some useful debugging macros. As we noted
a looong time ago, we don’t want to unfold the
<span class="Agda"><a href="Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a></span>
or
<span class="Agda"><a href="Agda.Builtin.Nat.html#528" class="Primitive Operator">_*_</a></span>
functions, so let’s make a list of those names so that we can call
<span class="Agda"><a href="Agda.Builtin.Reflection.html#10217" class="Postulate">dontReduceDefs</a></span>
more easily.</p>
<pre class="Agda"><a id="20732" class="Keyword">private</a>
  <a id="don&#39;t-reduce"></a><a id="20742" href="Data.Nat.Solver.html#20742" data-type="List Name" class="Function">don&#39;t-reduce</a> <a id="20755" class="Symbol">:</a> <a id="20757" href="Agda.Builtin.List.html#148" data-type="Type a → Type a" class="Datatype">List</a> <a id="20762" href="Agda.Builtin.Reflection.html#489" data-type="Type" class="Postulate">Name</a>
  <a id="20769" href="Data.Nat.Solver.html#20742" data-type="List Name" class="Function">don&#39;t-reduce</a> <a id="20782" class="Symbol">=</a> <a id="20784" class="Keyword">quote</a> <a id="20790" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">_+_</a> <a id="20794" href="Agda.Builtin.List.html#200" data-type="A → List A → List A" class="InductiveConstructor Operator">∷</a> <a id="20796" class="Keyword">quote</a> <a id="20802" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">_*_</a> <a id="20806" href="Agda.Builtin.List.html#200" data-type="A → List A → List A" class="InductiveConstructor Operator">∷</a> <a id="20808" class="Keyword">quote</a> <a id="20814" href="Agda.Builtin.FromNat.html#282" data-type="(r : Number A) (n : Nat) ⦃ _ : Constraint r n ⦄ → A" class="Field">Number.fromNat</a> <a id="20829" href="Agda.Builtin.List.html#200" data-type="A → List A → List A" class="InductiveConstructor Operator">∷</a> <a id="20831" href="Agda.Builtin.List.html#185" data-type="List A" class="InductiveConstructor">[]</a>
</pre>
<p>The <code>repr!</code> macro prints out a bunch of information about
a given expression of type <code>Nat</code>. This is <em>very</em>
useful when we are debugging.</p>
<pre class="Agda"><a id="repr-macro"></a><a id="20985" href="Data.Nat.Solver.html#20985" data-type="Nat → Term → TC ⊤" class="Function">repr-macro</a> <a id="20996" class="Symbol">:</a> <a id="20998" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="21002" class="Symbol">→</a> <a id="21004" href="Agda.Builtin.Reflection.html#4688" data-type="Type" class="Datatype">Term</a> <a id="21009" class="Symbol">→</a> <a id="21011" href="Agda.Builtin.Reflection.html#8218" data-type="Type a → Type a" class="Postulate">TC</a> <a id="21014" href="Agda.Builtin.Unit.html#164" data-type="Type" class="Record">⊤</a>
<a id="21016" href="Data.Nat.Solver.html#20985" data-type="Nat → Term → TC ⊤" class="Function">repr-macro</a> <a id="21027" href="Data.Nat.Solver.html#21027" class="Bound">n</a> <a id="21029" href="Data.Nat.Solver.html#21029" class="Bound">hole</a> <a id="21034" class="Symbol">=</a>
  <a id="21038" href="Agda.Builtin.Reflection.html#9555" data-type="Bool → TC A → TC A" class="Postulate">withNormalisation</a> <a id="21056" href="Agda.Builtin.Bool.html#182" data-type="Bool" class="InductiveConstructor">false</a> <a id="21062" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a>
  <a id="21066" href="Agda.Builtin.Reflection.html#10217" data-type="List Name → TC A → TC A" class="Postulate">dontReduceDefs</a> <a id="21081" href="Data.Nat.Solver.html#20742" data-type="List Name" class="Function">don&#39;t-reduce</a> <a id="21094" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="21096" class="Keyword">do</a>
  <a id="21101" href="Data.Nat.Solver.html#21101" class="Bound">tm</a> <a id="21104" href="Agda.Builtin.Reflection.html#8311" data-type="TC A → (A → TC B₁) → TC B₁" class="Postulate Operator">←</a> <a id="21106" href="Agda.Builtin.Reflection.html#8705" data-type="A → TC Term" class="Postulate">quoteTC</a> <a id="21114" href="Data.Nat.Solver.html#21027" class="Bound">n</a>
  <a id="21118" href="Data.Nat.Solver.html#21118" class="Bound">e</a> <a id="21120" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="21122" href="Data.Nat.Solver.html#21122" class="Bound">vs</a> <a id="21125" href="Agda.Builtin.Reflection.html#8311" data-type="TC A → (A → TC B₁) → TC B₁" class="Postulate Operator">←</a> <a id="21127" href="Data.Nat.Solver.html#18870" data-type="Variables Nat → Term → TC (Term × Variables Nat)" class="Function">build-expr</a> <a id="21138" href="1Lab.Reflection.Variables.html#2026" data-type="Variables A" class="Function">empty-vars</a> <a id="21149" href="Data.Nat.Solver.html#21101" class="Bound">tm</a>
  <a id="21154" href="Data.Nat.Solver.html#21154" class="Bound">size</a> <a id="21159" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="21161" href="Data.Nat.Solver.html#21161" class="Bound">env</a> <a id="21165" href="Agda.Builtin.Reflection.html#8311" data-type="TC A → (A → TC B₁) → TC B₁" class="Postulate Operator">←</a> <a id="21167" href="1Lab.Reflection.Variables.html#3280" data-type="Variables A → TC (Term × Term)" class="Function">environment</a> <a id="21179" href="Data.Nat.Solver.html#21122" class="Bound">vs</a>
  <a id="21184" href="Data.Nat.Solver.html#21184" class="Bound">repr</a> <a id="21189" href="Agda.Builtin.Reflection.html#8311" data-type="TC A → (A → TC B₁) → TC B₁" class="Postulate Operator">←</a> <a id="21191" href="Agda.Builtin.Reflection.html#8573" data-type="Term → TC Term" class="Postulate">normalise</a> <a id="21201" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="21203" href="Agda.Builtin.Reflection.html#4903" data-type="Name → List (Arg Term) → Term" class="InductiveConstructor">def</a> <a id="21207" class="Symbol">(</a><a id="21208" class="Keyword">quote</a> <a id="21214" href="Data.Nat.Solver.html#16030" data-type="Expr n → Poly Nat n" class="Function Operator">↓_</a><a id="21216" class="Symbol">)</a> <a id="21218" class="Symbol">(</a><a id="21219" href="Data.Nat.Solver.html#21154" class="Bound">size</a> <a id="21224" href="1Lab.Reflection.html#1330" class="InductiveConstructor Operator">h∷</a> <a id="21227" href="Data.Nat.Solver.html#21118" class="Bound">e</a> <a id="21229" href="1Lab.Reflection.html#1249" class="InductiveConstructor Operator">v∷</a> <a id="21232" href="Agda.Builtin.List.html#185" data-type="List A" class="InductiveConstructor">[]</a><a id="21234" class="Symbol">)</a>
  <a id="21238" href="Agda.Builtin.Reflection.html#8431" data-type="List ErrorPart → TC A" class="Postulate">typeError</a> <a id="21248" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="21250" href="Agda.Builtin.Reflection.html#7917" data-type="String → ErrorPart" class="InductiveConstructor">strErr</a> <a id="21257" class="String">&quot;The expression\n  &quot;</a> <a id="21278" href="Agda.Builtin.List.html#200" data-type="A → List A → List A" class="InductiveConstructor Operator">∷</a>
                <a id="21296" href="Agda.Builtin.Reflection.html#7948" data-type="Term → ErrorPart" class="InductiveConstructor">termErr</a> <a id="21304" href="Data.Nat.Solver.html#21101" class="Bound">tm</a> <a id="21307" href="Agda.Builtin.List.html#200" data-type="A → List A → List A" class="InductiveConstructor Operator">∷</a>
              <a id="21323" href="Agda.Builtin.Reflection.html#7917" data-type="String → ErrorPart" class="InductiveConstructor">strErr</a> <a id="21330" class="String">&quot;\nIs represented by the expression\n  &quot;</a> <a id="21371" href="Agda.Builtin.List.html#200" data-type="A → List A → List A" class="InductiveConstructor Operator">∷</a>
                <a id="21389" href="Agda.Builtin.Reflection.html#7948" data-type="Term → ErrorPart" class="InductiveConstructor">termErr</a> <a id="21397" href="Data.Nat.Solver.html#21118" class="Bound">e</a> <a id="21399" href="Agda.Builtin.List.html#200" data-type="A → List A → List A" class="InductiveConstructor Operator">∷</a>
              <a id="21415" href="Agda.Builtin.Reflection.html#7917" data-type="String → ErrorPart" class="InductiveConstructor">strErr</a> <a id="21422" class="String">&quot;\nAnd the polynomial\n  &quot;</a> <a id="21449" href="Agda.Builtin.List.html#200" data-type="A → List A → List A" class="InductiveConstructor Operator">∷</a>
                <a id="21467" href="Agda.Builtin.Reflection.html#7948" data-type="Term → ErrorPart" class="InductiveConstructor">termErr</a> <a id="21475" href="Data.Nat.Solver.html#21184" class="Bound">repr</a> <a id="21480" href="Agda.Builtin.List.html#200" data-type="A → List A → List A" class="InductiveConstructor Operator">∷</a>
              <a id="21496" href="Agda.Builtin.Reflection.html#7917" data-type="String → ErrorPart" class="InductiveConstructor">strErr</a> <a id="21503" class="String">&quot;\nThe environment is\n  &quot;</a> <a id="21530" href="Agda.Builtin.List.html#200" data-type="A → List A → List A" class="InductiveConstructor Operator">∷</a>
                <a id="21548" href="Agda.Builtin.Reflection.html#7948" data-type="Term → ErrorPart" class="InductiveConstructor">termErr</a> <a id="21556" href="Data.Nat.Solver.html#21161" class="Bound">env</a> <a id="21560" href="Agda.Builtin.List.html#200" data-type="A → List A → List A" class="InductiveConstructor Operator">∷</a> <a id="21562" href="Agda.Builtin.List.html#185" data-type="List A" class="InductiveConstructor">[]</a>
<a id="21565" class="Keyword">macro</a>
  <a id="repr!"></a><a id="21573" href="Data.Nat.Solver.html#21573" data-type="Nat → Term → TC ⊤" class="Function">repr!</a> <a id="21579" class="Symbol">:</a> <a id="21581" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="21585" class="Symbol">→</a> <a id="21587" href="Agda.Builtin.Reflection.html#4688" data-type="Type" class="Datatype">Term</a> <a id="21592" class="Symbol">→</a> <a id="21594" href="Agda.Builtin.Reflection.html#8218" data-type="Type a → Type a" class="Postulate">TC</a> <a id="21597" href="Agda.Builtin.Unit.html#164" data-type="Type" class="Record">⊤</a>
  <a id="21601" href="Data.Nat.Solver.html#21573" data-type="Nat → Term → TC ⊤" class="Function">repr!</a> <a id="21607" href="Data.Nat.Solver.html#21607" class="Bound">n</a> <a id="21609" class="Symbol">=</a> <a id="21611" href="Data.Nat.Solver.html#20985" data-type="Nat → Term → TC ⊤" class="Function">repr-macro</a> <a id="21622" href="Data.Nat.Solver.html#21607" class="Bound">n</a>
</pre>
<p>Slightly more useful is the <code>expand!</code> macro. This takes in
a natural number, and will fill in the hole with its expanded form. This
is intended to be used with the <code>agda2-elaborate-give</code>
command in Emacs, which is bound to <code>C-c RET</code> by default.</p>
<pre class="Agda"><a id="expand-macro"></a><a id="21883" href="Data.Nat.Solver.html#21883" data-type="Nat → Term → TC ⊤" class="Function">expand-macro</a> <a id="21896" class="Symbol">:</a> <a id="21898" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="21902" class="Symbol">→</a> <a id="21904" href="Agda.Builtin.Reflection.html#4688" data-type="Type" class="Datatype">Term</a> <a id="21909" class="Symbol">→</a> <a id="21911" href="Agda.Builtin.Reflection.html#8218" data-type="Type a → Type a" class="Postulate">TC</a> <a id="21914" href="Agda.Builtin.Unit.html#164" data-type="Type" class="Record">⊤</a>
<a id="21916" href="Data.Nat.Solver.html#21883" data-type="Nat → Term → TC ⊤" class="Function">expand-macro</a> <a id="21929" href="Data.Nat.Solver.html#21929" class="Bound">n</a> <a id="21931" href="Data.Nat.Solver.html#21931" class="Bound">hole</a> <a id="21936" class="Symbol">=</a>
  <a id="21940" href="Agda.Builtin.Reflection.html#9555" data-type="Bool → TC A → TC A" class="Postulate">withNormalisation</a> <a id="21958" href="Agda.Builtin.Bool.html#182" data-type="Bool" class="InductiveConstructor">false</a> <a id="21964" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a>
  <a id="21968" href="Agda.Builtin.Reflection.html#10217" data-type="List Name → TC A → TC A" class="Postulate">dontReduceDefs</a> <a id="21983" href="Data.Nat.Solver.html#20742" data-type="List Name" class="Function">don&#39;t-reduce</a> <a id="21996" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="21998" class="Keyword">do</a>
  <a id="22003" href="Data.Nat.Solver.html#22003" class="Bound">tm</a> <a id="22006" href="Agda.Builtin.Reflection.html#8311" data-type="TC A → (A → TC B₁) → TC B₁" class="Postulate Operator">←</a> <a id="22008" href="Agda.Builtin.Reflection.html#8705" data-type="A → TC Term" class="Postulate">quoteTC</a> <a id="22016" href="Data.Nat.Solver.html#21929" class="Bound">n</a>
  <a id="22020" href="Data.Nat.Solver.html#22020" class="Bound">e</a> <a id="22022" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="22024" href="Data.Nat.Solver.html#22024" class="Bound">vs</a> <a id="22027" href="Agda.Builtin.Reflection.html#8311" data-type="TC A → (A → TC B₁) → TC B₁" class="Postulate Operator">←</a> <a id="22029" href="Data.Nat.Solver.html#18870" data-type="Variables Nat → Term → TC (Term × Variables Nat)" class="Function">build-expr</a> <a id="22040" href="1Lab.Reflection.Variables.html#2026" data-type="Variables A" class="Function">empty-vars</a> <a id="22051" href="Data.Nat.Solver.html#22003" class="Bound">tm</a>
  <a id="22056" href="Data.Nat.Solver.html#22056" class="Bound">size</a> <a id="22061" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="22063" href="Data.Nat.Solver.html#22063" class="Bound">env</a> <a id="22067" href="Agda.Builtin.Reflection.html#8311" data-type="TC A → (A → TC B₁) → TC B₁" class="Postulate Operator">←</a> <a id="22069" href="1Lab.Reflection.Variables.html#3280" data-type="Variables A → TC (Term × Term)" class="Function">environment</a> <a id="22081" href="Data.Nat.Solver.html#22024" class="Bound">vs</a>
  <a id="22086" href="Data.Nat.Solver.html#22086" class="Bound">expanded</a> <a id="22095" href="Agda.Builtin.Reflection.html#8311" data-type="TC A → (A → TC B₁) → TC B₁" class="Postulate Operator">←</a> <a id="22097" href="Agda.Builtin.Reflection.html#8609" data-type="Term → TC Term" class="Postulate">reduce</a> <a id="22104" class="Symbol">(</a><a id="22105" href="Data.Nat.Solver.html#20125" data-type="Term → Term → Term" class="Function">″expand″</a> <a id="22114" href="Data.Nat.Solver.html#22020" class="Bound">e</a> <a id="22116" href="Data.Nat.Solver.html#22063" class="Bound">env</a><a id="22119" class="Symbol">)</a>
  <a id="22123" href="Agda.Builtin.Reflection.html#8391" data-type="Term → Term → TC ⊤" class="Postulate">unify</a> <a id="22129" href="Data.Nat.Solver.html#21931" class="Bound">hole</a> <a id="22134" href="Data.Nat.Solver.html#22086" class="Bound">expanded</a>

<a id="22144" class="Keyword">macro</a>
  <a id="expand!"></a><a id="22152" href="Data.Nat.Solver.html#22152" data-type="Nat → Term → TC ⊤" class="Function">expand!</a> <a id="22160" class="Symbol">:</a> <a id="22162" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="22166" class="Symbol">→</a> <a id="22168" href="Agda.Builtin.Reflection.html#4688" data-type="Type" class="Datatype">Term</a> <a id="22173" class="Symbol">→</a> <a id="22175" href="Agda.Builtin.Reflection.html#8218" data-type="Type a → Type a" class="Postulate">TC</a> <a id="22178" href="Agda.Builtin.Unit.html#164" data-type="Type" class="Record">⊤</a>
  <a id="22182" href="Data.Nat.Solver.html#22152" data-type="Nat → Term → TC ⊤" class="Function">expand!</a> <a id="22190" href="Data.Nat.Solver.html#22190" class="Bound">n</a> <a id="22192" class="Symbol">=</a> <a id="22194" href="Data.Nat.Solver.html#21883" data-type="Nat → Term → TC ⊤" class="Function">expand-macro</a> <a id="22207" href="Data.Nat.Solver.html#22190" class="Bound">n</a>
</pre>
<p>Now, finally, we have reached the summit. The <code>solve!</code>
macro allows us to automatically solve equations involving natural
numbers.</p>
<pre class="Agda"><a id="solve-macro"></a><a id="22354" href="Data.Nat.Solver.html#22354" data-type="Term → TC ⊤" class="Function">solve-macro</a> <a id="22366" class="Symbol">:</a> <a id="22368" href="Agda.Builtin.Reflection.html#4688" data-type="Type" class="Datatype">Term</a> <a id="22373" class="Symbol">→</a> <a id="22375" href="Agda.Builtin.Reflection.html#8218" data-type="Type a → Type a" class="Postulate">TC</a> <a id="22378" href="Agda.Builtin.Unit.html#164" data-type="Type" class="Record">⊤</a>
<a id="22380" href="Data.Nat.Solver.html#22354" data-type="Term → TC ⊤" class="Function">solve-macro</a> <a id="22392" href="Data.Nat.Solver.html#22392" class="Bound">hole</a> <a id="22397" class="Symbol">=</a>
  <a id="22401" href="Agda.Builtin.Reflection.html#9555" data-type="Bool → TC A → TC A" class="Postulate">withNormalisation</a> <a id="22419" href="Agda.Builtin.Bool.html#182" data-type="Bool" class="InductiveConstructor">false</a> <a id="22425" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a>
  <a id="22429" href="Agda.Builtin.Reflection.html#10217" data-type="List Name → TC A → TC A" class="Postulate">dontReduceDefs</a> <a id="22444" href="Data.Nat.Solver.html#20742" data-type="List Name" class="Function">don&#39;t-reduce</a> <a id="22457" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="22459" class="Keyword">do</a>
  <a id="22464" href="Data.Nat.Solver.html#22464" class="Bound">goal</a> <a id="22469" href="Agda.Builtin.Reflection.html#8311" data-type="TC A → (A → TC B₁) → TC B₁" class="Postulate Operator">←</a> <a id="22471" href="Agda.Builtin.Reflection.html#8494" data-type="Term → TC Type" class="Postulate">inferType</a> <a id="22481" href="Data.Nat.Solver.html#22392" class="Bound">hole</a> <a id="22486" href="Agda.Builtin.Reflection.html#8311" data-type="TC A → (A → TC B₁) → TC B₁" class="Postulate Operator">&gt;&gt;=</a> <a id="22490" href="Agda.Builtin.Reflection.html#8609" data-type="Term → TC Term" class="Postulate">reduce</a>

  <a id="22500" href="Agda.Builtin.Maybe.html#174" data-type="A → Maybe A" class="InductiveConstructor">just</a> <a id="22505" class="Symbol">(</a><a id="22506" href="Data.Nat.Solver.html#22506" class="Bound">lhs</a> <a id="22510" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="22512" href="Data.Nat.Solver.html#22512" class="Bound">rhs</a><a id="22515" class="Symbol">)</a> <a id="22517" href="Agda.Builtin.Reflection.html#8311" data-type="TC A → (A → TC B₁) → TC B₁" class="Postulate Operator">←</a> <a id="22519" href="Data.Nat.Solver.html#19737" data-type="Term → TC (Maybe (Term × Term))" class="Function">get-boundary</a> <a id="22532" href="Data.Nat.Solver.html#22464" class="Bound">goal</a>
    <a id="22541" class="Keyword">where</a> <a id="22547" href="Agda.Builtin.Maybe.html#195" data-type="Maybe A" class="InductiveConstructor">nothing</a> <a id="22555" class="Symbol">→</a> <a id="22557" href="Agda.Builtin.Reflection.html#8431" data-type="List ErrorPart → TC A" class="Postulate">typeError</a> <a id="22567" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="22569" href="Agda.Builtin.Reflection.html#7917" data-type="String → ErrorPart" class="InductiveConstructor">strErr</a> <a id="22576" class="String">&quot;Can&#39;t determine boundary: &quot;</a> <a id="22605" href="Agda.Builtin.List.html#200" data-type="A → List A → List A" class="InductiveConstructor Operator">∷</a>
                                <a id="22639" href="Agda.Builtin.Reflection.html#7948" data-type="Term → ErrorPart" class="InductiveConstructor">termErr</a> <a id="22647" href="Data.Nat.Solver.html#22464" class="Bound">goal</a> <a id="22652" href="Agda.Builtin.List.html#200" data-type="A → List A → List A" class="InductiveConstructor Operator">∷</a> <a id="22654" href="Agda.Builtin.List.html#185" data-type="List A" class="InductiveConstructor">[]</a>
  <a id="22659" href="Data.Nat.Solver.html#22659" class="Bound">elhs</a> <a id="22664" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="22666" href="Data.Nat.Solver.html#22666" class="Bound">vs</a> <a id="22669" href="Agda.Builtin.Reflection.html#8311" data-type="TC A → (A → TC B₁) → TC B₁" class="Postulate Operator">←</a> <a id="22671" href="Data.Nat.Solver.html#18870" data-type="Variables Nat → Term → TC (Term × Variables Nat)" class="Function">build-expr</a> <a id="22682" href="1Lab.Reflection.Variables.html#2026" data-type="Variables A" class="Function">empty-vars</a> <a id="22693" href="Data.Nat.Solver.html#22506" class="Bound">lhs</a>
  <a id="22699" href="Data.Nat.Solver.html#22699" class="Bound">erhs</a> <a id="22704" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="22706" href="Data.Nat.Solver.html#22706" class="Bound">vs</a> <a id="22709" href="Agda.Builtin.Reflection.html#8311" data-type="TC A → (A → TC B₁) → TC B₁" class="Postulate Operator">←</a> <a id="22711" href="Data.Nat.Solver.html#18870" data-type="Variables Nat → Term → TC (Term × Variables Nat)" class="Function">build-expr</a> <a id="22722" href="Data.Nat.Solver.html#22666" class="Bound">vs</a> <a id="22725" href="Data.Nat.Solver.html#22512" class="Bound">rhs</a>
  <a id="22731" href="Data.Nat.Solver.html#22731" class="Bound">size</a> <a id="22736" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="22738" href="Data.Nat.Solver.html#22738" class="Bound">env</a> <a id="22742" href="Agda.Builtin.Reflection.html#8311" data-type="TC A → (A → TC B₁) → TC B₁" class="Postulate Operator">←</a> <a id="22744" href="1Lab.Reflection.Variables.html#3280" data-type="Variables A → TC (Term × Term)" class="Function">environment</a> <a id="22756" href="Data.Nat.Solver.html#22706" class="Bound">vs</a>
  <a id="22761" class="Symbol">(</a><a id="22762" href="Agda.Builtin.Reflection.html#10373" data-type="TC A → TC A" class="Postulate">noConstraints</a> <a id="22776" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="22778" href="Agda.Builtin.Reflection.html#8391" data-type="Term → Term → TC ⊤" class="Postulate">unify</a> <a id="22784" href="Data.Nat.Solver.html#22392" class="Bound">hole</a> <a id="22789" class="Symbol">(</a><a id="22790" href="Data.Nat.Solver.html#20224" data-type="Term → Term → Term → Term" class="Function">″solve″</a> <a id="22798" href="Data.Nat.Solver.html#22659" class="Bound">elhs</a> <a id="22803" href="Data.Nat.Solver.html#22699" class="Bound">erhs</a> <a id="22808" href="Data.Nat.Solver.html#22738" class="Bound">env</a><a id="22811" class="Symbol">))</a> <a id="22814" href="Agda.Builtin.Reflection.html#8645" data-type="TC A → TC A → TC A" class="Postulate Operator">&lt;|&gt;</a> <a id="22818" class="Keyword">do</a>
    <a id="22825" href="Data.Nat.Solver.html#22825" class="Bound">nf-lhs</a> <a id="22832" href="Agda.Builtin.Reflection.html#8311" data-type="TC A → (A → TC B₁) → TC B₁" class="Postulate Operator">←</a> <a id="22834" href="Agda.Builtin.Reflection.html#8573" data-type="Term → TC Term" class="Postulate">normalise</a> <a id="22844" class="Symbol">(</a><a id="22845" href="Data.Nat.Solver.html#20125" data-type="Term → Term → Term" class="Function">″expand″</a> <a id="22854" href="Data.Nat.Solver.html#22659" class="Bound">elhs</a> <a id="22859" href="Data.Nat.Solver.html#22738" class="Bound">env</a><a id="22862" class="Symbol">)</a>
    <a id="22868" href="Data.Nat.Solver.html#22868" class="Bound">nf-rhs</a> <a id="22875" href="Agda.Builtin.Reflection.html#8311" data-type="TC A → (A → TC B₁) → TC B₁" class="Postulate Operator">←</a> <a id="22877" href="Agda.Builtin.Reflection.html#8573" data-type="Term → TC Term" class="Postulate">normalise</a> <a id="22887" class="Symbol">(</a><a id="22888" href="Data.Nat.Solver.html#20125" data-type="Term → Term → Term" class="Function">″expand″</a> <a id="22897" href="Data.Nat.Solver.html#22699" class="Bound">erhs</a> <a id="22902" href="Data.Nat.Solver.html#22738" class="Bound">env</a><a id="22905" class="Symbol">)</a>
    <a id="22911" href="Agda.Builtin.Reflection.html#8431" data-type="List ErrorPart → TC A" class="Postulate">typeError</a> <a id="22921" class="Symbol">(</a><a id="22922" href="Agda.Builtin.Reflection.html#7917" data-type="String → ErrorPart" class="InductiveConstructor">strErr</a> <a id="22929" class="String">&quot;Could not solve the following goal:\n  &quot;</a> <a id="22971" href="Agda.Builtin.List.html#200" data-type="A → List A → List A" class="InductiveConstructor Operator">∷</a>
                 <a id="22990" href="Agda.Builtin.Reflection.html#7948" data-type="Term → ErrorPart" class="InductiveConstructor">termErr</a> <a id="22998" href="Data.Nat.Solver.html#22506" class="Bound">lhs</a> <a id="23002" href="Agda.Builtin.List.html#200" data-type="A → List A → List A" class="InductiveConstructor Operator">∷</a> <a id="23004" href="Agda.Builtin.Reflection.html#7917" data-type="String → ErrorPart" class="InductiveConstructor">strErr</a> <a id="23011" class="String">&quot; ≡ &quot;</a> <a id="23017" href="Agda.Builtin.List.html#200" data-type="A → List A → List A" class="InductiveConstructor Operator">∷</a> <a id="23019" href="Agda.Builtin.Reflection.html#7948" data-type="Term → ErrorPart" class="InductiveConstructor">termErr</a> <a id="23027" href="Data.Nat.Solver.html#22512" class="Bound">rhs</a> <a id="23031" href="Agda.Builtin.List.html#200" data-type="A → List A → List A" class="InductiveConstructor Operator">∷</a>
               <a id="23048" href="Agda.Builtin.Reflection.html#7917" data-type="String → ErrorPart" class="InductiveConstructor">strErr</a> <a id="23055" class="String">&quot;\nComputed normal forms:\n  LHS: &quot;</a> <a id="23091" href="Agda.Builtin.List.html#200" data-type="A → List A → List A" class="InductiveConstructor Operator">∷</a>
                 <a id="23110" href="Agda.Builtin.Reflection.html#7948" data-type="Term → ErrorPart" class="InductiveConstructor">termErr</a> <a id="23118" href="Data.Nat.Solver.html#22825" class="Bound">nf-lhs</a> <a id="23125" href="Agda.Builtin.List.html#200" data-type="A → List A → List A" class="InductiveConstructor Operator">∷</a>
               <a id="23142" href="Agda.Builtin.Reflection.html#7917" data-type="String → ErrorPart" class="InductiveConstructor">strErr</a> <a id="23149" class="String">&quot;\n  RHS: &quot;</a> <a id="23161" href="Agda.Builtin.List.html#200" data-type="A → List A → List A" class="InductiveConstructor Operator">∷</a>
                 <a id="23180" href="Agda.Builtin.Reflection.html#7948" data-type="Term → ErrorPart" class="InductiveConstructor">termErr</a> <a id="23188" href="Data.Nat.Solver.html#22868" class="Bound">nf-rhs</a> <a id="23195" href="Agda.Builtin.List.html#200" data-type="A → List A → List A" class="InductiveConstructor Operator">∷</a> <a id="23197" href="Agda.Builtin.List.html#185" data-type="List A" class="InductiveConstructor">[]</a><a id="23199" class="Symbol">)</a>

<a id="23202" class="Keyword">macro</a>
  <a id="solve!"></a><a id="23210" href="Data.Nat.Solver.html#23210" data-type="Term → TC ⊤" class="Function">solve!</a> <a id="23217" class="Symbol">:</a> <a id="23219" href="Agda.Builtin.Reflection.html#4688" data-type="Type" class="Datatype">Term</a> <a id="23224" class="Symbol">→</a> <a id="23226" href="Agda.Builtin.Reflection.html#8218" data-type="Type a → Type a" class="Postulate">TC</a> <a id="23229" href="Agda.Builtin.Unit.html#164" data-type="Type" class="Record">⊤</a>
  <a id="23233" href="Data.Nat.Solver.html#23210" data-type="Term → TC ⊤" class="Function">solve!</a> <a id="23240" class="Symbol">=</a> <a id="23242" href="Data.Nat.Solver.html#22354" data-type="Term → TC ⊤" class="Function">solve-macro</a>
</pre>
<h1 id="examples"><a href="#examples" class="header-link">Examples<span class="header-link-emoji">🔗</span></a></h1>
<p>Congratulations! We now have a solver. Let’s marvel at all of our
hard work for a moment.</p>
<pre class="Agda"><a id="23370" class="Keyword">private</a>
  <a id="wow-good-job"></a><a id="23380" href="Data.Nat.Solver.html#23380" class="Function">wow-good-job</a> <a id="23393" class="Symbol">:</a> <a id="23395" class="Symbol">∀</a> <a id="23397" href="Data.Nat.Solver.html#23397" class="Bound">x</a> <a id="23399" href="Data.Nat.Solver.html#23399" class="Bound">y</a> <a id="23401" href="Data.Nat.Solver.html#23401" class="Bound">z</a>
               <a id="23418" class="Symbol">→</a> <a id="23420" class="Symbol">(</a><a id="23421" href="Data.Nat.Solver.html#23397" class="Bound">x</a> <a id="23423" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="23425" class="Number">5</a> <a id="23427" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="23429" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="23433" href="Data.Nat.Solver.html#23399" class="Bound">y</a><a id="23434" class="Symbol">)</a> <a id="23436" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="23438" href="Data.Nat.Solver.html#23401" class="Bound">z</a> <a id="23440" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="23442" href="Data.Nat.Solver.html#23401" class="Bound">z</a> <a id="23444" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="23446" class="Number">5</a> <a id="23448" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="23450" href="Data.Nat.Solver.html#23397" class="Bound">x</a> <a id="23452" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="23454" href="Data.Nat.Solver.html#23401" class="Bound">z</a> <a id="23456" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="23458" href="Data.Nat.Solver.html#23401" class="Bound">z</a> <a id="23460" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="23462" href="Data.Nat.Solver.html#23401" class="Bound">z</a> <a id="23464" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="23466" href="Data.Nat.Solver.html#23399" class="Bound">y</a>
  <a id="23470" href="Data.Nat.Solver.html#23380" class="Function">wow-good-job</a> <a id="23483" href="Data.Nat.Solver.html#23483" class="Bound">x</a> <a id="23485" href="Data.Nat.Solver.html#23485" class="Bound">y</a> <a id="23487" href="Data.Nat.Solver.html#23487" class="Bound">z</a> <a id="23489" class="Symbol">=</a> <a id="23491" href="Data.Nat.Solver.html#23210" data-type="Term → TC ⊤" class="Macro">solve!</a>
</pre>
<p>Thus concludes our journey. There is still room for improvement,
however. A sparse representation would be much more efficient, but these
proofs are already quite difficult to begin with. For the brave, here is
what a sparse representation might look like.</p>
<pre class="Agda"><a id="23770" class="Keyword">private</a>
  <a id="23780" class="Keyword">data</a> <a id="SparsePoly"></a><a id="23785" href="Data.Nat.Solver.html#23785" class="Datatype">SparsePoly</a> <a id="23796" class="Symbol">{</a><a id="23797" href="Data.Nat.Solver.html#23797" class="Bound">a</a><a id="23798" class="Symbol">}</a> <a id="23800" class="Symbol">(</a><a id="23801" href="Data.Nat.Solver.html#23801" class="Bound">A</a> <a id="23803" class="Symbol">:</a> <a id="23805" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="23810" href="Data.Nat.Solver.html#23797" class="Bound">a</a><a id="23811" class="Symbol">)</a> <a id="23813" class="Symbol">:</a> <a id="23815" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="23819" class="Symbol">→</a> <a id="23821" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="23826" href="Data.Nat.Solver.html#23797" class="Bound">a</a> <a id="23828" class="Keyword">where</a>
    <a id="SparsePoly.const-sparse"></a><a id="23838" href="Data.Nat.Solver.html#23838" class="InductiveConstructor">const-sparse</a> <a id="23851" class="Symbol">:</a> <a id="23853" class="Symbol">∀</a> <a id="23855" class="Symbol">{</a><a id="23856" href="Data.Nat.Solver.html#23856" class="Bound">n</a><a id="23857" class="Symbol">}</a> <a id="23859" class="Symbol">→</a> <a id="23861" href="Data.Nat.Solver.html#23801" class="Bound">A</a> <a id="23863" class="Symbol">→</a> <a id="23865" href="Data.Nat.Solver.html#23785" class="Datatype">SparsePoly</a> <a id="23876" href="Data.Nat.Solver.html#23801" class="Bound">A</a> <a id="23878" href="Data.Nat.Solver.html#23856" class="Bound">n</a>
    <a id="SparsePoly.shift"></a><a id="23884" href="Data.Nat.Solver.html#23884" class="InductiveConstructor">shift</a>        <a id="23897" class="Symbol">:</a> <a id="23899" class="Symbol">∀</a> <a id="23901" class="Symbol">{</a><a id="23902" href="Data.Nat.Solver.html#23902" class="Bound">n</a><a id="23903" class="Symbol">}</a> <a id="23905" class="Symbol">→</a> <a id="23907" class="Symbol">(</a><a id="23908" href="Data.Nat.Solver.html#23908" class="Bound">j</a> <a id="23910" class="Symbol">:</a> <a id="23912" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a><a id="23915" class="Symbol">)</a> <a id="23917" class="Symbol">→</a> <a id="23919" href="Data.Nat.Solver.html#23785" class="Datatype">SparsePoly</a> <a id="23930" href="Data.Nat.Solver.html#23801" class="Bound">A</a> <a id="23932" href="Data.Nat.Solver.html#23902" class="Bound">n</a>
                   <a id="23953" class="Symbol">→</a> <a id="23955" href="Data.Nat.Solver.html#23785" class="Datatype">SparsePoly</a> <a id="23966" href="Data.Nat.Solver.html#23801" class="Bound">A</a> <a id="23968" class="Symbol">(</a><a id="23969" href="Data.Nat.Solver.html#23908" class="Bound">j</a> <a id="23971" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="23973" href="Data.Nat.Solver.html#23902" class="Bound">n</a><a id="23974" class="Symbol">)</a>
    <a id="SparsePoly._*X^_+_"></a><a id="23980" href="Data.Nat.Solver.html#23980" class="InductiveConstructor Operator">_*X^_+_</a>      <a id="23993" class="Symbol">:</a> <a id="23995" class="Symbol">∀</a> <a id="23997" class="Symbol">{</a><a id="23998" href="Data.Nat.Solver.html#23998" class="Bound">n</a><a id="23999" class="Symbol">}</a> <a id="24001" class="Symbol">→</a> <a id="24003" href="Data.Nat.Solver.html#23785" class="Datatype">SparsePoly</a> <a id="24014" href="Data.Nat.Solver.html#23801" class="Bound">A</a> <a id="24016" class="Symbol">(</a><a id="24017" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="24021" href="Data.Nat.Solver.html#23998" class="Bound">n</a><a id="24022" class="Symbol">)</a> <a id="24024" class="Symbol">→</a> <a id="24026" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="24030" class="Symbol">→</a> <a id="24032" href="Data.Nat.Solver.html#23785" class="Datatype">SparsePoly</a> <a id="24043" href="Data.Nat.Solver.html#23801" class="Bound">A</a> <a id="24045" href="Data.Nat.Solver.html#23998" class="Bound">n</a>
                   <a id="24066" class="Symbol">→</a> <a id="24068" href="Data.Nat.Solver.html#23785" class="Datatype">SparsePoly</a> <a id="24079" href="Data.Nat.Solver.html#23801" class="Bound">A</a> <a id="24081" class="Symbol">(</a><a id="24082" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="24086" href="Data.Nat.Solver.html#23998" class="Bound">n</a><a id="24087" class="Symbol">)</a>
</pre>
  </article>
</div>
</main>
</body>
</html>
