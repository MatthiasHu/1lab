<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="keywords" content="Agda,categories,topos" />

  <title>1Lab.Univalence - 1Lab</title>

  <link rel="stylesheet" href="/css/default.css" />
  <link rel="stylesheet" href="/css/katex.min.css" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="1Lab.Univalence - 1Lab" />
  <meta name="twitter:image" content="https://1lab.dev/static/cube-128x.png" />

  <meta name="og:title" content="1Lab.Univalence - 1Lab" />
  <meta name="og:image" content="https://1lab.dev/static/cube-128x.png" />
  <meta name="og:site-name" content="1Lab" />
  <meta name="og:type" content="website" />

    <meta name="og:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="twitter:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  
  <script defer src="/main.js"></script>

  <noscript>
    <style>
      body span.reasoning-step .as-written {
        display: inline;
      }

      body span.reasoning-step .alternate {
        display: none;
      }
    </style>
  </noscript>

  <!-- Google font embeds -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;0,800;1,400;1,500;1,600;1,700;1,800&amp;family=Inria+Sans:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&amp;display=swap" rel="stylesheet">
</head>

<body class="text-page">
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <!-- Table of contents (only if the page has a table of contents) -->
    <aside id="toc">
    <div id="toc-container" style="min-width: 10em; font-size: 15pt;">
      <!-- Title for the page -->
      <h3 class="Agda" style="margin-top: 0; margin-bottom: 0; white-space: pre;">
                <a class="Module">1Lab.Univalence</a>
              </h3>

      <!-- Cube logo -->
      <a id="logo" href="/">
        <img alt="1Lab" src="/static/cube-72x.png" style="display: block; margin-bottom: 1em; margin: auto;" width="32px" height="32px" />
      </a>

      <!-- Actual table of contents (separated from the rest by
      horizontal rules) -->
      <hr />
      <ul>
      <li><a href="#univalence"><a href="#univalence" class="header-link">Univalence<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#glue"><a href="#glue" class="header-link">Glue<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#paths-from-glue"><a href="#paths-from-glue" class="header-link">Paths
      from Glue<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#paths-over-ua"><a href="#paths-over-ua" class="header-link">Paths
      over ua<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      <li><a href="#the-axiom"><a href="#the-axiom" class="header-link">The
      “axiom”<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#equivalence-induction"><a href="#equivalence-induction" class="header-link">Equivalence
      Induction<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#object-classifiers"><a href="#object-classifiers" class="header-link">Object
      Classifiers<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      </ul>
      <hr />

      <!-- Sidebar controls -->
      <div style="display: flex; gap: 0.25em; flex-flow: row wrap;">
        <!-- Sidebar equations control -->
        <span class="equations" style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-eqns" type="checkbox" class="equations" id="sidebar-eqns">
          <label for="sidebar-eqns">Equations</label>
        </span>

        <!-- Sidebar fonts control -->
        <span style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-font" type="checkbox" id="toggle-fonts">
          <label for="toggle-fonts">Serif Font</label>
        </span>

        <!-- Sidebar footnotes control -->
        <span class="inline-footnotes" style="display: none; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-fns" type="checkbox" class="inline-footnotes" id="sidebar-fns">
          <label for="sidebar-fns">Inline Footnotes</label>
        </span>
      </div>

      <hr />

      <!-- Navbar navigation (lol) -->
      <div id="return" style="white-space: nowrap;">
        <div class="search-form search-form-proxy" role="form">
          <input id="search-box-proxy" type_="text" placeholder="Search..." autocomplete="off" tabindex="0"></input>
        </div>

              <a href="/">back to index</a> <br />
              <a href="all-pages.html">view all pages</a> <br />
        <a href="https://github.com/plt-amy/cubical-1lab/blob/70c7c2583790a0ce190d3222e6affc0b07a470b8/src/1Lab/Univalence.lagda.md">link to source</a> <br />
                <hr /> <div class="author-list">Written by Amélia Liao and Jonathan Coates</div> <br />
              </div>
    </div>
  </aside>
  
  <article>
    <!-- Article navigation (narrow screens only) -->
    <div class="narrow-only" id="article-nav">
      <!-- Index return anchor (only if the page is not the index) -->
            <div id="return">
        <a href="/">back to index</a>
      </div>
      
      <!-- Navbar equations control -->
      <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-eqns" type="checkbox" class="equations" id="navbar-eqns">
        <label for="navbar-eqns">Equations</label>
      </span>

      <!-- Navbar footnotes control -->
      <span class="inline-footnotes" style="display: none; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-fns" type="checkbox" class="inline-footnotes" id="navbar-fns">
        <label for="navbar-fns">Inline Footnotes</label>
      </span>
    </div>

<pre class="Agda"><a id="9" class="Keyword">open</a> <a id="14" class="Keyword">import</a> <a id="21" href="1Lab.Path.Groupoid.html" class="Module">1Lab.Path.Groupoid</a>
<a id="40" class="Keyword">open</a> <a id="45" class="Keyword">import</a> <a id="52" href="1Lab.Type.Sigma.html" class="Module">1Lab.Type.Sigma</a>
<a id="68" class="Keyword">open</a> <a id="73" class="Keyword">import</a> <a id="80" href="1Lab.HLevel.html" class="Module">1Lab.HLevel</a>
<a id="92" class="Keyword">open</a> <a id="97" class="Keyword">import</a> <a id="104" href="1Lab.Equiv.html" class="Module">1Lab.Equiv</a>
<a id="115" class="Keyword">open</a> <a id="120" class="Keyword">import</a> <a id="127" href="1Lab.Path.html" class="Module">1Lab.Path</a>
<a id="137" class="Keyword">open</a> <a id="142" class="Keyword">import</a> <a id="149" href="1Lab.Type.html" class="Module">1Lab.Type</a>

<a id="160" class="Keyword">module</a> <a id="167" href="1Lab.Univalence.html" class="Module">1Lab.Univalence</a> <a id="183" class="Keyword">where</a>
</pre>
<h1 id="univalence"><a href="#univalence" class="header-link">Univalence<span class="header-link-emoji">🔗</span></a></h1>
<p>In Homotopy Type Theory, <strong>univalence</strong> is the principle
stating that <a href="1Lab.Equiv.html#_≃_">equivalent</a> types can be
<a href="1Lab.Path.html#Path">identified</a>. When <a href="https://homotopytypetheory.org/book">the book</a> first came out,
there was no widely-accepted <em>computational</em> interpretation of
this principle, so it was added to the theory as an axiom: the
<strong>univalence axiom</strong>.</p>
<p>Precisely, the axiom as presented in the book consists of the
following data (right under remark §2.10.4):</p>
<ul>
<li><p>A map which turns equivalences into identifications of types.
This map is called
<span class="Agda"><a href="1Lab.Univalence.html#8818" class="Function">ua</a></span>.</p></li>
<li><p>A rule for eliminating identifications of types, by turning them
into equivalences:
<span class="Agda"><a href="1Lab.Univalence.html#15486" class="Function">path→equiv</a></span></p></li>
<li><p>The propositional computation rule, stating that transport along
<code>ua(f)</code> is identical to applying <code>f</code>:
<span class="Agda"><a href="1Lab.Univalence.html#10966" class="Function">uaβ</a></span>.</p></li>
</ul>
<p>In the book, there is an extra postulated datum asserting that
<span class="Agda"><a href="1Lab.Univalence.html#8818" class="Function">ua</a></span>
is an inverse to
<span class="Agda"><a href="1Lab.Univalence.html#15486" class="Function">path→equiv</a></span>.
This datum does not have a name in this development, because it’s proved
in-line in the construction of the term
<span class="Agda"><a href="1Lab.Univalence.html#16772" class="Function">univalence</a></span>.</p>
<p>The point of cubical type theory is to give these terms constructive
interpretations, i.e., make them definable in the theory, in terms of
constructions that have computational behaviour. Let’s see how this is
done.</p>
<h2 id="glue"><a href="#glue" class="header-link">Glue<span class="header-link-emoji">🔗</span></a></h2>
<p>To even <em>state</em> univalence, we first have to make sure that
the concept of “paths between types” makes sense in the first place. In
“Book HoTT”, paths between types are a well-formed concept because the
path type is uniformly inductively defined for <em>everything</em> —
including universes. This is not the case in Cubical type theory, where
for paths in
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>
to be well-behaved,
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>
must <a href="1Lab.Path.html#fibrant">be <em>fibrant</em></a>.</p>
<p>Since there’s no obvious choice for how to interpret
<span class="Agda"><a href="1Lab.Path.html#2368" class="Primitive">hcomp</a></span>
in
<span class="Agda"><a href="1Lab.Type.html#391" class="Primitive">Type</a></span>,
a fine solution is to make
<span class="Agda"><a href="1Lab.Path.html#2368" class="Primitive">hcomp</a></span>
its own type former. This is the approach taken by some Cubical type
theories in the <a href="https://redprl.org/">RedPRL school</a>.
Univalence in those type theories is then achieved by adding a type
former, called <code>V</code>, which turns an equivalence into a
path.</p>
<p>In <a href="https://arxiv.org/abs/1611.02108">CCHM</a> — and
therefore Cubical Agda — a different approach is taken, which combines
proving univalence with defining a fibrancy structure for the universe.
The core idea is to define a new type former,
<span class="Agda"><a href="1Lab.Univalence.html#3439" class="Function">Glue</a></span>,
which “glues” a <a href="1Lab.Path.html#partial-elements">partial
type</a>, along an equivalence, to a total type.</p>
<!--
<pre class="Agda"><a id="2844" class="Keyword">private</a>
  <a id="2854" class="Keyword">variable</a>
    <a id="2867" href="1Lab.Univalence.html#2867" class="Generalizable">ℓ</a> <a id="2869" href="1Lab.Univalence.html#2869" class="Generalizable">ℓ&#39;</a> <a id="2872" class="Symbol">:</a> <a id="2874" href="Agda.Primitive.html#582" data-type="Type" class="Postulate">Level</a>

  <a id="2883" class="Keyword">primitive</a>
    <a id="primGlue"></a><a id="2897" href="1Lab.Univalence.html#2897" data-type="(A : Type ℓ) (T : Partial φ (Type ℓ&#39;)) →
PartialP φ (λ .o → T _ ≃ A) → Type ℓ&#39;" class="Primitive">primGlue</a> <a id="2906" class="Symbol">:</a> <a id="2908" class="Symbol">(</a><a id="2909" href="1Lab.Univalence.html#2909" class="Bound">A</a> <a id="2911" class="Symbol">:</a> <a id="2913" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="2918" href="1Lab.Univalence.html#2867" class="Generalizable">ℓ</a><a id="2919" class="Symbol">)</a> <a id="2921" class="Symbol">{</a><a id="2922" href="1Lab.Univalence.html#2922" class="Bound">φ</a> <a id="2924" class="Symbol">:</a> <a id="2926" href="Agda.Primitive.Cubical.html#150" class="Datatype">I</a><a id="2927" class="Symbol">}</a>
             <a id="2942" class="Symbol">→</a> <a id="2944" class="Symbol">(</a><a id="2945" href="1Lab.Univalence.html#2945" class="Bound">T</a> <a id="2947" class="Symbol">:</a> <a id="2949" href="Agda.Primitive.Cubical.html#1115" class="Primitive">Partial</a> <a id="2957" href="1Lab.Univalence.html#2922" class="Bound">φ</a> <a id="2959" class="Symbol">(</a><a id="2960" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="2965" href="1Lab.Univalence.html#2869" class="Generalizable">ℓ&#39;</a><a id="2967" class="Symbol">))</a> <a id="2970" class="Symbol">→</a> <a id="2972" class="Symbol">(</a><a id="2973" href="1Lab.Univalence.html#2973" class="Bound">e</a> <a id="2975" class="Symbol">:</a> <a id="2977" href="Agda.Primitive.Cubical.html#1149" class="Primitive">PartialP</a> <a id="2986" href="1Lab.Univalence.html#2922" class="Bound">φ</a> <a id="2988" class="Symbol">(λ</a> <a id="2991" href="1Lab.Univalence.html#2991" class="Bound">o</a> <a id="2993" class="Symbol">→</a> <a id="2995" href="1Lab.Univalence.html#2945" class="Bound">T</a> <a id="2997" href="1Lab.Univalence.html#2991" class="Bound">o</a> <a id="2999" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="3001" href="1Lab.Univalence.html#2909" class="Bound">A</a><a id="3002" class="Symbol">))</a>
             <a id="3018" class="Symbol">→</a> <a id="3020" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="3025" href="1Lab.Univalence.html#2869" class="Generalizable">ℓ&#39;</a>

    <a id="prim^glue"></a><a id="3033" href="1Lab.Univalence.html#3033" data-type="PartialP φ T → A → primGlue A T e" class="Primitive">prim^glue</a> <a id="3043" class="Symbol">:</a> <a id="3045" class="Symbol">{</a><a id="3046" href="1Lab.Univalence.html#3046" class="Bound">A</a> <a id="3048" class="Symbol">:</a> <a id="3050" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="3055" href="1Lab.Univalence.html#2867" class="Generalizable">ℓ</a><a id="3056" class="Symbol">}</a> <a id="3058" class="Symbol">{</a><a id="3059" href="1Lab.Univalence.html#3059" class="Bound">φ</a> <a id="3061" class="Symbol">:</a> <a id="3063" href="Agda.Primitive.Cubical.html#150" class="Datatype">I</a><a id="3064" class="Symbol">}</a>
              <a id="3080" class="Symbol">→</a> <a id="3082" class="Symbol">{</a><a id="3083" href="1Lab.Univalence.html#3083" class="Bound">T</a> <a id="3085" class="Symbol">:</a> <a id="3087" href="Agda.Primitive.Cubical.html#1115" class="Primitive">Partial</a> <a id="3095" href="1Lab.Univalence.html#3059" class="Bound">φ</a> <a id="3097" class="Symbol">(</a><a id="3098" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="3103" href="1Lab.Univalence.html#2869" class="Generalizable">ℓ&#39;</a><a id="3105" class="Symbol">)}</a> <a id="3108" class="Symbol">→</a> <a id="3110" class="Symbol">{</a><a id="3111" href="1Lab.Univalence.html#3111" class="Bound">e</a> <a id="3113" class="Symbol">:</a> <a id="3115" href="Agda.Primitive.Cubical.html#1149" class="Primitive">PartialP</a> <a id="3124" href="1Lab.Univalence.html#3059" class="Bound">φ</a> <a id="3126" class="Symbol">(λ</a> <a id="3129" href="1Lab.Univalence.html#3129" class="Bound">o</a> <a id="3131" class="Symbol">→</a> <a id="3133" href="1Lab.Univalence.html#3083" class="Bound">T</a> <a id="3135" href="1Lab.Univalence.html#3129" class="Bound">o</a> <a id="3137" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="3139" href="1Lab.Univalence.html#3046" class="Bound">A</a><a id="3140" class="Symbol">)}</a>
              <a id="3157" class="Symbol">→</a> <a id="3159" href="Agda.Primitive.Cubical.html#1149" class="Primitive">PartialP</a> <a id="3168" href="1Lab.Univalence.html#3059" class="Bound">φ</a> <a id="3170" href="1Lab.Univalence.html#3083" class="Bound">T</a> <a id="3172" class="Symbol">→</a> <a id="3174" href="1Lab.Univalence.html#3046" class="Bound">A</a> <a id="3176" class="Symbol">→</a> <a id="3178" href="1Lab.Univalence.html#2897" data-type="(A : Type ℓ) (T : Partial φ (Type ℓ&#39;)) →
PartialP φ (λ .o → T _ ≃ A) → Type ℓ&#39;" class="Primitive">primGlue</a> <a id="3187" href="1Lab.Univalence.html#3046" class="Bound">A</a> <a id="3189" href="1Lab.Univalence.html#3083" class="Bound">T</a> <a id="3191" href="1Lab.Univalence.html#3111" class="Bound">e</a>

    <a id="prim^unglue"></a><a id="3198" href="1Lab.Univalence.html#3198" data-type="primGlue A T e → A" class="Primitive">prim^unglue</a> <a id="3210" class="Symbol">:</a> <a id="3212" class="Symbol">{</a><a id="3213" href="1Lab.Univalence.html#3213" class="Bound">A</a> <a id="3215" class="Symbol">:</a> <a id="3217" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="3222" href="1Lab.Univalence.html#2867" class="Generalizable">ℓ</a><a id="3223" class="Symbol">}</a> <a id="3225" class="Symbol">{</a><a id="3226" href="1Lab.Univalence.html#3226" class="Bound">φ</a> <a id="3228" class="Symbol">:</a> <a id="3230" href="Agda.Primitive.Cubical.html#150" class="Datatype">I</a><a id="3231" class="Symbol">}</a>
                <a id="3249" class="Symbol">→</a> <a id="3251" class="Symbol">{</a><a id="3252" href="1Lab.Univalence.html#3252" class="Bound">T</a> <a id="3254" class="Symbol">:</a> <a id="3256" href="Agda.Primitive.Cubical.html#1115" class="Primitive">Partial</a> <a id="3264" href="1Lab.Univalence.html#3226" class="Bound">φ</a> <a id="3266" class="Symbol">(</a><a id="3267" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="3272" href="1Lab.Univalence.html#2869" class="Generalizable">ℓ&#39;</a><a id="3274" class="Symbol">)}</a> <a id="3277" class="Symbol">→</a> <a id="3279" class="Symbol">{</a><a id="3280" href="1Lab.Univalence.html#3280" class="Bound">e</a> <a id="3282" class="Symbol">:</a> <a id="3284" href="Agda.Primitive.Cubical.html#1149" class="Primitive">PartialP</a> <a id="3293" href="1Lab.Univalence.html#3226" class="Bound">φ</a> <a id="3295" class="Symbol">(λ</a> <a id="3298" href="1Lab.Univalence.html#3298" class="Bound">o</a> <a id="3300" class="Symbol">→</a> <a id="3302" href="1Lab.Univalence.html#3252" class="Bound">T</a> <a id="3304" href="1Lab.Univalence.html#3298" class="Bound">o</a> <a id="3306" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="3308" href="1Lab.Univalence.html#3213" class="Bound">A</a><a id="3309" class="Symbol">)}</a>
                <a id="3328" class="Symbol">→</a> <a id="3330" href="1Lab.Univalence.html#2897" data-type="(A : Type ℓ) (T : Partial φ (Type ℓ&#39;)) →
PartialP φ (λ .o → T _ ≃ A) → Type ℓ&#39;" class="Primitive">primGlue</a> <a id="3339" href="1Lab.Univalence.html#3213" class="Bound">A</a> <a id="3341" href="1Lab.Univalence.html#3252" class="Bound">T</a> <a id="3343" href="1Lab.Univalence.html#3280" class="Bound">e</a> <a id="3345" class="Symbol">→</a> <a id="3347" href="1Lab.Univalence.html#3213" class="Bound">A</a>

<a id="3350" class="Keyword">open</a> <a id="3355" class="Keyword">import</a> <a id="3362" href="Agda.Builtin.Cubical.HCompU.html" class="Module">Agda.Builtin.Cubical.HCompU</a>
<a id="3390" class="Keyword">open</a> <a id="3395" class="Keyword">import</a> <a id="3402" href="1Lab.Equiv.FromPath.html" class="Module">1Lab.Equiv.FromPath</a>
</pre>-->
<pre class="Agda"><a id="Glue"></a><a id="3439" href="1Lab.Univalence.html#3439" data-type="(A : Type ℓ) → Partial φ (Σ (λ T → T ≃ A)) → Type ℓ&#39;" class="Function">Glue</a> <a id="3444" class="Symbol">:</a> <a id="3446" class="Symbol">(</a><a id="3447" href="1Lab.Univalence.html#3447" class="Bound">A</a> <a id="3449" class="Symbol">:</a> <a id="3451" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="3456" href="1Lab.Univalence.html#2867" class="Generalizable">ℓ</a><a id="3457" class="Symbol">)</a>
     <a id="3464" class="Symbol">→</a> <a id="3466" class="Symbol">{</a><a id="3467" href="1Lab.Univalence.html#3467" class="Bound">φ</a> <a id="3469" class="Symbol">:</a> <a id="3471" href="Agda.Primitive.Cubical.html#150" class="Datatype">I</a><a id="3472" class="Symbol">}</a>
     <a id="3479" class="Symbol">→</a> <a id="3481" class="Symbol">(</a><a id="3482" href="1Lab.Univalence.html#3482" class="Bound">Te</a> <a id="3485" class="Symbol">:</a> <a id="3487" href="Agda.Primitive.Cubical.html#1115" class="Primitive">Partial</a> <a id="3495" href="1Lab.Univalence.html#3467" class="Bound">φ</a> <a id="3497" class="Symbol">(</a><a id="3498" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">Σ[</a> <a id="3501" href="1Lab.Univalence.html#3501" class="Bound">T</a> <a id="3503" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">∈</a> <a id="3505" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="3510" href="1Lab.Univalence.html#2869" class="Generalizable">ℓ&#39;</a> <a id="3513" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">]</a> <a id="3515" class="Symbol">(</a><a id="3516" href="1Lab.Univalence.html#3501" class="Bound">T</a> <a id="3518" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="3520" href="1Lab.Univalence.html#3447" class="Bound">A</a><a id="3521" class="Symbol">)))</a>
     <a id="3530" class="Symbol">→</a> <a id="3532" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="3537" href="1Lab.Univalence.html#2869" class="Generalizable">ℓ&#39;</a>
</pre>
<p>The public interface of
<span class="Agda"><a href="1Lab.Univalence.html#3439" class="Function">Glue</a></span>
demands a type
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>,</span>
called the <em>base type</em>, a formula
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">φ</span></span></span></span>,</span>
and a <a href="1Lab.Path.html#partial-elements">partial type</a>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>
which is equivalent to
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>.</span>
Since the equivalence is defined <em>inside</em> the partial element, it
can also (potentially) vary over the interval, so in reality we have a
<em>family</em> of partial types
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>
and a <em>family</em> of partial equivalences
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>≃</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">T \simeq A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≃</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>.</span></p>
<p>In the specific case where we set
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mo>=</mo><mi mathvariant="normal">¬</mi><mi>i</mi><mo>∨</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">\varphi = \neg i \lor i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">φ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord">¬</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>,</span>
we can illustrate <code>Glue A (T, f)</code> as the dashed line in the
square diagram below. The conceptual idea is that by “gluing”
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>
onto a totally defined type, we get a type which <a href="1Lab.Path.html#extensibility">extends</a>
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>.</span></p>
<div class="diagram-container">
<img src="light-8def3b27b2fca15a529978d85ac85b15089f39f2.svg" title="commutative diagram" class="diagram diagram-light quiver" />
<img src="dark-8def3b27b2fca15a529978d85ac85b15089f39f2.svg" title="commutative diagram" class="diagram diagram-dark quiver" />
</div>
<!--
<pre class="Agda"><a id="4497" href="1Lab.Univalence.html#3439" data-type="(A : Type ℓ) → Partial φ (Σ (λ T → T ≃ A)) → Type ℓ&#39;" class="Function">Glue</a> <a id="4502" href="1Lab.Univalence.html#4502" class="Bound">A</a> <a id="4504" href="1Lab.Univalence.html#4504" class="Bound">Te</a> <a id="4507" class="Symbol">=</a> <a id="4509" href="1Lab.Univalence.html#2897" data-type="(A : Type ℓ) (T : Partial φ (Type ℓ&#39;)) →
PartialP φ (λ .o → T _ ≃ A) → Type ℓ&#39;" class="Primitive">primGlue</a> <a id="4518" href="1Lab.Univalence.html#4502" class="Bound">A</a> <a id="4520" class="Symbol">(λ</a> <a id="4523" href="1Lab.Univalence.html#4523" class="Bound">x</a> <a id="4525" class="Symbol">→</a> <a id="4527" href="1Lab.Univalence.html#4504" class="Bound">Te</a> <a id="4530" href="1Lab.Univalence.html#4523" class="Bound">x</a> <a id="4532" class="Symbol">.</a><a id="4533" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a><a id="4536" class="Symbol">)</a> <a id="4538" class="Symbol">(λ</a> <a id="4541" href="1Lab.Univalence.html#4541" class="Bound">x</a> <a id="4543" class="Symbol">→</a> <a id="4545" href="1Lab.Univalence.html#4504" class="Bound">Te</a> <a id="4548" href="1Lab.Univalence.html#4541" class="Bound">x</a> <a id="4550" class="Symbol">.</a><a id="4551" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a><a id="4554" class="Symbol">)</a>

<a id="unglue"></a><a id="4557" href="1Lab.Univalence.html#4557" data-type="(φ : I) → primGlue A T e → A" class="Function">unglue</a> <a id="4564" class="Symbol">:</a> <a id="4566" class="Symbol">{</a><a id="4567" href="1Lab.Univalence.html#4567" class="Bound">A</a> <a id="4569" class="Symbol">:</a> <a id="4571" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="4576" href="1Lab.Univalence.html#2867" class="Generalizable">ℓ</a><a id="4577" class="Symbol">}</a> <a id="4579" class="Symbol">(</a><a id="4580" href="1Lab.Univalence.html#4580" class="Bound">φ</a> <a id="4582" class="Symbol">:</a> <a id="4584" href="Agda.Primitive.Cubical.html#150" class="Datatype">I</a><a id="4585" class="Symbol">)</a> <a id="4587" class="Symbol">{</a><a id="4588" href="1Lab.Univalence.html#4588" class="Bound">T</a> <a id="4590" class="Symbol">:</a> <a id="4592" href="Agda.Primitive.Cubical.html#1115" class="Primitive">Partial</a> <a id="4600" href="1Lab.Univalence.html#4580" class="Bound">φ</a> <a id="4602" class="Symbol">(</a><a id="4603" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="4608" href="1Lab.Univalence.html#2869" class="Generalizable">ℓ&#39;</a><a id="4610" class="Symbol">)}</a>
         <a id="4622" class="Symbol">{</a><a id="4623" href="1Lab.Univalence.html#4623" class="Bound">e</a> <a id="4625" class="Symbol">:</a> <a id="4627" href="Agda.Primitive.Cubical.html#1149" class="Primitive">PartialP</a> <a id="4636" href="1Lab.Univalence.html#4580" class="Bound">φ</a> <a id="4638" class="Symbol">(λ</a> <a id="4641" href="1Lab.Univalence.html#4641" class="Bound">o</a> <a id="4643" class="Symbol">→</a> <a id="4645" href="1Lab.Univalence.html#4588" class="Bound">T</a> <a id="4647" href="1Lab.Univalence.html#4641" class="Bound">o</a> <a id="4649" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="4651" href="1Lab.Univalence.html#4567" class="Bound">A</a><a id="4652" class="Symbol">)}</a> <a id="4655" class="Symbol">→</a> <a id="4657" href="1Lab.Univalence.html#2897" data-type="(A : Type ℓ) (T : Partial φ (Type ℓ&#39;)) →
PartialP φ (λ .o → T _ ≃ A) → Type ℓ&#39;" class="Primitive">primGlue</a> <a id="4666" href="1Lab.Univalence.html#4567" class="Bound">A</a> <a id="4668" href="1Lab.Univalence.html#4588" class="Bound">T</a> <a id="4670" href="1Lab.Univalence.html#4623" class="Bound">e</a> <a id="4672" class="Symbol">→</a> <a id="4674" href="1Lab.Univalence.html#4567" class="Bound">A</a>
<a id="4676" href="1Lab.Univalence.html#4557" data-type="(φ : I) → primGlue A T e → A" class="Function">unglue</a> <a id="4683" href="1Lab.Univalence.html#4683" class="Bound">φ</a> <a id="4685" class="Symbol">=</a> <a id="4687" href="1Lab.Univalence.html#3198" data-type="primGlue A T e → A" class="Primitive">prim^unglue</a> <a id="4699" class="Symbol">{</a><a id="4700" class="Argument">φ</a> <a id="4702" class="Symbol">=</a> <a id="4704" href="1Lab.Univalence.html#4683" class="Bound">φ</a><a id="4705" class="Symbol">}</a>
</pre>-->
<p>For
<span class="Agda"><a href="1Lab.Univalence.html#3439" class="Function">Glue</a></span>
to extend
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>,</span>
we add a computation rule which could be called a <strong>boundary
condition</strong>, since it specifies how
<span class="Agda"><a href="1Lab.Univalence.html#3439" class="Function">Glue</a></span>
behaves on the boundaries of cubes. Concisely, when
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mo>=</mo><mi>i</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">\varphi = i1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">φ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mord">1</span></span></span></span>,</span>
we have that
<span class="Agda"><a href="1Lab.Univalence.html#3439" class="Function">Glue</a></span>
evaluates to the partial type. This is exactly what it means for
<span class="Agda"><a href="1Lab.Univalence.html#3439" class="Function">Glue</a></span>
to extend
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>!</span></p>
<pre class="Agda"><a id="5118" class="Keyword">module</a> <a id="5125" href="1Lab.Univalence.html#5125" class="Module">_</a> <a id="5127" class="Symbol">{</a><a id="5128" href="1Lab.Univalence.html#5128" class="Bound">A</a> <a id="5130" href="1Lab.Univalence.html#5130" class="Bound">B</a> <a id="5132" class="Symbol">:</a> <a id="5134" href="1Lab.Type.html#391" class="Primitive">Type</a><a id="5138" class="Symbol">}</a> <a id="5140" class="Symbol">{</a><a id="5141" href="1Lab.Univalence.html#5141" class="Bound">e</a> <a id="5143" class="Symbol">:</a> <a id="5145" href="1Lab.Univalence.html#5128" class="Bound">A</a> <a id="5147" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="5149" href="1Lab.Univalence.html#5130" class="Bound">B</a><a id="5150" class="Symbol">}</a> <a id="5152" class="Keyword">where</a>
  <a id="5160" class="Keyword">private</a>
    <a id="5172" href="1Lab.Univalence.html#5172" class="Function">Glue-boundary</a> <a id="5186" class="Symbol">:</a> <a id="5188" href="1Lab.Univalence.html#3439" data-type="(A : Type ℓ) → Partial φ (Σ (λ T → T ≃ A)) → Type ℓ&#39;" class="Function">Glue</a> <a id="5193" href="1Lab.Univalence.html#5130" class="Bound">B</a> <a id="5195" class="Symbol">{</a><a id="5196" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="5198" class="Symbol">}</a> <a id="5200" class="Symbol">(λ</a> <a id="5203" href="1Lab.Univalence.html#5203" class="Bound">x</a> <a id="5205" class="Symbol">→</a> <a id="5207" href="1Lab.Univalence.html#5128" class="Bound">A</a> <a id="5209" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="5211" href="1Lab.Univalence.html#5141" class="Bound">e</a><a id="5212" class="Symbol">)</a> <a id="5214" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="5216" href="1Lab.Univalence.html#5128" class="Bound">A</a>
    <a id="5222" href="1Lab.Univalence.html#5172" class="Function">Glue-boundary</a> <a id="5236" href="1Lab.Univalence.html#5236" class="Bound">i</a> <a id="5238" class="Symbol">=</a> <a id="5240" href="1Lab.Univalence.html#5128" class="Bound">A</a>
</pre>
<p>Furthermore, since we can turn any family of paths into a family of
equivalences, we can use the
<span class="Agda"><a href="1Lab.Univalence.html#3439" class="Function">Glue</a></span>
construct to implement something with precisely the same interface as
<span class="Agda"><a href="1Lab.Path.html#2368" class="Primitive">hcomp</a></span>
for
<span class="Agda"><a href="1Lab.Type.html#391" class="Primitive">Type</a></span>:</p>
<pre class="Agda"><a id="glue-hfill"></a><a id="5471" href="1Lab.Univalence.html#5471" data-type="(φ : I) (u : I → Partial φ (Type ℓ)) (u0 : Type ℓ [ φ ↦ u i0 ])
(i : I) →
Type ℓ [ ~ i ∨ φ ↦ (λ { (i = i0) → outS u0 ; (φ = i1) → u i _ }) ]" class="Function">glue-hfill</a>
  <a id="5484" class="Symbol">:</a> <a id="5486" class="Symbol">∀</a> <a id="5488" class="Symbol">{</a><a id="5489" href="1Lab.Univalence.html#5489" class="Bound">ℓ</a><a id="5490" class="Symbol">}</a> <a id="5492" href="1Lab.Univalence.html#5492" class="Bound">φ</a> <a id="5494" class="Symbol">(</a><a id="5495" href="1Lab.Univalence.html#5495" class="Bound">u</a> <a id="5497" class="Symbol">:</a> <a id="5499" href="Agda.Primitive.Cubical.html#150" class="Datatype">I</a> <a id="5501" class="Symbol">→</a> <a id="5503" href="Agda.Primitive.Cubical.html#1115" class="Primitive">Partial</a> <a id="5511" href="1Lab.Univalence.html#5492" class="Bound">φ</a> <a id="5513" class="Symbol">(</a><a id="5514" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="5519" href="1Lab.Univalence.html#5489" class="Bound">ℓ</a><a id="5520" class="Symbol">))</a> <a id="5523" class="Symbol">(</a><a id="5524" href="1Lab.Univalence.html#5524" class="Bound">u0</a> <a id="5527" class="Symbol">:</a> <a id="5529" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="5534" href="1Lab.Univalence.html#5489" class="Bound">ℓ</a> <a id="5536" href="1Lab.Path.html#28574" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">[</a> <a id="5538" href="1Lab.Univalence.html#5492" class="Bound">φ</a> <a id="5540" href="1Lab.Path.html#28574" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">↦</a> <a id="5542" href="1Lab.Univalence.html#5495" class="Bound">u</a> <a id="5544" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a> <a id="5547" href="1Lab.Path.html#28574" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">]</a><a id="5548" class="Symbol">)</a>
  <a id="5552" class="Symbol">→</a> <a id="5554" class="Symbol">∀</a> <a id="5556" href="1Lab.Univalence.html#5556" class="Bound">i</a> <a id="5558" class="Symbol">→</a> <a id="5560" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="5565" href="1Lab.Univalence.html#5489" class="Bound">ℓ</a> <a id="5567" href="1Lab.Path.html#28574" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">[</a> <a id="5569" class="Symbol">_</a> <a id="5571" href="1Lab.Path.html#28574" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">↦</a> <a id="5573" class="Symbol">(λ</a> <a id="5576" class="Symbol">{</a> <a id="5578" class="Symbol">(</a><a id="5579" href="1Lab.Univalence.html#5556" class="Bound">i</a> <a id="5581" class="Symbol">=</a> <a id="5583" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="5585" class="Symbol">)</a> <a id="5587" class="Symbol">→</a> <a id="5589" href="1Lab.Path.html#2100" class="Primitive">outS</a> <a id="5594" href="1Lab.Univalence.html#5524" class="Bound">u0</a>
                          <a id="5623" class="Symbol">;</a> <a id="5625" class="Symbol">(</a><a id="5626" href="1Lab.Univalence.html#5492" class="Bound">φ</a> <a id="5628" class="Symbol">=</a> <a id="5630" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="5632" class="Symbol">)</a> <a id="5634" class="Symbol">→</a> <a id="5636" href="1Lab.Univalence.html#5495" class="Bound">u</a> <a id="5638" href="1Lab.Univalence.html#5556" class="Bound">i</a> <a id="5640" href="1Lab.Path.html#2443" class="Postulate">1=1</a> <a id="5644" class="Symbol">})</a> <a id="5647" href="1Lab.Path.html#28574" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">]</a>
</pre>
<p>The type of
<span class="Agda"><a href="1Lab.Univalence.html#5471" class="Function">glue-hfill</a></span>
is the same as that of <code class="sourceCode agda">hfill</code>, but
the type is stated much more verbosely — so that we may define it
without previous reference to a
<span class="Agda"><a href="1Lab.Path.html#2368" class="Primitive">hcomp</a></span>
analogue. Like <code class="sourceCode agda">hfill</code>,
<span class="Agda"><a href="1Lab.Univalence.html#5471" class="Function">glue-hfill</a></span>
extends an open box of types to a totally-defined cube. The type of
<span class="Agda"><a href="1Lab.Univalence.html#5471" class="Function">glue-hfill</a></span>
expresses this in terms of extensions: We have a path (that’s the
<code>∀ i →</code> binder) of
<span class="Agda"><a href="1Lab.Type.html#391" class="Primitive">Type</a></span>s
which agrees with <code>outS u0</code> on the left endpoint, and with
<code>u</code> everywhere.</p>
<pre class="Agda"><a id="6167" href="1Lab.Univalence.html#5471" data-type="(φ : I) (u : I → Partial φ (Type ℓ)) (u0 : Type ℓ [ φ ↦ u i0 ])
(i : I) →
Type ℓ [ ~ i ∨ φ ↦ (λ { (i = i0) → outS u0 ; (φ = i1) → u i _ }) ]" class="Function">glue-hfill</a> <a id="6178" href="1Lab.Univalence.html#6178" class="Bound">φ</a> <a id="6180" href="1Lab.Univalence.html#6180" class="Bound">u</a> <a id="6182" href="1Lab.Univalence.html#6182" class="Bound">u0</a> <a id="6185" href="1Lab.Univalence.html#6185" class="Bound">i</a> <a id="6187" class="Symbol">=</a> <a id="6189" href="1Lab.Path.html#2069" class="Postulate">inS</a> <a id="6193" class="Symbol">(</a>
  <a id="6197" href="1Lab.Univalence.html#3439" data-type="(A : Type ℓ) → Partial φ (Σ (λ T → T ≃ A)) → Type ℓ&#39;" class="Function">Glue</a> <a id="6202" class="Symbol">(</a><a id="6203" href="1Lab.Path.html#2100" class="Primitive">outS</a> <a id="6208" href="1Lab.Univalence.html#6182" class="Bound">u0</a><a id="6210" class="Symbol">)</a> <a id="6212" class="Symbol">{</a><a id="6213" class="Argument">φ</a> <a id="6215" class="Symbol">=</a> <a id="6217" href="1Lab.Univalence.html#6178" class="Bound">φ</a> <a id="6219" href="1Lab.Path.html#2226" class="Primitive Operator">∨</a> <a id="6221" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="6223" href="1Lab.Univalence.html#6185" class="Bound">i</a><a id="6224" class="Symbol">}</a>
    <a id="6230" class="Symbol">λ</a> <a id="6232" class="Symbol">{</a> <a id="6234" class="Symbol">(</a><a id="6235" href="1Lab.Univalence.html#6178" class="Bound">φ</a> <a id="6237" class="Symbol">=</a> <a id="6239" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="6241" class="Symbol">)</a> <a id="6243" class="Symbol">→</a> <a id="6245" href="1Lab.Univalence.html#6180" class="Bound">u</a> <a id="6247" href="1Lab.Univalence.html#6185" class="Bound">i</a> <a id="6249" href="1Lab.Path.html#2443" class="Postulate">1=1</a> <a id="6253" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="6255" href="1Lab.Equiv.FromPath.html#9366" data-type="(P : I → Type ℓ) → A P ≃ B P" class="Function">line→equiv</a> <a id="6266" class="Symbol">(λ</a> <a id="6269" href="1Lab.Univalence.html#6269" class="Bound">j</a> <a id="6271" class="Symbol">→</a> <a id="6273" href="1Lab.Univalence.html#6180" class="Bound">u</a> <a id="6275" class="Symbol">(</a><a id="6276" href="1Lab.Univalence.html#6185" class="Bound">i</a> <a id="6278" href="1Lab.Path.html#2191" class="Primitive Operator">∧</a> <a id="6280" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="6282" href="1Lab.Univalence.html#6269" class="Bound">j</a><a id="6283" class="Symbol">)</a> <a id="6285" href="1Lab.Path.html#2443" class="Postulate">1=1</a><a id="6288" class="Symbol">)</a>
      <a id="6296" class="Symbol">;</a> <a id="6298" class="Symbol">(</a><a id="6299" href="1Lab.Univalence.html#6185" class="Bound">i</a> <a id="6301" class="Symbol">=</a> <a id="6303" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="6305" class="Symbol">)</a> <a id="6307" class="Symbol">→</a> <a id="6309" href="1Lab.Path.html#2100" class="Primitive">outS</a> <a id="6314" href="1Lab.Univalence.html#6182" class="Bound">u0</a> <a id="6317" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="6319" href="1Lab.Equiv.FromPath.html#9366" data-type="(P : I → Type ℓ) → A P ≃ B P" class="Function">line→equiv</a> <a id="6330" class="Symbol">(λ</a> <a id="6333" href="1Lab.Univalence.html#6333" class="Bound">i</a> <a id="6335" class="Symbol">→</a> <a id="6337" href="1Lab.Path.html#2100" class="Primitive">outS</a> <a id="6342" href="1Lab.Univalence.html#6182" class="Bound">u0</a><a id="6344" class="Symbol">)</a>
      <a id="6352" class="Symbol">})</a>
</pre>
<p>In the case for
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mrow><mi mathvariant="normal">i</mi><mn>0</mn></mrow></mrow><annotation encoding="application/x-tex">i = \id{i0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i0</span></span></span></span></span>,</span>
we must glue
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">u0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord mathnormal">u</span><span class="mord">0</span></span></span></span>
onto itself using the identity equivalence. This guarantees that the
boundary of the stated type for
<span class="Agda"><a href="1Lab.Univalence.html#5471" class="Function">glue-hfill</a></span>
is satisfied. However, since different faces of partial elements must
agree where they are defined, we can not use the identity equivalence
directly, since <code>line→equiv refl</code> is not definitionally the
identity equivalence.</p>
<p>When
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mo>=</mo><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\varphi = \id{\phi}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">φ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ϕ</span></span></span></span>,</span>
hence where
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span>
is defined, we glue the endpoint
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span>
onto
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">u0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord mathnormal">u</span><span class="mord">0</span></span></span></span>
using the equivalence generated by the path provided by
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span>
itself! It’s a family of partial paths, after all, and that can be
turned into a family of partial equivalences.</p>
<p>To show that
<span class="Agda"><a href="1Lab.Univalence.html#5471" class="Function">glue-hfill</a></span>
expresses the fibrancy structure of the universe, we prove a theorem
that says anything with the same interface as <code class="sourceCode agda">hfill</code> must agree with
<span class="Agda"><a href="1Lab.Path.html#2368" class="Primitive">hcomp</a></span>
on
<span class="Agda"><a href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a></span>,
and from this conclude that
<span class="Agda"><a href="1Lab.Path.html#2368" class="Primitive">hcomp</a></span>
on
<span class="Agda"><a href="1Lab.Type.html#391" class="Primitive">Type</a></span>
agrees with the definition of
<span class="Agda"><a href="1Lab.Univalence.html#5471" class="Function">glue-hfill</a></span>.</p>
<pre class="Agda"><a id="hcomp-unique"></a><a id="7349" href="1Lab.Univalence.html#7349" data-type="(u : I → Partial φ A) (u0 : A [ φ ↦ u i0 ])
(h2
 : (i : I) →
   A [ ~ i ∨ φ ↦ (λ { (i = i0) → outS u0 ; (φ = i1) → u i _ }) ]) →
hcomp u (outS u0) ≡ outS (h2 i1)" class="Function">hcomp-unique</a> <a id="7362" class="Symbol">:</a> <a id="7364" class="Symbol">∀</a> <a id="7366" class="Symbol">{</a><a id="7367" href="1Lab.Univalence.html#7367" class="Bound">ℓ</a><a id="7368" class="Symbol">}</a> <a id="7370" class="Symbol">{</a><a id="7371" href="1Lab.Univalence.html#7371" class="Bound">A</a> <a id="7373" class="Symbol">:</a> <a id="7375" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="7380" href="1Lab.Univalence.html#7367" class="Bound">ℓ</a><a id="7381" class="Symbol">}</a> <a id="7383" class="Symbol">{</a><a id="7384" href="1Lab.Univalence.html#7384" class="Bound">φ</a><a id="7385" class="Symbol">}</a>
               <a id="7402" class="Symbol">(</a><a id="7403" href="1Lab.Univalence.html#7403" class="Bound">u</a> <a id="7405" class="Symbol">:</a> <a id="7407" href="Agda.Primitive.Cubical.html#150" class="Datatype">I</a> <a id="7409" class="Symbol">→</a> <a id="7411" href="Agda.Primitive.Cubical.html#1115" class="Primitive">Partial</a> <a id="7419" href="1Lab.Univalence.html#7384" class="Bound">φ</a> <a id="7421" href="1Lab.Univalence.html#7371" class="Bound">A</a><a id="7422" class="Symbol">)</a>
               <a id="7439" class="Symbol">(</a><a id="7440" href="1Lab.Univalence.html#7440" class="Bound">u0</a> <a id="7443" class="Symbol">:</a> <a id="7445" href="1Lab.Univalence.html#7371" class="Bound">A</a> <a id="7447" href="1Lab.Path.html#28574" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">[</a> <a id="7449" href="1Lab.Univalence.html#7384" class="Bound">φ</a> <a id="7451" href="1Lab.Path.html#28574" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">↦</a> <a id="7453" href="1Lab.Univalence.html#7403" class="Bound">u</a> <a id="7455" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a> <a id="7458" href="1Lab.Path.html#28574" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">]</a><a id="7459" class="Symbol">)</a>
             <a id="7474" class="Symbol">→</a> <a id="7476" class="Symbol">(</a><a id="7477" href="1Lab.Univalence.html#7477" class="Bound">h2</a> <a id="7480" class="Symbol">:</a> <a id="7482" class="Symbol">∀</a> <a id="7484" href="1Lab.Univalence.html#7484" class="Bound">i</a> <a id="7486" class="Symbol">→</a> <a id="7488" href="1Lab.Univalence.html#7371" class="Bound">A</a> <a id="7490" href="1Lab.Path.html#28574" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">[</a> <a id="7492" class="Symbol">_</a> <a id="7494" href="1Lab.Path.html#28574" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">↦</a> <a id="7496" class="Symbol">(λ</a> <a id="7499" class="Symbol">{</a> <a id="7501" class="Symbol">(</a><a id="7502" href="1Lab.Univalence.html#7484" class="Bound">i</a> <a id="7504" class="Symbol">=</a> <a id="7506" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="7508" class="Symbol">)</a> <a id="7510" class="Symbol">→</a> <a id="7512" href="1Lab.Path.html#2100" class="Primitive">outS</a> <a id="7517" href="1Lab.Univalence.html#7440" class="Bound">u0</a>
                                      <a id="7558" class="Symbol">;</a> <a id="7560" class="Symbol">(</a><a id="7561" href="1Lab.Univalence.html#7384" class="Bound">φ</a> <a id="7563" class="Symbol">=</a> <a id="7565" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="7567" class="Symbol">)</a> <a id="7569" class="Symbol">→</a> <a id="7571" href="1Lab.Univalence.html#7403" class="Bound">u</a> <a id="7573" href="1Lab.Univalence.html#7484" class="Bound">i</a> <a id="7575" href="1Lab.Path.html#2443" class="Postulate">1=1</a> <a id="7579" class="Symbol">})</a> <a id="7582" href="1Lab.Path.html#28574" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">]</a><a id="7583" class="Symbol">)</a>
             <a id="7598" class="Symbol">→</a> <a id="7600" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="7606" href="1Lab.Univalence.html#7403" class="Bound">u</a> <a id="7608" class="Symbol">(</a><a id="7609" href="1Lab.Path.html#2100" class="Primitive">outS</a> <a id="7614" href="1Lab.Univalence.html#7440" class="Bound">u0</a><a id="7616" class="Symbol">)</a> <a id="7618" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="7620" href="1Lab.Path.html#2100" class="Primitive">outS</a> <a id="7625" class="Symbol">(</a><a id="7626" href="1Lab.Univalence.html#7477" class="Bound">h2</a> <a id="7629" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="7631" class="Symbol">)</a>
<a id="7633" href="1Lab.Univalence.html#7349" data-type="(u : I → Partial φ A) (u0 : A [ φ ↦ u i0 ])
(h2
 : (i : I) →
   A [ ~ i ∨ φ ↦ (λ { (i = i0) → outS u0 ; (φ = i1) → u i _ }) ]) →
hcomp u (outS u0) ≡ outS (h2 i1)" class="Function">hcomp-unique</a> <a id="7646" class="Symbol">{</a><a id="7647" class="Argument">φ</a> <a id="7649" class="Symbol">=</a> <a id="7651" href="1Lab.Univalence.html#7651" class="Bound">φ</a><a id="7652" class="Symbol">}</a> <a id="7654" href="1Lab.Univalence.html#7654" class="Bound">u</a> <a id="7656" href="1Lab.Univalence.html#7656" class="Bound">u0</a> <a id="7659" href="1Lab.Univalence.html#7659" class="Bound">h2</a> <a id="7662" href="1Lab.Univalence.html#7662" class="Bound">i</a> <a id="7664" class="Symbol">=</a>
  <a id="7668" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="7674" class="Symbol">(λ</a> <a id="7677" href="1Lab.Univalence.html#7677" class="Bound">k</a> <a id="7679" class="Symbol">→</a> <a id="7681" class="Symbol">λ</a> <a id="7683" class="Symbol">{</a> <a id="7685" class="Symbol">(</a><a id="7686" href="1Lab.Univalence.html#7651" class="Bound">φ</a> <a id="7688" class="Symbol">=</a> <a id="7690" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="7692" class="Symbol">)</a> <a id="7694" class="Symbol">→</a> <a id="7696" href="1Lab.Univalence.html#7654" class="Bound">u</a> <a id="7698" href="1Lab.Univalence.html#7677" class="Bound">k</a> <a id="7700" href="1Lab.Path.html#2443" class="Postulate">1=1</a>
                 <a id="7721" class="Symbol">;</a> <a id="7723" class="Symbol">(</a><a id="7724" href="1Lab.Univalence.html#7662" class="Bound">i</a> <a id="7726" class="Symbol">=</a> <a id="7728" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="7730" class="Symbol">)</a> <a id="7732" class="Symbol">→</a> <a id="7734" href="1Lab.Path.html#2100" class="Primitive">outS</a> <a id="7739" class="Symbol">(</a><a id="7740" href="1Lab.Univalence.html#7659" class="Bound">h2</a> <a id="7743" href="1Lab.Univalence.html#7677" class="Bound">k</a><a id="7744" class="Symbol">)</a> <a id="7746" class="Symbol">})</a>
        <a id="7757" class="Symbol">(</a><a id="7758" href="1Lab.Path.html#2100" class="Primitive">outS</a> <a id="7763" href="1Lab.Univalence.html#7656" class="Bound">u0</a><a id="7765" class="Symbol">)</a>
</pre>
<p>Using
<span class="Agda"><a href="1Lab.Univalence.html#7349" class="Function">hcomp-unique</a></span>
and
<span class="Agda"><a href="1Lab.Univalence.html#5471" class="Function">glue-hfill</a></span>
together, we get a internal characterisation of the fibrancy structure
of the universe. While
<span class="Agda"><a href="1Lab.Univalence.html#7349" class="Function">hcomp-unique</a></span>
may appear surprising, it is essentially a generalisation of the
uniqueness of path compositions: Any open box has a contractible space
of fillers.</p>
<pre class="Agda"><a id="hcomp≡Glue"></a><a id="8097" href="1Lab.Univalence.html#8097" data-type="(u : I → Partial φ (Type ℓ)) (u0 : Type ℓ [ φ ↦ u i0 ]) →
hcomp u (outS u0) ≡
Glue (outS u0)
(λ { (φ = i1) → u i1 _ , line→equiv (λ j → u (~ j) _) })" class="Function">hcomp≡Glue</a> <a id="8108" class="Symbol">:</a> <a id="8110" class="Symbol">∀</a> <a id="8112" class="Symbol">{</a><a id="8113" href="1Lab.Univalence.html#8113" class="Bound">ℓ</a><a id="8114" class="Symbol">}</a> <a id="8116" class="Symbol">{</a><a id="8117" href="1Lab.Univalence.html#8117" class="Bound">φ</a><a id="8118" class="Symbol">}</a> <a id="8120" class="Symbol">(</a><a id="8121" href="1Lab.Univalence.html#8121" class="Bound">u</a> <a id="8123" class="Symbol">:</a> <a id="8125" href="Agda.Primitive.Cubical.html#150" class="Datatype">I</a> <a id="8127" class="Symbol">→</a> <a id="8129" href="Agda.Primitive.Cubical.html#1115" class="Primitive">Partial</a> <a id="8137" href="1Lab.Univalence.html#8117" class="Bound">φ</a> <a id="8139" class="Symbol">(</a><a id="8140" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="8145" href="1Lab.Univalence.html#8113" class="Bound">ℓ</a><a id="8146" class="Symbol">))</a> <a id="8149" class="Symbol">(</a><a id="8150" href="1Lab.Univalence.html#8150" class="Bound">u0</a> <a id="8153" class="Symbol">:</a> <a id="8155" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="8160" href="1Lab.Univalence.html#8113" class="Bound">ℓ</a> <a id="8162" href="1Lab.Path.html#28574" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">[</a> <a id="8164" href="1Lab.Univalence.html#8117" class="Bound">φ</a> <a id="8166" href="1Lab.Path.html#28574" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">↦</a> <a id="8168" href="1Lab.Univalence.html#8121" class="Bound">u</a> <a id="8170" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a> <a id="8173" href="1Lab.Path.html#28574" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">]</a><a id="8174" class="Symbol">)</a>
           <a id="8187" class="Symbol">→</a> <a id="8189" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="8195" href="1Lab.Univalence.html#8121" class="Bound">u</a> <a id="8197" class="Symbol">(</a><a id="8198" href="1Lab.Path.html#2100" class="Primitive">outS</a> <a id="8203" href="1Lab.Univalence.html#8150" class="Bound">u0</a><a id="8205" class="Symbol">)</a>
           <a id="8218" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="8220" href="1Lab.Univalence.html#3439" data-type="(A : Type ℓ) → Partial φ (Σ (λ T → T ≃ A)) → Type ℓ&#39;" class="Function">Glue</a> <a id="8225" class="Symbol">(</a><a id="8226" href="1Lab.Path.html#2100" class="Primitive">outS</a> <a id="8231" href="1Lab.Univalence.html#8150" class="Bound">u0</a><a id="8233" class="Symbol">)</a>
              <a id="8249" class="Symbol">(λ</a> <a id="8252" class="Symbol">{</a> <a id="8254" class="Symbol">(</a><a id="8255" href="1Lab.Univalence.html#8117" class="Bound">φ</a> <a id="8257" class="Symbol">=</a> <a id="8259" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="8261" class="Symbol">)</a> <a id="8263" class="Symbol">→</a> <a id="8265" href="1Lab.Univalence.html#8121" class="Bound">u</a> <a id="8267" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a> <a id="8270" href="1Lab.Path.html#2443" class="Postulate">1=1</a> <a id="8274" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="8276" href="1Lab.Equiv.FromPath.html#9366" data-type="(P : I → Type ℓ) → A P ≃ B P" class="Function">line→equiv</a> <a id="8287" class="Symbol">(λ</a> <a id="8290" href="1Lab.Univalence.html#8290" class="Bound">j</a> <a id="8292" class="Symbol">→</a> <a id="8294" href="1Lab.Univalence.html#8121" class="Bound">u</a> <a id="8296" class="Symbol">(</a><a id="8297" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="8299" href="1Lab.Univalence.html#8290" class="Bound">j</a><a id="8300" class="Symbol">)</a> <a id="8302" href="1Lab.Path.html#2443" class="Postulate">1=1</a><a id="8305" class="Symbol">)</a> <a id="8307" class="Symbol">})</a>
<a id="8310" href="1Lab.Univalence.html#8097" data-type="(u : I → Partial φ (Type ℓ)) (u0 : Type ℓ [ φ ↦ u i0 ]) →
hcomp u (outS u0) ≡
Glue (outS u0)
(λ { (φ = i1) → u i1 _ , line→equiv (λ j → u (~ j) _) })" class="Function">hcomp≡Glue</a> <a id="8321" href="1Lab.Univalence.html#8321" class="Bound">u</a> <a id="8323" href="1Lab.Univalence.html#8323" class="Bound">u0</a> <a id="8326" class="Symbol">=</a> <a id="8328" href="1Lab.Univalence.html#7349" data-type="(u : I → Partial φ A) (u0 : A [ φ ↦ u i0 ])
(h2
 : (i : I) →
   A [ ~ i ∨ φ ↦ (λ { (i = i0) → outS u0 ; (φ = i1) → u i _ }) ]) →
hcomp u (outS u0) ≡ outS (h2 i1)" class="Function">hcomp-unique</a> <a id="8341" href="1Lab.Univalence.html#8321" class="Bound">u</a> <a id="8343" href="1Lab.Univalence.html#8323" class="Bound">u0</a> <a id="8346" class="Symbol">(</a><a id="8347" href="1Lab.Univalence.html#5471" data-type="(φ : I) (u : I → Partial φ (Type ℓ)) (u0 : Type ℓ [ φ ↦ u i0 ])
(i : I) →
Type ℓ [ ~ i ∨ φ ↦ (λ { (i = i0) → outS u0 ; (φ = i1) → u i _ }) ]" class="Function">glue-hfill</a> <a id="8358" class="Symbol">_</a> <a id="8360" href="1Lab.Univalence.html#8321" class="Bound">u</a> <a id="8362" href="1Lab.Univalence.html#8323" class="Bound">u0</a><a id="8364" class="Symbol">)</a>
</pre>
<h2 id="paths-from-glue"><a href="#paths-from-glue" class="header-link">Paths
from Glue<span class="header-link-emoji">🔗</span></a></h2>
<p>Since
<span class="Agda"><a href="1Lab.Univalence.html#3439" class="Function">Glue</a></span>
generalises
<span class="Agda"><a href="1Lab.Path.html#2368" class="Primitive">hcomp</a></span>
by allowing a partial equivalence as its “tube”, rather than a partial
path, it allows us to turn any equivalence into a path, using a sort of
“trick”: We consider the <em>line</em> with endpoints
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>
and
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>
as an open cube to be filled. A filler for this line is exactly a path
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>≡</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \equiv B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>.</span>
Since
<span class="Agda"><a href="1Lab.Univalence.html#3439" class="Function">Glue</a></span>
fills open boxes of types using equivalences, this path exists!</p>
<pre class="Agda"><a id="ua"></a><a id="8818" href="1Lab.Univalence.html#8818" data-type="A ≃ B₁ → A ≡ B₁" class="Function">ua</a> <a id="8821" class="Symbol">:</a> <a id="8823" class="Symbol">{</a><a id="8824" href="1Lab.Univalence.html#8824" class="Bound">A</a> <a id="8826" href="1Lab.Univalence.html#8826" class="Bound">B</a> <a id="8828" class="Symbol">:</a> <a id="8830" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="8835" href="1Lab.Univalence.html#2867" class="Generalizable">ℓ</a><a id="8836" class="Symbol">}</a> <a id="8838" class="Symbol">→</a> <a id="8840" href="1Lab.Univalence.html#8824" class="Bound">A</a> <a id="8842" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="8844" href="1Lab.Univalence.html#8826" class="Bound">B</a> <a id="8846" class="Symbol">→</a> <a id="8848" href="1Lab.Univalence.html#8824" class="Bound">A</a> <a id="8850" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="8852" href="1Lab.Univalence.html#8826" class="Bound">B</a>
<a id="8854" href="1Lab.Univalence.html#8818" data-type="A ≃ B₁ → A ≡ B₁" class="Function">ua</a> <a id="8857" class="Symbol">{</a><a id="8858" class="Argument">A</a> <a id="8860" class="Symbol">=</a> <a id="8862" href="1Lab.Univalence.html#8862" class="Bound">A</a><a id="8863" class="Symbol">}</a> <a id="8865" class="Symbol">{</a><a id="8866" href="1Lab.Univalence.html#8866" class="Bound">B</a><a id="8867" class="Symbol">}</a> <a id="8869" href="1Lab.Univalence.html#8869" class="Bound">eqv</a> <a id="8873" href="1Lab.Univalence.html#8873" class="Bound">i</a> <a id="8875" class="Symbol">=</a> <a id="8877" href="1Lab.Univalence.html#3439" data-type="(A : Type ℓ) → Partial φ (Σ (λ T → T ≃ A)) → Type ℓ&#39;" class="Function">Glue</a> <a id="8882" href="1Lab.Univalence.html#8866" class="Bound">B</a> <a id="8884" class="Symbol">λ</a> <a id="8886" class="Symbol">{</a> <a id="8888" class="Symbol">(</a><a id="8889" href="1Lab.Univalence.html#8873" class="Bound">i</a> <a id="8891" class="Symbol">=</a> <a id="8893" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="8895" class="Symbol">)</a> <a id="8897" class="Symbol">→</a> <a id="8899" href="1Lab.Univalence.html#8862" class="Bound">A</a> <a id="8901" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="8903" href="1Lab.Univalence.html#8869" class="Bound">eqv</a>
                                <a id="8939" class="Symbol">;</a> <a id="8941" class="Symbol">(</a><a id="8942" href="1Lab.Univalence.html#8873" class="Bound">i</a> <a id="8944" class="Symbol">=</a> <a id="8946" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="8948" class="Symbol">)</a> <a id="8950" class="Symbol">→</a> <a id="8952" href="1Lab.Univalence.html#8866" class="Bound">B</a> <a id="8954" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="8956" class="Symbol">_</a> <a id="8958" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="8960" href="1Lab.Equiv.html#2524" data-type="is-equiv (λ x → x)" class="Function">id-equiv</a>
                                <a id="9001" class="Symbol">}</a>
</pre>
<p>Semantically, the explanation of
<span class="Agda"><a href="1Lab.Univalence.html#8818" class="Function">ua</a></span>
as completing a partial line is sufficient. But we can also ask
ourselves: Why does this definition go through, <em>syntactically</em>?
Because of the boundary condition for Glue: when <code>i = i0</code>,
the whole thing evaluates to <code>A</code>, meaning that the left
endpoint of the path is correct. The same thing happens with the right
endpoint.</p>
<p>The action of <a href="1Lab.Path.html">transporting</a> along
<code>ua(f)</code> can be described by chasing an element around the
diagram that illustrates Glue in the
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mo>=</mo><mi>i</mi><mo>∨</mo><mi mathvariant="normal">¬</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">\varphi = i \lor \neg i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">φ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord">¬</span><span class="mord mathnormal">i</span></span></span></span>
case, specialising to
<span class="Agda"><a href="1Lab.Univalence.html#8818" class="Function">ua</a></span>.
Keep in mind that, since the right face of the diagram “points in the
wrong direction”, it must be inverted. However, the inverse of the
identity equivalence is the identity equivalence, so nothing changes
(for this example).</p>
<figure>
<div class="diagram-container">
<img src="light-155b9f3d0f08d65c2f175143d0cab78f9918bda8.svg" title="commutative diagram" class="diagram diagram-light quiver" />
<img src="dark-155b9f3d0f08d65c2f175143d0cab78f9918bda8.svg" title="commutative diagram" class="diagram diagram-dark quiver" />
</div>
</figure>
<ol type="1">
<li>The action that corresponds to the left face of the diagram is to
apply the underlying function of <code>f</code>. This contributes the
<code>f .fst x</code> part of the
<span class="Agda"><a href="1Lab.Univalence.html#10966" class="Function">uaβ</a></span>
term below.</li>
</ol>
<ol start="2" type="1">
<li>For the bottom face, we have a path rather than an equivalence, so
we must
<span class="Agda"><a href="1Lab.Path.html#11776" class="Function">transport</a></span>
along it. In this case, the path is the reflexivity on <code>B</code>,
but in a more general
<span class="Agda"><a href="1Lab.Univalence.html#3439" class="Function">Glue</a></span>
construction, it might be a non-trivial path.</li>
</ol>
<p>To compensate for this extra transport, we use
<span class="Agda"><a href="1Lab.Path.html#51798" class="Function">coe1→i</a></span>,
which connects <code>f .fst x</code> and
<code>transport (λ i → B) (f .fst x)</code>.</p>
<ol start="3" type="1">
<li>Finally, we apply the inverse of the identity equivalence,
corresponding to the right face in the diagram. This immediately
computes away, and thus contributes nothing to the
<span class="Agda"><a href="1Lab.Univalence.html#10966" class="Function">uaβ</a></span>
path.</li>
</ol>
<pre class="Agda"><a id="uaβ"></a><a id="10966" href="1Lab.Univalence.html#10966" data-type="(f : A ≃ B₁) (x : A) → transport (ua f) x ≡ f .fst x" class="Function">uaβ</a> <a id="10970" class="Symbol">:</a> <a id="10972" class="Symbol">{</a><a id="10973" href="1Lab.Univalence.html#10973" class="Bound">A</a> <a id="10975" href="1Lab.Univalence.html#10975" class="Bound">B</a> <a id="10977" class="Symbol">:</a> <a id="10979" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="10984" href="1Lab.Univalence.html#2867" class="Generalizable">ℓ</a><a id="10985" class="Symbol">}</a> <a id="10987" class="Symbol">(</a><a id="10988" href="1Lab.Univalence.html#10988" class="Bound">f</a> <a id="10990" class="Symbol">:</a> <a id="10992" href="1Lab.Univalence.html#10973" class="Bound">A</a> <a id="10994" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="10996" href="1Lab.Univalence.html#10975" class="Bound">B</a><a id="10997" class="Symbol">)</a> <a id="10999" class="Symbol">(</a><a id="11000" href="1Lab.Univalence.html#11000" class="Bound">x</a> <a id="11002" class="Symbol">:</a> <a id="11004" href="1Lab.Univalence.html#10973" class="Bound">A</a><a id="11005" class="Symbol">)</a> <a id="11007" class="Symbol">→</a> <a id="11009" href="1Lab.Path.html#11776" data-type="A ≡ B₁ → A → B₁" class="Function">transport</a> <a id="11019" class="Symbol">(</a><a id="11020" href="1Lab.Univalence.html#8818" data-type="A ≃ B₁ → A ≡ B₁" class="Function">ua</a> <a id="11023" href="1Lab.Univalence.html#10988" class="Bound">f</a><a id="11024" class="Symbol">)</a> <a id="11026" href="1Lab.Univalence.html#11000" class="Bound">x</a> <a id="11028" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="11030" href="1Lab.Univalence.html#10988" class="Bound">f</a> <a id="11032" class="Symbol">.</a><a id="11033" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="11037" href="1Lab.Univalence.html#11000" class="Bound">x</a>
<a id="11039" href="1Lab.Univalence.html#10966" data-type="(f : A ≃ B₁) (x : A) → transport (ua f) x ≡ f .fst x" class="Function">uaβ</a> <a id="11043" class="Symbol">{</a><a id="11044" class="Argument">A</a> <a id="11046" class="Symbol">=</a> <a id="11048" href="1Lab.Univalence.html#11048" class="Bound">A</a><a id="11049" class="Symbol">}</a> <a id="11051" class="Symbol">{</a><a id="11052" href="1Lab.Univalence.html#11052" class="Bound">B</a><a id="11053" class="Symbol">}</a> <a id="11055" href="1Lab.Univalence.html#11055" class="Bound">f</a> <a id="11057" href="1Lab.Univalence.html#11057" class="Bound">x</a> <a id="11059" href="1Lab.Univalence.html#11059" class="Bound">i</a> <a id="11061" class="Symbol">=</a> <a id="11063" href="1Lab.Path.html#51798" data-type="(A : (i : I) → Type (ℓ i)) (i : I) → A i1 → A i" class="Function">coe1→i</a> <a id="11070" class="Symbol">(λ</a> <a id="11073" href="1Lab.Univalence.html#11073" class="Bound">_</a> <a id="11075" class="Symbol">→</a> <a id="11077" href="1Lab.Univalence.html#11052" class="Bound">B</a><a id="11078" class="Symbol">)</a> <a id="11080" href="1Lab.Univalence.html#11059" class="Bound">i</a> <a id="11082" class="Symbol">(</a><a id="11083" href="1Lab.Univalence.html#11055" class="Bound">f</a> <a id="11085" class="Symbol">.</a><a id="11086" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="11090" href="1Lab.Univalence.html#11057" class="Bound">x</a><a id="11091" class="Symbol">)</a>
</pre>
<p>Since
<span class="Agda"><a href="1Lab.Univalence.html#8818" class="Function">ua</a></span>
is a map that turns equivalences into paths, we can compose it with a
function that turns <a href="1Lab.Equiv.html#Iso">isomorphisms</a> into
equivalences to get the map
<span class="Agda"><a href="1Lab.Univalence.html#11319" class="Function">Iso→Path</a></span>.</p>
<pre class="Agda"><a id="Iso→Path"></a><a id="11319" href="1Lab.Univalence.html#11319" data-type="Iso A B₁ → A ≡ B₁" class="Function">Iso→Path</a> <a id="11328" class="Symbol">:</a> <a id="11330" class="Symbol">{</a><a id="11331" href="1Lab.Univalence.html#11331" class="Bound">A</a> <a id="11333" href="1Lab.Univalence.html#11333" class="Bound">B</a> <a id="11335" class="Symbol">:</a> <a id="11337" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="11342" href="1Lab.Univalence.html#2867" class="Generalizable">ℓ</a><a id="11343" class="Symbol">}</a> <a id="11345" class="Symbol">→</a> <a id="11347" href="1Lab.Equiv.html#6298" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function">Iso</a> <a id="11351" href="1Lab.Univalence.html#11331" class="Bound">A</a> <a id="11353" href="1Lab.Univalence.html#11333" class="Bound">B</a> <a id="11355" class="Symbol">→</a> <a id="11357" href="1Lab.Univalence.html#11331" class="Bound">A</a> <a id="11359" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="11361" href="1Lab.Univalence.html#11333" class="Bound">B</a>
<a id="11363" href="1Lab.Univalence.html#11319" data-type="Iso A B₁ → A ≡ B₁" class="Function">Iso→Path</a> <a id="11372" class="Symbol">(</a><a id="11373" href="1Lab.Univalence.html#11373" class="Bound">f</a> <a id="11375" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="11377" href="1Lab.Univalence.html#11377" class="Bound">iiso</a><a id="11381" class="Symbol">)</a> <a id="11383" class="Symbol">=</a> <a id="11385" href="1Lab.Univalence.html#8818" data-type="A ≃ B₁ → A ≡ B₁" class="Function">ua</a> <a id="11388" class="Symbol">(</a><a id="11389" href="1Lab.Univalence.html#11373" class="Bound">f</a> <a id="11391" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="11393" href="1Lab.Equiv.html#19815" data-type="(i : is-iso f) → is-equiv f" class="Function">is-iso→is-equiv</a> <a id="11409" href="1Lab.Univalence.html#11377" class="Bound">iiso</a><a id="11413" class="Symbol">)</a>
</pre>
<h2 id="paths-over-ua"><a href="#paths-over-ua" class="header-link">Paths
over ua<span class="header-link-emoji">🔗</span></a></h2>
<p>The introduction and elimination forms for
<span class="Agda"><a href="1Lab.Univalence.html#3439" class="Function">Glue</a></span>
can be specialised to the case of
<span class="Agda"><a href="1Lab.Univalence.html#8818" class="Function">ua</a></span>,
leading to the definitions of
<span class="Agda"><a href="1Lab.Univalence.html#13141" class="Function">ua-glue</a></span>
and
<span class="Agda"><a href="1Lab.Univalence.html#12067" class="Function">ua-unglue</a></span>
below. Their types are written in terms of interval variables and <a href="1Lab.Path.html#extensibility">extensions</a>, rather than using
<code class="sourceCode agda">Path</code>s, because these typings make
the structure of
<span class="Agda"><a href="1Lab.Univalence.html#3439" class="Function">Glue</a></span>
more explicit.</p>
<p>The first,
<span class="Agda"><a href="1Lab.Univalence.html#12067" class="Function">ua-unglue</a></span>,
tells us that if we have some <code>x : ua e i</code> (varying over an
interval variable <code>i</code>), then we have an element of
<code>B</code> which agrees with <code>e .fst x</code> on the left and
with <code>x</code> on the right.</p>
<pre class="Agda"><a id="ua-unglue"></a><a id="12067" href="1Lab.Univalence.html#12067" data-type="(e : A ≃ B₁) (i : I) (x : ua e i) →
B₁ [ ~ i ∨ i ↦ (λ { (i = i0) → e .fst x ; (i = i1) → x }) ]" class="Function">ua-unglue</a> <a id="12077" class="Symbol">:</a> <a id="12079" class="Symbol">∀</a> <a id="12081" class="Symbol">{</a><a id="12082" href="1Lab.Univalence.html#12082" class="Bound">A</a> <a id="12084" href="1Lab.Univalence.html#12084" class="Bound">B</a> <a id="12086" class="Symbol">:</a> <a id="12088" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="12093" href="1Lab.Univalence.html#2867" class="Generalizable">ℓ</a><a id="12094" class="Symbol">}</a> <a id="12096" class="Symbol">(</a><a id="12097" href="1Lab.Univalence.html#12097" class="Bound">e</a> <a id="12099" class="Symbol">:</a> <a id="12101" href="1Lab.Univalence.html#12082" class="Bound">A</a> <a id="12103" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="12105" href="1Lab.Univalence.html#12084" class="Bound">B</a><a id="12106" class="Symbol">)</a> <a id="12108" class="Symbol">(</a><a id="12109" href="1Lab.Univalence.html#12109" class="Bound">i</a> <a id="12111" class="Symbol">:</a> <a id="12113" href="Agda.Primitive.Cubical.html#150" class="Datatype">I</a><a id="12114" class="Symbol">)</a> <a id="12116" class="Symbol">(</a><a id="12117" href="1Lab.Univalence.html#12117" class="Bound">x</a> <a id="12119" class="Symbol">:</a> <a id="12121" href="1Lab.Univalence.html#8818" data-type="A ≃ B₁ → A ≡ B₁" class="Function">ua</a> <a id="12124" href="1Lab.Univalence.html#12097" class="Bound">e</a> <a id="12126" href="1Lab.Univalence.html#12109" class="Bound">i</a><a id="12127" class="Symbol">)</a>
            <a id="12141" class="Symbol">→</a> <a id="12143" href="1Lab.Univalence.html#12084" class="Bound">B</a> <a id="12145" href="1Lab.Path.html#28574" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">[</a> <a id="12147" class="Symbol">_</a> <a id="12149" href="1Lab.Path.html#28574" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">↦</a> <a id="12151" class="Symbol">(λ</a> <a id="12154" class="Symbol">{</a> <a id="12156" class="Symbol">(</a><a id="12157" href="1Lab.Univalence.html#12109" class="Bound">i</a> <a id="12159" class="Symbol">=</a> <a id="12161" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="12163" class="Symbol">)</a> <a id="12165" class="Symbol">→</a> <a id="12167" href="1Lab.Univalence.html#12097" class="Bound">e</a> <a id="12169" class="Symbol">.</a><a id="12170" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="12174" href="1Lab.Univalence.html#12117" class="Bound">x</a>
                         <a id="12201" class="Symbol">;</a> <a id="12203" class="Symbol">(</a><a id="12204" href="1Lab.Univalence.html#12109" class="Bound">i</a> <a id="12206" class="Symbol">=</a> <a id="12208" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="12210" class="Symbol">)</a> <a id="12212" class="Symbol">→</a> <a id="12214" href="1Lab.Univalence.html#12117" class="Bound">x</a> <a id="12216" class="Symbol">})</a> <a id="12219" href="1Lab.Path.html#28574" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">]</a>
<a id="12221" href="1Lab.Univalence.html#12067" data-type="(e : A ≃ B₁) (i : I) (x : ua e i) →
B₁ [ ~ i ∨ i ↦ (λ { (i = i0) → e .fst x ; (i = i1) → x }) ]" class="Function">ua-unglue</a> <a id="12231" href="1Lab.Univalence.html#12231" class="Bound">e</a> <a id="12233" href="1Lab.Univalence.html#12233" class="Bound">i</a> <a id="12235" href="1Lab.Univalence.html#12235" class="Bound">x</a> <a id="12237" class="Symbol">=</a> <a id="12239" href="1Lab.Path.html#2069" class="Postulate">inS</a> <a id="12243" class="Symbol">(</a><a id="12244" href="1Lab.Univalence.html#4557" data-type="(φ : I) → primGlue A T e → A" class="Function">unglue</a> <a id="12251" class="Symbol">(</a><a id="12252" href="1Lab.Univalence.html#12233" class="Bound">i</a> <a id="12254" href="1Lab.Path.html#2226" class="Primitive Operator">∨</a> <a id="12256" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="12258" href="1Lab.Univalence.html#12233" class="Bound">i</a><a id="12259" class="Symbol">)</a> <a id="12261" href="1Lab.Univalence.html#12235" class="Bound">x</a><a id="12262" class="Symbol">)</a>
</pre>
<p>We can factor the interval variable out, to get a type in terms of
<span class="Agda"><a href="Agda.Primitive.Cubical.html#2013" class="Postulate">PathP</a></span>,
leading to an explanation of <code>ua-unglue</code> without mentioning
extensions: A path <code>x ≡ y</code> over <code>ua e</code> induces a
path <code>e .fst x ≡ y</code>.</p>
<pre class="Agda"><a id="ua-pathp→path"></a><a id="12491" href="1Lab.Univalence.html#12491" data-type="(e : A ≃ B₁) → PathP (λ i → ua e i) x y → e .fst x ≡ y" class="Function">ua-pathp→path</a> <a id="12505" class="Symbol">:</a> <a id="12507" class="Symbol">∀</a> <a id="12509" class="Symbol">{</a><a id="12510" href="1Lab.Univalence.html#12510" class="Bound">A</a> <a id="12512" href="1Lab.Univalence.html#12512" class="Bound">B</a> <a id="12514" class="Symbol">:</a> <a id="12516" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="12521" href="1Lab.Univalence.html#2867" class="Generalizable">ℓ</a><a id="12522" class="Symbol">}</a> <a id="12524" class="Symbol">(</a><a id="12525" href="1Lab.Univalence.html#12525" class="Bound">e</a> <a id="12527" class="Symbol">:</a> <a id="12529" href="1Lab.Univalence.html#12510" class="Bound">A</a> <a id="12531" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="12533" href="1Lab.Univalence.html#12512" class="Bound">B</a><a id="12534" class="Symbol">)</a> <a id="12536" class="Symbol">{</a><a id="12537" href="1Lab.Univalence.html#12537" class="Bound">x</a> <a id="12539" class="Symbol">:</a> <a id="12541" href="1Lab.Univalence.html#12510" class="Bound">A</a><a id="12542" class="Symbol">}</a> <a id="12544" class="Symbol">{</a><a id="12545" href="1Lab.Univalence.html#12545" class="Bound">y</a> <a id="12547" class="Symbol">:</a> <a id="12549" href="1Lab.Univalence.html#12512" class="Bound">B</a><a id="12550" class="Symbol">}</a>
              <a id="12566" class="Symbol">→</a> <a id="12568" href="Agda.Primitive.Cubical.html#2013" class="Postulate">PathP</a> <a id="12574" class="Symbol">(λ</a> <a id="12577" href="1Lab.Univalence.html#12577" class="Bound">i</a> <a id="12579" class="Symbol">→</a> <a id="12581" href="1Lab.Univalence.html#8818" data-type="A ≃ B₁ → A ≡ B₁" class="Function">ua</a> <a id="12584" href="1Lab.Univalence.html#12525" class="Bound">e</a> <a id="12586" href="1Lab.Univalence.html#12577" class="Bound">i</a><a id="12587" class="Symbol">)</a> <a id="12589" href="1Lab.Univalence.html#12537" class="Bound">x</a> <a id="12591" href="1Lab.Univalence.html#12545" class="Bound">y</a>
              <a id="12607" class="Symbol">→</a> <a id="12609" href="1Lab.Univalence.html#12525" class="Bound">e</a> <a id="12611" class="Symbol">.</a><a id="12612" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="12616" href="1Lab.Univalence.html#12537" class="Bound">x</a> <a id="12618" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="12620" href="1Lab.Univalence.html#12545" class="Bound">y</a>
<a id="12622" href="1Lab.Univalence.html#12491" data-type="(e : A ≃ B₁) → PathP (λ i → ua e i) x y → e .fst x ≡ y" class="Function">ua-pathp→path</a> <a id="12636" href="1Lab.Univalence.html#12636" class="Bound">e</a> <a id="12638" href="1Lab.Univalence.html#12638" class="Bound">p</a> <a id="12640" href="1Lab.Univalence.html#12640" class="Bound">i</a> <a id="12642" class="Symbol">=</a> <a id="12644" href="1Lab.Path.html#2100" class="Primitive">outS</a> <a id="12649" class="Symbol">(</a><a id="12650" href="1Lab.Univalence.html#12067" data-type="(e : A ≃ B₁) (i : I) (x : ua e i) →
B₁ [ ~ i ∨ i ↦ (λ { (i = i0) → e .fst x ; (i = i1) → x }) ]" class="Function">ua-unglue</a> <a id="12660" href="1Lab.Univalence.html#12636" class="Bound">e</a> <a id="12662" href="1Lab.Univalence.html#12640" class="Bound">i</a> <a id="12664" class="Symbol">(</a><a id="12665" href="1Lab.Univalence.html#12638" class="Bound">p</a> <a id="12667" href="1Lab.Univalence.html#12640" class="Bound">i</a><a id="12668" class="Symbol">))</a>
</pre>
<p>In the other direction, we have
<span class="Agda"><a href="1Lab.Univalence.html#13141" class="Function">ua-glue</a></span>,
which expresses that a path <code>e .fst x ≡ y</code> implies that
<code>x ≡ y</code> over <code>ua e</code>. For the type of
<span class="Agda"><a href="1Lab.Univalence.html#13141" class="Function">ua-glue</a></span>,
suppose that we have a partial element
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>
defined on the left endpoint of the interval, together with an extension
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>
of
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">e(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>
where
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>
is defined. What
<span class="Agda"><a href="1Lab.Univalence.html#13141" class="Function">ua-glue</a></span>
expresses is that we can complete this to a path in
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">u</mi><mi mathvariant="normal">a</mi></mrow><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\id{ua}(e)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">ua</span></span><span class="mopen">(</span><span class="mord mathnormal">e</span><span class="mclose">)</span></span></span></span>,</span>
which agrees with
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>
and
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>
where these are defined.</p>
<pre class="Agda"><a id="ua-glue"></a><a id="13141" href="1Lab.Univalence.html#13141" data-type="(e : A ≃ B₁) (i : I) (x : Partial (~ i) A)
(y : B₁ [ ~ i ↦ (λ { (i = i0) → e .fst (x _) }) ]) →
ua e i [ ~ i ∨ i ↦ (λ { (i = i0) → x _ ; (i = i1) → outS y }) ]" class="Function">ua-glue</a> <a id="13149" class="Symbol">:</a> <a id="13151" class="Symbol">∀</a> <a id="13153" class="Symbol">{</a><a id="13154" href="1Lab.Univalence.html#13154" class="Bound">A</a> <a id="13156" href="1Lab.Univalence.html#13156" class="Bound">B</a> <a id="13158" class="Symbol">:</a> <a id="13160" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="13165" href="1Lab.Univalence.html#2867" class="Generalizable">ℓ</a><a id="13166" class="Symbol">}</a> <a id="13168" class="Symbol">(</a><a id="13169" href="1Lab.Univalence.html#13169" class="Bound">e</a> <a id="13171" class="Symbol">:</a> <a id="13173" href="1Lab.Univalence.html#13154" class="Bound">A</a> <a id="13175" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="13177" href="1Lab.Univalence.html#13156" class="Bound">B</a><a id="13178" class="Symbol">)</a> <a id="13180" class="Symbol">(</a><a id="13181" href="1Lab.Univalence.html#13181" class="Bound">i</a> <a id="13183" class="Symbol">:</a> <a id="13185" href="Agda.Primitive.Cubical.html#150" class="Datatype">I</a><a id="13186" class="Symbol">)</a>
            <a id="13200" class="Symbol">(</a><a id="13201" href="1Lab.Univalence.html#13201" class="Bound">x</a> <a id="13203" class="Symbol">:</a> <a id="13205" href="Agda.Primitive.Cubical.html#1115" class="Primitive">Partial</a> <a id="13213" class="Symbol">(</a><a id="13214" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="13216" href="1Lab.Univalence.html#13181" class="Bound">i</a><a id="13217" class="Symbol">)</a> <a id="13219" href="1Lab.Univalence.html#13154" class="Bound">A</a><a id="13220" class="Symbol">)</a>
            <a id="13234" class="Symbol">(</a><a id="13235" href="1Lab.Univalence.html#13235" class="Bound">y</a> <a id="13237" class="Symbol">:</a> <a id="13239" href="1Lab.Univalence.html#13156" class="Bound">B</a> <a id="13241" href="1Lab.Path.html#28574" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">[</a> <a id="13243" class="Symbol">_</a> <a id="13245" href="1Lab.Path.html#28574" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">↦</a> <a id="13247" class="Symbol">(λ</a> <a id="13250" class="Symbol">{</a> <a id="13252" class="Symbol">(</a><a id="13253" href="1Lab.Univalence.html#13181" class="Bound">i</a> <a id="13255" class="Symbol">=</a> <a id="13257" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="13259" class="Symbol">)</a> <a id="13261" class="Symbol">→</a> <a id="13263" href="1Lab.Univalence.html#13169" class="Bound">e</a> <a id="13265" class="Symbol">.</a><a id="13266" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="13270" class="Symbol">(</a><a id="13271" href="1Lab.Univalence.html#13201" class="Bound">x</a> <a id="13273" href="1Lab.Path.html#2443" class="Postulate">1=1</a><a id="13276" class="Symbol">)</a> <a id="13278" class="Symbol">})</a> <a id="13281" href="1Lab.Path.html#28574" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">]</a><a id="13282" class="Symbol">)</a>
          <a id="13294" class="Symbol">→</a> <a id="13296" href="1Lab.Univalence.html#8818" data-type="A ≃ B₁ → A ≡ B₁" class="Function">ua</a> <a id="13299" href="1Lab.Univalence.html#13169" class="Bound">e</a> <a id="13301" href="1Lab.Univalence.html#13181" class="Bound">i</a> <a id="13303" href="1Lab.Path.html#28574" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">[</a> <a id="13305" class="Symbol">_</a> <a id="13307" href="1Lab.Path.html#28574" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">↦</a> <a id="13309" class="Symbol">(λ</a> <a id="13312" class="Symbol">{</a> <a id="13314" class="Symbol">(</a><a id="13315" href="1Lab.Univalence.html#13181" class="Bound">i</a> <a id="13317" class="Symbol">=</a> <a id="13319" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="13321" class="Symbol">)</a> <a id="13323" class="Symbol">→</a> <a id="13325" href="1Lab.Univalence.html#13201" class="Bound">x</a> <a id="13327" href="1Lab.Path.html#2443" class="Postulate">1=1</a>
                            <a id="13359" class="Symbol">;</a> <a id="13361" class="Symbol">(</a><a id="13362" href="1Lab.Univalence.html#13181" class="Bound">i</a> <a id="13364" class="Symbol">=</a> <a id="13366" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="13368" class="Symbol">)</a> <a id="13370" class="Symbol">→</a> <a id="13372" href="1Lab.Path.html#2100" class="Primitive">outS</a> <a id="13377" href="1Lab.Univalence.html#13235" class="Bound">y</a>
                            <a id="13407" class="Symbol">})</a> <a id="13410" href="1Lab.Path.html#28574" data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" class="Function Operator">]</a>
<a id="13412" href="1Lab.Univalence.html#13141" data-type="(e : A ≃ B₁) (i : I) (x : Partial (~ i) A)
(y : B₁ [ ~ i ↦ (λ { (i = i0) → e .fst (x _) }) ]) →
ua e i [ ~ i ∨ i ↦ (λ { (i = i0) → x _ ; (i = i1) → outS y }) ]" class="Function">ua-glue</a> <a id="13420" href="1Lab.Univalence.html#13420" class="Bound">e</a> <a id="13422" href="1Lab.Univalence.html#13422" class="Bound">i</a> <a id="13424" href="1Lab.Univalence.html#13424" class="Bound">x</a> <a id="13426" href="1Lab.Univalence.html#13426" class="Bound">y</a> <a id="13428" class="Symbol">=</a> <a id="13430" href="1Lab.Path.html#2069" class="Postulate">inS</a> <a id="13434" class="Symbol">(</a><a id="13435" href="1Lab.Univalence.html#3033" data-type="PartialP φ T → A → primGlue A T e" class="Primitive">prim^glue</a> <a id="13445" class="Symbol">{</a><a id="13446" class="Argument">φ</a> <a id="13448" class="Symbol">=</a> <a id="13450" href="1Lab.Univalence.html#13422" class="Bound">i</a> <a id="13452" href="1Lab.Path.html#2226" class="Primitive Operator">∨</a> <a id="13454" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="13456" href="1Lab.Univalence.html#13422" class="Bound">i</a><a id="13457" class="Symbol">}</a>
                                 <a id="13492" class="Symbol">(λ</a> <a id="13495" class="Symbol">{</a> <a id="13497" class="Symbol">(</a><a id="13498" href="1Lab.Univalence.html#13422" class="Bound">i</a> <a id="13500" class="Symbol">=</a> <a id="13502" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="13504" class="Symbol">)</a> <a id="13506" class="Symbol">→</a> <a id="13508" href="1Lab.Univalence.html#13424" class="Bound">x</a> <a id="13510" href="1Lab.Path.html#2443" class="Postulate">1=1</a>
                                    <a id="13550" class="Symbol">;</a> <a id="13552" class="Symbol">(</a><a id="13553" href="1Lab.Univalence.html#13422" class="Bound">i</a> <a id="13555" class="Symbol">=</a> <a id="13557" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="13559" class="Symbol">)</a> <a id="13561" class="Symbol">→</a> <a id="13563" href="1Lab.Path.html#2100" class="Primitive">outS</a> <a id="13568" href="1Lab.Univalence.html#13426" class="Bound">y</a> <a id="13570" class="Symbol">})</a>
                                 <a id="13606" class="Symbol">(</a><a id="13607" href="1Lab.Path.html#2100" class="Primitive">outS</a> <a id="13612" href="1Lab.Univalence.html#13426" class="Bound">y</a><a id="13613" class="Symbol">))</a>
</pre>
<p>Observe that, since
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>
is partially in the image of
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>,</span>
this essentially constrains
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>
to be a “partial preimage” of
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>
under the equivalence
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span>.</span>
Factoring in the type of the interval, we get the promised map between
dependent paths over
<span class="Agda"><a href="1Lab.Univalence.html#8818" class="Function">ua</a></span>
and paths in B.</p>
<pre class="Agda"><a id="path→ua-pathp"></a><a id="13901" href="1Lab.Univalence.html#13901" data-type="(e : A ≃ B₁) → e .fst x ≡ y → PathP (λ i → ua e i) x y" class="Function">path→ua-pathp</a> <a id="13915" class="Symbol">:</a> <a id="13917" class="Symbol">∀</a> <a id="13919" class="Symbol">{</a><a id="13920" href="1Lab.Univalence.html#13920" class="Bound">A</a> <a id="13922" href="1Lab.Univalence.html#13922" class="Bound">B</a> <a id="13924" class="Symbol">:</a> <a id="13926" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="13931" href="1Lab.Univalence.html#2867" class="Generalizable">ℓ</a><a id="13932" class="Symbol">}</a> <a id="13934" class="Symbol">(</a><a id="13935" href="1Lab.Univalence.html#13935" class="Bound">e</a> <a id="13937" class="Symbol">:</a> <a id="13939" href="1Lab.Univalence.html#13920" class="Bound">A</a> <a id="13941" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="13943" href="1Lab.Univalence.html#13922" class="Bound">B</a><a id="13944" class="Symbol">)</a> <a id="13946" class="Symbol">{</a><a id="13947" href="1Lab.Univalence.html#13947" class="Bound">x</a> <a id="13949" class="Symbol">:</a> <a id="13951" href="1Lab.Univalence.html#13920" class="Bound">A</a><a id="13952" class="Symbol">}</a> <a id="13954" class="Symbol">{</a><a id="13955" href="1Lab.Univalence.html#13955" class="Bound">y</a> <a id="13957" class="Symbol">:</a> <a id="13959" href="1Lab.Univalence.html#13922" class="Bound">B</a><a id="13960" class="Symbol">}</a>
              <a id="13976" class="Symbol">→</a> <a id="13978" href="1Lab.Univalence.html#13935" class="Bound">e</a> <a id="13980" class="Symbol">.</a><a id="13981" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="13985" href="1Lab.Univalence.html#13947" class="Bound">x</a> <a id="13987" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="13989" href="1Lab.Univalence.html#13955" class="Bound">y</a>
              <a id="14005" class="Symbol">→</a> <a id="14007" href="Agda.Primitive.Cubical.html#2013" class="Postulate">PathP</a> <a id="14013" class="Symbol">(λ</a> <a id="14016" href="1Lab.Univalence.html#14016" class="Bound">i</a> <a id="14018" class="Symbol">→</a> <a id="14020" href="1Lab.Univalence.html#8818" data-type="A ≃ B₁ → A ≡ B₁" class="Function">ua</a> <a id="14023" href="1Lab.Univalence.html#13935" class="Bound">e</a> <a id="14025" href="1Lab.Univalence.html#14016" class="Bound">i</a><a id="14026" class="Symbol">)</a> <a id="14028" href="1Lab.Univalence.html#13947" class="Bound">x</a> <a id="14030" href="1Lab.Univalence.html#13955" class="Bound">y</a>
<a id="14032" href="1Lab.Univalence.html#13901" data-type="(e : A ≃ B₁) → e .fst x ≡ y → PathP (λ i → ua e i) x y" class="Function">path→ua-pathp</a> <a id="14046" href="1Lab.Univalence.html#14046" class="Bound">e</a> <a id="14048" class="Symbol">{</a><a id="14049" class="Argument">x</a> <a id="14051" class="Symbol">=</a> <a id="14053" href="1Lab.Univalence.html#14053" class="Bound">x</a><a id="14054" class="Symbol">}</a> <a id="14056" href="1Lab.Univalence.html#14056" class="Bound">p</a> <a id="14058" href="1Lab.Univalence.html#14058" class="Bound">i</a> <a id="14060" class="Symbol">=</a> <a id="14062" href="1Lab.Path.html#2100" class="Primitive">outS</a> <a id="14067" class="Symbol">(</a><a id="14068" href="1Lab.Univalence.html#13141" data-type="(e : A ≃ B₁) (i : I) (x : Partial (~ i) A)
(y : B₁ [ ~ i ↦ (λ { (i = i0) → e .fst (x _) }) ]) →
ua e i [ ~ i ∨ i ↦ (λ { (i = i0) → x _ ; (i = i1) → outS y }) ]" class="Function">ua-glue</a> <a id="14076" href="1Lab.Univalence.html#14046" class="Bound">e</a> <a id="14078" href="1Lab.Univalence.html#14058" class="Bound">i</a> <a id="14080" class="Symbol">(λ</a> <a id="14083" class="Symbol">{</a> <a id="14085" class="Symbol">(</a><a id="14086" href="1Lab.Univalence.html#14058" class="Bound">i</a> <a id="14088" class="Symbol">=</a> <a id="14090" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="14092" class="Symbol">)</a> <a id="14094" class="Symbol">→</a> <a id="14096" href="1Lab.Univalence.html#14053" class="Bound">x</a> <a id="14098" class="Symbol">})</a> <a id="14101" class="Symbol">(</a><a id="14102" href="1Lab.Path.html#2069" class="Postulate">inS</a> <a id="14106" class="Symbol">(</a><a id="14107" href="1Lab.Univalence.html#14056" class="Bound">p</a> <a id="14109" href="1Lab.Univalence.html#14058" class="Bound">i</a><a id="14110" class="Symbol">)))</a>
</pre>
<p>The “pathp to path” versions of the above lemmas are definitionally
inverses, so they provide a characterisation of
<code>PathP (ua f)</code> in terms of non-dependent paths.</p>
<pre class="Agda"><a id="ua-pathp≃path"></a><a id="14292" href="1Lab.Univalence.html#14292" data-type="(e : A ≃ B₁) → (e .fst x ≡ y) ≃ PathP (λ i → ua e i) x y" class="Function">ua-pathp≃path</a> <a id="14306" class="Symbol">:</a> <a id="14308" class="Symbol">∀</a> <a id="14310" class="Symbol">{</a><a id="14311" href="1Lab.Univalence.html#14311" class="Bound">A</a> <a id="14313" href="1Lab.Univalence.html#14313" class="Bound">B</a> <a id="14315" class="Symbol">:</a> <a id="14317" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="14322" href="1Lab.Univalence.html#2867" class="Generalizable">ℓ</a><a id="14323" class="Symbol">}</a> <a id="14325" class="Symbol">(</a><a id="14326" href="1Lab.Univalence.html#14326" class="Bound">e</a> <a id="14328" class="Symbol">:</a> <a id="14330" href="1Lab.Univalence.html#14311" class="Bound">A</a> <a id="14332" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="14334" href="1Lab.Univalence.html#14313" class="Bound">B</a><a id="14335" class="Symbol">)</a> <a id="14337" class="Symbol">{</a><a id="14338" href="1Lab.Univalence.html#14338" class="Bound">x</a> <a id="14340" class="Symbol">:</a> <a id="14342" href="1Lab.Univalence.html#14311" class="Bound">A</a><a id="14343" class="Symbol">}</a> <a id="14345" class="Symbol">{</a><a id="14346" href="1Lab.Univalence.html#14346" class="Bound">y</a> <a id="14348" class="Symbol">:</a> <a id="14350" href="1Lab.Univalence.html#14313" class="Bound">B</a><a id="14351" class="Symbol">}</a>
              <a id="14367" class="Symbol">→</a> <a id="14369" class="Symbol">(</a><a id="14370" href="1Lab.Univalence.html#14326" class="Bound">e</a> <a id="14372" class="Symbol">.</a><a id="14373" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="14377" href="1Lab.Univalence.html#14338" class="Bound">x</a> <a id="14379" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="14381" href="1Lab.Univalence.html#14346" class="Bound">y</a><a id="14382" class="Symbol">)</a> <a id="14384" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="14386" class="Symbol">(</a><a id="14387" href="Agda.Primitive.Cubical.html#2013" class="Postulate">PathP</a> <a id="14393" class="Symbol">(λ</a> <a id="14396" href="1Lab.Univalence.html#14396" class="Bound">i</a> <a id="14398" class="Symbol">→</a> <a id="14400" href="1Lab.Univalence.html#8818" data-type="A ≃ B₁ → A ≡ B₁" class="Function">ua</a> <a id="14403" href="1Lab.Univalence.html#14326" class="Bound">e</a> <a id="14405" href="1Lab.Univalence.html#14396" class="Bound">i</a><a id="14406" class="Symbol">)</a> <a id="14408" href="1Lab.Univalence.html#14338" class="Bound">x</a> <a id="14410" href="1Lab.Univalence.html#14346" class="Bound">y</a><a id="14411" class="Symbol">)</a>
<a id="14413" href="1Lab.Univalence.html#14292" data-type="(e : A ≃ B₁) → (e .fst x ≡ y) ≃ PathP (λ i → ua e i) x y" class="Function">ua-pathp≃path</a> <a id="14427" href="1Lab.Univalence.html#14427" class="Bound">eqv</a> <a id="14431" class="Symbol">.</a><a id="14432" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="14436" class="Symbol">=</a> <a id="14438" href="1Lab.Univalence.html#13901" data-type="(e : A ≃ B₁) → e .fst x ≡ y → PathP (λ i → ua e i) x y" class="Function">path→ua-pathp</a> <a id="14452" href="1Lab.Univalence.html#14427" class="Bound">eqv</a>
<a id="14456" href="1Lab.Univalence.html#14292" data-type="(e : A ≃ B₁) → (e .fst x ≡ y) ≃ PathP (λ i → ua e i) x y" class="Function">ua-pathp≃path</a> <a id="14470" href="1Lab.Univalence.html#14470" class="Bound">eqv</a> <a id="14474" class="Symbol">.</a><a id="14475" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="14479" class="Symbol">.</a><a id="14480" href="1Lab.Equiv.html#2376" data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" class="Field">is-eqv</a> <a id="14487" href="1Lab.Univalence.html#14487" class="Bound">y</a> <a id="14489" class="Symbol">.</a><a id="14490" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a> <a id="14497" class="Symbol">=</a> <a id="14499" href="1Lab.Equiv.html#2806" data-type="(g : B₁ → A) (b : B₁) →
Σ
(λ t →
   (t&#39; : fibre f b) →
   Path (fibre f (f (g b))) t
   (g (f (t&#39; .fst)) , ap (f ⊙ g) (t&#39; .snd)))" class="Function">strict-fibres</a> <a id="14513" class="Symbol">(</a><a id="14514" href="1Lab.Univalence.html#12491" data-type="(e : A ≃ B₁) → PathP (λ i → ua e i) x y → e .fst x ≡ y" class="Function">ua-pathp→path</a> <a id="14528" href="1Lab.Univalence.html#14470" class="Bound">eqv</a><a id="14531" class="Symbol">)</a> <a id="14533" href="1Lab.Univalence.html#14487" class="Bound">y</a> <a id="14535" class="Symbol">.</a><a id="14536" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a>
<a id="14540" href="1Lab.Univalence.html#14292" data-type="(e : A ≃ B₁) → (e .fst x ≡ y) ≃ PathP (λ i → ua e i) x y" class="Function">ua-pathp≃path</a> <a id="14554" href="1Lab.Univalence.html#14554" class="Bound">eqv</a> <a id="14558" class="Symbol">.</a><a id="14559" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="14563" class="Symbol">.</a><a id="14564" href="1Lab.Equiv.html#2376" data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" class="Field">is-eqv</a> <a id="14571" href="1Lab.Univalence.html#14571" class="Bound">y</a> <a id="14573" class="Symbol">.</a><a id="14574" href="1Lab.HLevel.html#1416" data-type="(r : is-contr A) (x : A) → r .centre ≡ x" class="Field">paths</a> <a id="14580" class="Symbol">=</a> <a id="14582" href="1Lab.Equiv.html#2806" data-type="(g : B₁ → A) (b : B₁) →
Σ
(λ t →
   (t&#39; : fibre f b) →
   Path (fibre f (f (g b))) t
   (g (f (t&#39; .fst)) , ap (f ⊙ g) (t&#39; .snd)))" class="Function">strict-fibres</a> <a id="14596" class="Symbol">(</a><a id="14597" href="1Lab.Univalence.html#12491" data-type="(e : A ≃ B₁) → PathP (λ i → ua e i) x y → e .fst x ≡ y" class="Function">ua-pathp→path</a> <a id="14611" href="1Lab.Univalence.html#14554" class="Bound">eqv</a><a id="14614" class="Symbol">)</a> <a id="14616" href="1Lab.Univalence.html#14571" class="Bound">y</a> <a id="14618" class="Symbol">.</a><a id="14619" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a>
</pre>
<h1 id="the-axiom"><a href="#the-axiom" class="header-link">The
“axiom”<span class="header-link-emoji">🔗</span></a></h1>
<p>The actual “univalence axiom”, as stated in the HoTT book, says that
the canonical map <code>A ≡ B</code>, defined using
<span class="Agda"><a href="1Lab.Path.html#19544" class="Function">J</a></span>,
is an equivalence. This map is
<span class="Agda"><a href="1Lab.Univalence.html#15001" class="Function">id→equiv</a></span>,
defined right above. In more intuitive terms, it’s “casting” the
identity equivalence <code>A ≃ A</code> along a proof that
<code>A ≡ B</code> to get an equivalence <code>A ≃ B</code>.</p>
<pre class="Agda"><a id="14976" class="Keyword">module</a> <a id="14983" href="1Lab.Univalence.html#14983" class="Module">_</a> <a id="14985" class="Keyword">where</a> <a id="14991" class="Keyword">private</a>
  <a id="15001" href="1Lab.Univalence.html#15001" class="Function">id→equiv</a> <a id="15010" class="Symbol">:</a> <a id="15012" class="Symbol">{</a><a id="15013" href="1Lab.Univalence.html#15013" class="Bound">A</a> <a id="15015" href="1Lab.Univalence.html#15015" class="Bound">B</a> <a id="15017" class="Symbol">:</a> <a id="15019" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="15024" href="1Lab.Univalence.html#2867" class="Generalizable">ℓ</a><a id="15025" class="Symbol">}</a> <a id="15027" class="Symbol">→</a> <a id="15029" href="1Lab.Univalence.html#15013" class="Bound">A</a> <a id="15031" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="15033" href="1Lab.Univalence.html#15015" class="Bound">B</a> <a id="15035" class="Symbol">→</a> <a id="15037" href="1Lab.Univalence.html#15013" class="Bound">A</a> <a id="15039" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="15041" href="1Lab.Univalence.html#15015" class="Bound">B</a>
  <a id="15045" href="1Lab.Univalence.html#15001" class="Function">id→equiv</a> <a id="15054" class="Symbol">{</a><a id="15055" class="Argument">A</a> <a id="15057" class="Symbol">=</a> <a id="15059" href="1Lab.Univalence.html#15059" class="Bound">A</a><a id="15060" class="Symbol">}</a> <a id="15062" class="Symbol">{</a><a id="15063" href="1Lab.Univalence.html#15063" class="Bound">B</a><a id="15064" class="Symbol">}</a> <a id="15066" class="Symbol">=</a> <a id="15068" href="1Lab.Path.html#19544" data-type="(P : (y : A) → x ≡ y → Type ℓ₂) → P x refl → (p : x ≡ y) → P y p" class="Function">J</a> <a id="15070" class="Symbol">(λ</a> <a id="15073" href="1Lab.Univalence.html#15073" class="Bound">x</a> <a id="15075" href="1Lab.Univalence.html#15075" class="Bound">_</a> <a id="15077" class="Symbol">→</a> <a id="15079" href="1Lab.Univalence.html#15059" class="Bound">A</a> <a id="15081" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="15083" href="1Lab.Univalence.html#15073" class="Bound">x</a><a id="15084" class="Symbol">)</a> <a id="15086" class="Symbol">(_</a> <a id="15089" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="15091" href="1Lab.Equiv.html#2524" data-type="is-equiv (λ x → x)" class="Function">id-equiv</a><a id="15099" class="Symbol">)</a>

  <a id="15104" href="1Lab.Univalence.html#15104" class="Function">id→equiv-refl</a> <a id="15118" class="Symbol">:</a> <a id="15120" class="Symbol">{</a><a id="15121" href="1Lab.Univalence.html#15121" class="Bound">A</a> <a id="15123" class="Symbol">:</a> <a id="15125" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="15130" href="1Lab.Univalence.html#2867" class="Generalizable">ℓ</a><a id="15131" class="Symbol">}</a> <a id="15133" class="Symbol">→</a> <a id="15135" href="1Lab.Univalence.html#15001" class="Function">id→equiv</a> <a id="15144" class="Symbol">(λ</a> <a id="15147" href="1Lab.Univalence.html#15147" class="Bound">i</a> <a id="15149" class="Symbol">→</a> <a id="15151" href="1Lab.Univalence.html#15121" class="Bound">A</a><a id="15152" class="Symbol">)</a> <a id="15154" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="15156" class="Symbol">(_</a> <a id="15159" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="15161" href="1Lab.Equiv.html#2524" data-type="is-equiv (λ x → x)" class="Function">id-equiv</a><a id="15169" class="Symbol">)</a>
  <a id="15173" href="1Lab.Univalence.html#15104" class="Function">id→equiv-refl</a> <a id="15187" class="Symbol">{</a><a id="15188" class="Argument">A</a> <a id="15190" class="Symbol">=</a> <a id="15192" href="1Lab.Univalence.html#15192" class="Bound">A</a><a id="15193" class="Symbol">}</a> <a id="15195" class="Symbol">=</a> <a id="15197" href="1Lab.Path.html#20103" data-type="(P : (y : A) → x ≡ y → Type ℓ₂) (pxr : P x refl) →
J P pxr refl ≡ pxr" class="Function">J-refl</a> <a id="15204" class="Symbol">(λ</a> <a id="15207" href="1Lab.Univalence.html#15207" class="Bound">x</a> <a id="15209" href="1Lab.Univalence.html#15209" class="Bound">_</a> <a id="15211" class="Symbol">→</a> <a id="15213" href="1Lab.Univalence.html#15192" class="Bound">A</a> <a id="15215" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="15217" href="1Lab.Univalence.html#15207" class="Bound">x</a><a id="15218" class="Symbol">)</a> <a id="15220" class="Symbol">(_</a> <a id="15223" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="15225" href="1Lab.Equiv.html#2524" data-type="is-equiv (λ x → x)" class="Function">id-equiv</a><a id="15233" class="Symbol">)</a>
</pre>
<p>However, because of efficiency concerns (Agda <em>is</em> a
programming language, after all), instead of using
<span class="Agda"><a href="1Lab.Univalence.html#15001" class="Function">id→equiv</a></span>
defined using J, we use
<span class="Agda"><a href="1Lab.Univalence.html#15486" class="Function">path→equiv</a></span>,
which is <a href="1Lab.Equiv.FromPath.html">defined in an auxilliary
module</a>.</p>
<pre class="Agda"><a id="path→equiv"></a><a id="15486" href="1Lab.Univalence.html#15486" data-type="A ≡ B₁ → A ≃ B₁" class="Function">path→equiv</a> <a id="15497" class="Symbol">:</a> <a id="15499" class="Symbol">{</a><a id="15500" href="1Lab.Univalence.html#15500" class="Bound">A</a> <a id="15502" href="1Lab.Univalence.html#15502" class="Bound">B</a> <a id="15504" class="Symbol">:</a> <a id="15506" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="15511" href="1Lab.Univalence.html#2867" class="Generalizable">ℓ</a><a id="15512" class="Symbol">}</a> <a id="15514" class="Symbol">→</a> <a id="15516" href="1Lab.Univalence.html#15500" class="Bound">A</a> <a id="15518" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="15520" href="1Lab.Univalence.html#15502" class="Bound">B</a> <a id="15522" class="Symbol">→</a> <a id="15524" href="1Lab.Univalence.html#15500" class="Bound">A</a> <a id="15526" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="15528" href="1Lab.Univalence.html#15502" class="Bound">B</a>
<a id="15530" href="1Lab.Univalence.html#15486" data-type="A ≡ B₁ → A ≃ B₁" class="Function">path→equiv</a> <a id="15541" href="1Lab.Univalence.html#15541" class="Bound">p</a> <a id="15543" class="Symbol">=</a> <a id="15545" href="1Lab.Equiv.FromPath.html#9366" data-type="(P : I → Type ℓ) → A P ≃ B P" class="Function">line→equiv</a> <a id="15556" class="Symbol">(λ</a> <a id="15559" href="1Lab.Univalence.html#15559" class="Bound">i</a> <a id="15561" class="Symbol">→</a> <a id="15563" href="1Lab.Univalence.html#15541" class="Bound">p</a> <a id="15565" href="1Lab.Univalence.html#15559" class="Bound">i</a><a id="15566" class="Symbol">)</a>
</pre>
<p>Since identity of equivalences is determined by identity of their
underlying functions, to show that
<span class="Agda"><a href="1Lab.Univalence.html#15486" class="Function">path→equiv</a></span>
of
<span class="Agda"><a href="1Lab.Path.html#3593" class="Function">refl</a></span>
is the identity equivalence, we use
<span class="Agda"><a href="1Lab.Path.html#51798" class="Function">coe1→i</a></span>
to show that
<span class="Agda"><a href="1Lab.Path.html#11776" class="Function">transport</a></span>
by
<span class="Agda"><a href="1Lab.Path.html#3593" class="Function">refl</a></span>
is the identity.</p>
<pre class="Agda"><a id="path→equiv-refl"></a><a id="15838" href="1Lab.Univalence.html#15838" data-type="path→equiv refl ≡ (id , id-equiv)" class="Function">path→equiv-refl</a> <a id="15854" class="Symbol">:</a> <a id="15856" class="Symbol">{</a><a id="15857" href="1Lab.Univalence.html#15857" class="Bound">A</a> <a id="15859" class="Symbol">:</a> <a id="15861" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="15866" href="1Lab.Univalence.html#2867" class="Generalizable">ℓ</a><a id="15867" class="Symbol">}</a> <a id="15869" class="Symbol">→</a> <a id="15871" href="1Lab.Univalence.html#15486" data-type="A ≡ B₁ → A ≃ B₁" class="Function">path→equiv</a> <a id="15882" class="Symbol">(</a><a id="15883" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="15888" class="Symbol">{</a><a id="15889" class="Argument">x</a> <a id="15891" class="Symbol">=</a> <a id="15893" href="1Lab.Univalence.html#15857" class="Bound">A</a><a id="15894" class="Symbol">})</a> <a id="15897" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="15899" class="Symbol">(</a><a id="15900" href="1Lab.Type.html#2424" data-type="A → A" class="Function">id</a> <a id="15903" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="15905" href="1Lab.Equiv.html#2524" data-type="is-equiv (λ x → x)" class="Function">id-equiv</a><a id="15913" class="Symbol">)</a>
<a id="15915" href="1Lab.Univalence.html#15838" data-type="path→equiv refl ≡ (id , id-equiv)" class="Function">path→equiv-refl</a> <a id="15931" class="Symbol">{</a><a id="15932" class="Argument">A</a> <a id="15934" class="Symbol">=</a> <a id="15936" href="1Lab.Univalence.html#15936" class="Bound">A</a><a id="15937" class="Symbol">}</a> <a id="15939" class="Symbol">=</a>
  <a id="15943" href="1Lab.Path.html#57659" data-type="(p : x .fst ≡ y .fst) → subst B₁ p (x .snd) ≡ y .snd → x ≡ y" class="Function">Σ-path</a> <a id="15950" class="Symbol">(λ</a> <a id="15953" href="1Lab.Univalence.html#15953" class="Bound">i</a> <a id="15955" href="1Lab.Univalence.html#15955" class="Bound">x</a> <a id="15957" class="Symbol">→</a> <a id="15959" href="1Lab.Path.html#51798" data-type="(A : (i : I) → Type (ℓ i)) (i : I) → A i1 → A i" class="Function">coe1→i</a> <a id="15966" class="Symbol">(λ</a> <a id="15969" href="1Lab.Univalence.html#15969" class="Bound">i</a> <a id="15971" class="Symbol">→</a> <a id="15973" href="1Lab.Univalence.html#15936" class="Bound">A</a><a id="15974" class="Symbol">)</a> <a id="15976" href="1Lab.Univalence.html#15953" class="Bound">i</a> <a id="15978" href="1Lab.Univalence.html#15955" class="Bound">x</a><a id="15979" class="Symbol">)</a>
         <a id="15990" class="Symbol">(</a><a id="15991" href="1Lab.HLevel.html#13498" data-type="((i : I) → is-prop (B₁ i)) →
(b0 : B₁ i0) (b1 : B₁ i1) → PathP B₁ b0 b1" class="Function">is-prop→pathp</a> <a id="16005" class="Symbol">(λ</a> <a id="16008" href="1Lab.Univalence.html#16008" class="Bound">i</a> <a id="16010" class="Symbol">→</a> <a id="16012" href="1Lab.Equiv.html#4916" data-type="(f : A → B₁) → is-prop (is-equiv f)" class="Function">is-equiv-is-prop</a> <a id="16029" class="Symbol">_)</a> <a id="16032" class="Symbol">_</a> <a id="16034" class="Symbol">_)</a>
</pre>
<p>For the other direction, we must show that
<span class="Agda"><a href="1Lab.Univalence.html#8818" class="Function">ua</a></span>
of
<span class="Agda"><a href="1Lab.Equiv.html#2524" class="Function">id-equiv</a></span>
is
<span class="Agda"><a href="1Lab.Path.html#3593" class="Function">refl</a></span>.
We can do this quite efficiently using
<span class="Agda"><a href="1Lab.Univalence.html#3439" class="Function">Glue</a></span>.
Since this is a path between paths, we have two interval variables.</p>
<pre class="Agda"><a id="ua-id-equiv"></a><a id="16267" href="1Lab.Univalence.html#16267" data-type="ua ((λ x → x) , id-equiv) ≡ refl" class="Function">ua-id-equiv</a> <a id="16279" class="Symbol">:</a> <a id="16281" class="Symbol">{</a><a id="16282" href="1Lab.Univalence.html#16282" class="Bound">A</a> <a id="16284" class="Symbol">:</a> <a id="16286" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="16291" href="1Lab.Univalence.html#2867" class="Generalizable">ℓ</a><a id="16292" class="Symbol">}</a> <a id="16294" class="Symbol">→</a> <a id="16296" href="1Lab.Univalence.html#8818" data-type="A ≃ B₁ → A ≡ B₁" class="Function">ua</a> <a id="16299" class="Symbol">(_</a> <a id="16302" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="16304" href="1Lab.Equiv.html#2524" data-type="is-equiv (λ x → x)" class="Function">id-equiv</a> <a id="16313" class="Symbol">{</a><a id="16314" class="Argument">A</a> <a id="16316" class="Symbol">=</a> <a id="16318" href="1Lab.Univalence.html#16282" class="Bound">A</a><a id="16319" class="Symbol">})</a> <a id="16322" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="16324" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
<a id="16329" href="1Lab.Univalence.html#16267" data-type="ua ((λ x → x) , id-equiv) ≡ refl" class="Function">ua-id-equiv</a> <a id="16341" class="Symbol">{</a><a id="16342" class="Argument">A</a> <a id="16344" class="Symbol">=</a> <a id="16346" href="1Lab.Univalence.html#16346" class="Bound">A</a><a id="16347" class="Symbol">}</a> <a id="16349" href="1Lab.Univalence.html#16349" class="Bound">i</a> <a id="16351" href="1Lab.Univalence.html#16351" class="Bound">j</a> <a id="16353" class="Symbol">=</a> <a id="16355" href="1Lab.Univalence.html#3439" data-type="(A : Type ℓ) → Partial φ (Σ (λ T → T ≃ A)) → Type ℓ&#39;" class="Function">Glue</a> <a id="16360" href="1Lab.Univalence.html#16346" class="Bound">A</a> <a id="16362" class="Symbol">{</a><a id="16363" class="Argument">φ</a> <a id="16365" class="Symbol">=</a> <a id="16367" href="1Lab.Univalence.html#16349" class="Bound">i</a> <a id="16369" href="1Lab.Path.html#2226" class="Primitive Operator">∨</a> <a id="16371" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="16373" href="1Lab.Univalence.html#16351" class="Bound">j</a> <a id="16375" href="1Lab.Path.html#2226" class="Primitive Operator">∨</a> <a id="16377" href="1Lab.Univalence.html#16351" class="Bound">j</a><a id="16378" class="Symbol">}</a> <a id="16380" class="Symbol">(λ</a> <a id="16383" href="1Lab.Univalence.html#16383" class="Bound">_</a> <a id="16385" class="Symbol">→</a> <a id="16387" href="1Lab.Univalence.html#16346" class="Bound">A</a> <a id="16389" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="16391" class="Symbol">_</a> <a id="16393" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="16395" href="1Lab.Equiv.html#2524" data-type="is-equiv (λ x → x)" class="Function">id-equiv</a><a id="16403" class="Symbol">)</a>
</pre>
<p>We can then prove that the map
<span class="Agda"><a href="1Lab.Univalence.html#15486" class="Function">path→equiv</a></span>
is an isomorphism, hence an equivalence. It’s very useful to have
explicit names for the proofs that
<span class="Agda"><a href="1Lab.Univalence.html#15486" class="Function">path→equiv</a></span>
and
<span class="Agda"><a href="1Lab.Univalence.html#8818" class="Function">ua</a></span>
are equivalences without referring to components of
<span class="Agda"><a href="1Lab.Univalence.html#16720" class="Function">Path≃Equiv</a></span>,
so we introduce names for them as well.</p>
<pre class="Agda"><a id="Path≃Equiv"></a><a id="16720" href="1Lab.Univalence.html#16720" data-type="Iso (A ≡ B₁) (A ≃ B₁)" class="Function">Path≃Equiv</a>   <a id="16733" class="Symbol">:</a> <a id="16735" class="Symbol">{</a><a id="16736" href="1Lab.Univalence.html#16736" class="Bound">A</a> <a id="16738" href="1Lab.Univalence.html#16738" class="Bound">B</a> <a id="16740" class="Symbol">:</a> <a id="16742" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="16747" href="1Lab.Univalence.html#2867" class="Generalizable">ℓ</a><a id="16748" class="Symbol">}</a> <a id="16750" class="Symbol">→</a> <a id="16752" href="1Lab.Equiv.html#6298" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function">Iso</a> <a id="16756" class="Symbol">(</a><a id="16757" href="1Lab.Univalence.html#16736" class="Bound">A</a> <a id="16759" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="16761" href="1Lab.Univalence.html#16738" class="Bound">B</a><a id="16762" class="Symbol">)</a> <a id="16764" class="Symbol">(</a><a id="16765" href="1Lab.Univalence.html#16736" class="Bound">A</a> <a id="16767" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="16769" href="1Lab.Univalence.html#16738" class="Bound">B</a><a id="16770" class="Symbol">)</a>
<a id="univalence"></a><a id="16772" href="1Lab.Univalence.html#16772" data-type="is-equiv path→equiv" class="Function">univalence</a>   <a id="16785" class="Symbol">:</a> <a id="16787" class="Symbol">{</a><a id="16788" href="1Lab.Univalence.html#16788" class="Bound">A</a> <a id="16790" href="1Lab.Univalence.html#16790" class="Bound">B</a> <a id="16792" class="Symbol">:</a> <a id="16794" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="16799" href="1Lab.Univalence.html#2867" class="Generalizable">ℓ</a><a id="16800" class="Symbol">}</a> <a id="16802" class="Symbol">→</a> <a id="16804" href="1Lab.Equiv.html#2286" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-equiv</a> <a id="16813" class="Symbol">(</a><a id="16814" href="1Lab.Univalence.html#15486" data-type="A ≡ B₁ → A ≃ B₁" class="Function">path→equiv</a> <a id="16825" class="Symbol">{</a><a id="16826" class="Argument">A</a> <a id="16828" class="Symbol">=</a> <a id="16830" href="1Lab.Univalence.html#16788" class="Bound">A</a><a id="16831" class="Symbol">}</a> <a id="16833" class="Symbol">{</a><a id="16834" href="1Lab.Univalence.html#16790" class="Bound">B</a><a id="16835" class="Symbol">})</a>
<a id="univalence⁻¹"></a><a id="16838" href="1Lab.Univalence.html#16838" data-type="is-equiv ua" class="Function">univalence⁻¹</a> <a id="16851" class="Symbol">:</a> <a id="16853" class="Symbol">{</a><a id="16854" href="1Lab.Univalence.html#16854" class="Bound">A</a> <a id="16856" href="1Lab.Univalence.html#16856" class="Bound">B</a> <a id="16858" class="Symbol">:</a> <a id="16860" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="16865" href="1Lab.Univalence.html#2867" class="Generalizable">ℓ</a><a id="16866" class="Symbol">}</a> <a id="16868" class="Symbol">→</a> <a id="16870" href="1Lab.Equiv.html#2286" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-equiv</a> <a id="16879" class="Symbol">(</a><a id="16880" href="1Lab.Univalence.html#8818" data-type="A ≃ B₁ → A ≡ B₁" class="Function">ua</a> <a id="16883" class="Symbol">{</a><a id="16884" class="Argument">A</a> <a id="16886" class="Symbol">=</a> <a id="16888" href="1Lab.Univalence.html#16854" class="Bound">A</a><a id="16889" class="Symbol">}</a> <a id="16891" class="Symbol">{</a><a id="16892" href="1Lab.Univalence.html#16856" class="Bound">B</a><a id="16893" class="Symbol">})</a>

<a id="16897" href="1Lab.Univalence.html#16720" data-type="Iso (A ≡ B₁) (A ≃ B₁)" class="Function">Path≃Equiv</a> <a id="16908" class="Symbol">{</a><a id="16909" class="Argument">A</a> <a id="16911" class="Symbol">=</a> <a id="16913" href="1Lab.Univalence.html#16913" class="Bound">A</a><a id="16914" class="Symbol">}</a> <a id="16916" class="Symbol">{</a><a id="16917" class="Argument">B</a> <a id="16919" class="Symbol">=</a> <a id="16921" href="1Lab.Univalence.html#16921" class="Bound">B</a><a id="16922" class="Symbol">}</a> <a id="16924" class="Symbol">=</a> <a id="16926" href="1Lab.Univalence.html#15486" data-type="A ≡ B₁ → A ≃ B₁" class="Function">path→equiv</a> <a id="16937" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="16939" href="1Lab.Univalence.html#16952" data-type="is-iso path→equiv" class="Function">iiso</a> <a id="16944" class="Keyword">where</a>
  <a id="16952" href="1Lab.Univalence.html#16952" data-type="is-iso path→equiv" class="Function">iiso</a> <a id="16957" class="Symbol">:</a> <a id="16959" href="1Lab.Equiv.html#6026" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-iso</a> <a id="16966" href="1Lab.Univalence.html#15486" data-type="A ≡ B₁ → A ≃ B₁" class="Function">path→equiv</a>
  <a id="16979" href="1Lab.Equiv.html#6132" data-type="is-iso f → B₁ → A" class="Field">is-iso.inv</a> <a id="16990" href="1Lab.Univalence.html#16952" data-type="is-iso path→equiv" class="Function">iiso</a> <a id="16995" class="Symbol">=</a> <a id="16997" href="1Lab.Univalence.html#8818" data-type="A ≃ B₁ → A ≡ B₁" class="Function">ua</a>
</pre>
<p>We show that <code>path→equiv</code> inverts
<span class="Agda"><a href="1Lab.Univalence.html#8818" class="Function">ua</a></span>,
which means proving that one can recover the original equivalence from
the generated path. Because of the computational nature of Cubical Agda,
all we have to do is apply
<span class="Agda"><a href="1Lab.Univalence.html#10966" class="Function">uaβ</a></span>:</p>
<pre class="Agda">  <a id="17248" href="1Lab.Equiv.html#6148" data-type="(r : is-iso f) → is-right-inverse (r .inv) f" class="Field">is-iso.rinv</a> <a id="17260" href="1Lab.Univalence.html#16952" data-type="is-iso path→equiv" class="Function">iiso</a> <a id="17265" class="Symbol">(</a><a id="17266" href="1Lab.Univalence.html#17266" class="Bound">f</a> <a id="17268" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="17270" href="1Lab.Univalence.html#17270" class="Bound">is-eqv</a><a id="17276" class="Symbol">)</a> <a id="17278" class="Symbol">=</a>
    <a id="17284" href="1Lab.Path.html#57659" data-type="(p : x .fst ≡ y .fst) → subst B₁ p (x .snd) ≡ y .snd → x ≡ y" class="Function">Σ-path</a> <a id="17291" class="Symbol">(</a><a id="17292" href="1Lab.Path.html#58474" data-type="((x : A) → f x ≡ g x) → f ≡ g" class="Function">funext</a> <a id="17299" class="Symbol">(</a><a id="17300" href="1Lab.Univalence.html#10966" data-type="(f : A ≃ B₁) (x : A) → transport (ua f) x ≡ f .fst x" class="Function">uaβ</a> <a id="17304" class="Symbol">(</a><a id="17305" href="1Lab.Univalence.html#17266" class="Bound">f</a> <a id="17307" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="17309" href="1Lab.Univalence.html#17270" class="Bound">is-eqv</a><a id="17315" class="Symbol">)))</a> <a id="17319" class="Symbol">(</a><a id="17320" href="1Lab.Equiv.html#4916" data-type="(f : A → B₁) → is-prop (is-equiv f)" class="Function">is-equiv-is-prop</a> <a id="17337" href="1Lab.Univalence.html#17266" class="Bound">f</a> <a id="17339" class="Symbol">_</a> <a id="17341" class="Symbol">_)</a>
</pre>
<p>For the other direction, we use <a href="1Lab.Path.html#J">path
induction</a> to reduce the problem from showing that
<span class="Agda"><a href="1Lab.Univalence.html#8818" class="Function">ua</a></span>
inverts
<span class="Agda"><a href="1Lab.Univalence.html#15486" class="Function">path→equiv</a></span>
for an arbitrary path (which is hard) to showing that
<span class="Agda"><a href="1Lab.Univalence.html#15486" class="Function">path→equiv</a></span>
takes
<span class="Agda"><a href="1Lab.Path.html#3593" class="Function">refl</a></span>
to the identity equivalence
(<span class="Agda"><a href="1Lab.Univalence.html#15838" class="Function">path→equiv-refl</a></span>),
and that
<span class="Agda"><a href="1Lab.Univalence.html#8818" class="Function">ua</a></span>
takes the identity equivalence to
<span class="Agda"><a href="1Lab.Path.html#3593" class="Function">refl</a></span>
(<span class="Agda"><a href="1Lab.Univalence.html#16267" class="Function">ua-id-equiv</a></span>).</p>
<pre class="Agda">  <a id="17768" href="1Lab.Equiv.html#6182" data-type="(r : is-iso f) → is-left-inverse (r .inv) f" class="Field">is-iso.linv</a> <a id="17780" href="1Lab.Univalence.html#16952" data-type="is-iso path→equiv" class="Function">iiso</a> <a id="17785" class="Symbol">=</a>
    <a id="17791" href="1Lab.Path.html#19544" data-type="(P : (y : A) → x ≡ y → Type ℓ₂) → P x refl → (p : x ≡ y) → P y p" class="Function">J</a> <a id="17793" class="Symbol">(λ</a> <a id="17796" href="1Lab.Univalence.html#17796" class="Bound">_</a> <a id="17798" href="1Lab.Univalence.html#17798" class="Bound">p</a> <a id="17800" class="Symbol">→</a> <a id="17802" href="1Lab.Univalence.html#8818" data-type="A ≃ B₁ → A ≡ B₁" class="Function">ua</a> <a id="17805" class="Symbol">(</a><a id="17806" href="1Lab.Univalence.html#15486" data-type="A ≡ B₁ → A ≃ B₁" class="Function">path→equiv</a> <a id="17817" href="1Lab.Univalence.html#17798" class="Bound">p</a><a id="17818" class="Symbol">)</a> <a id="17820" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="17822" href="1Lab.Univalence.html#17798" class="Bound">p</a><a id="17823" class="Symbol">)</a>
      <a id="17831" class="Symbol">(</a><a id="17832" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="17835" href="1Lab.Univalence.html#8818" data-type="A ≃ B₁ → A ≡ B₁" class="Function">ua</a> <a id="17838" href="1Lab.Univalence.html#15838" data-type="path→equiv refl ≡ (id , id-equiv)" class="Function">path→equiv-refl</a> <a id="17854" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="17856" href="1Lab.Univalence.html#16267" data-type="ua ((λ x → x) , id-equiv) ≡ refl" class="Function">ua-id-equiv</a><a id="17867" class="Symbol">)</a>

<a id="17870" href="1Lab.Univalence.html#16772" data-type="is-equiv path→equiv" class="Function">univalence</a> <a id="17881" class="Symbol">{</a><a id="17882" class="Argument">A</a> <a id="17884" class="Symbol">=</a> <a id="17886" href="1Lab.Univalence.html#17886" class="Bound">A</a><a id="17887" class="Symbol">}</a> <a id="17889" class="Symbol">{</a><a id="17890" href="1Lab.Univalence.html#17890" class="Bound">B</a><a id="17891" class="Symbol">}</a> <a id="17893" class="Symbol">=</a> <a id="17895" href="1Lab.Equiv.html#19815" data-type="(i : is-iso f) → is-equiv f" class="Function">is-iso→is-equiv</a> <a id="17911" class="Symbol">(</a><a id="17912" href="1Lab.Univalence.html#16720" data-type="Iso (A ≡ B₁) (A ≃ B₁)" class="Function">Path≃Equiv</a> <a id="17923" class="Symbol">.</a><a id="17924" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a><a id="17927" class="Symbol">)</a>
<a id="17929" href="1Lab.Univalence.html#16838" data-type="is-equiv ua" class="Function">univalence⁻¹</a> <a id="17942" class="Symbol">{</a><a id="17943" class="Argument">A</a> <a id="17945" class="Symbol">=</a> <a id="17947" href="1Lab.Univalence.html#17947" class="Bound">A</a><a id="17948" class="Symbol">}</a> <a id="17950" class="Symbol">{</a><a id="17951" href="1Lab.Univalence.html#17951" class="Bound">B</a><a id="17952" class="Symbol">}</a> <a id="17954" class="Symbol">=</a> <a id="17956" href="1Lab.Equiv.html#19815" data-type="(i : is-iso f) → is-equiv f" class="Function">is-iso→is-equiv</a> <a id="17972" class="Symbol">(</a><a id="17973" href="1Lab.Equiv.html#6214" data-type="(r : is-iso f) → is-iso (inv r)" class="Function">is-iso.inverse</a> <a id="17988" class="Symbol">(</a><a id="17989" href="1Lab.Univalence.html#16720" data-type="Iso (A ≡ B₁) (A ≃ B₁)" class="Function">Path≃Equiv</a> <a id="18000" class="Symbol">.</a><a id="18001" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a><a id="18004" class="Symbol">))</a>
</pre>
<p>In some situations, it is helpful to have a proof that
<span class="Agda"><a href="1Lab.Univalence.html#15486" class="Function">path→equiv</a></span>
followed by <code class="sourceCode agda" data-ident="Lift">an adjustment of levels</code> is still an
equivalence:</p>
<pre class="Agda"><a id="univalence-lift"></a><a id="18177" href="1Lab.Univalence.html#18177" data-type="is-equiv (λ e → lift (path→equiv e))" class="Function">univalence-lift</a> <a id="18193" class="Symbol">:</a> <a id="18195" class="Symbol">{</a><a id="18196" href="1Lab.Univalence.html#18196" class="Bound">A</a> <a id="18198" href="1Lab.Univalence.html#18198" class="Bound">B</a> <a id="18200" class="Symbol">:</a> <a id="18202" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="18207" href="1Lab.Univalence.html#2867" class="Generalizable">ℓ</a><a id="18208" class="Symbol">}</a> <a id="18210" class="Symbol">→</a> <a id="18212" href="1Lab.Equiv.html#2286" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-equiv</a> <a id="18221" class="Symbol">(λ</a> <a id="18224" href="1Lab.Univalence.html#18224" class="Bound">e</a> <a id="18226" class="Symbol">→</a> <a id="18228" href="1Lab.Type.html#2075" data-type="(lower : A) → Lift ℓ A" class="InductiveConstructor">lift</a> <a id="18233" class="Symbol">(</a><a id="18234" href="1Lab.Univalence.html#15486" data-type="A ≡ B₁ → A ≃ B₁" class="Function">path→equiv</a> <a id="18245" class="Symbol">{</a><a id="18246" class="Argument">A</a> <a id="18248" class="Symbol">=</a> <a id="18250" href="1Lab.Univalence.html#18196" class="Bound">A</a><a id="18251" class="Symbol">}</a> <a id="18253" class="Symbol">{</a><a id="18254" href="1Lab.Univalence.html#18198" class="Bound">B</a><a id="18255" class="Symbol">}</a> <a id="18257" href="1Lab.Univalence.html#18224" class="Bound">e</a><a id="18258" class="Symbol">))</a>
<a id="18261" href="1Lab.Univalence.html#18177" data-type="is-equiv (λ e → lift (path→equiv e))" class="Function">univalence-lift</a> <a id="18277" class="Symbol">{</a><a id="18278" class="Argument">ℓ</a> <a id="18280" class="Symbol">=</a> <a id="18282" href="1Lab.Univalence.html#18282" class="Bound">ℓ</a><a id="18283" class="Symbol">}</a> <a id="18285" class="Symbol">=</a> <a id="18287" href="1Lab.Equiv.html#19815" data-type="(i : is-iso f) → is-equiv f" class="Function">is-iso→is-equiv</a> <a id="18303" href="1Lab.Univalence.html#18316" data-type="is-iso (λ e → lift (path→equiv e))" class="Function">morp</a> <a id="18308" class="Keyword">where</a>
  <a id="18316" href="1Lab.Univalence.html#18316" data-type="is-iso (λ e → lift (path→equiv e))" class="Function">morp</a> <a id="18321" class="Symbol">:</a> <a id="18323" href="1Lab.Equiv.html#6026" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-iso</a> <a id="18330" class="Symbol">(λ</a> <a id="18333" href="1Lab.Univalence.html#18333" class="Bound">e</a> <a id="18335" class="Symbol">→</a> <a id="18337" href="1Lab.Type.html#2075" data-type="(lower : A) → Lift ℓ A" class="InductiveConstructor">lift</a> <a id="18342" class="Symbol">{</a><a id="18343" class="Argument">ℓ</a> <a id="18345" class="Symbol">=</a> <a id="18347" href="Agda.Primitive.html#765" data-type="Level → Level" class="Primitive">lsuc</a> <a id="18352" href="1Lab.Univalence.html#18282" class="Bound">ℓ</a><a id="18353" class="Symbol">}</a> <a id="18355" class="Symbol">(</a><a id="18356" href="1Lab.Univalence.html#15486" data-type="A ≡ B₁ → A ≃ B₁" class="Function">path→equiv</a> <a id="18367" href="1Lab.Univalence.html#18333" class="Bound">e</a><a id="18368" class="Symbol">))</a>
  <a id="18373" href="1Lab.Univalence.html#18316" data-type="is-iso (λ e → lift (path→equiv e))" class="Function">morp</a> <a id="18378" class="Symbol">.</a><a id="18379" href="1Lab.Equiv.html#6132" data-type="is-iso f → B₁ → A" class="Field">is-iso.inv</a> <a id="18390" href="1Lab.Univalence.html#18390" class="Bound">x</a> <a id="18392" class="Symbol">=</a> <a id="18394" href="1Lab.Univalence.html#8818" data-type="A ≃ B₁ → A ≡ B₁" class="Function">ua</a> <a id="18397" class="Symbol">(</a><a id="18398" href="1Lab.Univalence.html#18390" class="Bound">x</a> <a id="18400" class="Symbol">.</a><a id="18401" href="1Lab.Type.html#2092" data-type="Lift ℓ A → A" class="Field">Lift.lower</a><a id="18411" class="Symbol">)</a>
  <a id="18415" href="1Lab.Univalence.html#18316" data-type="is-iso (λ e → lift (path→equiv e))" class="Function">morp</a> <a id="18420" class="Symbol">.</a><a id="18421" href="1Lab.Equiv.html#6148" data-type="(r : is-iso f) → is-right-inverse (r .inv) f" class="Field">is-iso.rinv</a> <a id="18433" href="1Lab.Univalence.html#18433" class="Bound">x</a> <a id="18435" class="Symbol">=</a>
    <a id="18441" href="1Lab.Type.html#2075" data-type="(lower : A) → Lift ℓ A" class="InductiveConstructor">lift</a> <a id="18446" class="Symbol">(</a><a id="18447" href="1Lab.Univalence.html#15486" data-type="A ≡ B₁ → A ≃ B₁" class="Function">path→equiv</a> <a id="18458" class="Symbol">(</a><a id="18459" href="1Lab.Univalence.html#8818" data-type="A ≃ B₁ → A ≡ B₁" class="Function">ua</a> <a id="18462" class="Symbol">(</a><a id="18463" href="1Lab.Univalence.html#18433" class="Bound">x</a> <a id="18465" class="Symbol">.</a><a id="18466" href="1Lab.Type.html#2092" data-type="Lift ℓ A → A" class="Field">Lift.lower</a><a id="18476" class="Symbol">)))</a> <span class="reasoning-step"><span class="as-written Function"><a id="18480" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="18483" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="18486" href="1Lab.Type.html#2075" data-type="(lower : A) → Lift ℓ A" class="InductiveConstructor">lift</a> <a id="18491" class="Symbol">(</a><a id="18492" href="1Lab.Univalence.html#16720" data-type="Iso (A ≡ B₁) (A ≃ B₁)" class="Function">Path≃Equiv</a> <a id="18503" class="Symbol">.</a><a id="18504" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="18508" class="Symbol">.</a><a id="18509" href="1Lab.Equiv.html#6148" data-type="(r : is-iso f) → is-right-inverse (r .inv) f" class="Field">is-iso.rinv</a> <a id="18521" class="Symbol">_)</a> <a id="18524" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="18530" href="1Lab.Univalence.html#18433" class="Bound">x</a>                                      <a id="18569" href="1Lab.Path.html#46945" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
  <a id="18573" href="1Lab.Univalence.html#18316" data-type="is-iso (λ e → lift (path→equiv e))" class="Function">morp</a> <a id="18578" class="Symbol">.</a><a id="18579" href="1Lab.Equiv.html#6182" data-type="(r : is-iso f) → is-left-inverse (r .inv) f" class="Field">is-iso.linv</a> <a id="18591" href="1Lab.Univalence.html#18591" class="Bound">x</a> <a id="18593" class="Symbol">=</a> <a id="18595" href="1Lab.Univalence.html#16720" data-type="Iso (A ≡ B₁) (A ≃ B₁)" class="Function">Path≃Equiv</a> <a id="18606" class="Symbol">.</a><a id="18607" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="18611" class="Symbol">.</a><a id="18612" href="1Lab.Equiv.html#6182" data-type="(r : is-iso f) → is-left-inverse (r .inv) f" class="Field">is-iso.linv</a> <a id="18624" class="Symbol">_</a>
</pre>
<h2 id="equivalence-induction"><a href="#equivalence-induction" class="header-link">Equivalence
Induction<span class="header-link-emoji">🔗</span></a></h2>
<p>One useful consequence of
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo>≡</mo><mi>B</mi><mo stretchy="false">)</mo><mo>≃</mo><mo stretchy="false">(</mo><mi>A</mi><mo>≃</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(A \equiv B) \simeq (A \simeq B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≃</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≃</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> is that the type of
<em>equivalences</em> satisfies <a href="1Lab.Path.html#J">the same
induction principle</a> as the type of <em>identifications</em>. By
analogy with how path induction can be characterised as contractibility
of singletons and transport, “equivalence induction” can be
characterised as transport and contractibility of <em>singletons up to
equivalence</em>:</p>
<pre class="Agda"><a id="Equiv-is-contr"></a><a id="19108" href="1Lab.Univalence.html#19108" data-type="(A : Type ℓ) → is-contr (Σ (_≃_ A))" class="Function">Equiv-is-contr</a> <a id="19123" class="Symbol">:</a> <a id="19125" class="Symbol">∀</a> <a id="19127" class="Symbol">{</a><a id="19128" href="1Lab.Univalence.html#19128" class="Bound">ℓ</a><a id="19129" class="Symbol">}</a> <a id="19131" class="Symbol">(</a><a id="19132" href="1Lab.Univalence.html#19132" class="Bound">A</a> <a id="19134" class="Symbol">:</a> <a id="19136" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="19141" href="1Lab.Univalence.html#19128" class="Bound">ℓ</a><a id="19142" class="Symbol">)</a> <a id="19144" class="Symbol">→</a> <a id="19146" href="1Lab.HLevel.html#1328" data-type="(A : Type ℓ) → Type ℓ" class="Record">is-contr</a> <a id="19155" class="Symbol">(</a><a id="19156" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">Σ[</a> <a id="19159" href="1Lab.Univalence.html#19159" class="Bound">B</a> <a id="19161" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">∈</a> <a id="19163" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="19168" href="1Lab.Univalence.html#19128" class="Bound">ℓ</a> <a id="19170" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">]</a> <a id="19172" href="1Lab.Univalence.html#19132" class="Bound">A</a> <a id="19174" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="19176" href="1Lab.Univalence.html#19159" class="Bound">B</a><a id="19177" class="Symbol">)</a>
<a id="19179" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">is-contr.centre</a> <a id="19195" class="Symbol">(</a><a id="19196" href="1Lab.Univalence.html#19108" data-type="(A : Type ℓ) → is-contr (Σ (_≃_ A))" class="Function">Equiv-is-contr</a> <a id="19211" href="1Lab.Univalence.html#19211" class="Bound">A</a><a id="19212" class="Symbol">)</a>            <a id="19225" class="Symbol">=</a> <a id="19227" href="1Lab.Univalence.html#19211" class="Bound">A</a> <a id="19229" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="19231" class="Symbol">_</a> <a id="19233" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="19235" href="1Lab.Equiv.html#2524" data-type="is-equiv (λ x → x)" class="Function">id-equiv</a>
<a id="19244" href="1Lab.HLevel.html#1416" data-type="(r : is-contr A) (x : A) → r .centre ≡ x" class="Field">is-contr.paths</a> <a id="19259" class="Symbol">(</a><a id="19260" href="1Lab.Univalence.html#19108" data-type="(A : Type ℓ) → is-contr (Σ (_≃_ A))" class="Function">Equiv-is-contr</a> <a id="19275" href="1Lab.Univalence.html#19275" class="Bound">A</a><a id="19276" class="Symbol">)</a> <a id="19278" class="Symbol">(</a><a id="19279" href="1Lab.Univalence.html#19279" class="Bound">B</a> <a id="19281" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="19283" href="1Lab.Univalence.html#19283" class="Bound">A≃B</a><a id="19286" class="Symbol">)</a> <a id="19288" href="1Lab.Univalence.html#19288" class="Bound">i</a> <a id="19290" class="Symbol">=</a> <a id="19292" href="1Lab.Univalence.html#8818" data-type="A ≃ B₁ → A ≡ B₁" class="Function">ua</a> <a id="19295" href="1Lab.Univalence.html#19283" class="Bound">A≃B</a> <a id="19299" href="1Lab.Univalence.html#19288" class="Bound">i</a> <a id="19301" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="19303" href="1Lab.Univalence.html#19321" data-type="(A B₁ : Type ℓ) (A≃B : A ≃ B₁) (i : I) →
PathP (λ i₁ → A → ua A≃B i₁) id (A≃B .fst)" class="Function">p</a> <a id="19305" href="1Lab.Univalence.html#19288" class="Bound">i</a> <a id="19307" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="19309" href="1Lab.Univalence.html#19440" data-type="(A B₁ : Type ℓ) (A≃B : A ≃ B₁) (i : I) →
PathP (λ i₁ → is-equiv (p A B₁ A≃B i i₁)) id-equiv (A≃B .snd)" class="Function">q</a> <a id="19311" href="1Lab.Univalence.html#19288" class="Bound">i</a> <a id="19313" class="Keyword">where</a>
  <a id="19321" href="1Lab.Univalence.html#19321" data-type="(A B₁ : Type ℓ) (A≃B : A ≃ B₁) (i : I) →
PathP (λ i₁ → A → ua A≃B i₁) id (A≃B .fst)" class="Function">p</a> <a id="19323" class="Symbol">:</a> <a id="19325" href="Agda.Primitive.Cubical.html#2013" class="Postulate">PathP</a> <a id="19331" class="Symbol">(λ</a> <a id="19334" href="1Lab.Univalence.html#19334" class="Bound">i</a> <a id="19336" class="Symbol">→</a> <a id="19338" href="1Lab.Univalence.html#19275" class="Bound">A</a> <a id="19340" class="Symbol">→</a> <a id="19342" href="1Lab.Univalence.html#8818" data-type="A ≃ B₁ → A ≡ B₁" class="Function">ua</a> <a id="19345" href="1Lab.Univalence.html#19283" class="Bound">A≃B</a> <a id="19349" href="1Lab.Univalence.html#19334" class="Bound">i</a><a id="19350" class="Symbol">)</a> <a id="19352" href="1Lab.Type.html#2424" data-type="A → A" class="Function">id</a> <a id="19355" class="Symbol">(</a><a id="19356" href="1Lab.Univalence.html#19283" class="Bound">A≃B</a> <a id="19360" class="Symbol">.</a><a id="19361" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a><a id="19364" class="Symbol">)</a>
  <a id="19368" href="1Lab.Univalence.html#19321" data-type="(A B₁ : Type ℓ) (A≃B : A ≃ B₁) (i : I) →
PathP (λ i₁ → A → ua A≃B i₁) id (A≃B .fst)" class="Function">p</a> <a id="19370" href="1Lab.Univalence.html#19370" class="Bound">i</a> <a id="19372" href="1Lab.Univalence.html#19372" class="Bound">x</a> <a id="19374" class="Symbol">=</a> <a id="19376" href="1Lab.Path.html#2100" class="Primitive">outS</a> <a id="19381" class="Symbol">(</a><a id="19382" href="1Lab.Univalence.html#13141" data-type="(e : A ≃ B₁) (i : I) (x : Partial (~ i) A)
(y : B₁ [ ~ i ↦ (λ { (i = i0) → e .fst (x _) }) ]) →
ua e i [ ~ i ∨ i ↦ (λ { (i = i0) → x _ ; (i = i1) → outS y }) ]" class="Function">ua-glue</a> <a id="19390" href="1Lab.Univalence.html#19283" class="Bound">A≃B</a> <a id="19394" href="1Lab.Univalence.html#19370" class="Bound">i</a> <a id="19396" class="Symbol">(λ</a> <a id="19399" class="Symbol">{</a> <a id="19401" class="Symbol">(</a><a id="19402" href="1Lab.Univalence.html#19370" class="Bound">i</a> <a id="19404" class="Symbol">=</a> <a id="19406" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="19408" class="Symbol">)</a> <a id="19410" class="Symbol">→</a> <a id="19412" href="1Lab.Univalence.html#19372" class="Bound">x</a> <a id="19414" class="Symbol">})</a> <a id="19417" class="Symbol">(</a><a id="19418" href="1Lab.Path.html#2069" class="Postulate">inS</a> <a id="19422" class="Symbol">(</a><a id="19423" href="1Lab.Univalence.html#19283" class="Bound">A≃B</a> <a id="19427" class="Symbol">.</a><a id="19428" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="19432" href="1Lab.Univalence.html#19372" class="Bound">x</a><a id="19433" class="Symbol">)))</a>

  <a id="19440" href="1Lab.Univalence.html#19440" data-type="(A B₁ : Type ℓ) (A≃B : A ≃ B₁) (i : I) →
PathP (λ i₁ → is-equiv (p A B₁ A≃B i i₁)) id-equiv (A≃B .snd)" class="Function">q</a> <a id="19442" class="Symbol">:</a> <a id="19444" href="Agda.Primitive.Cubical.html#2013" class="Postulate">PathP</a> <a id="19450" class="Symbol">(λ</a> <a id="19453" href="1Lab.Univalence.html#19453" class="Bound">i</a> <a id="19455" class="Symbol">→</a> <a id="19457" href="1Lab.Equiv.html#2286" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-equiv</a> <a id="19466" class="Symbol">(</a><a id="19467" href="1Lab.Univalence.html#19321" data-type="(A B₁ : Type ℓ) (A≃B : A ≃ B₁) (i : I) →
PathP (λ i₁ → A → ua A≃B i₁) id (A≃B .fst)" class="Function">p</a> <a id="19469" href="1Lab.Univalence.html#19453" class="Bound">i</a><a id="19470" class="Symbol">))</a> <a id="19473" href="1Lab.Equiv.html#2524" data-type="is-equiv (λ x → x)" class="Function">id-equiv</a> <a id="19482" class="Symbol">(</a><a id="19483" href="1Lab.Univalence.html#19283" class="Bound">A≃B</a> <a id="19487" class="Symbol">.</a><a id="19488" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a><a id="19491" class="Symbol">)</a>
  <a id="19495" href="1Lab.Univalence.html#19440" data-type="(A B₁ : Type ℓ) (A≃B : A ≃ B₁) (i : I) →
PathP (λ i₁ → is-equiv (p A B₁ A≃B i i₁)) id-equiv (A≃B .snd)" class="Function">q</a> <a id="19497" class="Symbol">=</a> <a id="19499" href="1Lab.HLevel.html#13498" data-type="((i : I) → is-prop (B₁ i)) →
(b0 : B₁ i0) (b1 : B₁ i1) → PathP B₁ b0 b1" class="Function">is-prop→pathp</a> <a id="19513" class="Symbol">(λ</a> <a id="19516" href="1Lab.Univalence.html#19516" class="Bound">i</a> <a id="19518" class="Symbol">→</a> <a id="19520" href="1Lab.Equiv.html#4916" data-type="(f : A → B₁) → is-prop (is-equiv f)" class="Function">is-equiv-is-prop</a> <a id="19537" class="Symbol">(</a><a id="19538" href="1Lab.Univalence.html#19321" data-type="(A B₁ : Type ℓ) (A≃B : A ≃ B₁) (i : I) →
PathP (λ i₁ → A → ua A≃B i₁) id (A≃B .fst)" class="Function">p</a> <a id="19540" href="1Lab.Univalence.html#19516" class="Bound">i</a><a id="19541" class="Symbol">))</a> <a id="19544" class="Symbol">_</a> <a id="19546" class="Symbol">_</a>
</pre>
<p>Combining
<span class="Agda"><a href="1Lab.Univalence.html#19108" class="Function">Equiv-is-contr</a></span>
with
<span class="Agda"><a href="1Lab.Path.html#15309" class="Function">subst</a></span>,
we get an induction principle for the type of equivalences based at
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>:</span>
To prove
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>B</mi><mo separator="true">,</mo><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(B,e)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">e</span><span class="mclose">)</span></span></span></span>
for any
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>:</mo><mi>A</mi><mo>≃</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">e : A \simeq B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≃</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>,</span>
it suffices to consider the case where
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>
is
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>
and
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span>
is the identity equivalence.</p>
<pre class="Agda"><a id="EquivJ"></a><a id="19821" href="1Lab.Univalence.html#19821" data-type="(P : (B₁ : Type ℓ) → A ≃ B₁ → Type ℓ&#39;) →
P A ((λ x → x) , id-equiv) → (e : A ≃ B₁) → P B₁ e" class="Function">EquivJ</a> <a id="19828" class="Symbol">:</a> <a id="19830" class="Symbol">∀</a> <a id="19832" class="Symbol">{</a><a id="19833" href="1Lab.Univalence.html#19833" class="Bound">ℓ</a> <a id="19835" href="1Lab.Univalence.html#19835" class="Bound">ℓ&#39;</a><a id="19837" class="Symbol">}</a> <a id="19839" class="Symbol">{</a><a id="19840" href="1Lab.Univalence.html#19840" class="Bound">A</a> <a id="19842" class="Symbol">:</a> <a id="19844" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="19849" href="1Lab.Univalence.html#19833" class="Bound">ℓ</a><a id="19850" class="Symbol">}</a>
       <a id="19859" class="Symbol">→</a> <a id="19861" class="Symbol">(</a><a id="19862" href="1Lab.Univalence.html#19862" class="Bound">P</a> <a id="19864" class="Symbol">:</a> <a id="19866" class="Symbol">(</a><a id="19867" href="1Lab.Univalence.html#19867" class="Bound">B</a> <a id="19869" class="Symbol">:</a> <a id="19871" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="19876" href="1Lab.Univalence.html#19833" class="Bound">ℓ</a><a id="19877" class="Symbol">)</a> <a id="19879" class="Symbol">→</a> <a id="19881" href="1Lab.Univalence.html#19840" class="Bound">A</a> <a id="19883" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="19885" href="1Lab.Univalence.html#19867" class="Bound">B</a> <a id="19887" class="Symbol">→</a> <a id="19889" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="19894" href="1Lab.Univalence.html#19835" class="Bound">ℓ&#39;</a><a id="19896" class="Symbol">)</a>
       <a id="19905" class="Symbol">→</a> <a id="19907" href="1Lab.Univalence.html#19862" class="Bound">P</a> <a id="19909" href="1Lab.Univalence.html#19840" class="Bound">A</a> <a id="19911" class="Symbol">(_</a> <a id="19914" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="19916" href="1Lab.Equiv.html#2524" data-type="is-equiv (λ x → x)" class="Function">id-equiv</a><a id="19924" class="Symbol">)</a>
       <a id="19933" class="Symbol">→</a> <a id="19935" class="Symbol">{</a><a id="19936" href="1Lab.Univalence.html#19936" class="Bound">B</a> <a id="19938" class="Symbol">:</a> <a id="19940" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="19945" href="1Lab.Univalence.html#19833" class="Bound">ℓ</a><a id="19946" class="Symbol">}</a> <a id="19948" class="Symbol">(</a><a id="19949" href="1Lab.Univalence.html#19949" class="Bound">e</a> <a id="19951" class="Symbol">:</a> <a id="19953" href="1Lab.Univalence.html#19840" class="Bound">A</a> <a id="19955" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="19957" href="1Lab.Univalence.html#19936" class="Bound">B</a><a id="19958" class="Symbol">)</a>
       <a id="19967" class="Symbol">→</a> <a id="19969" href="1Lab.Univalence.html#19862" class="Bound">P</a> <a id="19971" href="1Lab.Univalence.html#19936" class="Bound">B</a> <a id="19973" href="1Lab.Univalence.html#19949" class="Bound">e</a>
<a id="19975" href="1Lab.Univalence.html#19821" data-type="(P : (B₁ : Type ℓ) → A ≃ B₁ → Type ℓ&#39;) →
P A ((λ x → x) , id-equiv) → (e : A ≃ B₁) → P B₁ e" class="Function">EquivJ</a> <a id="19982" href="1Lab.Univalence.html#19982" class="Bound">P</a> <a id="19984" href="1Lab.Univalence.html#19984" class="Bound">pid</a> <a id="19988" href="1Lab.Univalence.html#19988" class="Bound">eqv</a> <a id="19992" class="Symbol">=</a>
  <a id="19996" href="1Lab.Path.html#15309" data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" class="Function">subst</a> <a id="20002" class="Symbol">(λ</a> <a id="20005" href="1Lab.Univalence.html#20005" class="Bound">e</a> <a id="20007" class="Symbol">→</a> <a id="20009" href="1Lab.Univalence.html#19982" class="Bound">P</a> <a id="20011" class="Symbol">(</a><a id="20012" href="1Lab.Univalence.html#20005" class="Bound">e</a> <a id="20014" class="Symbol">.</a><a id="20015" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a><a id="20018" class="Symbol">)</a> <a id="20020" class="Symbol">(</a><a id="20021" href="1Lab.Univalence.html#20005" class="Bound">e</a> <a id="20023" class="Symbol">.</a><a id="20024" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a><a id="20027" class="Symbol">))</a> <a id="20030" class="Symbol">(</a><a id="20031" href="1Lab.Univalence.html#19108" data-type="(A : Type ℓ) → is-contr (Σ (_≃_ A))" class="Function">Equiv-is-contr</a> <a id="20046" class="Symbol">_</a> <a id="20048" class="Symbol">.</a><a id="20049" href="1Lab.HLevel.html#1416" data-type="(r : is-contr A) (x : A) → r .centre ≡ x" class="Field">is-contr.paths</a> <a id="20064" class="Symbol">(_</a> <a id="20067" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="20069" href="1Lab.Univalence.html#19988" class="Bound">eqv</a><a id="20072" class="Symbol">))</a> <a id="20075" href="1Lab.Univalence.html#19984" class="Bound">pid</a>
</pre>
<p>Equivalence induction simplifies the proofs of many properties about
equivalences. For example, if
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>
is an equivalence, then so is its
<span class="Agda"><a href="1Lab.Path.html#20756" class="Function">action on paths</a></span>
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">p</mi></mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\id{ap}(f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">ap</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span>.</span></p>
<pre class="Agda"><a id="is-equiv→is-embedding"></a><a id="20329" href="1Lab.Univalence.html#20329" data-type="(f : A → B₁) → is-equiv f → is-equiv (ap f)" class="Function">is-equiv→is-embedding</a> <a id="20351" class="Symbol">:</a> <a id="20353" class="Symbol">∀</a> <a id="20355" class="Symbol">{</a><a id="20356" href="1Lab.Univalence.html#20356" class="Bound">ℓ</a><a id="20357" class="Symbol">}</a> <a id="20359" class="Symbol">{</a><a id="20360" href="1Lab.Univalence.html#20360" class="Bound">A</a> <a id="20362" href="1Lab.Univalence.html#20362" class="Bound">B</a> <a id="20364" class="Symbol">:</a> <a id="20366" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="20371" href="1Lab.Univalence.html#20356" class="Bound">ℓ</a><a id="20372" class="Symbol">}</a>
                      <a id="20396" class="Symbol">→</a> <a id="20398" class="Symbol">(</a><a id="20399" href="1Lab.Univalence.html#20399" class="Bound">f</a> <a id="20401" class="Symbol">:</a> <a id="20403" href="1Lab.Univalence.html#20360" class="Bound">A</a> <a id="20405" class="Symbol">→</a> <a id="20407" href="1Lab.Univalence.html#20362" class="Bound">B</a><a id="20408" class="Symbol">)</a> <a id="20410" class="Symbol">→</a> <a id="20412" href="1Lab.Equiv.html#2286" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-equiv</a> <a id="20421" href="1Lab.Univalence.html#20399" class="Bound">f</a>
                      <a id="20445" class="Symbol">→</a> <a id="20447" class="Symbol">{</a><a id="20448" href="1Lab.Univalence.html#20448" class="Bound">x</a> <a id="20450" href="1Lab.Univalence.html#20450" class="Bound">y</a> <a id="20452" class="Symbol">:</a> <a id="20454" href="1Lab.Univalence.html#20360" class="Bound">A</a><a id="20455" class="Symbol">}</a>
                      <a id="20479" class="Symbol">→</a> <a id="20481" href="1Lab.Equiv.html#2286" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-equiv</a> <a id="20490" class="Symbol">(</a><a id="20491" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="20494" href="1Lab.Univalence.html#20399" class="Bound">f</a> <a id="20496" class="Symbol">{</a><a id="20497" class="Argument">x</a> <a id="20499" class="Symbol">=</a> <a id="20501" href="1Lab.Univalence.html#20448" class="Bound">x</a><a id="20502" class="Symbol">}</a> <a id="20504" class="Symbol">{</a><a id="20505" class="Argument">y</a> <a id="20507" class="Symbol">=</a> <a id="20509" href="1Lab.Univalence.html#20450" class="Bound">y</a><a id="20510" class="Symbol">})</a>
<a id="20513" href="1Lab.Univalence.html#20329" data-type="(f : A → B₁) → is-equiv f → is-equiv (ap f)" class="Function">is-equiv→is-embedding</a> <a id="20535" href="1Lab.Univalence.html#20535" class="Bound">f</a> <a id="20537" href="1Lab.Univalence.html#20537" class="Bound">eqv</a> <a id="20541" class="Symbol">=</a>
  <a id="20545" href="1Lab.Univalence.html#19821" data-type="(P : (B₁ : Type ℓ) → A ≃ B₁ → Type ℓ&#39;) →
P A ((λ x → x) , id-equiv) → (e : A ≃ B₁) → P B₁ e" class="Function">EquivJ</a> <a id="20552" class="Symbol">(λ</a> <a id="20555" href="1Lab.Univalence.html#20555" class="Bound">B</a> <a id="20557" href="1Lab.Univalence.html#20557" class="Bound">e</a> <a id="20559" class="Symbol">→</a> <a id="20561" href="1Lab.Equiv.html#2286" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-equiv</a> <a id="20570" class="Symbol">(</a><a id="20571" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="20574" class="Symbol">(</a><a id="20575" href="1Lab.Univalence.html#20557" class="Bound">e</a> <a id="20577" class="Symbol">.</a><a id="20578" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a><a id="20581" class="Symbol">)))</a> <a id="20585" href="1Lab.Equiv.html#2524" data-type="is-equiv (λ x → x)" class="Function">id-equiv</a> <a id="20594" class="Symbol">(</a><a id="20595" href="1Lab.Univalence.html#20535" class="Bound">f</a> <a id="20597" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="20599" href="1Lab.Univalence.html#20537" class="Bound">eqv</a><a id="20602" class="Symbol">)</a>
</pre>
<p>The proof can be rendered in English roughly as follows:</p>
<blockquote>
<p>Suppose
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">f : A \to B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>
<span class="Agda"><a href="1Lab.Equiv.html#2286" class="Record">is an equivalence</a></span>.
We want to show that, for any choice of
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">x, y : A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>,</span>
the map
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">p</mi></mrow><mo stretchy="false">(</mo><mi>f</mi><msub><mo stretchy="false">)</mo><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow></msub><mo>:</mo><mi>x</mi><mo>≡</mo><mi>y</mi><mo>→</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>≡</mo><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\id{ap}(f)_{x,y} : x \equiv y \to f(x) \equiv f(y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathrm">ap</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4637em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>
is an equivalence.</p>
<p>By
<span class="Agda"><a href="1Lab.Univalence.html#19821" class="Function">induction</a></span>,
it suffices to cover the case where
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>
is
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>,</span>
and
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>
is the identity function.</p>
<p>But then, we have that
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">p</mi></mrow><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi></mrow><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\id{ap}(\id{id})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">ap</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">id</span></span><span class="mclose">)</span></span></span></span>
is <a href="1Lab.Path.html#ap-id">definitionally equal</a> to
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi></mrow><annotation encoding="application/x-tex">\id{id}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">id</span></span></span></span></span>,</span>
which is known to be
<span class="Agda"><a href="1Lab.Equiv.html#2524" class="Function">an equivalence</a></span>.
<span class="qed"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">■</mi></mrow><annotation encoding="application/x-tex">\blacksquare</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.675em;"></span><span class="mord amsrm">■</span></span></span></span></span></p>
</blockquote>
<h2 id="object-classifiers"><a href="#object-classifiers" class="header-link">Object
Classifiers<span class="header-link-emoji">🔗</span></a></h2>
<p>In category theory, the idea of <em>classifiers</em> (or
<em>classifying objects</em>) often comes up when categories applied to
the study of logic. For example, any <a href="https://ncatlab.org/nlab/show/topos#ElementaryTopos">elementary
topos</a> has a <em><a href="https://ncatlab.org/nlab/show/subobject+classifier">subobject
classifier</a></em>: an object
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Ω</mi></mrow><annotation encoding="application/x-tex">\Omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Ω</span></span></span></span>
such that maps
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>→</mo><mi mathvariant="normal">Ω</mi></mrow><annotation encoding="application/x-tex">B \to \Omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Ω</span></span></span></span>
corresponds to maps
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \to B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>
with propositional fibres (equivalently, inclusions
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>↪</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \hookrightarrow B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6943em;vertical-align:-0.011em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↪</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>).</span>
In higher categorical analyses of logic, classifying objects exist for
more maps: an elementary <strong>2</strong>-topos has a <a href="https://ncatlab.org/nlab/show/discrete+object+classifier">discrete
object classifier</a>, which classify maps with <em>discrete</em>
fibres.</p>
<p>Since a
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>-topos</span>
has classifiers for maps with
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>-truncated</span>
fibres, and a
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(2,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>-topos</span>
has classifiers for maps with
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>-truncated</span>
fibres, one might expect that an <a href="https://ncatlab.org/nlab/show/(infinity,1)-topos"><span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">∞</mi><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\io</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">∞</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>-topos</span></a>
would have classifiers for maps with fibres that are not truncated at
all. This is indeed the case! In HoTT, this fact is internalised using
the univalent universes, and we can prove that univalent universes are
<a href="https://ncatlab.org/nlab/show/object+classifier"><em>object
classifiers</em></a>.</p>
<!--
<pre class="Agda"><a id="22576" class="Keyword">private</a> <a id="22584" class="Keyword">variable</a>
  <a id="22595" href="1Lab.Univalence.html#22595" class="Generalizable">A</a> <a id="22597" href="1Lab.Univalence.html#22597" class="Generalizable">B</a> <a id="22599" href="1Lab.Univalence.html#22599" class="Generalizable">E</a> <a id="22601" class="Symbol">:</a> <a id="22603" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="22608" href="1Lab.Univalence.html#2867" class="Generalizable">ℓ</a>
<a id="22610" class="Keyword">open</a> <a id="22615" href="1Lab.Equiv.html#6026" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Module">is-iso</a>
</pre>-->
<p>As an intermediate step, we prove that the value
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">B(a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mclose">)</span></span></span></span>
of a type family
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>
at a point
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span>
is equivalent to the fibre of
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">f</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">t</mi></mrow><mo>:</mo><msub><mi mathvariant="normal">Σ</mi><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy="false">)</mo></mrow></msub><mi>B</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\id{fst} : \Sigma_{(x : A)}B(x) \to A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">fst</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3552em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">x</span><span class="mrel mtight">:</span><span class="mord mathnormal mtight">A</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>
over
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span>.</span>
The proof follows from the De Morgan structure on the interval, and the
“spread” operation
<span class="Agda"><a href="1Lab.Path.html#51798" class="Function">coe1→i</a></span>.</p>
<pre class="Agda"><a id="22920" class="Comment">-- HoTT book lemma 4.8.1</a>
<a id="Fibre-equiv"></a><a id="22945" href="1Lab.Univalence.html#22945" data-type="(B₁ : A → Type ℓ&#39;) (a : A) → fibre fst a ≃ B₁ a" class="Function">Fibre-equiv</a> <a id="22957" class="Symbol">:</a> <a id="22959" class="Symbol">(</a><a id="22960" href="1Lab.Univalence.html#22960" class="Bound">B</a> <a id="22962" class="Symbol">:</a> <a id="22964" href="1Lab.Univalence.html#22595" class="Generalizable">A</a> <a id="22966" class="Symbol">→</a> <a id="22968" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="22973" href="1Lab.Univalence.html#2869" class="Generalizable">ℓ&#39;</a><a id="22975" class="Symbol">)</a> <a id="22977" class="Symbol">(</a><a id="22978" href="1Lab.Univalence.html#22978" class="Bound">a</a> <a id="22980" class="Symbol">:</a> <a id="22982" href="1Lab.Univalence.html#22595" class="Generalizable">A</a><a id="22983" class="Symbol">)</a>
            <a id="22997" class="Symbol">→</a> <a id="22999" href="1Lab.Equiv.html#1873" data-type="(A → B₁) → B₁ → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Function">fibre</a> <a id="23005" class="Symbol">(</a><a id="23006" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="23010" class="Symbol">{</a><a id="23011" class="Argument">B</a> <a id="23013" class="Symbol">=</a> <a id="23015" href="1Lab.Univalence.html#22960" class="Bound">B</a><a id="23016" class="Symbol">})</a> <a id="23019" href="1Lab.Univalence.html#22978" class="Bound">a</a> <a id="23021" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="23023" href="1Lab.Univalence.html#22960" class="Bound">B</a> <a id="23025" href="1Lab.Univalence.html#22978" class="Bound">a</a>
<a id="23027" href="1Lab.Univalence.html#22945" data-type="(B₁ : A → Type ℓ&#39;) (a : A) → fibre fst a ≃ B₁ a" class="Function">Fibre-equiv</a> <a id="23039" href="1Lab.Univalence.html#23039" class="Bound">B</a> <a id="23041" href="1Lab.Univalence.html#23041" class="Bound">a</a> <a id="23043" class="Symbol">=</a> <a id="23045" href="1Lab.Equiv.html#20161" data-type="Iso A B₁ → A ≃ B₁" class="Function">Iso→Equiv</a> <a id="23055" href="1Lab.Univalence.html#23068" data-type="(B₁ : A → Type ℓ&#39;) (a : A) → Iso (fibre fst a) (B₁ a)" class="Function">isom</a> <a id="23060" class="Keyword">where</a>
  <a id="23068" href="1Lab.Univalence.html#23068" data-type="(B₁ : A → Type ℓ&#39;) (a : A) → Iso (fibre fst a) (B₁ a)" class="Function">isom</a> <a id="23073" class="Symbol">:</a> <a id="23075" href="1Lab.Equiv.html#6298" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function">Iso</a> <a id="23079" class="Symbol">_</a> <a id="23081" class="Symbol">_</a>
  <a id="23085" href="1Lab.Univalence.html#23068" data-type="(B₁ : A → Type ℓ&#39;) (a : A) → Iso (fibre fst a) (B₁ a)" class="Function">isom</a> <a id="23090" class="Symbol">.</a><a id="23091" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="23095" class="Symbol">((</a><a id="23097" href="1Lab.Univalence.html#23097" class="Bound">x</a> <a id="23099" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="23101" href="1Lab.Univalence.html#23101" class="Bound">y</a><a id="23102" class="Symbol">)</a> <a id="23104" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="23106" href="1Lab.Univalence.html#23106" class="Bound">p</a><a id="23107" class="Symbol">)</a> <a id="23109" class="Symbol">=</a> <a id="23111" href="1Lab.Path.html#15309" data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" class="Function">subst</a> <a id="23117" href="1Lab.Univalence.html#23039" class="Bound">B</a> <a id="23119" href="1Lab.Univalence.html#23106" class="Bound">p</a> <a id="23121" href="1Lab.Univalence.html#23101" class="Bound">y</a>
  <a id="23125" href="1Lab.Univalence.html#23068" data-type="(B₁ : A → Type ℓ&#39;) (a : A) → Iso (fibre fst a) (B₁ a)" class="Function">isom</a> <a id="23130" class="Symbol">.</a><a id="23131" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="23135" class="Symbol">.</a><a id="23136" href="1Lab.Equiv.html#6132" data-type="is-iso f → B₁ → A" class="Field">inv</a> <a id="23140" href="1Lab.Univalence.html#23140" class="Bound">x</a>        <a id="23149" class="Symbol">=</a> <a id="23151" class="Symbol">(</a><a id="23152" href="1Lab.Univalence.html#23041" class="Bound">a</a> <a id="23154" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="23156" href="1Lab.Univalence.html#23140" class="Bound">x</a><a id="23157" class="Symbol">)</a> <a id="23159" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="23161" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
  <a id="23168" href="1Lab.Univalence.html#23068" data-type="(B₁ : A → Type ℓ&#39;) (a : A) → Iso (fibre fst a) (B₁ a)" class="Function">isom</a> <a id="23173" class="Symbol">.</a><a id="23174" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="23178" class="Symbol">.</a><a id="23179" href="1Lab.Equiv.html#6148" data-type="(r : is-iso f) → is-right-inverse (r .inv) f" class="Field">rinv</a> <a id="23184" href="1Lab.Univalence.html#23184" class="Bound">x</a> <a id="23186" href="1Lab.Univalence.html#23186" class="Bound">i</a>     <a id="23192" class="Symbol">=</a> <a id="23194" href="1Lab.Path.html#51798" data-type="(A : (i : I) → Type (ℓ i)) (i : I) → A i1 → A i" class="Function">coe1→i</a> <a id="23201" class="Symbol">(λ</a> <a id="23204" href="1Lab.Univalence.html#23204" class="Bound">_</a> <a id="23206" class="Symbol">→</a> <a id="23208" href="1Lab.Univalence.html#23039" class="Bound">B</a> <a id="23210" href="1Lab.Univalence.html#23041" class="Bound">a</a><a id="23211" class="Symbol">)</a> <a id="23213" href="1Lab.Univalence.html#23186" class="Bound">i</a> <a id="23215" href="1Lab.Univalence.html#23184" class="Bound">x</a>
  <a id="23219" href="1Lab.Univalence.html#23068" data-type="(B₁ : A → Type ℓ&#39;) (a : A) → Iso (fibre fst a) (B₁ a)" class="Function">isom</a> <a id="23224" class="Symbol">.</a><a id="23225" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="23229" class="Symbol">.</a><a id="23230" href="1Lab.Equiv.html#6182" data-type="(r : is-iso f) → is-left-inverse (r .inv) f" class="Field">linv</a> <a id="23235" class="Symbol">((</a><a id="23237" href="1Lab.Univalence.html#23237" class="Bound">x</a> <a id="23239" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="23241" href="1Lab.Univalence.html#23241" class="Bound">y</a><a id="23242" class="Symbol">)</a> <a id="23244" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="23246" href="1Lab.Univalence.html#23246" class="Bound">p</a><a id="23247" class="Symbol">)</a> <a id="23249" href="1Lab.Univalence.html#23249" class="Bound">i</a> <a id="23251" class="Symbol">=</a>
    <a id="23257" class="Symbol">(</a><a id="23258" href="1Lab.Univalence.html#23246" class="Bound">p</a> <a id="23260" class="Symbol">(</a><a id="23261" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="23263" href="1Lab.Univalence.html#23249" class="Bound">i</a><a id="23264" class="Symbol">)</a> <a id="23266" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="23268" href="1Lab.Path.html#51798" data-type="(A : (i : I) → Type (ℓ i)) (i : I) → A i1 → A i" class="Function">coe1→i</a> <a id="23275" class="Symbol">(λ</a> <a id="23278" href="1Lab.Univalence.html#23278" class="Bound">j</a> <a id="23280" class="Symbol">→</a> <a id="23282" href="1Lab.Univalence.html#23039" class="Bound">B</a> <a id="23284" class="Symbol">(</a><a id="23285" href="1Lab.Univalence.html#23246" class="Bound">p</a> <a id="23287" class="Symbol">(</a><a id="23288" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="23290" href="1Lab.Univalence.html#23249" class="Bound">i</a> <a id="23292" href="1Lab.Path.html#2191" class="Primitive Operator">∧</a> <a id="23294" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="23296" href="1Lab.Univalence.html#23278" class="Bound">j</a><a id="23297" class="Symbol">)))</a> <a id="23301" href="1Lab.Univalence.html#23249" class="Bound">i</a> <a id="23303" href="1Lab.Univalence.html#23241" class="Bound">y</a><a id="23304" class="Symbol">)</a> <a id="23306" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="23308" class="Symbol">λ</a> <a id="23310" href="1Lab.Univalence.html#23310" class="Bound">j</a> <a id="23312" class="Symbol">→</a> <a id="23314" href="1Lab.Univalence.html#23246" class="Bound">p</a> <a id="23316" class="Symbol">(</a><a id="23317" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="23319" href="1Lab.Univalence.html#23249" class="Bound">i</a> <a id="23321" href="1Lab.Path.html#2226" class="Primitive Operator">∨</a> <a id="23323" href="1Lab.Univalence.html#23310" class="Bound">j</a><a id="23324" class="Symbol">)</a>
</pre>
<p>Another fact from homotopy theory that we can import into homotopy
<em>type</em> theory is that any map is equivalent to a fibration. More
specifically, given a map
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>:</mo><mi>E</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">p : E \to B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>,</span>
the total space
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span>
is equivalent to the dependent sum of the fibres. The theorems
<span class="Agda"><a href="1Lab.Univalence.html#23719" class="Function">Total-equiv</a></span>
and
<span class="Agda"><a href="1Lab.Univalence.html#22945" class="Function">Fibre-equiv</a></span>
are what justify referring to
<span class="Agda"><a href="1Lab.Type.html#1573" class="Function">Σ</a></span>
the “total space” of a type family.</p>
<pre class="Agda"><a id="Total-equiv"></a><a id="23719" href="1Lab.Univalence.html#23719" data-type="(p : E → B₁) → E ≃ Σ (fibre p)" class="Function">Total-equiv</a> <a id="23731" class="Symbol">:</a> <a id="23733" class="Symbol">(</a><a id="23734" href="1Lab.Univalence.html#23734" class="Bound">p</a> <a id="23736" class="Symbol">:</a> <a id="23738" href="1Lab.Univalence.html#22599" class="Generalizable">E</a> <a id="23740" class="Symbol">→</a> <a id="23742" href="1Lab.Univalence.html#22597" class="Generalizable">B</a><a id="23743" class="Symbol">)</a> <a id="23745" class="Symbol">→</a> <a id="23747" href="1Lab.Univalence.html#22599" class="Generalizable">E</a> <a id="23749" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="23751" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">Σ</a> <a id="23753" class="Symbol">(</a><a id="23754" href="1Lab.Equiv.html#1873" data-type="(A → B₁) → B₁ → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Function">fibre</a> <a id="23760" href="1Lab.Univalence.html#23734" class="Bound">p</a><a id="23761" class="Symbol">)</a>
<a id="23763" href="1Lab.Univalence.html#23719" data-type="(p : E → B₁) → E ≃ Σ (fibre p)" class="Function">Total-equiv</a> <a id="23775" href="1Lab.Univalence.html#23775" class="Bound">p</a> <a id="23777" class="Symbol">=</a> <a id="23779" href="1Lab.Equiv.html#20161" data-type="Iso A B₁ → A ≃ B₁" class="Function">Iso→Equiv</a> <a id="23789" href="1Lab.Univalence.html#23802" data-type="(p : E → B₁) → Iso E (Σ (fibre p))" class="Function">isom</a> <a id="23794" class="Keyword">where</a>
  <a id="23802" href="1Lab.Univalence.html#23802" data-type="(p : E → B₁) → Iso E (Σ (fibre p))" class="Function">isom</a> <a id="23807" class="Symbol">:</a> <a id="23809" href="1Lab.Equiv.html#6298" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function">Iso</a> <a id="23813" class="Symbol">_</a> <a id="23815" class="Symbol">(</a><a id="23816" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">Σ</a> <a id="23818" class="Symbol">(</a><a id="23819" href="1Lab.Equiv.html#1873" data-type="(A → B₁) → B₁ → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Function">fibre</a> <a id="23825" href="1Lab.Univalence.html#23775" class="Bound">p</a><a id="23826" class="Symbol">))</a>
  <a id="23831" href="1Lab.Univalence.html#23802" data-type="(p : E → B₁) → Iso E (Σ (fibre p))" class="Function">isom</a> <a id="23836" class="Symbol">.</a><a id="23837" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="23841" href="1Lab.Univalence.html#23841" class="Bound">x</a>                   <a id="23861" class="Symbol">=</a> <a id="23863" href="1Lab.Univalence.html#23775" class="Bound">p</a> <a id="23865" href="1Lab.Univalence.html#23841" class="Bound">x</a> <a id="23867" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="23869" href="1Lab.Univalence.html#23841" class="Bound">x</a> <a id="23871" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="23873" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
  <a id="23880" href="1Lab.Univalence.html#23802" data-type="(p : E → B₁) → Iso E (Σ (fibre p))" class="Function">isom</a> <a id="23885" class="Symbol">.</a><a id="23886" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="23890" class="Symbol">.</a><a id="23891" href="1Lab.Equiv.html#6132" data-type="is-iso f → B₁ → A" class="Field">inv</a> <a id="23895" class="Symbol">(_</a> <a id="23898" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="23900" href="1Lab.Univalence.html#23900" class="Bound">x</a> <a id="23902" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="23904" class="Symbol">_)</a>    <a id="23910" class="Symbol">=</a> <a id="23912" href="1Lab.Univalence.html#23900" class="Bound">x</a>
  <a id="23916" href="1Lab.Univalence.html#23802" data-type="(p : E → B₁) → Iso E (Σ (fibre p))" class="Function">isom</a> <a id="23921" class="Symbol">.</a><a id="23922" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="23926" class="Symbol">.</a><a id="23927" href="1Lab.Equiv.html#6148" data-type="(r : is-iso f) → is-right-inverse (r .inv) f" class="Field">rinv</a> <a id="23932" class="Symbol">(</a><a id="23933" href="1Lab.Univalence.html#23933" class="Bound">b</a> <a id="23935" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="23937" href="1Lab.Univalence.html#23937" class="Bound">x</a> <a id="23939" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="23941" href="1Lab.Univalence.html#23941" class="Bound">q</a><a id="23942" class="Symbol">)</a> <a id="23944" href="1Lab.Univalence.html#23944" class="Bound">i</a> <a id="23946" class="Symbol">=</a> <a id="23948" href="1Lab.Univalence.html#23941" class="Bound">q</a> <a id="23950" href="1Lab.Univalence.html#23944" class="Bound">i</a> <a id="23952" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="23954" href="1Lab.Univalence.html#23937" class="Bound">x</a> <a id="23956" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="23958" class="Symbol">λ</a> <a id="23960" href="1Lab.Univalence.html#23960" class="Bound">j</a> <a id="23962" class="Symbol">→</a> <a id="23964" href="1Lab.Univalence.html#23941" class="Bound">q</a> <a id="23966" class="Symbol">(</a><a id="23967" href="1Lab.Univalence.html#23944" class="Bound">i</a> <a id="23969" href="1Lab.Path.html#2191" class="Primitive Operator">∧</a> <a id="23971" href="1Lab.Univalence.html#23960" class="Bound">j</a><a id="23972" class="Symbol">)</a>
  <a id="23976" href="1Lab.Univalence.html#23802" data-type="(p : E → B₁) → Iso E (Σ (fibre p))" class="Function">isom</a> <a id="23981" class="Symbol">.</a><a id="23982" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="23986" class="Symbol">.</a><a id="23987" href="1Lab.Equiv.html#6182" data-type="(r : is-iso f) → is-left-inverse (r .inv) f" class="Field">linv</a> <a id="23992" href="1Lab.Univalence.html#23992" class="Bound">x</a>             <a id="24006" class="Symbol">=</a> <a id="24008" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
</pre>
<p>Putting these together, we get the promised theorem: The space of
maps
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>→</mo><mrow><mi mathvariant="normal">T</mi><mi mathvariant="normal">y</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">e</mi></mrow></mrow><annotation encoding="application/x-tex">B \to \ty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathrm">Type</span></span></span></span></span>
is equivalent to the space of fibrations with base space
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>
and variable total space
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span>,</span>
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Σ</mi><mrow><mo stretchy="false">(</mo><mi>E</mi><mo>:</mo><mrow><mi mathvariant="normal">T</mi><mi mathvariant="normal">y</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">e</mi></mrow><mo stretchy="false">)</mo></mrow></msub><mo stretchy="false">(</mo><mi>E</mi><mo>→</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Sigma_{(E : \ty)} (E \to B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3552em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">E</span><span class="mrel mtight">:</span><span class="mord mtight"><span class="mord mathrm mtight">Type</span></span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span>.</span>
If we allow
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span>
and
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>
to live in different universes, then the maps are classified by the
biggest universe in which they both fit, namely
<code>Type (ℓ ⊔ ℓ&#39;)</code>. Note that the proof of
<span class="Agda"><a href="1Lab.Univalence.html#24644" class="Function">Fibration-equiv</a></span>
makes fundamental use of
<span class="Agda"><a href="1Lab.Univalence.html#8818" class="Function">ua</a></span>,
to construct the witnesses that taking fibres and taking total spaces
are inverses. Without
<span class="Agda"><a href="1Lab.Univalence.html#8818" class="Function">ua</a></span>,
we could only get an “isomorphism-up-to-equivalence” of types.</p>
<pre class="Agda"><a id="Fibration-equiv"></a><a id="24644" href="1Lab.Univalence.html#24644" data-type="Σ (λ E → E → B₁) ≃ (B₁ → Type (ℓ ⊔ ℓ&#39;))" class="Function">Fibration-equiv</a> <a id="24660" class="Symbol">:</a> <a id="24662" class="Symbol">∀</a> <a id="24664" class="Symbol">{</a><a id="24665" href="1Lab.Univalence.html#24665" class="Bound">ℓ</a> <a id="24667" href="1Lab.Univalence.html#24667" class="Bound">ℓ&#39;</a><a id="24669" class="Symbol">}</a> <a id="24671" class="Symbol">{</a><a id="24672" href="1Lab.Univalence.html#24672" class="Bound">B</a> <a id="24674" class="Symbol">:</a> <a id="24676" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="24681" href="1Lab.Univalence.html#24665" class="Bound">ℓ</a><a id="24682" class="Symbol">}</a>
                <a id="24700" class="Symbol">→</a> <a id="24702" class="Symbol">(</a><a id="24703" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">Σ[</a> <a id="24706" href="1Lab.Univalence.html#24706" class="Bound">E</a> <a id="24708" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">∈</a> <a id="24710" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="24715" class="Symbol">(</a><a id="24716" href="1Lab.Univalence.html#24665" class="Bound">ℓ</a> <a id="24718" href="Agda.Primitive.html#795" data-type="Level → Level → Level" class="Primitive Operator">⊔</a> <a id="24720" href="1Lab.Univalence.html#24667" class="Bound">ℓ&#39;</a><a id="24722" class="Symbol">)</a> <a id="24724" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">]</a> <a id="24726" class="Symbol">(</a><a id="24727" href="1Lab.Univalence.html#24706" class="Bound">E</a> <a id="24729" class="Symbol">→</a> <a id="24731" href="1Lab.Univalence.html#24672" class="Bound">B</a><a id="24732" class="Symbol">))</a>
                <a id="24751" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="24753" class="Symbol">(</a><a id="24754" href="1Lab.Univalence.html#24672" class="Bound">B</a> <a id="24756" class="Symbol">→</a> <a id="24758" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="24763" class="Symbol">(</a><a id="24764" href="1Lab.Univalence.html#24665" class="Bound">ℓ</a> <a id="24766" href="Agda.Primitive.html#795" data-type="Level → Level → Level" class="Primitive Operator">⊔</a> <a id="24768" href="1Lab.Univalence.html#24667" class="Bound">ℓ&#39;</a><a id="24770" class="Symbol">))</a>
<a id="24773" href="1Lab.Univalence.html#24644" data-type="Σ (λ E → E → B₁) ≃ (B₁ → Type (ℓ ⊔ ℓ&#39;))" class="Function">Fibration-equiv</a> <a id="24789" class="Symbol">{</a><a id="24790" class="Argument">B</a> <a id="24792" class="Symbol">=</a> <a id="24794" href="1Lab.Univalence.html#24794" class="Bound">B</a><a id="24795" class="Symbol">}</a> <a id="24797" class="Symbol">=</a> <a id="24799" href="1Lab.Equiv.html#20161" data-type="Iso A B₁ → A ≃ B₁" class="Function">Iso→Equiv</a> <a id="24809" href="1Lab.Univalence.html#24822" data-type="Iso (Σ (λ E → E → B₁)) (B₁ → Type (ℓ ⊔ ℓ&#39;))" class="Function">isom</a> <a id="24814" class="Keyword">where</a>
  <a id="24822" href="1Lab.Univalence.html#24822" data-type="Iso (Σ (λ E → E → B₁)) (B₁ → Type (ℓ ⊔ ℓ&#39;))" class="Function">isom</a> <a id="24827" class="Symbol">:</a> <a id="24829" href="1Lab.Equiv.html#6298" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function">Iso</a> <a id="24833" class="Symbol">(</a><a id="24834" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">Σ[</a> <a id="24837" href="1Lab.Univalence.html#24837" class="Bound">E</a> <a id="24839" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">∈</a> <a id="24841" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="24846" class="Symbol">_</a> <a id="24848" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">]</a> <a id="24850" class="Symbol">(</a><a id="24851" href="1Lab.Univalence.html#24837" class="Bound">E</a> <a id="24853" class="Symbol">→</a> <a id="24855" href="1Lab.Univalence.html#24794" class="Bound">B</a><a id="24856" class="Symbol">))</a> <a id="24859" class="Symbol">(</a><a id="24860" href="1Lab.Univalence.html#24794" class="Bound">B</a> <a id="24862" class="Symbol">→</a> <a id="24864" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="24869" class="Symbol">_)</a>
  <a id="24874" href="1Lab.Univalence.html#24822" data-type="Iso (Σ (λ E → E → B₁)) (B₁ → Type (ℓ ⊔ ℓ&#39;))" class="Function">isom</a> <a id="24879" class="Symbol">.</a><a id="24880" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="24884" class="Symbol">(</a><a id="24885" href="1Lab.Univalence.html#24885" class="Bound">E</a> <a id="24887" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="24889" href="1Lab.Univalence.html#24889" class="Bound">p</a><a id="24890" class="Symbol">)</a>       <a id="24898" class="Symbol">=</a> <a id="24900" href="1Lab.Equiv.html#1873" data-type="(A → B₁) → B₁ → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Function">fibre</a> <a id="24906" href="1Lab.Univalence.html#24889" class="Bound">p</a>
  <a id="24910" href="1Lab.Univalence.html#24822" data-type="Iso (Σ (λ E → E → B₁)) (B₁ → Type (ℓ ⊔ ℓ&#39;))" class="Function">isom</a> <a id="24915" class="Symbol">.</a><a id="24916" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="24920" class="Symbol">.</a><a id="24921" href="1Lab.Equiv.html#6132" data-type="is-iso f → B₁ → A" class="Field">inv</a> <a id="24925" href="1Lab.Univalence.html#24925" class="Bound">p⁻¹</a>      <a id="24934" class="Symbol">=</a> <a id="24936" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">Σ</a> <a id="24938" href="1Lab.Univalence.html#24925" class="Bound">p⁻¹</a> <a id="24942" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="24944" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a>
  <a id="24950" href="1Lab.Univalence.html#24822" data-type="Iso (Σ (λ E → E → B₁)) (B₁ → Type (ℓ ⊔ ℓ&#39;))" class="Function">isom</a> <a id="24955" class="Symbol">.</a><a id="24956" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="24960" class="Symbol">.</a><a id="24961" href="1Lab.Equiv.html#6148" data-type="(r : is-iso f) → is-right-inverse (r .inv) f" class="Field">rinv</a> <a id="24966" href="1Lab.Univalence.html#24966" class="Bound">prep</a> <a id="24971" href="1Lab.Univalence.html#24971" class="Bound">i</a> <a id="24973" href="1Lab.Univalence.html#24973" class="Bound">x</a> <a id="24975" class="Symbol">=</a> <a id="24977" href="1Lab.Univalence.html#8818" data-type="A ≃ B₁ → A ≡ B₁" class="Function">ua</a> <a id="24980" class="Symbol">(</a><a id="24981" href="1Lab.Univalence.html#22945" data-type="(B₁ : A → Type ℓ&#39;) (a : A) → fibre fst a ≃ B₁ a" class="Function">Fibre-equiv</a> <a id="24993" href="1Lab.Univalence.html#24966" class="Bound">prep</a> <a id="24998" href="1Lab.Univalence.html#24973" class="Bound">x</a><a id="24999" class="Symbol">)</a> <a id="25001" href="1Lab.Univalence.html#24971" class="Bound">i</a>
  <a id="25005" href="1Lab.Univalence.html#24822" data-type="Iso (Σ (λ E → E → B₁)) (B₁ → Type (ℓ ⊔ ℓ&#39;))" class="Function">isom</a> <a id="25010" class="Symbol">.</a><a id="25011" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="25015" class="Symbol">.</a><a id="25016" href="1Lab.Equiv.html#6182" data-type="(r : is-iso f) → is-left-inverse (r .inv) f" class="Field">linv</a> <a id="25021" class="Symbol">(</a><a id="25022" href="1Lab.Univalence.html#25022" class="Bound">E</a> <a id="25024" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="25026" href="1Lab.Univalence.html#25026" class="Bound">p</a><a id="25027" class="Symbol">)</a> <a id="25029" href="1Lab.Univalence.html#25029" class="Bound">i</a>
    <a id="25035" class="Symbol">=</a> <a id="25037" href="1Lab.Univalence.html#8818" data-type="A ≃ B₁ → A ≡ B₁" class="Function">ua</a> <a id="25040" href="1Lab.Univalence.html#25099" data-type="(E : Type (ℓ ⊔ ℓ&#39;)) (p : E → B₁) (i : I) → E ≃ Σ (fibre p)" class="Function">e</a> <a id="25042" class="Symbol">(</a><a id="25043" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="25045" href="1Lab.Univalence.html#25029" class="Bound">i</a><a id="25046" class="Symbol">)</a> <a id="25048" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="25050" class="Symbol">λ</a> <a id="25052" href="1Lab.Univalence.html#25052" class="Bound">x</a> <a id="25054" class="Symbol">→</a> <a id="25056" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="25060" class="Symbol">(</a><a id="25061" href="1Lab.Path.html#2100" class="Primitive">outS</a> <a id="25066" class="Symbol">(</a><a id="25067" href="1Lab.Univalence.html#12067" data-type="(e : A ≃ B₁) (i : I) (x : ua e i) →
B₁ [ ~ i ∨ i ↦ (λ { (i = i0) → e .fst x ; (i = i1) → x }) ]" class="Function">ua-unglue</a> <a id="25077" href="1Lab.Univalence.html#25099" data-type="(E : Type (ℓ ⊔ ℓ&#39;)) (p : E → B₁) (i : I) → E ≃ Σ (fibre p)" class="Function">e</a> <a id="25079" class="Symbol">(</a><a id="25080" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="25082" href="1Lab.Univalence.html#25029" class="Bound">i</a><a id="25083" class="Symbol">)</a> <a id="25085" href="1Lab.Univalence.html#25052" class="Bound">x</a><a id="25086" class="Symbol">))</a>
    <a id="25093" class="Keyword">where</a> <a id="25099" href="1Lab.Univalence.html#25099" data-type="(E : Type (ℓ ⊔ ℓ&#39;)) (p : E → B₁) (i : I) → E ≃ Σ (fibre p)" class="Function">e</a> <a id="25101" class="Symbol">=</a> <a id="25103" href="1Lab.Univalence.html#23719" data-type="(p : E → B₁) → E ≃ Σ (fibre p)" class="Function">Total-equiv</a> <a id="25115" href="1Lab.Univalence.html#25026" class="Bound">p</a>
</pre>
<p>To solidify the explanation that object classifiers generalise the
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n-2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span>-truncated</span>
object classifiers you would find in a
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>-topos,</span>
we prove that any class of maps described by a property
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>
which holds of all of its fibres (or even <em>structure</em> on all of
its fibres!) has a classifying object — the total space
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">\Sigma P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>.</span></p>
<p>For instance, if we take
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>
to be the property of
<span class="Agda"><a href="1Lab.HLevel.html#2597" class="Function">being a proposition</a></span>,
this theorem tells us that <code>Σ is-prop</code> classifies
<em>subobjects</em>. With the slight caveat that <code>Σ is-prop</code>
is not closed under impredicative quantification, this corresponds
exactly to the notion of subobject classifier in a
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>-topos,</span>
since the maps with propositional fibres are precisely the injective
maps.</p>
<!--
<pre class="Agda"><a id="25873" href="1Lab.Univalence.html#25873" class="Function">_</a> <a id="25875" class="Symbol">=</a> <a id="25877" href="1Lab.HLevel.html#2597" data-type="Type ℓ → Type ℓ" class="Function">is-prop</a>
</pre>-->
<p>Since the type of “maps into B with variable domain and P fibres” has
a very unwieldy description — both in words or in Agda syntax — we
abbreviate it by
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">ℓ</mi><msub><mi mathvariant="normal">/</mi><mrow><mo stretchy="false">[</mo><mi>P</mi><mo stretchy="false">]</mo></mrow></msub><mi>B</mi></mrow><annotation encoding="application/x-tex">\ell /_{[P]} B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3552em;"></span><span class="mord">ℓ</span><span class="mord"><span class="mord">/</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">[</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span><span class="mclose mtight">]</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>.</span>
The notation is meant to evoke the idea of a slice category: The objects
of
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi mathvariant="normal">/</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">C/c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord">/</span><span class="mord mathnormal">c</span></span></span></span>
are objects of the category
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>
equipped with choices of maps into
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span>.</span>
Similarly, the objects of
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">ℓ</mi><msub><mi mathvariant="normal">/</mi><mrow><mo stretchy="false">[</mo><mi>P</mi><mo stretchy="false">]</mo></mrow></msub><mi>B</mi></mrow><annotation encoding="application/x-tex">\ell/_{[P]}B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3552em;"></span><span class="mord">ℓ</span><span class="mord"><span class="mord">/</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">[</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span><span class="mclose mtight">]</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>
are objects of the universe
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">T</mi><mi mathvariant="normal">y</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">e</mi></mrow><mtext> </mtext><mi mathvariant="normal">ℓ</mi></mrow><annotation encoding="application/x-tex">\ty\
\ell</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathrm">Type</span></span><span class="mspace"> </span><span class="mord">ℓ</span></span></span></span>,</span>
with a choice of map
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>
into
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>,</span>
such that
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>
holds for all the fibres of
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>.</span></p>
<pre class="Agda"><a id="_/[_]_"></a><a id="26397" href="1Lab.Univalence.html#26397" data-type="(ℓ : Level) →
(Type (ℓ&#39; ⊔ ℓ) → Type ℓ&#39;&#39;) →
Type ℓ&#39; → Type (lsuc ℓ&#39; ⊔ ℓ&#39;&#39; ⊔ lsuc ℓ)" class="Function Operator">_/[_]_</a> <a id="26404" class="Symbol">:</a> <a id="26406" class="Symbol">∀</a> <a id="26408" class="Symbol">{</a><a id="26409" href="1Lab.Univalence.html#26409" class="Bound">ℓ&#39;</a> <a id="26412" href="1Lab.Univalence.html#26412" class="Bound">ℓ&#39;&#39;</a><a id="26415" class="Symbol">}</a> <a id="26417" class="Symbol">(</a><a id="26418" href="1Lab.Univalence.html#26418" class="Bound">ℓ</a> <a id="26420" class="Symbol">:</a> <a id="26422" href="Agda.Primitive.html#582" data-type="Type" class="Postulate">Level</a><a id="26427" class="Symbol">)</a> <a id="26429" class="Symbol">→</a> <a id="26431" class="Symbol">(</a><a id="26432" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="26437" class="Symbol">(</a><a id="26438" href="1Lab.Univalence.html#26418" class="Bound">ℓ</a> <a id="26440" href="Agda.Primitive.html#795" data-type="Level → Level → Level" class="Primitive Operator">⊔</a> <a id="26442" href="1Lab.Univalence.html#26409" class="Bound">ℓ&#39;</a><a id="26444" class="Symbol">)</a> <a id="26446" class="Symbol">→</a> <a id="26448" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="26453" href="1Lab.Univalence.html#26412" class="Bound">ℓ&#39;&#39;</a><a id="26456" class="Symbol">)</a> <a id="26458" class="Symbol">→</a> <a id="26460" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="26465" href="1Lab.Univalence.html#26409" class="Bound">ℓ&#39;</a> <a id="26468" class="Symbol">→</a> <a id="26470" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="26475" class="Symbol">_</a>
<a id="26477" href="1Lab.Univalence.html#26397" data-type="(ℓ : Level) →
(Type (ℓ&#39; ⊔ ℓ) → Type ℓ&#39;&#39;) →
Type ℓ&#39; → Type (lsuc ℓ&#39; ⊔ ℓ&#39;&#39; ⊔ lsuc ℓ)" class="Function Operator">_/[_]_</a> <a id="26484" class="Symbol">{</a><a id="26485" href="1Lab.Univalence.html#26485" class="Bound">ℓ</a><a id="26486" class="Symbol">}</a> <a id="26488" href="1Lab.Univalence.html#26488" class="Bound">ℓ&#39;</a> <a id="26491" href="1Lab.Univalence.html#26491" class="Bound">P</a> <a id="26493" href="1Lab.Univalence.html#26493" class="Bound">B</a> <a id="26495" class="Symbol">=</a>
  <a id="26499" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">Σ</a> <a id="26501" class="Symbol">λ</a> <a id="26503" class="Symbol">(</a><a id="26504" href="1Lab.Univalence.html#26504" class="Bound">A</a> <a id="26506" class="Symbol">:</a> <a id="26508" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="26513" class="Symbol">(</a><a id="26514" href="1Lab.Univalence.html#26485" class="Bound">ℓ</a> <a id="26516" href="Agda.Primitive.html#795" data-type="Level → Level → Level" class="Primitive Operator">⊔</a> <a id="26518" href="1Lab.Univalence.html#26488" class="Bound">ℓ&#39;</a><a id="26520" class="Symbol">))</a> <a id="26523" class="Symbol">→</a>
  <a id="26527" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">Σ</a> <a id="26529" class="Symbol">λ</a> <a id="26531" class="Symbol">(</a><a id="26532" href="1Lab.Univalence.html#26532" class="Bound">f</a> <a id="26534" class="Symbol">:</a> <a id="26536" href="1Lab.Univalence.html#26504" class="Bound">A</a> <a id="26538" class="Symbol">→</a> <a id="26540" href="1Lab.Univalence.html#26493" class="Bound">B</a><a id="26541" class="Symbol">)</a> <a id="26543" class="Symbol">→</a>
  <a id="26547" class="Symbol">(</a><a id="26548" href="1Lab.Univalence.html#26548" class="Bound">x</a> <a id="26550" class="Symbol">:</a> <a id="26552" href="1Lab.Univalence.html#26493" class="Bound">B</a><a id="26553" class="Symbol">)</a> <a id="26555" class="Symbol">→</a> <a id="26557" href="1Lab.Univalence.html#26491" class="Bound">P</a> <a id="26559" class="Symbol">(</a><a id="26560" href="1Lab.Equiv.html#1873" data-type="(A → B₁) → B₁ → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Function">fibre</a> <a id="26566" href="1Lab.Univalence.html#26532" class="Bound">f</a> <a id="26568" href="1Lab.Univalence.html#26548" class="Bound">x</a><a id="26569" class="Symbol">)</a>
</pre>
<p>The proof that the slice
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">ℓ</mi><msub><mi mathvariant="normal">/</mi><mrow><mo stretchy="false">[</mo><mi>P</mi><mo stretchy="false">]</mo></mrow></msub><mi>B</mi></mrow><annotation encoding="application/x-tex">\ell /_{[P]} B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3552em;"></span><span class="mord">ℓ</span><span class="mord"><span class="mord">/</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">[</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span><span class="mclose mtight">]</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>
is classified by
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">\Sigma P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>
follows from elementary properties of
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span></span></span></span>
types (namely:
<span class="Agda"><a href="1Lab.Type.Sigma.html#4067" class="Function">reassociation</a></span>,
<span class="Agda"><a href="1Lab.Type.Sigma.html#4446" class="Function">distributivity</a></span>
of
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span></span></span></span>
over
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Π</mi></mrow><annotation encoding="application/x-tex">\Pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Π</span></span></span></span>),</span>
and the classification theorem
<span class="Agda"><a href="1Lab.Univalence.html#24644" class="Function">Fibration-equiv</a></span>.
Really, the most complicated part of this proof is rearranging the
nested sum and product types to a form to which we can apply
<span class="Agda"><a href="1Lab.Univalence.html#24644" class="Function">Fibration-equiv</a></span>.</p>
<pre class="Agda"><a id="Map-classifier"></a><a id="27033" href="1Lab.Univalence.html#27033" data-type="(P : Type (ℓ ⊔ ℓ&#39;) → Type ℓ&#39;&#39;) → (ℓ /[ P ] B₁) ≃ (B₁ → Σ P)" class="Function">Map-classifier</a>
  <a id="27050" class="Symbol">:</a> <a id="27052" class="Symbol">∀</a> <a id="27054" class="Symbol">{</a><a id="27055" href="1Lab.Univalence.html#27055" class="Bound">ℓ</a> <a id="27057" href="1Lab.Univalence.html#27057" class="Bound">ℓ&#39;</a> <a id="27060" href="1Lab.Univalence.html#27060" class="Bound">ℓ&#39;&#39;</a><a id="27063" class="Symbol">}</a> <a id="27065" class="Symbol">{</a><a id="27066" href="1Lab.Univalence.html#27066" class="Bound">B</a> <a id="27068" class="Symbol">:</a> <a id="27070" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="27075" href="1Lab.Univalence.html#27057" class="Bound">ℓ&#39;</a><a id="27077" class="Symbol">}</a> <a id="27079" class="Symbol">(</a><a id="27080" href="1Lab.Univalence.html#27080" class="Bound">P</a> <a id="27082" class="Symbol">:</a> <a id="27084" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="27089" class="Symbol">(</a><a id="27090" href="1Lab.Univalence.html#27055" class="Bound">ℓ</a> <a id="27092" href="Agda.Primitive.html#795" data-type="Level → Level → Level" class="Primitive Operator">⊔</a> <a id="27094" href="1Lab.Univalence.html#27057" class="Bound">ℓ&#39;</a><a id="27096" class="Symbol">)</a> <a id="27098" class="Symbol">→</a> <a id="27100" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="27105" href="1Lab.Univalence.html#27060" class="Bound">ℓ&#39;&#39;</a><a id="27108" class="Symbol">)</a>
  <a id="27112" class="Symbol">→</a> <a id="27114" class="Symbol">(</a><a id="27115" href="1Lab.Univalence.html#27055" class="Bound">ℓ</a> <a id="27117" href="1Lab.Univalence.html#26397" data-type="(ℓ : Level) →
(Type (ℓ&#39; ⊔ ℓ) → Type ℓ&#39;&#39;) →
Type ℓ&#39; → Type (lsuc ℓ&#39; ⊔ ℓ&#39;&#39; ⊔ lsuc ℓ)" class="Function Operator">/[</a> <a id="27120" href="1Lab.Univalence.html#27080" class="Bound">P</a> <a id="27122" href="1Lab.Univalence.html#26397" data-type="(ℓ : Level) →
(Type (ℓ&#39; ⊔ ℓ) → Type ℓ&#39;&#39;) →
Type ℓ&#39; → Type (lsuc ℓ&#39; ⊔ ℓ&#39;&#39; ⊔ lsuc ℓ)" class="Function Operator">]</a> <a id="27124" href="1Lab.Univalence.html#27066" class="Bound">B</a><a id="27125" class="Symbol">)</a> <a id="27127" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="27129" class="Symbol">(</a><a id="27130" href="1Lab.Univalence.html#27066" class="Bound">B</a> <a id="27132" class="Symbol">→</a> <a id="27134" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">Σ</a> <a id="27136" href="1Lab.Univalence.html#27080" class="Bound">P</a><a id="27137" class="Symbol">)</a>
<a id="27139" href="1Lab.Univalence.html#27033" data-type="(P : Type (ℓ ⊔ ℓ&#39;) → Type ℓ&#39;&#39;) → (ℓ /[ P ] B₁) ≃ (B₁ → Σ P)" class="Function">Map-classifier</a> <a id="27154" class="Symbol">{</a><a id="27155" class="Argument">ℓ</a> <a id="27157" class="Symbol">=</a> <a id="27159" href="1Lab.Univalence.html#27159" class="Bound">ℓ</a><a id="27160" class="Symbol">}</a> <a id="27162" class="Symbol">{</a><a id="27163" class="Argument">B</a> <a id="27165" class="Symbol">=</a> <a id="27167" href="1Lab.Univalence.html#27167" class="Bound">B</a><a id="27168" class="Symbol">}</a> <a id="27170" href="1Lab.Univalence.html#27170" class="Bound">P</a> <a id="27172" class="Symbol">=</a>
  <a id="27176" class="Symbol">(</a><a id="27177" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">Σ</a> <a id="27179" class="Symbol">λ</a> <a id="27181" href="1Lab.Univalence.html#27181" class="Bound">A</a> <a id="27183" class="Symbol">→</a> <a id="27185" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">Σ</a> <a id="27187" class="Symbol">λ</a> <a id="27189" href="1Lab.Univalence.html#27189" class="Bound">f</a> <a id="27191" class="Symbol">→</a> <a id="27193" class="Symbol">(</a><a id="27194" href="1Lab.Univalence.html#27194" class="Bound">x</a> <a id="27196" class="Symbol">:</a> <a id="27198" href="1Lab.Univalence.html#27167" class="Bound">B</a><a id="27199" class="Symbol">)</a> <a id="27201" class="Symbol">→</a> <a id="27203" href="1Lab.Univalence.html#27170" class="Bound">P</a> <a id="27205" class="Symbol">(</a><a id="27206" href="1Lab.Equiv.html#1873" data-type="(A → B₁) → B₁ → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Function">fibre</a> <a id="27212" href="1Lab.Univalence.html#27189" class="Bound">f</a> <a id="27214" href="1Lab.Univalence.html#27194" class="Bound">x</a><a id="27215" class="Symbol">))</a>     <span class="reasoning-step"><span class="as-written Function Operator"><a id="27222" href="1Lab.Equiv.html#22981" data-type="(A : Type ℓ) → A ≃ B₁ → B₁ ≃ C → A ≃ C" class="Function Operator">≃⟨</a> <a id="27225" href="1Lab.Type.Sigma.html#4067" data-type="Σ (λ x → Σ (C x)) ≃ Σ (λ x → C (x .fst) (x .snd))" class="Function">Σ-assoc</a> <a id="27233" href="1Lab.Equiv.html#22981" data-type="(A : Type ℓ) → A ≃ B₁ → B₁ ≃ C → A ≃ C" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span>
  <a id="27237" class="Symbol">(</a><a id="27238" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">Σ</a> <a id="27240" class="Symbol">λ</a> <a id="27242" class="Symbol">{</a> <a id="27244" class="Symbol">(</a><a id="27245" href="1Lab.Univalence.html#27245" class="Bound">x</a> <a id="27247" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="27249" href="1Lab.Univalence.html#27249" class="Bound">f</a><a id="27250" class="Symbol">)</a> <a id="27252" class="Symbol">→</a> <a id="27254" class="Symbol">(</a><a id="27255" href="1Lab.Univalence.html#27255" class="Bound">x</a> <a id="27257" class="Symbol">:</a> <a id="27259" href="1Lab.Univalence.html#27167" class="Bound">B</a><a id="27260" class="Symbol">)</a> <a id="27262" class="Symbol">→</a> <a id="27264" href="1Lab.Univalence.html#27170" class="Bound">P</a> <a id="27266" class="Symbol">(</a><a id="27267" href="1Lab.Equiv.html#1873" data-type="(A → B₁) → B₁ → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Function">fibre</a> <a id="27273" href="1Lab.Univalence.html#27249" class="Bound">f</a> <a id="27275" href="1Lab.Univalence.html#27255" class="Bound">x</a><a id="27276" class="Symbol">)</a> <a id="27278" class="Symbol">})</a>   <span class="reasoning-step"><span class="as-written Function Operator"><a id="27283" href="1Lab.Equiv.html#22981" data-type="(A : Type ℓ) → A ≃ B₁ → B₁ ≃ C → A ≃ C" class="Function Operator">≃⟨</a> <a id="27286" href="1Lab.Type.Sigma.html#2065" data-type="(e : A ≃ A&#39;) → Σ (B₁ ⊙ e .fst) ≃ Σ B₁" class="Function">Σ-ap-fst</a> <a id="27295" class="Symbol">(</a><a id="27296" href="1Lab.Univalence.html#24644" data-type="Σ (λ E → E → B₁) ≃ (B₁ → Type (ℓ ⊔ ℓ&#39;))" class="Function">Fibration-equiv</a> <a id="27312" class="Symbol">{</a><a id="27313" class="Argument">ℓ&#39;</a> <a id="27316" class="Symbol">=</a> <a id="27318" href="1Lab.Univalence.html#27159" class="Bound">ℓ</a><a id="27319" class="Symbol">})</a> <a id="27322" href="1Lab.Equiv.html#22981" data-type="(A : Type ℓ) → A ≃ B₁ → B₁ ≃ C → A ≃ C" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span>
  <a id="27326" class="Symbol">(</a><a id="27327" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">Σ</a> <a id="27329" class="Symbol">λ</a> <a id="27331" href="1Lab.Univalence.html#27331" class="Bound">A</a> <a id="27333" class="Symbol">→</a> <a id="27335" class="Symbol">(</a><a id="27336" href="1Lab.Univalence.html#27336" class="Bound">x</a> <a id="27338" class="Symbol">:</a> <a id="27340" href="1Lab.Univalence.html#27167" class="Bound">B</a><a id="27341" class="Symbol">)</a> <a id="27343" class="Symbol">→</a> <a id="27345" href="1Lab.Univalence.html#27170" class="Bound">P</a> <a id="27347" class="Symbol">(</a><a id="27348" href="1Lab.Univalence.html#27331" class="Bound">A</a> <a id="27350" href="1Lab.Univalence.html#27336" class="Bound">x</a><a id="27351" class="Symbol">))</a>                   <span class="reasoning-step"><span class="as-written Function Operator"><a id="27372" href="1Lab.Equiv.html#22981" data-type="(A : Type ℓ) → A ≃ B₁ → B₁ ≃ C → A ≃ C" class="Function Operator">≃⟨</a> <a id="27375" href="1Lab.Type.Sigma.html#4446" data-type="((x : A) → Σ (C x)) ≃ Σ (λ f → (x : A) → C x (f x))" class="Function">Σ-Π-distrib</a> <a id="27387" href="1Lab.Equiv.html#21355" data-type="A ≃ B₁ → B₁ ≃ A" class="Function Operator">e⁻¹</a> <a id="27391" href="1Lab.Equiv.html#22981" data-type="(A : Type ℓ) → A ≃ B₁ → B₁ ≃ C → A ≃ C" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span>
  <a id="27395" class="Symbol">(</a><a id="27396" href="1Lab.Univalence.html#27167" class="Bound">B</a> <a id="27398" class="Symbol">→</a> <a id="27400" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">Σ</a> <a id="27402" href="1Lab.Univalence.html#27170" class="Bound">P</a><a id="27403" class="Symbol">)</a>                                     <a id="27441" href="1Lab.Equiv.html#23172" data-type="(A : Type ℓ) → A ≃ A" class="Function Operator">≃∎</a>
</pre>
<!--
<pre class="Agda"><a id="ua∙"></a><a id="27462" href="1Lab.Univalence.html#27462" data-type="ua (f ∙e g) ≡ ua f ∙ ua g" class="Function">ua∙</a> <a id="27466" class="Symbol">:</a> <a id="27468" class="Symbol">∀</a> <a id="27470" class="Symbol">{</a><a id="27471" href="1Lab.Univalence.html#27471" class="Bound">A</a> <a id="27473" href="1Lab.Univalence.html#27473" class="Bound">B</a> <a id="27475" href="1Lab.Univalence.html#27475" class="Bound">C</a> <a id="27477" class="Symbol">:</a> <a id="27479" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="27484" href="1Lab.Univalence.html#2867" class="Generalizable">ℓ</a><a id="27485" class="Symbol">}</a> <a id="27487" class="Symbol">{</a><a id="27488" href="1Lab.Univalence.html#27488" class="Bound">f</a> <a id="27490" class="Symbol">:</a> <a id="27492" href="1Lab.Univalence.html#27471" class="Bound">A</a> <a id="27494" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="27496" href="1Lab.Univalence.html#27473" class="Bound">B</a><a id="27497" class="Symbol">}</a> <a id="27499" class="Symbol">{</a><a id="27500" href="1Lab.Univalence.html#27500" class="Bound">g</a> <a id="27502" class="Symbol">:</a> <a id="27504" href="1Lab.Univalence.html#27473" class="Bound">B</a> <a id="27506" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="27508" href="1Lab.Univalence.html#27475" class="Bound">C</a><a id="27509" class="Symbol">}</a>
    <a id="27515" class="Symbol">→</a> <a id="27517" href="1Lab.Univalence.html#8818" data-type="A ≃ B₁ → A ≡ B₁" class="Function">ua</a> <a id="27520" class="Symbol">(</a><a id="27521" href="1Lab.Univalence.html#27488" class="Bound">f</a> <a id="27523" href="1Lab.Equiv.html#21265" data-type="A ≃ B₁ → B₁ ≃ C → A ≃ C" class="Function Operator">∙e</a> <a id="27526" href="1Lab.Univalence.html#27500" class="Bound">g</a><a id="27527" class="Symbol">)</a> <a id="27529" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="27531" href="1Lab.Univalence.html#8818" data-type="A ≃ B₁ → A ≡ B₁" class="Function">ua</a> <a id="27534" href="1Lab.Univalence.html#27488" class="Bound">f</a> <a id="27536" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="27538" href="1Lab.Univalence.html#8818" data-type="A ≃ B₁ → A ≡ B₁" class="Function">ua</a> <a id="27541" href="1Lab.Univalence.html#27500" class="Bound">g</a>
<a id="27543" href="1Lab.Univalence.html#27462" data-type="ua (f ∙e g) ≡ ua f ∙ ua g" class="Function">ua∙</a> <a id="27547" class="Symbol">{</a><a id="27548" class="Argument">C</a> <a id="27550" class="Symbol">=</a> <a id="27552" href="1Lab.Univalence.html#27552" class="Bound">C</a><a id="27553" class="Symbol">}</a> <a id="27555" class="Symbol">{</a><a id="27556" class="Argument">f</a> <a id="27558" class="Symbol">=</a> <a id="27560" href="1Lab.Univalence.html#27560" class="Bound">f</a><a id="27561" class="Symbol">}</a> <a id="27563" class="Symbol">{</a><a id="27564" href="1Lab.Univalence.html#27564" class="Bound">g</a><a id="27565" class="Symbol">}</a> <a id="27567" class="Symbol">=</a>
  <a id="27571" href="1Lab.Univalence.html#19821" data-type="(P : (B₁ : Type ℓ) → A ≃ B₁ → Type ℓ&#39;) →
P A ((λ x → x) , id-equiv) → (e : A ≃ B₁) → P B₁ e" class="Function">EquivJ</a>
    <a id="27582" class="Symbol">(λ</a> <a id="27585" href="1Lab.Univalence.html#27585" class="Bound">B</a> <a id="27587" href="1Lab.Univalence.html#27587" class="Bound">eq</a> <a id="27590" class="Symbol">→</a> <a id="27592" class="Symbol">(</a><a id="27593" href="1Lab.Univalence.html#27593" class="Bound">g</a> <a id="27595" class="Symbol">:</a> <a id="27597" href="1Lab.Univalence.html#27585" class="Bound">B</a> <a id="27599" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="27601" href="1Lab.Univalence.html#27552" class="Bound">C</a><a id="27602" class="Symbol">)</a> <a id="27604" class="Symbol">→</a> <a id="27606" href="1Lab.Univalence.html#8818" data-type="A ≃ B₁ → A ≡ B₁" class="Function">ua</a> <a id="27609" class="Symbol">(</a><a id="27610" href="1Lab.Univalence.html#27587" class="Bound">eq</a> <a id="27613" href="1Lab.Equiv.html#21265" data-type="A ≃ B₁ → B₁ ≃ C → A ≃ C" class="Function Operator">∙e</a> <a id="27616" href="1Lab.Univalence.html#27593" class="Bound">g</a><a id="27617" class="Symbol">)</a> <a id="27619" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="27621" href="1Lab.Univalence.html#8818" data-type="A ≃ B₁ → A ≡ B₁" class="Function">ua</a> <a id="27624" href="1Lab.Univalence.html#27587" class="Bound">eq</a> <a id="27627" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="27629" href="1Lab.Univalence.html#8818" data-type="A ≃ B₁ → A ≡ B₁" class="Function">ua</a> <a id="27632" href="1Lab.Univalence.html#27593" class="Bound">g</a><a id="27633" class="Symbol">)</a>
    <a id="27639" class="Symbol">(λ</a> <a id="27642" href="1Lab.Univalence.html#27642" class="Bound">g</a> <a id="27644" class="Symbol">→</a> <a id="27646" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="27649" href="1Lab.Univalence.html#8818" data-type="A ≃ B₁ → A ≡ B₁" class="Function">ua</a> <a id="27652" class="Symbol">(</a><a id="27653" href="1Lab.Type.Sigma.html#5139" data-type="((x : A) → is-prop (B₁ x)) → x .fst ≡ y .fst → x ≡ y" class="Function">Σ-prop-path</a> <a id="27665" href="1Lab.Equiv.html#4916" data-type="(f : A → B₁) → is-prop (is-equiv f)" class="Function">is-equiv-is-prop</a> <a id="27682" class="Symbol">(</a><a id="27683" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="27688" class="Symbol">{</a><a id="27689" class="Argument">x</a> <a id="27691" class="Symbol">=</a> <a id="27693" href="1Lab.Univalence.html#27642" class="Bound">g</a> <a id="27695" class="Symbol">.</a><a id="27696" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a><a id="27699" class="Symbol">}))</a>
        <a id="27711" href="1Lab.Path.html#38293" data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" class="Function Operator">··</a> <a id="27714" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="27718" class="Symbol">(</a><a id="27719" href="1Lab.Path.Groupoid.html#4623" data-type="(p : x ≡ y) → refl ∙ p ≡ p" class="Function">∙-id-l</a> <a id="27726" class="Symbol">(</a><a id="27727" href="1Lab.Univalence.html#8818" data-type="A ≃ B₁ → A ≡ B₁" class="Function">ua</a> <a id="27730" href="1Lab.Univalence.html#27642" class="Bound">g</a><a id="27731" class="Symbol">))</a>
        <a id="27742" href="1Lab.Path.html#38293" data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" class="Function Operator">··</a> <a id="27745" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="27749" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">_∙_</a> <a id="27753" class="Symbol">(</a><a id="27754" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="27758" href="1Lab.Univalence.html#16267" data-type="ua ((λ x → x) , id-equiv) ≡ refl" class="Function">ua-id-equiv</a><a id="27769" class="Symbol">)</a> <a id="27771" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a><a id="27775" class="Symbol">)</a>
    <a id="27781" href="1Lab.Univalence.html#27560" class="Bound">f</a> <a id="27783" href="1Lab.Univalence.html#27564" class="Bound">g</a>

<a id="ua→"></a><a id="27786" href="1Lab.Univalence.html#27786" data-type="((a : A₀) → PathP B₁ (f₀ a) (f₁ (e .fst a))) →
PathP (λ i → ua e i → B₁ i) f₀ f₁" class="Function">ua→</a> <a id="27790" class="Symbol">:</a> <a id="27792" class="Symbol">∀</a> <a id="27794" class="Symbol">{</a><a id="27795" href="1Lab.Univalence.html#27795" class="Bound">ℓ</a> <a id="27797" href="1Lab.Univalence.html#27797" class="Bound">ℓ&#39;</a><a id="27799" class="Symbol">}</a> <a id="27801" class="Symbol">{</a><a id="27802" href="1Lab.Univalence.html#27802" class="Bound">A₀</a> <a id="27805" href="1Lab.Univalence.html#27805" class="Bound">A₁</a> <a id="27808" class="Symbol">:</a> <a id="27810" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="27815" href="1Lab.Univalence.html#27795" class="Bound">ℓ</a><a id="27816" class="Symbol">}</a> <a id="27818" class="Symbol">{</a><a id="27819" href="1Lab.Univalence.html#27819" class="Bound">e</a> <a id="27821" class="Symbol">:</a> <a id="27823" href="1Lab.Univalence.html#27802" class="Bound">A₀</a> <a id="27826" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="27828" href="1Lab.Univalence.html#27805" class="Bound">A₁</a><a id="27830" class="Symbol">}</a> <a id="27832" class="Symbol">{</a><a id="27833" href="1Lab.Univalence.html#27833" class="Bound">B</a> <a id="27835" class="Symbol">:</a> <a id="27837" class="Symbol">(</a><a id="27838" href="1Lab.Univalence.html#27838" class="Bound">i</a> <a id="27840" class="Symbol">:</a> <a id="27842" href="Agda.Primitive.Cubical.html#150" class="Datatype">I</a><a id="27843" class="Symbol">)</a> <a id="27845" class="Symbol">→</a> <a id="27847" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="27852" href="1Lab.Univalence.html#27797" class="Bound">ℓ&#39;</a><a id="27854" class="Symbol">}</a>
  <a id="27858" class="Symbol">{</a><a id="27859" href="1Lab.Univalence.html#27859" class="Bound">f₀</a> <a id="27862" class="Symbol">:</a> <a id="27864" href="1Lab.Univalence.html#27802" class="Bound">A₀</a> <a id="27867" class="Symbol">→</a> <a id="27869" href="1Lab.Univalence.html#27833" class="Bound">B</a> <a id="27871" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="27873" class="Symbol">}</a> <a id="27875" class="Symbol">{</a><a id="27876" href="1Lab.Univalence.html#27876" class="Bound">f₁</a> <a id="27879" class="Symbol">:</a> <a id="27881" href="1Lab.Univalence.html#27805" class="Bound">A₁</a> <a id="27884" class="Symbol">→</a> <a id="27886" href="1Lab.Univalence.html#27833" class="Bound">B</a> <a id="27888" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="27890" class="Symbol">}</a>
  <a id="27894" class="Symbol">→</a> <a id="27896" class="Symbol">((</a><a id="27898" href="1Lab.Univalence.html#27898" class="Bound">a</a> <a id="27900" class="Symbol">:</a> <a id="27902" href="1Lab.Univalence.html#27802" class="Bound">A₀</a><a id="27904" class="Symbol">)</a> <a id="27906" class="Symbol">→</a> <a id="27908" href="Agda.Primitive.Cubical.html#2013" class="Postulate">PathP</a> <a id="27914" href="1Lab.Univalence.html#27833" class="Bound">B</a> <a id="27916" class="Symbol">(</a><a id="27917" href="1Lab.Univalence.html#27859" class="Bound">f₀</a> <a id="27920" href="1Lab.Univalence.html#27898" class="Bound">a</a><a id="27921" class="Symbol">)</a> <a id="27923" class="Symbol">(</a><a id="27924" href="1Lab.Univalence.html#27876" class="Bound">f₁</a> <a id="27927" class="Symbol">(</a><a id="27928" href="1Lab.Univalence.html#27819" class="Bound">e</a> <a id="27930" class="Symbol">.</a><a id="27931" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="27935" href="1Lab.Univalence.html#27898" class="Bound">a</a><a id="27936" class="Symbol">)))</a>
  <a id="27942" class="Symbol">→</a> <a id="27944" href="Agda.Primitive.Cubical.html#2013" class="Postulate">PathP</a> <a id="27950" class="Symbol">(λ</a> <a id="27953" href="1Lab.Univalence.html#27953" class="Bound">i</a> <a id="27955" class="Symbol">→</a> <a id="27957" href="1Lab.Univalence.html#8818" data-type="A ≃ B₁ → A ≡ B₁" class="Function">ua</a> <a id="27960" href="1Lab.Univalence.html#27819" class="Bound">e</a> <a id="27962" href="1Lab.Univalence.html#27953" class="Bound">i</a> <a id="27964" class="Symbol">→</a> <a id="27966" href="1Lab.Univalence.html#27833" class="Bound">B</a> <a id="27968" href="1Lab.Univalence.html#27953" class="Bound">i</a><a id="27969" class="Symbol">)</a> <a id="27971" href="1Lab.Univalence.html#27859" class="Bound">f₀</a> <a id="27974" href="1Lab.Univalence.html#27876" class="Bound">f₁</a>
<a id="27977" href="1Lab.Univalence.html#27786" data-type="((a : A₀) → PathP B₁ (f₀ a) (f₁ (e .fst a))) →
PathP (λ i → ua e i → B₁ i) f₀ f₁" class="Function">ua→</a> <a id="27981" class="Symbol">{</a><a id="27982" class="Argument">e</a> <a id="27984" class="Symbol">=</a> <a id="27986" href="1Lab.Univalence.html#27986" class="Bound">e</a><a id="27987" class="Symbol">}</a> <a id="27989" class="Symbol">{</a><a id="27990" class="Argument">f₀</a> <a id="27993" class="Symbol">=</a> <a id="27995" href="1Lab.Univalence.html#27995" class="Bound">f₀</a><a id="27997" class="Symbol">}</a> <a id="27999" class="Symbol">{</a><a id="28000" href="1Lab.Univalence.html#28000" class="Bound">f₁</a><a id="28002" class="Symbol">}</a> <a id="28004" href="1Lab.Univalence.html#28004" class="Bound">h</a> <a id="28006" href="1Lab.Univalence.html#28006" class="Bound">i</a> <a id="28008" href="1Lab.Univalence.html#28008" class="Bound">a</a> <a id="28010" class="Symbol">=</a>
  <a id="28014" href="1Lab.Path.html#2368" class="Primitive">hcomp</a>
    <a id="28024" class="Symbol">(λ</a> <a id="28027" href="1Lab.Univalence.html#28027" class="Bound">j</a> <a id="28029" class="Symbol">→</a> <a id="28031" class="Symbol">λ</a>
      <a id="28039" class="Symbol">{</a> <a id="28041" class="Symbol">(</a><a id="28042" href="1Lab.Univalence.html#28006" class="Bound">i</a> <a id="28044" class="Symbol">=</a> <a id="28046" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="28048" class="Symbol">)</a> <a id="28050" class="Symbol">→</a> <a id="28052" href="1Lab.Univalence.html#27995" class="Bound">f₀</a> <a id="28055" href="1Lab.Univalence.html#28008" class="Bound">a</a>
      <a id="28063" class="Symbol">;</a> <a id="28065" class="Symbol">(</a><a id="28066" href="1Lab.Univalence.html#28006" class="Bound">i</a> <a id="28068" class="Symbol">=</a> <a id="28070" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="28072" class="Symbol">)</a> <a id="28074" class="Symbol">→</a> <a id="28076" href="1Lab.Univalence.html#28000" class="Bound">f₁</a> <a id="28079" class="Symbol">(</a><a id="28080" href="1Lab.Univalence.html#28158" data-type="((a : A₀) → PathP B₁ (f₀ a) (f₁ (e .fst a))) →
(i : I) →
ua e i → (a₁ : A₁) → e .fst (transport (sym (ua e)) a₁) ≡ a₁" class="Function">lem</a> <a id="28084" href="1Lab.Univalence.html#28008" class="Bound">a</a> <a id="28086" href="1Lab.Univalence.html#28027" class="Bound">j</a><a id="28087" class="Symbol">)</a>
      <a id="28095" class="Symbol">})</a>
    <a id="28102" class="Symbol">(</a><a id="28103" href="1Lab.Univalence.html#28004" class="Bound">h</a> <a id="28105" class="Symbol">(</a><a id="28106" href="1Lab.Path.html#2405" class="Primitive">transp</a> <a id="28113" class="Symbol">(λ</a> <a id="28116" href="1Lab.Univalence.html#28116" class="Bound">j</a> <a id="28118" class="Symbol">→</a> <a id="28120" href="1Lab.Univalence.html#8818" data-type="A ≃ B₁ → A ≡ B₁" class="Function">ua</a> <a id="28123" href="1Lab.Univalence.html#27986" class="Bound">e</a> <a id="28125" class="Symbol">(</a><a id="28126" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="28128" href="1Lab.Univalence.html#28116" class="Bound">j</a> <a id="28130" href="1Lab.Path.html#2191" class="Primitive Operator">∧</a> <a id="28132" href="1Lab.Univalence.html#28006" class="Bound">i</a><a id="28133" class="Symbol">))</a> <a id="28136" class="Symbol">(</a><a id="28137" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="28139" href="1Lab.Univalence.html#28006" class="Bound">i</a><a id="28140" class="Symbol">)</a> <a id="28142" href="1Lab.Univalence.html#28008" class="Bound">a</a><a id="28143" class="Symbol">)</a> <a id="28145" href="1Lab.Univalence.html#28006" class="Bound">i</a><a id="28146" class="Symbol">)</a>
  <a id="28150" class="Keyword">where</a>
  <a id="28158" href="1Lab.Univalence.html#28158" data-type="((a : A₀) → PathP B₁ (f₀ a) (f₁ (e .fst a))) →
(i : I) →
ua e i → (a₁ : A₁) → e .fst (transport (sym (ua e)) a₁) ≡ a₁" class="Function">lem</a> <a id="28162" class="Symbol">:</a> <a id="28164" class="Symbol">∀</a> <a id="28166" href="1Lab.Univalence.html#28166" class="Bound">a₁</a> <a id="28169" class="Symbol">→</a> <a id="28171" href="1Lab.Univalence.html#27986" class="Bound">e</a> <a id="28173" class="Symbol">.</a><a id="28174" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="28178" class="Symbol">(</a><a id="28179" href="1Lab.Path.html#11776" data-type="A ≡ B₁ → A → B₁" class="Function">transport</a> <a id="28189" class="Symbol">(</a><a id="28190" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="28194" class="Symbol">(</a><a id="28195" href="1Lab.Univalence.html#8818" data-type="A ≃ B₁ → A ≡ B₁" class="Function">ua</a> <a id="28198" href="1Lab.Univalence.html#27986" class="Bound">e</a><a id="28199" class="Symbol">))</a> <a id="28202" href="1Lab.Univalence.html#28166" class="Bound">a₁</a><a id="28204" class="Symbol">)</a> <a id="28206" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="28208" href="1Lab.Univalence.html#28166" class="Bound">a₁</a>
  <a id="28213" href="1Lab.Univalence.html#28158" data-type="((a : A₀) → PathP B₁ (f₀ a) (f₁ (e .fst a))) →
(i : I) →
ua e i → (a₁ : A₁) → e .fst (transport (sym (ua e)) a₁) ≡ a₁" class="Function">lem</a> <a id="28217" href="1Lab.Univalence.html#28217" class="Bound">a₁</a> <a id="28220" class="Symbol">=</a> <a id="28222" href="1Lab.Equiv.html#6548" data-type="(eqv : is-equiv f) → is-right-inverse (equiv→inverse eqv) f" class="Function">equiv→section</a> <a id="28236" class="Symbol">(</a><a id="28237" href="1Lab.Univalence.html#27986" class="Bound">e</a> <a id="28239" class="Symbol">.</a><a id="28240" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a><a id="28243" class="Symbol">)</a> <a id="28245" class="Symbol">_</a> <a id="28247" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="28249" href="1Lab.Path.html#13454" data-type="(x : A) → transport (λ i → A) x ≡ x" class="Function">transport-refl</a> <a id="28264" class="Symbol">_</a>

<a id="ua→2"></a><a id="28267" href="1Lab.Univalence.html#28267" data-type="((a : A₀) (b : B₀) →
 PathP C (f₀ a b) (f₁ (e₁ .fst a) (e₂ .fst b))) →
PathP (λ i → ua e₁ i → ua e₂ i → C i) f₀ f₁" class="Function">ua→2</a> <a id="28272" class="Symbol">:</a> <a id="28274" class="Symbol">∀</a> <a id="28276" class="Symbol">{</a><a id="28277" href="1Lab.Univalence.html#28277" class="Bound">ℓ</a> <a id="28279" href="1Lab.Univalence.html#28279" class="Bound">ℓ&#39;</a> <a id="28282" href="1Lab.Univalence.html#28282" class="Bound">ℓ&#39;&#39;</a><a id="28285" class="Symbol">}</a> <a id="28287" class="Symbol">{</a><a id="28288" href="1Lab.Univalence.html#28288" class="Bound">A₀</a> <a id="28291" href="1Lab.Univalence.html#28291" class="Bound">A₁</a> <a id="28294" class="Symbol">:</a> <a id="28296" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="28301" href="1Lab.Univalence.html#28277" class="Bound">ℓ</a><a id="28302" class="Symbol">}</a> <a id="28304" class="Symbol">{</a><a id="28305" href="1Lab.Univalence.html#28305" class="Bound">e₁</a> <a id="28308" class="Symbol">:</a> <a id="28310" href="1Lab.Univalence.html#28288" class="Bound">A₀</a> <a id="28313" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="28315" href="1Lab.Univalence.html#28291" class="Bound">A₁</a><a id="28317" class="Symbol">}</a>
  <a id="28321" class="Symbol">{</a><a id="28322" href="1Lab.Univalence.html#28322" class="Bound">B₀</a> <a id="28325" href="1Lab.Univalence.html#28325" class="Bound">B₁</a> <a id="28328" class="Symbol">:</a> <a id="28330" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="28335" href="1Lab.Univalence.html#28279" class="Bound">ℓ&#39;</a><a id="28337" class="Symbol">}</a> <a id="28339" class="Symbol">{</a><a id="28340" href="1Lab.Univalence.html#28340" class="Bound">e₂</a> <a id="28343" class="Symbol">:</a> <a id="28345" href="1Lab.Univalence.html#28322" class="Bound">B₀</a> <a id="28348" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="28350" href="1Lab.Univalence.html#28325" class="Bound">B₁</a><a id="28352" class="Symbol">}</a>
  <a id="28356" class="Symbol">{</a><a id="28357" href="1Lab.Univalence.html#28357" class="Bound">C</a> <a id="28359" class="Symbol">:</a> <a id="28361" class="Symbol">(</a><a id="28362" href="1Lab.Univalence.html#28362" class="Bound">i</a> <a id="28364" class="Symbol">:</a> <a id="28366" href="Agda.Primitive.Cubical.html#150" class="Datatype">I</a><a id="28367" class="Symbol">)</a> <a id="28369" class="Symbol">→</a> <a id="28371" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="28376" href="1Lab.Univalence.html#28282" class="Bound">ℓ&#39;&#39;</a><a id="28379" class="Symbol">}</a>
  <a id="28383" class="Symbol">{</a><a id="28384" href="1Lab.Univalence.html#28384" class="Bound">f₀</a> <a id="28387" class="Symbol">:</a> <a id="28389" href="1Lab.Univalence.html#28288" class="Bound">A₀</a> <a id="28392" class="Symbol">→</a> <a id="28394" href="1Lab.Univalence.html#28322" class="Bound">B₀</a> <a id="28397" class="Symbol">→</a> <a id="28399" href="1Lab.Univalence.html#28357" class="Bound">C</a> <a id="28401" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="28403" class="Symbol">}</a> <a id="28405" class="Symbol">{</a><a id="28406" href="1Lab.Univalence.html#28406" class="Bound">f₁</a> <a id="28409" class="Symbol">:</a> <a id="28411" href="1Lab.Univalence.html#28291" class="Bound">A₁</a> <a id="28414" class="Symbol">→</a> <a id="28416" href="1Lab.Univalence.html#28325" class="Bound">B₁</a> <a id="28419" class="Symbol">→</a> <a id="28421" href="1Lab.Univalence.html#28357" class="Bound">C</a> <a id="28423" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="28425" class="Symbol">}</a>
  <a id="28429" class="Symbol">→</a> <a id="28431" class="Symbol">(∀</a> <a id="28434" href="1Lab.Univalence.html#28434" class="Bound">a</a> <a id="28436" href="1Lab.Univalence.html#28436" class="Bound">b</a> <a id="28438" class="Symbol">→</a> <a id="28440" href="Agda.Primitive.Cubical.html#2013" class="Postulate">PathP</a> <a id="28446" href="1Lab.Univalence.html#28357" class="Bound">C</a> <a id="28448" class="Symbol">(</a><a id="28449" href="1Lab.Univalence.html#28384" class="Bound">f₀</a> <a id="28452" href="1Lab.Univalence.html#28434" class="Bound">a</a> <a id="28454" href="1Lab.Univalence.html#28436" class="Bound">b</a><a id="28455" class="Symbol">)</a> <a id="28457" class="Symbol">(</a><a id="28458" href="1Lab.Univalence.html#28406" class="Bound">f₁</a> <a id="28461" class="Symbol">(</a><a id="28462" href="1Lab.Univalence.html#28305" class="Bound">e₁</a> <a id="28465" class="Symbol">.</a><a id="28466" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="28470" href="1Lab.Univalence.html#28434" class="Bound">a</a><a id="28471" class="Symbol">)</a> <a id="28473" class="Symbol">(</a><a id="28474" href="1Lab.Univalence.html#28340" class="Bound">e₂</a> <a id="28477" class="Symbol">.</a><a id="28478" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="28482" href="1Lab.Univalence.html#28436" class="Bound">b</a><a id="28483" class="Symbol">)))</a>
  <a id="28489" class="Symbol">→</a> <a id="28491" href="Agda.Primitive.Cubical.html#2013" class="Postulate">PathP</a> <a id="28497" class="Symbol">(λ</a> <a id="28500" href="1Lab.Univalence.html#28500" class="Bound">i</a> <a id="28502" class="Symbol">→</a> <a id="28504" href="1Lab.Univalence.html#8818" data-type="A ≃ B₁ → A ≡ B₁" class="Function">ua</a> <a id="28507" href="1Lab.Univalence.html#28305" class="Bound">e₁</a> <a id="28510" href="1Lab.Univalence.html#28500" class="Bound">i</a> <a id="28512" class="Symbol">→</a> <a id="28514" href="1Lab.Univalence.html#8818" data-type="A ≃ B₁ → A ≡ B₁" class="Function">ua</a> <a id="28517" href="1Lab.Univalence.html#28340" class="Bound">e₂</a> <a id="28520" href="1Lab.Univalence.html#28500" class="Bound">i</a> <a id="28522" class="Symbol">→</a> <a id="28524" href="1Lab.Univalence.html#28357" class="Bound">C</a> <a id="28526" href="1Lab.Univalence.html#28500" class="Bound">i</a><a id="28527" class="Symbol">)</a> <a id="28529" href="1Lab.Univalence.html#28384" class="Bound">f₀</a> <a id="28532" href="1Lab.Univalence.html#28406" class="Bound">f₁</a>
<a id="28535" href="1Lab.Univalence.html#28267" data-type="((a : A₀) (b : B₀) →
 PathP C (f₀ a b) (f₁ (e₁ .fst a) (e₂ .fst b))) →
PathP (λ i → ua e₁ i → ua e₂ i → C i) f₀ f₁" class="Function">ua→2</a> <a id="28540" href="1Lab.Univalence.html#28540" class="Bound">h</a> <a id="28542" class="Symbol">=</a> <a id="28544" href="1Lab.Univalence.html#27786" data-type="((a : A₀) → PathP B₁ (f₀ a) (f₁ (e .fst a))) →
PathP (λ i → ua e i → B₁ i) f₀ f₁" class="Function">ua→</a> <a id="28548" class="Symbol">(</a><a id="28549" href="1Lab.Univalence.html#27786" data-type="((a : A₀) → PathP B₁ (f₀ a) (f₁ (e .fst a))) →
PathP (λ i → ua e i → B₁ i) f₀ f₁" class="Function">ua→</a> <a id="28553" href="1Lab.Type.html#2227" data-type="((y : B₁ x) → C x y) → (f : (x : A) → B₁ x) (x : A) → C x (f x)" class="Function Operator">∘</a> <a id="28555" href="1Lab.Univalence.html#28540" class="Bound">h</a><a id="28556" class="Symbol">)</a>

<a id="transport-∙"></a><a id="28559" href="1Lab.Univalence.html#28559" data-type="(p : A ≡ B₁) (q : B₁ ≡ C) (u : A) →
transport (p ∙ q) u ≡ transport q (transport p u)" class="Function">transport-∙</a> <a id="28571" class="Symbol">:</a> <a id="28573" class="Symbol">∀</a> <a id="28575" class="Symbol">{</a><a id="28576" href="1Lab.Univalence.html#28576" class="Bound">ℓ</a><a id="28577" class="Symbol">}</a> <a id="28579" class="Symbol">{</a><a id="28580" href="1Lab.Univalence.html#28580" class="Bound">A</a> <a id="28582" href="1Lab.Univalence.html#28582" class="Bound">B</a> <a id="28584" href="1Lab.Univalence.html#28584" class="Bound">C</a> <a id="28586" class="Symbol">:</a> <a id="28588" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="28593" href="1Lab.Univalence.html#28576" class="Bound">ℓ</a><a id="28594" class="Symbol">}</a>
            <a id="28608" class="Symbol">→</a> <a id="28610" class="Symbol">(</a><a id="28611" href="1Lab.Univalence.html#28611" class="Bound">p</a> <a id="28613" class="Symbol">:</a> <a id="28615" href="1Lab.Univalence.html#28580" class="Bound">A</a> <a id="28617" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="28619" href="1Lab.Univalence.html#28582" class="Bound">B</a><a id="28620" class="Symbol">)</a> <a id="28622" class="Symbol">(</a><a id="28623" href="1Lab.Univalence.html#28623" class="Bound">q</a> <a id="28625" class="Symbol">:</a> <a id="28627" href="1Lab.Univalence.html#28582" class="Bound">B</a> <a id="28629" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="28631" href="1Lab.Univalence.html#28584" class="Bound">C</a><a id="28632" class="Symbol">)</a> <a id="28634" class="Symbol">(</a><a id="28635" href="1Lab.Univalence.html#28635" class="Bound">u</a> <a id="28637" class="Symbol">:</a> <a id="28639" href="1Lab.Univalence.html#28580" class="Bound">A</a><a id="28640" class="Symbol">)</a>
            <a id="28654" class="Symbol">→</a> <a id="28656" href="1Lab.Path.html#11776" data-type="A ≡ B₁ → A → B₁" class="Function">transport</a> <a id="28666" class="Symbol">(</a><a id="28667" href="1Lab.Univalence.html#28611" class="Bound">p</a> <a id="28669" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="28671" href="1Lab.Univalence.html#28623" class="Bound">q</a><a id="28672" class="Symbol">)</a> <a id="28674" href="1Lab.Univalence.html#28635" class="Bound">u</a> <a id="28676" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="28678" href="1Lab.Path.html#11776" data-type="A ≡ B₁ → A → B₁" class="Function">transport</a> <a id="28688" href="1Lab.Univalence.html#28623" class="Bound">q</a> <a id="28690" class="Symbol">(</a><a id="28691" href="1Lab.Path.html#11776" data-type="A ≡ B₁ → A → B₁" class="Function">transport</a> <a id="28701" href="1Lab.Univalence.html#28611" class="Bound">p</a> <a id="28703" href="1Lab.Univalence.html#28635" class="Bound">u</a><a id="28704" class="Symbol">)</a>
<a id="28706" href="1Lab.Univalence.html#28559" data-type="(p : A ≡ B₁) (q : B₁ ≡ C) (u : A) →
transport (p ∙ q) u ≡ transport q (transport p u)" class="Function">transport-∙</a> <a id="28718" href="1Lab.Univalence.html#28718" class="Bound">p</a> <a id="28720" href="1Lab.Univalence.html#28720" class="Bound">q</a> <a id="28722" href="1Lab.Univalence.html#28722" class="Bound">x</a> <a id="28724" href="1Lab.Univalence.html#28724" class="Bound">i</a> <a id="28726" class="Symbol">=</a>
  <a id="28730" href="1Lab.Path.html#11776" data-type="A ≡ B₁ → A → B₁" class="Function">transport</a> <a id="28740" class="Symbol">(</a><a id="28741" href="1Lab.Path.html#40307" data-type="(p : x ≡ y) (q : y ≡ z) → Square (sym p) q (p ∙ q) refl" class="Function">∙-filler&#39;</a> <a id="28751" href="1Lab.Univalence.html#28718" class="Bound">p</a> <a id="28753" href="1Lab.Univalence.html#28720" class="Bound">q</a> <a id="28755" class="Symbol">(</a><a id="28756" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="28758" href="1Lab.Univalence.html#28724" class="Bound">i</a><a id="28759" class="Symbol">))</a> <a id="28762" class="Symbol">(</a><a id="28763" href="1Lab.Path.html#14369" data-type="(p : A ≡ B₁) → PathP (λ i → A → p i) (λ x → x) (transport p)" class="Function">transport-filler-ext</a> <a id="28784" href="1Lab.Univalence.html#28718" class="Bound">p</a> <a id="28786" href="1Lab.Univalence.html#28724" class="Bound">i</a> <a id="28788" href="1Lab.Univalence.html#28722" class="Bound">x</a><a id="28789" class="Symbol">)</a>

<a id="subst-∙"></a><a id="28792" href="1Lab.Univalence.html#28792" data-type="(B₁ : A → Type ℓ′) (p : x ≡ y) (q : y ≡ z) (u : B₁ x) →
subst B₁ (p ∙ q) u ≡ subst B₁ q (subst B₁ p u)" class="Function">subst-∙</a> <a id="28800" class="Symbol">:</a> <a id="28802" class="Symbol">∀</a> <a id="28804" class="Symbol">{</a><a id="28805" href="1Lab.Univalence.html#28805" class="Bound">ℓ</a> <a id="28807" href="1Lab.Univalence.html#28807" class="Bound">ℓ′</a><a id="28809" class="Symbol">}</a> <a id="28811" class="Symbol">{</a><a id="28812" href="1Lab.Univalence.html#28812" class="Bound">A</a> <a id="28814" class="Symbol">:</a> <a id="28816" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="28821" href="1Lab.Univalence.html#28805" class="Bound">ℓ</a><a id="28822" class="Symbol">}</a> <a id="28824" class="Symbol">→</a> <a id="28826" class="Symbol">(</a><a id="28827" href="1Lab.Univalence.html#28827" class="Bound">B</a> <a id="28829" class="Symbol">:</a> <a id="28831" href="1Lab.Univalence.html#28812" class="Bound">A</a> <a id="28833" class="Symbol">→</a> <a id="28835" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="28840" href="1Lab.Univalence.html#28807" class="Bound">ℓ′</a><a id="28842" class="Symbol">)</a>
        <a id="28852" class="Symbol">→</a> <a id="28854" class="Symbol">{</a><a id="28855" href="1Lab.Univalence.html#28855" class="Bound">x</a> <a id="28857" href="1Lab.Univalence.html#28857" class="Bound">y</a> <a id="28859" href="1Lab.Univalence.html#28859" class="Bound">z</a> <a id="28861" class="Symbol">:</a> <a id="28863" href="1Lab.Univalence.html#28812" class="Bound">A</a><a id="28864" class="Symbol">}</a> <a id="28866" class="Symbol">(</a><a id="28867" href="1Lab.Univalence.html#28867" class="Bound">p</a> <a id="28869" class="Symbol">:</a> <a id="28871" href="1Lab.Univalence.html#28855" class="Bound">x</a> <a id="28873" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="28875" href="1Lab.Univalence.html#28857" class="Bound">y</a><a id="28876" class="Symbol">)</a> <a id="28878" class="Symbol">(</a><a id="28879" href="1Lab.Univalence.html#28879" class="Bound">q</a> <a id="28881" class="Symbol">:</a> <a id="28883" href="1Lab.Univalence.html#28857" class="Bound">y</a> <a id="28885" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="28887" href="1Lab.Univalence.html#28859" class="Bound">z</a><a id="28888" class="Symbol">)</a> <a id="28890" class="Symbol">(</a><a id="28891" href="1Lab.Univalence.html#28891" class="Bound">u</a> <a id="28893" class="Symbol">:</a> <a id="28895" href="1Lab.Univalence.html#28827" class="Bound">B</a> <a id="28897" href="1Lab.Univalence.html#28855" class="Bound">x</a><a id="28898" class="Symbol">)</a>
        <a id="28908" class="Symbol">→</a> <a id="28910" href="1Lab.Path.html#15309" data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" class="Function">subst</a> <a id="28916" href="1Lab.Univalence.html#28827" class="Bound">B</a> <a id="28918" class="Symbol">(</a><a id="28919" href="1Lab.Univalence.html#28867" class="Bound">p</a> <a id="28921" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="28923" href="1Lab.Univalence.html#28879" class="Bound">q</a><a id="28924" class="Symbol">)</a> <a id="28926" href="1Lab.Univalence.html#28891" class="Bound">u</a> <a id="28928" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="28930" href="1Lab.Path.html#15309" data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" class="Function">subst</a> <a id="28936" href="1Lab.Univalence.html#28827" class="Bound">B</a> <a id="28938" href="1Lab.Univalence.html#28879" class="Bound">q</a> <a id="28940" class="Symbol">(</a><a id="28941" href="1Lab.Path.html#15309" data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" class="Function">subst</a> <a id="28947" href="1Lab.Univalence.html#28827" class="Bound">B</a> <a id="28949" href="1Lab.Univalence.html#28867" class="Bound">p</a> <a id="28951" href="1Lab.Univalence.html#28891" class="Bound">u</a><a id="28952" class="Symbol">)</a>
<a id="28954" href="1Lab.Univalence.html#28792" data-type="(B₁ : A → Type ℓ′) (p : x ≡ y) (q : y ≡ z) (u : B₁ x) →
subst B₁ (p ∙ q) u ≡ subst B₁ q (subst B₁ p u)" class="Function">subst-∙</a> <a id="28962" href="1Lab.Univalence.html#28962" class="Bound">B</a> <a id="28964" href="1Lab.Univalence.html#28964" class="Bound">p</a> <a id="28966" href="1Lab.Univalence.html#28966" class="Bound">q</a> <a id="28968" href="1Lab.Univalence.html#28968" class="Bound">Bx</a> <a id="28971" href="1Lab.Univalence.html#28971" class="Bound">i</a> <a id="28973" class="Symbol">=</a>
  <a id="28977" href="1Lab.Path.html#11776" data-type="A ≡ B₁ → A → B₁" class="Function">transport</a> <a id="28987" class="Symbol">(</a><a id="28988" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="28991" href="1Lab.Univalence.html#28962" class="Bound">B</a> <a id="28993" class="Symbol">(</a><a id="28994" href="1Lab.Path.html#40307" data-type="(p : x ≡ y) (q : y ≡ z) → Square (sym p) q (p ∙ q) refl" class="Function">∙-filler&#39;</a> <a id="29004" href="1Lab.Univalence.html#28964" class="Bound">p</a> <a id="29006" href="1Lab.Univalence.html#28966" class="Bound">q</a> <a id="29008" class="Symbol">(</a><a id="29009" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="29011" href="1Lab.Univalence.html#28971" class="Bound">i</a><a id="29012" class="Symbol">)))</a> <a id="29016" class="Symbol">(</a><a id="29017" href="1Lab.Path.html#14369" data-type="(p : A ≡ B₁) → PathP (λ i → A → p i) (λ x → x) (transport p)" class="Function">transport-filler-ext</a> <a id="29038" class="Symbol">(</a><a id="29039" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="29042" href="1Lab.Univalence.html#28962" class="Bound">B</a> <a id="29044" href="1Lab.Univalence.html#28964" class="Bound">p</a><a id="29045" class="Symbol">)</a> <a id="29047" href="1Lab.Univalence.html#28971" class="Bound">i</a> <a id="29049" href="1Lab.Univalence.html#28968" class="Bound">Bx</a><a id="29051" class="Symbol">)</a>

<a id="sym-ua"></a><a id="29054" href="1Lab.Univalence.html#29054" data-type="(e : A ≃ B₁) → sym (ua e) ≡ ua (e e⁻¹)" class="Function">sym-ua</a> <a id="29061" class="Symbol">:</a> <a id="29063" class="Symbol">∀</a> <a id="29065" class="Symbol">{</a><a id="29066" href="1Lab.Univalence.html#29066" class="Bound">ℓ</a><a id="29067" class="Symbol">}</a> <a id="29069" class="Symbol">{</a><a id="29070" href="1Lab.Univalence.html#29070" class="Bound">A</a> <a id="29072" href="1Lab.Univalence.html#29072" class="Bound">B</a> <a id="29074" class="Symbol">:</a> <a id="29076" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="29081" href="1Lab.Univalence.html#29066" class="Bound">ℓ</a><a id="29082" class="Symbol">}</a> <a id="29084" class="Symbol">(</a><a id="29085" href="1Lab.Univalence.html#29085" class="Bound">e</a> <a id="29087" class="Symbol">:</a> <a id="29089" href="1Lab.Univalence.html#29070" class="Bound">A</a> <a id="29091" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="29093" href="1Lab.Univalence.html#29072" class="Bound">B</a><a id="29094" class="Symbol">)</a> <a id="29096" class="Symbol">→</a> <a id="29098" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="29102" class="Symbol">(</a><a id="29103" href="1Lab.Univalence.html#8818" data-type="A ≃ B₁ → A ≡ B₁" class="Function">ua</a> <a id="29106" href="1Lab.Univalence.html#29085" class="Bound">e</a><a id="29107" class="Symbol">)</a> <a id="29109" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="29111" href="1Lab.Univalence.html#8818" data-type="A ≃ B₁ → A ≡ B₁" class="Function">ua</a> <a id="29114" class="Symbol">(</a><a id="29115" href="1Lab.Univalence.html#29085" class="Bound">e</a> <a id="29117" href="1Lab.Equiv.html#21355" data-type="A ≃ B₁ → B₁ ≃ A" class="Function Operator">e⁻¹</a><a id="29120" class="Symbol">)</a>
<a id="29122" href="1Lab.Univalence.html#29054" data-type="(e : A ≃ B₁) → sym (ua e) ≡ ua (e e⁻¹)" class="Function">sym-ua</a> <a id="29129" class="Symbol">=</a> <a id="29131" href="1Lab.Univalence.html#19821" data-type="(P : (B₁ : Type ℓ) → A ≃ B₁ → Type ℓ&#39;) →
P A ((λ x → x) , id-equiv) → (e : A ≃ B₁) → P B₁ e" class="Function">EquivJ</a> <a id="29138" class="Symbol">(λ</a> <a id="29141" href="1Lab.Univalence.html#29141" class="Bound">B</a> <a id="29143" href="1Lab.Univalence.html#29143" class="Bound">e</a> <a id="29145" class="Symbol">→</a> <a id="29147" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="29151" class="Symbol">(</a><a id="29152" href="1Lab.Univalence.html#8818" data-type="A ≃ B₁ → A ≡ B₁" class="Function">ua</a> <a id="29155" href="1Lab.Univalence.html#29143" class="Bound">e</a><a id="29156" class="Symbol">)</a> <a id="29158" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="29160" href="1Lab.Univalence.html#8818" data-type="A ≃ B₁ → A ≡ B₁" class="Function">ua</a> <a id="29163" class="Symbol">(</a><a id="29164" href="1Lab.Univalence.html#29143" class="Bound">e</a> <a id="29166" href="1Lab.Equiv.html#21355" data-type="A ≃ B₁ → B₁ ≃ A" class="Function Operator">e⁻¹</a><a id="29169" class="Symbol">))</a>
  <a id="29174" class="Symbol">(</a><a id="29175" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="29178" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="29182" href="1Lab.Univalence.html#16267" data-type="ua ((λ x → x) , id-equiv) ≡ refl" class="Function">ua-id-equiv</a> <a id="29194" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="29196" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="29200" class="Symbol">(</a><a id="29201" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="29204" href="1Lab.Univalence.html#8818" data-type="A ≃ B₁ → A ≡ B₁" class="Function">ua</a> <a id="29207" class="Symbol">(</a><a id="29208" href="1Lab.Type.Sigma.html#5139" data-type="((x : A) → is-prop (B₁ x)) → x .fst ≡ y .fst → x ≡ y" class="Function">Σ-prop-path</a> <a id="29220" href="1Lab.Equiv.html#4916" data-type="(f : A → B₁) → is-prop (is-equiv f)" class="Function">is-equiv-is-prop</a> <a id="29237" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a><a id="29241" class="Symbol">)</a> <a id="29243" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="29245" href="1Lab.Univalence.html#16267" data-type="ua ((λ x → x) , id-equiv) ≡ refl" class="Function">ua-id-equiv</a><a id="29256" class="Symbol">))</a>
</pre>-->
<section class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>Not the fundamental theorem of
engineering!<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
  </article>
</div>
</main>
</body>
</html>
