<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="keywords" content="Agda,categories,topos" />

  <title>…isplayed.Instances.Slice - 1Lab</title>

  <link rel="stylesheet" href="/css/default.css" />
  <link rel="stylesheet" href="/css/katex.min.css" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="…isplayed.Instances.Slice - 1Lab" />
  <meta name="twitter:image" content="https://1lab.dev/static/cube-128x.png" />

  <meta name="og:title" content="…isplayed.Instances.Slice - 1Lab" />
  <meta name="og:image" content="https://1lab.dev/static/cube-128x.png" />
  <meta name="og:site-name" content="1Lab" />
  <meta name="og:type" content="website" />

    <meta name="og:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="twitter:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  
  <script defer src="/main.js"></script>

  <noscript>
    <style>
      body span.reasoning-step .as-written {
        display: inline;
      }

      body span.reasoning-step .alternate {
        display: none;
      }
    </style>
  </noscript>

  <!-- Google font embeds -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;0,800;1,400;1,500;1,600;1,700;1,800&amp;family=Inria+Sans:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&amp;display=swap" rel="stylesheet">
</head>

<body class="text-page">
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <!-- Table of contents (only if the page has a table of contents) -->
    <aside id="toc">
    <div id="toc-container" style="min-width: 10em; font-size: 15pt;">
      <!-- Title for the page -->
      <h3 class="Agda" style="margin-top: 0; margin-bottom: 0; white-space: pre;">
                <a class="Module">…isplayed.Instances.Slice</a>
              </h3>

      <!-- Cube logo -->
      <a id="logo" href="/">
        <img alt="1Lab" src="/static/cube-72x.png" style="display: block; margin-bottom: 1em; margin: auto;" width="32px" height="32px" />
      </a>

      <!-- Actual table of contents (separated from the rest by
      horizontal rules) -->
      <hr />
      <ul>
      <li><a href="#the-canonical-self-indexing"><a href="#the-canonical-self-indexing" class="header-link">The
      canonical
      self-indexing<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#as-a-fibration"><a href="#as-a-fibration" class="header-link">As
      a fibration<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      </ul>
      <hr />

      <!-- Sidebar controls -->
      <div style="display: flex; gap: 0.25em; flex-flow: row wrap;">
        <!-- Sidebar equations control -->
        <span class="equations" style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-eqns" type="checkbox" class="equations" id="sidebar-eqns">
          <label for="sidebar-eqns">Equations</label>
        </span>

        <!-- Sidebar fonts control -->
        <span style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-font" type="checkbox" id="toggle-fonts">
          <label for="toggle-fonts">Serif Font</label>
        </span>

        <!-- Sidebar footnotes control -->
        <span class="inline-footnotes" style="display: none; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-fns" type="checkbox" class="inline-footnotes" id="sidebar-fns">
          <label for="sidebar-fns">Inline Footnotes</label>
        </span>
      </div>

      <hr />

      <!-- Navbar navigation (lol) -->
      <div id="return" style="white-space: nowrap;">
        <div class="search-form search-form-proxy" role="form">
          <input id="search-box-proxy" type_="text" placeholder="Search..." autocomplete="off" tabindex="0"></input>
        </div>

              <a href="/">back to index</a> <br />
              <a href="all-pages.html">view all pages</a> <br />
        <a href="https://github.com/plt-amy/cubical-1lab/blob/c4a8622243c83c929bba8590e960752ac2ff2a88/src/Cat/Displayed/Instances/Slice.lagda.md">link to source</a> <br />
                <hr /> <div class="author-list">Written by Amélia Liao and Reed Mullanix</div> <br />
              </div>
    </div>
  </aside>
  
  <article>
    <!-- Article navigation (narrow screens only) -->
    <div class="narrow-only" id="article-nav">
      <!-- Index return anchor (only if the page is not the index) -->
            <div id="return">
        <a href="/">back to index</a>
      </div>
      
      <!-- Navbar equations control -->
      <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-eqns" type="checkbox" class="equations" id="navbar-eqns">
        <label for="navbar-eqns">Equations</label>
      </span>

      <!-- Navbar footnotes control -->
      <span class="inline-footnotes" style="display: none; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-fns" type="checkbox" class="inline-footnotes" id="navbar-fns">
        <label for="navbar-fns">Inline Footnotes</label>
      </span>
    </div>

<pre class="Agda"><a id="9" class="Keyword">open</a> <a id="14" class="Keyword">import</a> <a id="21" href="Cat.Displayed.Cartesian.html" class="Module">Cat.Displayed.Cartesian</a>
<a id="45" class="Keyword">open</a> <a id="50" class="Keyword">import</a> <a id="57" href="Cat.Functor.Equivalence.html" class="Module">Cat.Functor.Equivalence</a>
<a id="81" class="Keyword">open</a> <a id="86" class="Keyword">import</a> <a id="93" href="Cat.Diagram.Pullback.html" class="Module">Cat.Diagram.Pullback</a>
<a id="114" class="Keyword">open</a> <a id="119" class="Keyword">import</a> <a id="126" href="Cat.Displayed.Fibre.html" class="Module">Cat.Displayed.Fibre</a>
<a id="146" class="Keyword">open</a> <a id="151" class="Keyword">import</a> <a id="158" href="Cat.Instances.Slice.html" class="Module">Cat.Instances.Slice</a>
<a id="178" class="Keyword">open</a> <a id="183" class="Keyword">import</a> <a id="190" href="Cat.Displayed.Base.html" class="Module">Cat.Displayed.Base</a>
<a id="209" class="Keyword">open</a> <a id="214" class="Keyword">import</a> <a id="221" href="Cat.Functor.Base.html" class="Module">Cat.Functor.Base</a>
<a id="238" class="Keyword">open</a> <a id="243" class="Keyword">import</a> <a id="250" href="Cat.Prelude.html" class="Module">Cat.Prelude</a>

<a id="263" class="Keyword">import</a> <a id="270" href="Cat.Reasoning.html" class="Module">Cat.Reasoning</a> <a id="284" class="Symbol">as</a> <a id="287" class="Module">CR</a>

<a id="291" class="Keyword">module</a> <a id="298" href="Cat.Displayed.Instances.Slice.html" class="Module">Cat.Displayed.Instances.Slice</a> <a id="328" class="Symbol">{</a><a id="329" href="Cat.Displayed.Instances.Slice.html#329" class="Bound">o</a> <a id="331" href="Cat.Displayed.Instances.Slice.html#331" class="Bound">ℓ</a><a id="332" class="Symbol">}</a> <a id="334" class="Symbol">(</a><a id="335" href="Cat.Displayed.Instances.Slice.html#335" class="Bound">B</a> <a id="337" class="Symbol">:</a> <a id="339" href="Cat.Base.html#704" data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" class="Record">Precategory</a> <a id="351" href="Cat.Displayed.Instances.Slice.html#329" class="Bound">o</a> <a id="353" href="Cat.Displayed.Instances.Slice.html#331" class="Bound">ℓ</a><a id="354" class="Symbol">)</a> <a id="356" class="Keyword">where</a>
</pre>
<!--
<pre class="Agda"><a id="380" class="Keyword">open</a> <a id="385" href="Cat.Displayed.Cartesian.html#958" data-type="(E : Displayed B₁ o′ ℓ′) → Type (o ⊔ ℓ ⊔ o′ ⊔ ℓ′)" class="Module">Cartesian-fibration</a>
<a id="405" class="Keyword">open</a> <a id="410" href="Cat.Displayed.Cartesian.html#740" data-type="(E : Displayed B₁ o′ ℓ′) (f : B₁ .Hom x y) (y′ : Ob[ E ] y) →
Type (o ⊔ ℓ ⊔ o′ ⊔ ℓ′)" class="Module">Cartesian-lift</a>
<a id="425" class="Keyword">open</a> <a id="430" href="Cat.Displayed.Base.html#686" data-type="(B₁ : Precategory o ℓ) (o′ ℓ′ : Level) →
Type (o ⊔ ℓ ⊔ lsuc o′ ⊔ lsuc ℓ′)" class="Module">Displayed</a>
<a id="440" class="Keyword">open</a> <a id="445" href="Cat.Displayed.Cartesian.html#257" data-type="(E : Displayed B₁ o′ ℓ′) (f : B₁ .Hom a b) (f′ : Hom[ E ] f x y) →
Type (o ⊔ ℓ ⊔ o′ ⊔ ℓ′)" class="Module">Cartesian</a>
<a id="455" class="Keyword">open</a> <a id="460" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Module">Functor</a>
<a id="468" class="Keyword">open</a> <a id="473" href="Cat.Reasoning.html" class="Module">CR</a> <a id="476" href="Cat.Displayed.Instances.Slice.html#335" class="Bound">B</a>
<a id="478" class="Keyword">open</a> <a id="483" href="Cat.Instances.Slice.html#2190" data-type="(c : Ob C) → Type (o ⊔ ℓ)" class="Module">/-Obj</a>
</pre>-->
<h1 id="the-canonical-self-indexing"><a href="#the-canonical-self-indexing" class="header-link">The
canonical
self-indexing<span class="header-link-emoji">🔗</span></a></h1>
<p>There is a canonical way of viewing any category
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">B</mi></mrow><annotation encoding="application/x-tex">\ca{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.03041em;">B</span></span></span></span>
as displayed over <em>itself</em>, given <a href="Cat.Displayed.Fibre.html">fibrewise</a> by taking <a href="Cat.Instances.Slice.html">slice categories</a>. Following <span class="citation" data-cites="relativect">(<a href="#ref-relativect" role="doc-biblioref" title="Foundations of relative category theory">Sterling and Angiuli
2022</a>)</span>, we refer to this construction as the
<strong>canonical-self indexing</strong> of
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">B</mi></mrow><annotation encoding="application/x-tex">\ca{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.03041em;">B</span></span></span></span>
and denote it
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munder accentunder="true"><mi mathvariant="script">B</mi><mo stretchy="true">‾</mo></munder></mrow><annotation encoding="application/x-tex">\underline{\ca{B}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8833em;vertical-align:-0.2em;"></span><span class="mord underline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6833em;"><span style="top:-2.84em;"><span class="pstrut" style="height:3em;"></span><span class="underline-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.03041em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2em;"><span></span></span></span></span></span></span></span></span>.</span>
Recall that the objects in the slice over
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>
are pairs consisting of an object
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>
and a map
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>x</mi><mo>→</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">f : x \to y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>.</span>
The core idea is that <em>any morphism</em> lets us view an object
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>
as being “structure over” an object
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>;</span>
the collection of all possible such structures, then, is the set of
morphisms
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>→</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \to y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>,</span>
with domain allowed to vary.</p>
<p>Contrary to the maps in the slice category, the maps in the canonical
self-indexing have an extra “adjustment” by a morphism
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>x</mi><mo>→</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">f : x \to y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>
of the base category. Where maps in the ordinary slice are given by
commuting triangles, maps in the canonical self-indexing are given by
commuting <em>squares</em>, of the form</p>
<div class="diagram-container">
<img src="light-60896208dff90ed0ff84760d730df97648bc7e32.svg" title="commutative diagram" class="diagram diagram-light quiver" />
<img src="dark-60896208dff90ed0ff84760d730df97648bc7e32.svg" title="commutative diagram" class="diagram diagram-dark quiver" />
</div>
<p>where the primed objects and dotted arrows are displayed.</p>
<pre class="Agda"><a id="1848" class="Keyword">record</a>
  <a id="Slice-hom"></a><a id="1857" href="Cat.Displayed.Instances.Slice.html#1857" data-type="(B₁ : Precategory o ℓ) (f : Hom B₁ x y) (px : /-Obj x)
(py : /-Obj y) →
Type (o ⊔ ℓ)" class="Record">Slice-hom</a>
    <a id="1871" class="Symbol">{</a><a id="1872" href="Cat.Displayed.Instances.Slice.html#1872" class="Bound">x</a> <a id="1874" href="Cat.Displayed.Instances.Slice.html#1874" class="Bound">y</a><a id="1875" class="Symbol">}</a> <a id="1877" class="Symbol">(</a><a id="1878" href="Cat.Displayed.Instances.Slice.html#1878" class="Bound">f</a> <a id="1880" class="Symbol">:</a> <a id="1882" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Field">Hom</a> <a id="1886" href="Cat.Displayed.Instances.Slice.html#1872" class="Bound">x</a> <a id="1888" href="Cat.Displayed.Instances.Slice.html#1874" class="Bound">y</a><a id="1889" class="Symbol">)</a>
    <a id="1895" class="Symbol">(</a><a id="1896" href="Cat.Displayed.Instances.Slice.html#1896" class="Bound">px</a> <a id="1899" class="Symbol">:</a> <a id="1901" href="Cat.Instances.Slice.html#2190" data-type="(c : Ob C) → Type (o ⊔ ℓ)" class="Record">/-Obj</a> <a id="1907" class="Symbol">{</a><a id="1908" class="Argument">C</a> <a id="1910" class="Symbol">=</a> <a id="1912" href="Cat.Displayed.Instances.Slice.html#335" class="Bound">B</a><a id="1913" class="Symbol">}</a> <a id="1915" href="Cat.Displayed.Instances.Slice.html#1872" class="Bound">x</a><a id="1916" class="Symbol">)</a> <a id="1918" class="Symbol">(</a><a id="1919" href="Cat.Displayed.Instances.Slice.html#1919" class="Bound">py</a> <a id="1922" class="Symbol">:</a> <a id="1924" href="Cat.Instances.Slice.html#2190" data-type="(c : Ob C) → Type (o ⊔ ℓ)" class="Record">/-Obj</a> <a id="1930" class="Symbol">{</a><a id="1931" class="Argument">C</a> <a id="1933" class="Symbol">=</a> <a id="1935" href="Cat.Displayed.Instances.Slice.html#335" class="Bound">B</a><a id="1936" class="Symbol">}</a> <a id="1938" href="Cat.Displayed.Instances.Slice.html#1874" class="Bound">y</a><a id="1939" class="Symbol">)</a>
    <a id="1945" class="Symbol">:</a> <a id="1947" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="1952" class="Symbol">(</a><a id="1953" href="Cat.Displayed.Instances.Slice.html#329" class="Bound">o</a> <a id="1955" href="Agda.Primitive.html#810" data-type="Level → Level → Level" class="Primitive Operator">⊔</a> <a id="1957" href="Cat.Displayed.Instances.Slice.html#331" class="Bound">ℓ</a><a id="1958" class="Symbol">)</a>
  <a id="1962" class="Keyword">where</a>
  <a id="1970" class="Keyword">constructor</a> <a id="slice-hom"></a><a id="1982" href="Cat.Displayed.Instances.Slice.html#1982" data-type="(to₁ : Hom B₁ (px .domain) (py .domain))
(commute : (B₁ ∘ f) (px .map) ≡ (B₁ ∘ py .map) to₁) →
Slice-hom B₁ f px py" class="InductiveConstructor">slice-hom</a>
  <a id="1994" class="Keyword">field</a>
    <a id="Slice-hom.to"></a><a id="2004" href="Cat.Displayed.Instances.Slice.html#2004" data-type="Slice-hom B₁ f px py → Hom B₁ (px .domain) (py .domain)" class="Field">to</a>      <a id="2012" class="Symbol">:</a> <a id="2014" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Field">Hom</a> <a id="2018" class="Symbol">(</a><a id="2019" href="Cat.Displayed.Instances.Slice.html#1896" class="Bound">px</a> <a id="2022" class="Symbol">.</a><a id="2023" href="Cat.Instances.Slice.html#2285" data-type="/-Obj c → Ob C" class="Field">domain</a><a id="2029" class="Symbol">)</a> <a id="2031" class="Symbol">(</a><a id="2032" href="Cat.Displayed.Instances.Slice.html#1919" class="Bound">py</a> <a id="2035" class="Symbol">.</a><a id="2036" href="Cat.Instances.Slice.html#2285" data-type="/-Obj c → Ob C" class="Field">domain</a><a id="2042" class="Symbol">)</a>
    <a id="Slice-hom.commute"></a><a id="2048" href="Cat.Displayed.Instances.Slice.html#2048" data-type="(r : Slice-hom B₁ f px py) →
(B₁ ∘ f) (px .map) ≡ (B₁ ∘ py .map) (r .to)" class="Field">commute</a> <a id="2056" class="Symbol">:</a> <a id="2058" href="Cat.Displayed.Instances.Slice.html#1878" class="Bound">f</a> <a id="2060" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Field Operator">∘</a> <a id="2062" href="Cat.Displayed.Instances.Slice.html#1896" class="Bound">px</a> <a id="2065" class="Symbol">.</a><a id="2066" href="Cat.Instances.Slice.html#2306" data-type="(r : /-Obj c) → Hom C (r .domain) c" class="Field">map</a> <a id="2070" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="2072" href="Cat.Displayed.Instances.Slice.html#1919" class="Bound">py</a> <a id="2075" class="Symbol">.</a><a id="2076" href="Cat.Instances.Slice.html#2306" data-type="(r : /-Obj c) → Hom C (r .domain) c" class="Field">map</a> <a id="2080" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Field Operator">∘</a> <a id="2082" class="Field">to</a>

<a id="2086" class="Keyword">open</a> <a id="2091" href="Cat.Displayed.Instances.Slice.html#1857" data-type="(B₁ : Precategory o ℓ) (f : Hom B₁ x y) (px : /-Obj x)
(py : /-Obj y) →
Type (o ⊔ ℓ)" class="Module">Slice-hom</a>
</pre>
<!--
<pre class="Agda"><a id="2119" class="Keyword">private</a> <a id="2127" class="Keyword">unquoteDecl</a> <a id="eqv"></a><a id="2139" href="Cat.Displayed.Instances.Slice.html#2139" data-type="(B₁ : Precategory o ℓ) →
Iso (Slice-hom B₁ f px py)
(∑ (Hom B₁ (domain px) (domain py))
 (λ to₁ → (B₁ ∘ f) (map px) ≡ (B₁ ∘ map py) to₁))" class="Function">eqv</a> <a id="2143" class="Symbol">=</a> <a id="2145" href="1Lab.Reflection.Record.html#5133" data-type="Name → Name → TC ⊤" class="Function">declare-record-iso</a> <a id="2164" href="Cat.Displayed.Instances.Slice.html#2139" data-type="(B₁ : Precategory o ℓ) →
Iso (Slice-hom B₁ f px py)
(∑ (Hom B₁ (domain px) (domain py))
 (λ to₁ → (B₁ ∘ f) (map px) ≡ (B₁ ∘ map py) to₁))" class="Function">eqv</a> <a id="2168" class="Symbol">(</a><a id="2169" class="Keyword">quote</a> <a id="2175" href="Cat.Displayed.Instances.Slice.html#1857" data-type="(B₁ : Precategory o ℓ) (f : Hom B₁ x y) (px : /-Obj x)
(py : /-Obj y) →
Type (o ⊔ ℓ)" class="Record">Slice-hom</a><a id="2184" class="Symbol">)</a>
</pre>-->
<p>The intuitive idea for the canonical self-indexing is possibly best
obtained by considering the canonical self-indexing of
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="bold">S</mi><mi mathvariant="bold">e</mi><mi mathvariant="bold">t</mi><mi mathvariant="bold">s</mi></mrow><mi>κ</mi></msub></mrow><annotation encoding="application/x-tex">\sets_\kappa</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8361em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">Sets</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">κ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</span>
First, recall that an object
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mrow><mi mathvariant="bold">S</mi><mi mathvariant="bold">e</mi><mi mathvariant="bold">t</mi><mi mathvariant="bold">s</mi></mrow><mi mathvariant="normal">/</mi><mi>X</mi></mrow><annotation encoding="application/x-tex">f : \sets/X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathbf">Sets</span></span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>
is equivalently a
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>-indexed</span>
family of sets, with the value of the family at each point
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>:</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">x : X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>
being the fibre
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo>∗</mo></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f^*(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>.</span>
A function
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>
of sets then corresponds to a <em>reindexing</em>, which takes an
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>-family</span>
of sets to a
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>-family</span>
of sets (<a href="Cat.Instances.Slice.html#slices-of-sets">in a
functorial way</a>). A morphism
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>X</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>→</mo><msup><mi>Y</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">X&#39; \to Y&#39;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>
in the canonical self-indexing of
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">S</mi><mi mathvariant="bold">e</mi><mi mathvariant="bold">t</mi><mi mathvariant="bold">s</mi></mrow><annotation encoding="application/x-tex">\sets</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6861em;"></span><span class="mord"><span class="mord mathbf">Sets</span></span></span></span></span>
lying over a map
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">f : X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>
is then a function between the families
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>X</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>→</mo><msup><mi>Y</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">X&#39; \to Y&#39;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>
which commutes with the reindexing given by
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>.</span></p>
<!--
<pre class="Agda"><a id="2923" class="Keyword">module</a> <a id="2930" href="Cat.Displayed.Instances.Slice.html#2930" class="Module">_</a> <a id="2932" class="Symbol">{</a><a id="2933" href="Cat.Displayed.Instances.Slice.html#2933" class="Bound">x</a> <a id="2935" href="Cat.Displayed.Instances.Slice.html#2935" class="Bound">y</a><a id="2936" class="Symbol">}</a> <a id="2938" class="Symbol">{</a><a id="2939" href="Cat.Displayed.Instances.Slice.html#2939" class="Bound">f</a> <a id="2941" href="Cat.Displayed.Instances.Slice.html#2941" class="Bound">g</a> <a id="2943" class="Symbol">:</a> <a id="2945" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Field">Hom</a> <a id="2949" href="Cat.Displayed.Instances.Slice.html#2933" class="Bound">x</a> <a id="2951" href="Cat.Displayed.Instances.Slice.html#2935" class="Bound">y</a><a id="2952" class="Symbol">}</a> <a id="2954" class="Symbol">{</a><a id="2955" href="Cat.Displayed.Instances.Slice.html#2955" class="Bound">px</a> <a id="2958" class="Symbol">:</a> <a id="2960" href="Cat.Instances.Slice.html#2190" data-type="(c : Ob C) → Type (o ⊔ ℓ)" class="Record">/-Obj</a> <a id="2966" href="Cat.Displayed.Instances.Slice.html#2933" class="Bound">x</a><a id="2967" class="Symbol">}</a> <a id="2969" class="Symbol">{</a><a id="2970" href="Cat.Displayed.Instances.Slice.html#2970" class="Bound">py</a> <a id="2973" class="Symbol">:</a> <a id="2975" href="Cat.Instances.Slice.html#2190" data-type="(c : Ob C) → Type (o ⊔ ℓ)" class="Record">/-Obj</a> <a id="2981" href="Cat.Displayed.Instances.Slice.html#2935" class="Bound">y</a><a id="2982" class="Symbol">}</a>
         <a id="2993" class="Symbol">{</a><a id="2994" href="Cat.Displayed.Instances.Slice.html#2994" class="Bound">f′</a> <a id="2997" class="Symbol">:</a> <a id="2999" href="Cat.Displayed.Instances.Slice.html#1857" data-type="(B₁ : Precategory o ℓ) (f : Hom B₁ x y) (px : /-Obj x)
(py : /-Obj y) →
Type (o ⊔ ℓ)" class="Record">Slice-hom</a> <a id="3009" href="Cat.Displayed.Instances.Slice.html#2939" class="Bound">f</a> <a id="3011" href="Cat.Displayed.Instances.Slice.html#2955" class="Bound">px</a> <a id="3014" href="Cat.Displayed.Instances.Slice.html#2970" class="Bound">py</a><a id="3016" class="Symbol">}</a> <a id="3018" class="Symbol">{</a><a id="3019" href="Cat.Displayed.Instances.Slice.html#3019" class="Bound">g′</a> <a id="3022" class="Symbol">:</a> <a id="3024" href="Cat.Displayed.Instances.Slice.html#1857" data-type="(B₁ : Precategory o ℓ) (f : Hom B₁ x y) (px : /-Obj x)
(py : /-Obj y) →
Type (o ⊔ ℓ)" class="Record">Slice-hom</a> <a id="3034" href="Cat.Displayed.Instances.Slice.html#2941" class="Bound">g</a> <a id="3036" href="Cat.Displayed.Instances.Slice.html#2955" class="Bound">px</a> <a id="3039" href="Cat.Displayed.Instances.Slice.html#2970" class="Bound">py</a><a id="3041" class="Symbol">}</a> <a id="3043" class="Keyword">where</a>

  <a id="3052" href="Cat.Displayed.Instances.Slice.html#3052" data-type="(B₁ : Precategory o ℓ) (p : f ≡ g) →
f′ .to ≡ g′ .to → PathP (λ i → Slice-hom B₁ (p i) px py) f′ g′" class="Function">Slice-pathp</a> <a id="3064" class="Symbol">:</a> <a id="3066" class="Symbol">(</a><a id="3067" href="Cat.Displayed.Instances.Slice.html#3067" class="Bound">p</a> <a id="3069" class="Symbol">:</a> <a id="3071" href="Cat.Displayed.Instances.Slice.html#2939" class="Bound">f</a> <a id="3073" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="3075" href="Cat.Displayed.Instances.Slice.html#2941" class="Bound">g</a><a id="3076" class="Symbol">)</a> <a id="3078" class="Symbol">→</a> <a id="3080" class="Symbol">(</a><a id="3081" href="Cat.Displayed.Instances.Slice.html#2994" class="Bound">f′</a> <a id="3084" class="Symbol">.</a><a id="3085" href="Cat.Displayed.Instances.Slice.html#2004" data-type="Slice-hom B₁ f px py → Hom B₁ (px .domain) (py .domain)" class="Field">to</a> <a id="3088" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="3090" href="Cat.Displayed.Instances.Slice.html#3019" class="Bound">g′</a> <a id="3093" class="Symbol">.</a><a id="3094" href="Cat.Displayed.Instances.Slice.html#2004" data-type="Slice-hom B₁ f px py → Hom B₁ (px .domain) (py .domain)" class="Field">to</a><a id="3096" class="Symbol">)</a> <a id="3098" class="Symbol">→</a> <a id="3100" href="Agda.Builtin.Cubical.Path.html#197" data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" class="Postulate">PathP</a> <a id="3106" class="Symbol">(λ</a> <a id="3109" href="Cat.Displayed.Instances.Slice.html#3109" class="Bound">i</a> <a id="3111" class="Symbol">→</a> <a id="3113" href="Cat.Displayed.Instances.Slice.html#1857" data-type="(B₁ : Precategory o ℓ) (f : Hom B₁ x y) (px : /-Obj x)
(py : /-Obj y) →
Type (o ⊔ ℓ)" class="Record">Slice-hom</a> <a id="3123" class="Symbol">(</a><a id="3124" href="Cat.Displayed.Instances.Slice.html#3067" class="Bound">p</a> <a id="3126" href="Cat.Displayed.Instances.Slice.html#3109" class="Bound">i</a><a id="3127" class="Symbol">)</a> <a id="3129" href="Cat.Displayed.Instances.Slice.html#2955" class="Bound">px</a> <a id="3132" href="Cat.Displayed.Instances.Slice.html#2970" class="Bound">py</a><a id="3134" class="Symbol">)</a> <a id="3136" href="Cat.Displayed.Instances.Slice.html#2994" class="Bound">f′</a> <a id="3139" href="Cat.Displayed.Instances.Slice.html#3019" class="Bound">g′</a>
  <a id="3144" href="Cat.Displayed.Instances.Slice.html#3052" data-type="(B₁ : Precategory o ℓ) (p : f ≡ g) →
f′ .to ≡ g′ .to → PathP (λ i → Slice-hom B₁ (p i) px py) f′ g′" class="Function">Slice-pathp</a> <a id="3156" href="Cat.Displayed.Instances.Slice.html#3156" class="Bound">p</a> <a id="3158" href="Cat.Displayed.Instances.Slice.html#3158" class="Bound">p′</a> <a id="3161" href="Cat.Displayed.Instances.Slice.html#3161" class="Bound">i</a> <a id="3163" class="Symbol">.</a><a id="3164" href="Cat.Displayed.Instances.Slice.html#2004" data-type="Slice-hom B₁ f px py → Hom B₁ (px .domain) (py .domain)" class="Field">to</a> <a id="3167" class="Symbol">=</a> <a id="3169" href="Cat.Displayed.Instances.Slice.html#3158" class="Bound">p′</a> <a id="3172" href="Cat.Displayed.Instances.Slice.html#3161" class="Bound">i</a>
  <a id="3176" href="Cat.Displayed.Instances.Slice.html#3052" data-type="(B₁ : Precategory o ℓ) (p : f ≡ g) →
f′ .to ≡ g′ .to → PathP (λ i → Slice-hom B₁ (p i) px py) f′ g′" class="Function">Slice-pathp</a> <a id="3188" href="Cat.Displayed.Instances.Slice.html#3188" class="Bound">p</a> <a id="3190" href="Cat.Displayed.Instances.Slice.html#3190" class="Bound">p′</a> <a id="3193" href="Cat.Displayed.Instances.Slice.html#3193" class="Bound">i</a> <a id="3195" class="Symbol">.</a><a id="3196" href="Cat.Displayed.Instances.Slice.html#2048" data-type="(r : Slice-hom B₁ f px py) →
(B₁ ∘ f) (px .map) ≡ (B₁ ∘ py .map) (r .to)" class="Field">commute</a> <a id="3204" class="Symbol">=</a>
    <a id="3210" href="1Lab.HLevel.html#13498" data-type="((i : I) → is-prop (B₁ i)) →
(b0 : B₁ i0) (b1 : B₁ i1) → PathP B₁ b0 b1" class="Function">is-prop→pathp</a>
      <a id="3230" class="Symbol">(λ</a> <a id="3233" href="Cat.Displayed.Instances.Slice.html#3233" class="Bound">i</a> <a id="3235" class="Symbol">→</a> <a id="3237" href="Cat.Base.html#1784" data-type="(r : Precategory o h) (x y : r .Ob) → is-set (r .Hom x y)" class="Field">Hom-set</a> <a id="3245" class="Symbol">_</a> <a id="3247" class="Symbol">_</a> <a id="3249" class="Symbol">(</a><a id="3250" href="Cat.Displayed.Instances.Slice.html#3188" class="Bound">p</a> <a id="3252" href="Cat.Displayed.Instances.Slice.html#3233" class="Bound">i</a> <a id="3254" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Field Operator">∘</a> <a id="3256" href="Cat.Displayed.Instances.Slice.html#2955" class="Bound">px</a> <a id="3259" class="Symbol">.</a><a id="3260" href="Cat.Instances.Slice.html#2306" data-type="(r : /-Obj c) → Hom C (r .domain) c" class="Field">map</a><a id="3263" class="Symbol">)</a> <a id="3265" class="Symbol">(</a><a id="3266" href="Cat.Displayed.Instances.Slice.html#2970" class="Bound">py</a> <a id="3269" class="Symbol">.</a><a id="3270" href="Cat.Instances.Slice.html#2306" data-type="(r : /-Obj c) → Hom C (r .domain) c" class="Field">map</a> <a id="3274" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Field Operator">∘</a> <a id="3276" class="Symbol">(</a><a id="3277" href="Cat.Displayed.Instances.Slice.html#3190" class="Bound">p′</a> <a id="3280" href="Cat.Displayed.Instances.Slice.html#3233" class="Bound">i</a><a id="3281" class="Symbol">)))</a>
      <a id="3291" class="Symbol">(</a><a id="3292" href="Cat.Displayed.Instances.Slice.html#2994" class="Bound">f′</a> <a id="3295" class="Symbol">.</a><a id="3296" href="Cat.Displayed.Instances.Slice.html#2048" data-type="(r : Slice-hom B₁ f px py) →
(B₁ ∘ f) (px .map) ≡ (B₁ ∘ py .map) (r .to)" class="Field">commute</a><a id="3303" class="Symbol">)</a>
      <a id="3311" class="Symbol">(</a><a id="3312" href="Cat.Displayed.Instances.Slice.html#3019" class="Bound">g′</a> <a id="3315" class="Symbol">.</a><a id="3316" href="Cat.Displayed.Instances.Slice.html#2048" data-type="(r : Slice-hom B₁ f px py) →
(B₁ ∘ f) (px .map) ≡ (B₁ ∘ py .map) (r .to)" class="Field">commute</a><a id="3323" class="Symbol">)</a>
      <a id="3331" href="Cat.Displayed.Instances.Slice.html#3193" class="Bound">i</a>

<a id="3334" class="Keyword">module</a> <a id="3341" href="Cat.Displayed.Instances.Slice.html#3341" class="Module">_</a> <a id="3343" class="Symbol">{</a><a id="3344" href="Cat.Displayed.Instances.Slice.html#3344" class="Bound">x</a> <a id="3346" href="Cat.Displayed.Instances.Slice.html#3346" class="Bound">y</a><a id="3347" class="Symbol">}</a> <a id="3349" class="Symbol">(</a><a id="3350" href="Cat.Displayed.Instances.Slice.html#3350" class="Bound">f</a> <a id="3352" class="Symbol">:</a> <a id="3354" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Field">Hom</a> <a id="3358" href="Cat.Displayed.Instances.Slice.html#3344" class="Bound">x</a> <a id="3360" href="Cat.Displayed.Instances.Slice.html#3346" class="Bound">y</a><a id="3361" class="Symbol">)</a> <a id="3363" class="Symbol">(</a><a id="3364" href="Cat.Displayed.Instances.Slice.html#3364" class="Bound">px</a> <a id="3367" class="Symbol">:</a> <a id="3369" href="Cat.Instances.Slice.html#2190" data-type="(c : Ob C) → Type (o ⊔ ℓ)" class="Record">/-Obj</a> <a id="3375" href="Cat.Displayed.Instances.Slice.html#3344" class="Bound">x</a><a id="3376" class="Symbol">)</a> <a id="3378" class="Symbol">(</a><a id="3379" href="Cat.Displayed.Instances.Slice.html#3379" class="Bound">py</a> <a id="3382" class="Symbol">:</a> <a id="3384" href="Cat.Instances.Slice.html#2190" data-type="(c : Ob C) → Type (o ⊔ ℓ)" class="Record">/-Obj</a> <a id="3390" href="Cat.Displayed.Instances.Slice.html#3346" class="Bound">y</a><a id="3391" class="Symbol">)</a> <a id="3393" class="Keyword">where</a>
  <a id="3401" href="Cat.Displayed.Instances.Slice.html#3401" data-type="(B₁ : Precategory o ℓ) (f : Hom B₁ x y) (px : /-Obj x)
(py : /-Obj y) →
is-set (Slice-hom B₁ f px py)" class="Function">Slice-is-set</a> <a id="3414" class="Symbol">:</a> <a id="3416" href="1Lab.HLevel.html#3356" data-type="Type ℓ → Type ℓ" class="Function">is-set</a> <a id="3423" class="Symbol">(</a><a id="3424" href="Cat.Displayed.Instances.Slice.html#1857" data-type="(B₁ : Precategory o ℓ) (f : Hom B₁ x y) (px : /-Obj x)
(py : /-Obj y) →
Type (o ⊔ ℓ)" class="Record">Slice-hom</a> <a id="3434" href="Cat.Displayed.Instances.Slice.html#3350" class="Bound">f</a> <a id="3436" href="Cat.Displayed.Instances.Slice.html#3364" class="Bound">px</a> <a id="3439" href="Cat.Displayed.Instances.Slice.html#3379" class="Bound">py</a><a id="3441" class="Symbol">)</a>
  <a id="3445" href="Cat.Displayed.Instances.Slice.html#3401" data-type="(B₁ : Precategory o ℓ) (f : Hom B₁ x y) (px : /-Obj x)
(py : /-Obj y) →
is-set (Slice-hom B₁ f px py)" class="Function">Slice-is-set</a> <a id="3458" class="Symbol">=</a> <a id="3460" href="1Lab.HLevel.Retracts.html#4220" data-type="(n : Nat) → A ≃ B₁ → is-hlevel A n → is-hlevel B₁ n" class="Function">is-hlevel≃</a> <a id="3471" class="Number">2</a> <a id="3473" class="Symbol">(</a><a id="3474" href="1Lab.Equiv.html#20161" data-type="Iso A B₁ → A ≃ B₁" class="Function">Iso→Equiv</a> <a id="3484" href="Cat.Displayed.Instances.Slice.html#2139" data-type="(B₁ : Precategory o ℓ) →
Iso (Slice-hom B₁ f px py)
(∑ (Hom B₁ (domain px) (domain py))
 (λ to₁ → (B₁ ∘ f) (map px) ≡ (B₁ ∘ map py) to₁))" class="Function">eqv</a> <a id="3488" href="1Lab.Equiv.html#21355" data-type="A ≃ B₁ → B₁ ≃ A" class="Function Operator">e⁻¹</a><a id="3491" class="Symbol">)</a> <a id="3493" class="Symbol">(</a><a id="3494" href="1Lab.HLevel.Retracts.html#8061" data-type="(n : Nat) ⦃ x : H-Level T n ⦄ → is-hlevel T n" class="Function">hlevel</a> <a id="3501" class="Number">2</a><a id="3502" class="Symbol">)</a>
    <a id="3508" class="Keyword">where</a> <a id="3514" class="Keyword">open</a> <a id="3519" href="Cat.Base.html#3984" class="Module">HLevel-instance</a>
</pre>-->
<p>It’s straightforward to piece together the objects of the (ordinary)
slice category and our displayed maps
<span class="Agda"><a href="Cat.Displayed.Instances.Slice.html#1857" class="Record">Slice-hom</a></span>
into a category displayed over
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">B</mi></mrow><annotation encoding="application/x-tex">\ca{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.03041em;">B</span></span></span></span>.</span></p>
<pre class="Agda"><a id="Slices"></a><a id="3720" href="Cat.Displayed.Instances.Slice.html#3720" data-type="(B₁ : Precategory o ℓ) → Displayed B₁ (o ⊔ ℓ) (o ⊔ ℓ)" class="Function">Slices</a> <a id="3727" class="Symbol">:</a> <a id="3729" href="Cat.Displayed.Base.html#686" data-type="(B₁ : Precategory o ℓ) (o′ ℓ′ : Level) →
Type (o ⊔ ℓ ⊔ lsuc o′ ⊔ lsuc ℓ′)" class="Record">Displayed</a> <a id="3739" href="Cat.Displayed.Instances.Slice.html#335" class="Bound">B</a> <a id="3741" class="Symbol">(</a><a id="3742" href="Cat.Displayed.Instances.Slice.html#329" class="Bound">o</a> <a id="3744" href="Agda.Primitive.html#810" data-type="Level → Level → Level" class="Primitive Operator">⊔</a> <a id="3746" href="Cat.Displayed.Instances.Slice.html#331" class="Bound">ℓ</a><a id="3747" class="Symbol">)</a> <a id="3749" class="Symbol">(</a><a id="3750" href="Cat.Displayed.Instances.Slice.html#329" class="Bound">o</a> <a id="3752" href="Agda.Primitive.html#810" data-type="Level → Level → Level" class="Primitive Operator">⊔</a> <a id="3754" href="Cat.Displayed.Instances.Slice.html#331" class="Bound">ℓ</a><a id="3755" class="Symbol">)</a>
<a id="3757" href="Cat.Displayed.Instances.Slice.html#3720" data-type="(B₁ : Precategory o ℓ) → Displayed B₁ (o ⊔ ℓ) (o ⊔ ℓ)" class="Function">Slices</a> <a id="3764" class="Symbol">.</a><a id="3765" href="Cat.Displayed.Base.html#1197" data-type="Displayed B₁ o′ ℓ′ → B₁ .Ob → Type o′" class="Field Operator">Ob[_]</a> <a id="3771" class="Symbol">=</a> <a id="3773" href="Cat.Instances.Slice.html#2190" data-type="(c : Ob C) → Type (o ⊔ ℓ)" class="Record">/-Obj</a> <a id="3779" class="Symbol">{</a><a id="3780" class="Argument">C</a> <a id="3782" class="Symbol">=</a> <a id="3784" href="Cat.Displayed.Instances.Slice.html#335" class="Bound">B</a><a id="3785" class="Symbol">}</a>
<a id="3787" href="Cat.Displayed.Instances.Slice.html#3720" data-type="(B₁ : Precategory o ℓ) → Displayed B₁ (o ⊔ ℓ) (o ⊔ ℓ)" class="Function">Slices</a> <a id="3794" class="Symbol">.</a><a id="3795" href="Cat.Displayed.Base.html#1668" data-type="(r : Displayed B₁ o′ ℓ′) →
B₁ .Hom x y → r .Ob[_] x → r .Ob[_] y → Type ℓ′" class="Field Operator">Hom[_]</a> <a id="3802" class="Symbol">=</a> <a id="3804" href="Cat.Displayed.Instances.Slice.html#1857" data-type="(B₁ : Precategory o ℓ) (f : Hom B₁ x y) (px : /-Obj x)
(py : /-Obj y) →
Type (o ⊔ ℓ)" class="Record">Slice-hom</a>
<a id="3814" href="Cat.Displayed.Instances.Slice.html#3720" data-type="(B₁ : Precategory o ℓ) → Displayed B₁ (o ⊔ ℓ) (o ⊔ ℓ)" class="Function">Slices</a> <a id="3821" class="Symbol">.</a><a id="3822" href="Cat.Displayed.Base.html#1729" data-type="(r : Displayed B₁ o′ ℓ′) (f : B₁ .Hom a b) (x : r .Ob[_] a)
(y : r .Ob[_] b) →
is-set (r .Hom[_] f x y)" class="Field Operator">Hom[_]-set</a> <a id="3833" class="Symbol">=</a> <a id="3835" href="Cat.Displayed.Instances.Slice.html#3401" data-type="(B₁ : Precategory o ℓ) (f : Hom B₁ x y) (px : /-Obj x)
(py : /-Obj y) →
is-set (Slice-hom B₁ f px py)" class="Function">Slice-is-set</a>
<a id="3848" href="Cat.Displayed.Instances.Slice.html#3720" data-type="(B₁ : Precategory o ℓ) → Displayed B₁ (o ⊔ ℓ) (o ⊔ ℓ)" class="Function">Slices</a> <a id="3855" class="Symbol">.</a><a id="3856" href="Cat.Displayed.Base.html#2219" data-type="(r : Displayed B₁ o′ ℓ′) → r .Hom[_] (B₁ .id) x x" class="Field">id′</a> <a id="3860" class="Symbol">=</a> <a id="3862" href="Cat.Displayed.Instances.Slice.html#1982" data-type="(to₁ : Hom B₁ (px .domain) (py .domain))
(commute : (B₁ ∘ f) (px .map) ≡ (B₁ ∘ py .map) to₁) →
Slice-hom B₁ f px py" class="InductiveConstructor">slice-hom</a> <a id="3872" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Field">id</a> <a id="3875" href="Cat.Reasoning.html#878" data-type="(C : Precategory o ℓ) → (C ∘ id C) f ≡ (C ∘ f) (id C)" class="Function">id-comm-sym</a>
<a id="3887" href="Cat.Displayed.Instances.Slice.html#3720" data-type="(B₁ : Precategory o ℓ) → Displayed B₁ (o ⊔ ℓ) (o ⊔ ℓ)" class="Function">Slices</a> <a id="3894" class="Symbol">.</a><a id="3895" href="Cat.Displayed.Base.html#2265" data-type="(r : Displayed B₁ o′ ℓ′) →
r .Hom[_] f y z → r .Hom[_] g x y → r .Hom[_] (B₁ ._∘_ f g) x z" class="Field Operator">_∘′_</a> <a id="3900" class="Symbol">{</a><a id="3901" class="Argument">x</a> <a id="3903" class="Symbol">=</a> <a id="3905" href="Cat.Displayed.Instances.Slice.html#3905" class="Bound">x</a><a id="3906" class="Symbol">}</a> <a id="3908" class="Symbol">{</a><a id="3909" class="Argument">y</a> <a id="3911" class="Symbol">=</a> <a id="3913" href="Cat.Displayed.Instances.Slice.html#3913" class="Bound">y</a><a id="3914" class="Symbol">}</a> <a id="3916" class="Symbol">{</a><a id="3917" class="Argument">z</a> <a id="3919" class="Symbol">=</a> <a id="3921" href="Cat.Displayed.Instances.Slice.html#3921" class="Bound">z</a><a id="3922" class="Symbol">}</a> <a id="3924" class="Symbol">{</a><a id="3925" class="Argument">f</a> <a id="3927" class="Symbol">=</a> <a id="3929" href="Cat.Displayed.Instances.Slice.html#3929" class="Bound">f</a><a id="3930" class="Symbol">}</a> <a id="3932" class="Symbol">{</a><a id="3933" class="Argument">g</a> <a id="3935" class="Symbol">=</a> <a id="3937" href="Cat.Displayed.Instances.Slice.html#3937" class="Bound">g</a><a id="3938" class="Symbol">}</a> <a id="3940" href="Cat.Displayed.Instances.Slice.html#3940" class="Bound">px</a> <a id="3943" href="Cat.Displayed.Instances.Slice.html#3943" class="Bound">py</a> <a id="3946" class="Symbol">=</a>
  <a id="3950" href="Cat.Displayed.Instances.Slice.html#1982" data-type="(to₁ : Hom B₁ (px .domain) (py .domain))
(commute : (B₁ ∘ f) (px .map) ≡ (B₁ ∘ py .map) to₁) →
Slice-hom B₁ f px py" class="InductiveConstructor">slice-hom</a> <a id="3960" class="Symbol">(</a><a id="3961" href="Cat.Displayed.Instances.Slice.html#3940" class="Bound">px</a> <a id="3964" class="Symbol">.</a><a id="3965" href="Cat.Displayed.Instances.Slice.html#2004" data-type="Slice-hom B₁ f px py → Hom B₁ (px .domain) (py .domain)" class="Field">to</a> <a id="3968" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Field Operator">∘</a> <a id="3970" href="Cat.Displayed.Instances.Slice.html#3943" class="Bound">py</a> <a id="3973" class="Symbol">.</a><a id="3974" href="Cat.Displayed.Instances.Slice.html#2004" data-type="Slice-hom B₁ f px py → Hom B₁ (px .domain) (py .domain)" class="Field">to</a><a id="3976" class="Symbol">)</a> <a id="3978" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a>
    <a id="3984" class="Symbol">(</a><a id="3985" href="Cat.Displayed.Instances.Slice.html#3929" class="Bound">f</a> <a id="3987" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Field Operator">∘</a> <a id="3989" href="Cat.Displayed.Instances.Slice.html#3937" class="Bound">g</a><a id="3990" class="Symbol">)</a> <a id="3992" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Field Operator">∘</a> <a id="3994" href="Cat.Displayed.Instances.Slice.html#3905" class="Bound">x</a> <a id="3996" class="Symbol">.</a><a id="3997" href="Cat.Instances.Slice.html#2306" data-type="(r : /-Obj c) → Hom C (r .domain) c" class="Field">map</a>           <span class="reasoning-step"><span class="as-written Function"><a id="4011" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="4014" href="Cat.Reasoning.html#1678" data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ (C ∘ f) a) b ≡ (C ∘ f) c" class="Function">pullr</a> <a id="4020" class="Symbol">(</a><a id="4021" href="Cat.Displayed.Instances.Slice.html#3943" class="Bound">py</a> <a id="4024" class="Symbol">.</a><a id="4025" href="Cat.Displayed.Instances.Slice.html#2048" data-type="(r : Slice-hom B₁ f px py) →
(B₁ ∘ f) (px .map) ≡ (B₁ ∘ py .map) (r .to)" class="Field">commute</a><a id="4032" class="Symbol">)</a> <a id="4034" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="4040" href="Cat.Displayed.Instances.Slice.html#3929" class="Bound">f</a> <a id="4042" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Field Operator">∘</a> <a id="4044" class="Symbol">(</a><a id="4045" href="Cat.Displayed.Instances.Slice.html#3913" class="Bound">y</a> <a id="4047" class="Symbol">.</a><a id="4048" href="Cat.Instances.Slice.html#2306" data-type="(r : /-Obj c) → Hom C (r .domain) c" class="Field">map</a> <a id="4052" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Field Operator">∘</a> <a id="4054" href="Cat.Displayed.Instances.Slice.html#3943" class="Bound">py</a> <a id="4057" class="Symbol">.</a><a id="4058" href="Cat.Displayed.Instances.Slice.html#2004" data-type="Slice-hom B₁ f px py → Hom B₁ (px .domain) (py .domain)" class="Field">to</a><a id="4060" class="Symbol">)</a>      <span class="reasoning-step"><span class="as-written Function"><a id="4067" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="4070" href="Cat.Reasoning.html#2007" data-type="(C : Precategory o ℓ) (p : (C ∘ f) h ≡ (C ∘ g) i) →
(C ∘ f) ((C ∘ h) b) ≡ (C ∘ g) ((C ∘ i) b)" class="Function">extendl</a> <a id="4078" class="Symbol">(</a><a id="4079" href="Cat.Displayed.Instances.Slice.html#3940" class="Bound">px</a> <a id="4082" class="Symbol">.</a><a id="4083" href="Cat.Displayed.Instances.Slice.html#2048" data-type="(r : Slice-hom B₁ f px py) →
(B₁ ∘ f) (px .map) ≡ (B₁ ∘ py .map) (r .to)" class="Field">commute</a><a id="4090" class="Symbol">)</a> <a id="4092" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="4098" href="Cat.Displayed.Instances.Slice.html#3921" class="Bound">z</a> <a id="4100" class="Symbol">.</a><a id="4101" href="Cat.Instances.Slice.html#2306" data-type="(r : /-Obj c) → Hom C (r .domain) c" class="Field">map</a> <a id="4105" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Field Operator">∘</a> <a id="4107" class="Symbol">(</a><a id="4108" href="Cat.Displayed.Instances.Slice.html#3940" class="Bound">px</a> <a id="4111" class="Symbol">.</a><a id="4112" href="Cat.Displayed.Instances.Slice.html#2004" data-type="Slice-hom B₁ f px py → Hom B₁ (px .domain) (py .domain)" class="Field">to</a> <a id="4115" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Field Operator">∘</a> <a id="4117" href="Cat.Displayed.Instances.Slice.html#3943" class="Bound">py</a> <a id="4120" class="Symbol">.</a><a id="4121" href="Cat.Displayed.Instances.Slice.html#2004" data-type="Slice-hom B₁ f px py → Hom B₁ (px .domain) (py .domain)" class="Field">to</a><a id="4123" class="Symbol">)</a> <a id="4125" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
<a id="4127" href="Cat.Displayed.Instances.Slice.html#3720" data-type="(B₁ : Precategory o ℓ) → Displayed B₁ (o ⊔ ℓ) (o ⊔ ℓ)" class="Function">Slices</a> <a id="4134" class="Symbol">.</a><a id="4135" href="Cat.Displayed.Base.html#3137" data-type="(r : Displayed B₁ o′ ℓ′) (f′ : r .Hom[_] f x y) →
PathP (λ i → r .Hom[_] (B₁ .idr f i) x y) (r ._∘′_ f′ (r .id′)) f′" class="Field">idr′</a> <a id="4140" class="Symbol">{</a><a id="4141" class="Argument">f</a> <a id="4143" class="Symbol">=</a> <a id="4145" href="Cat.Displayed.Instances.Slice.html#4145" class="Bound">f</a><a id="4146" class="Symbol">}</a> <a id="4148" href="Cat.Displayed.Instances.Slice.html#4148" class="Bound">f′</a> <a id="4151" class="Symbol">=</a> <a id="4153" href="Cat.Displayed.Instances.Slice.html#3052" data-type="(B₁ : Precategory o ℓ) (p : f ≡ g) →
f′ .to ≡ g′ .to → PathP (λ i → Slice-hom B₁ (p i) px py) f′ g′" class="Function">Slice-pathp</a> <a id="4165" class="Symbol">(</a><a id="4166" href="Cat.Base.html#3437" data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ f (r .id) ≡ f" class="Field">idr</a> <a id="4170" href="Cat.Displayed.Instances.Slice.html#4145" class="Bound">f</a><a id="4171" class="Symbol">)</a> <a id="4173" class="Symbol">(</a><a id="4174" href="Cat.Base.html#3437" data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ f (r .id) ≡ f" class="Field">idr</a> <a id="4178" class="Symbol">(</a><a id="4179" href="Cat.Displayed.Instances.Slice.html#4148" class="Bound">f′</a> <a id="4182" class="Symbol">.</a><a id="4183" href="Cat.Displayed.Instances.Slice.html#2004" data-type="Slice-hom B₁ f px py → Hom B₁ (px .domain) (py .domain)" class="Field">to</a><a id="4185" class="Symbol">))</a>
<a id="4188" href="Cat.Displayed.Instances.Slice.html#3720" data-type="(B₁ : Precategory o ℓ) → Displayed B₁ (o ⊔ ℓ) (o ⊔ ℓ)" class="Function">Slices</a> <a id="4195" class="Symbol">.</a><a id="4196" href="Cat.Displayed.Base.html#3224" data-type="(r : Displayed B₁ o′ ℓ′) (f′ : r .Hom[_] f x y) →
PathP (λ i → r .Hom[_] (B₁ .idl f i) x y) (r ._∘′_ (r .id′) f′) f′" class="Field">idl′</a> <a id="4201" class="Symbol">{</a><a id="4202" class="Argument">f</a> <a id="4204" class="Symbol">=</a> <a id="4206" href="Cat.Displayed.Instances.Slice.html#4206" class="Bound">f</a><a id="4207" class="Symbol">}</a> <a id="4209" href="Cat.Displayed.Instances.Slice.html#4209" class="Bound">f′</a> <a id="4212" class="Symbol">=</a> <a id="4214" href="Cat.Displayed.Instances.Slice.html#3052" data-type="(B₁ : Precategory o ℓ) (p : f ≡ g) →
f′ .to ≡ g′ .to → PathP (λ i → Slice-hom B₁ (p i) px py) f′ g′" class="Function">Slice-pathp</a> <a id="4226" class="Symbol">(</a><a id="4227" href="Cat.Base.html#3482" data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ (r .id) f ≡ f" class="Field">idl</a> <a id="4231" href="Cat.Displayed.Instances.Slice.html#4206" class="Bound">f</a><a id="4232" class="Symbol">)</a> <a id="4234" class="Symbol">(</a><a id="4235" href="Cat.Base.html#3482" data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ (r .id) f ≡ f" class="Field">idl</a> <a id="4239" class="Symbol">(</a><a id="4240" href="Cat.Displayed.Instances.Slice.html#4209" class="Bound">f′</a> <a id="4243" class="Symbol">.</a><a id="4244" href="Cat.Displayed.Instances.Slice.html#2004" data-type="Slice-hom B₁ f px py → Hom B₁ (px .domain) (py .domain)" class="Field">to</a><a id="4246" class="Symbol">))</a>
<a id="4249" href="Cat.Displayed.Instances.Slice.html#3720" data-type="(B₁ : Precategory o ℓ) → Displayed B₁ (o ⊔ ℓ) (o ⊔ ℓ)" class="Function">Slices</a> <a id="4256" class="Symbol">.</a><a id="4257" href="Cat.Displayed.Base.html#3311" data-type="(r : Displayed B₁ o′ ℓ′) (f′ : r .Hom[_] f y z)
(g′ : r .Hom[_] g x y) (h′ : r .Hom[_] h w x) →
PathP (λ i → r .Hom[_] (B₁ .assoc f g h i) w z)
(r ._∘′_ f′ (r ._∘′_ g′ h′)) (r ._∘′_ (r ._∘′_ f′ g′) h′)" class="Field">assoc′</a> <a id="4264" class="Symbol">{</a><a id="4265" class="Argument">f</a> <a id="4267" class="Symbol">=</a> <a id="4269" href="Cat.Displayed.Instances.Slice.html#4269" class="Bound">f</a><a id="4270" class="Symbol">}</a> <a id="4272" class="Symbol">{</a><a id="4273" class="Argument">g</a> <a id="4275" class="Symbol">=</a> <a id="4277" href="Cat.Displayed.Instances.Slice.html#4277" class="Bound">g</a><a id="4278" class="Symbol">}</a> <a id="4280" class="Symbol">{</a><a id="4281" class="Argument">h</a> <a id="4283" class="Symbol">=</a> <a id="4285" href="Cat.Displayed.Instances.Slice.html#4285" class="Bound">h</a><a id="4286" class="Symbol">}</a> <a id="4288" href="Cat.Displayed.Instances.Slice.html#4288" class="Bound">f′</a> <a id="4291" href="Cat.Displayed.Instances.Slice.html#4291" class="Bound">g′</a> <a id="4294" href="Cat.Displayed.Instances.Slice.html#4294" class="Bound">h′</a> <a id="4297" class="Symbol">=</a>
  <a id="4301" href="Cat.Displayed.Instances.Slice.html#3052" data-type="(B₁ : Precategory o ℓ) (p : f ≡ g) →
f′ .to ≡ g′ .to → PathP (λ i → Slice-hom B₁ (p i) px py) f′ g′" class="Function">Slice-pathp</a> <a id="4313" class="Symbol">(</a><a id="4314" href="Cat.Base.html#3857" data-type="(r : Precategory o h) (f : r .Hom y z) (g : r .Hom x y)
(h : r .Hom w x) →
r ._∘_ f (r ._∘_ g h) ≡ r ._∘_ (r ._∘_ f g) h" class="Field">assoc</a> <a id="4320" href="Cat.Displayed.Instances.Slice.html#4269" class="Bound">f</a> <a id="4322" href="Cat.Displayed.Instances.Slice.html#4277" class="Bound">g</a> <a id="4324" href="Cat.Displayed.Instances.Slice.html#4285" class="Bound">h</a><a id="4325" class="Symbol">)</a> <a id="4327" class="Symbol">(</a><a id="4328" href="Cat.Base.html#3857" data-type="(r : Precategory o h) (f : r .Hom y z) (g : r .Hom x y)
(h : r .Hom w x) →
r ._∘_ f (r ._∘_ g h) ≡ r ._∘_ (r ._∘_ f g) h" class="Field">assoc</a> <a id="4334" class="Symbol">(</a><a id="4335" href="Cat.Displayed.Instances.Slice.html#4288" class="Bound">f′</a> <a id="4338" class="Symbol">.</a><a id="4339" href="Cat.Displayed.Instances.Slice.html#2004" data-type="Slice-hom B₁ f px py → Hom B₁ (px .domain) (py .domain)" class="Field">to</a><a id="4341" class="Symbol">)</a> <a id="4343" class="Symbol">(</a><a id="4344" href="Cat.Displayed.Instances.Slice.html#4291" class="Bound">g′</a> <a id="4347" class="Symbol">.</a><a id="4348" href="Cat.Displayed.Instances.Slice.html#2004" data-type="Slice-hom B₁ f px py → Hom B₁ (px .domain) (py .domain)" class="Field">to</a><a id="4350" class="Symbol">)</a> <a id="4352" class="Symbol">(</a><a id="4353" href="Cat.Displayed.Instances.Slice.html#4294" class="Bound">h′</a> <a id="4356" class="Symbol">.</a><a id="4357" href="Cat.Displayed.Instances.Slice.html#2004" data-type="Slice-hom B₁ f px py → Hom B₁ (px .domain) (py .domain)" class="Field">to</a><a id="4359" class="Symbol">))</a>
</pre>
<p>It’s only slightly more annoying to show that a vertical map in the
canonical self-indexing is a map in the ordinary slice category which,
since the objects displayed over
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>
are <em>defined</em> to be those of the slice category
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">B</mi><mi mathvariant="normal">/</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">\ca{B}/x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.03041em;">B</span><span class="mord">/</span><span class="mord mathnormal">x</span></span></span></span>,</span>
gives an equivalence of categories between the fibre
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><munder accentunder="true"><mi mathvariant="script">B</mi><mo stretchy="true">‾</mo></munder><mo>∗</mo></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\underline{\ca{B}}^*(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0119em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord underline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6833em;"><span style="top:-2.84em;"><span class="pstrut" style="height:3em;"></span><span class="underline-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.03041em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7619em;"><span style="top:-3.1362em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>
and the slice
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">B</mi><mi mathvariant="normal">/</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">\ca{B}/x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.03041em;">B</span><span class="mord">/</span><span class="mord mathnormal">x</span></span></span></span>.</span></p>
<pre class="Agda"><a id="Fibre→slice"></a><a id="4717" href="Cat.Displayed.Instances.Slice.html#4717" data-type="(B₁ : Precategory o ℓ) → Functor (Fibre (Slices B₁) x) (Slice B₁ x)" class="Function">Fibre→slice</a> <a id="4729" class="Symbol">:</a> <a id="4731" class="Symbol">∀</a> <a id="4733" class="Symbol">{</a><a id="4734" href="Cat.Displayed.Instances.Slice.html#4734" class="Bound">x</a><a id="4735" class="Symbol">}</a> <a id="4737" class="Symbol">→</a> <a id="4739" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="4747" class="Symbol">(</a><a id="4748" href="Cat.Displayed.Fibre.html#2876" data-type="(E : Displayed B₁ o′ ℓ′) → B₁ .Ob → Precategory o′ ℓ′" class="Function">Fibre</a> <a id="4754" href="Cat.Displayed.Instances.Slice.html#3720" data-type="(B₁ : Precategory o ℓ) → Displayed B₁ (o ⊔ ℓ) (o ⊔ ℓ)" class="Function">Slices</a> <a id="4761" href="Cat.Displayed.Instances.Slice.html#4734" class="Bound">x</a><a id="4762" class="Symbol">)</a> <a id="4764" class="Symbol">(</a><a id="4765" href="Cat.Instances.Slice.html#4479" data-type="(C : Precategory o ℓ) → Ob C → Precategory (o ⊔ ℓ) ℓ" class="Function">Slice</a> <a id="4771" href="Cat.Displayed.Instances.Slice.html#335" class="Bound">B</a> <a id="4773" href="Cat.Displayed.Instances.Slice.html#4734" class="Bound">x</a><a id="4774" class="Symbol">)</a>
<a id="4776" href="Cat.Displayed.Instances.Slice.html#4717" data-type="(B₁ : Precategory o ℓ) → Functor (Fibre (Slices B₁) x) (Slice B₁ x)" class="Function">Fibre→slice</a> <a id="4788" class="Symbol">.</a><a id="4789" href="Cat.Base.html#7996" data-type="Functor C D → C .Ob → Ob D" class="Field">F₀</a> <a id="4792" href="Cat.Displayed.Instances.Slice.html#4792" class="Bound">x</a> <a id="4794" class="Symbol">=</a> <a id="4796" href="Cat.Displayed.Instances.Slice.html#4792" class="Bound">x</a>
<a id="4798" href="Cat.Displayed.Instances.Slice.html#4717" data-type="(B₁ : Precategory o ℓ) → Functor (Fibre (Slices B₁) x) (Slice B₁ x)" class="Function">Fibre→slice</a> <a id="4810" class="Symbol">.</a><a id="4811" href="Cat.Base.html#8017" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="4814" href="Cat.Displayed.Instances.Slice.html#4814" class="Bound">f</a> <a id="4816" class="Symbol">.</a><a id="4817" href="Cat.Instances.Slice.html#2951" data-type="/-Hom a b → Hom C (a .domain) (domain b)" class="Field">/-Hom.map</a> <a id="4827" class="Symbol">=</a> <a id="4829" href="Cat.Displayed.Instances.Slice.html#4814" class="Bound">f</a> <a id="4831" class="Symbol">.</a><a id="4832" href="Cat.Displayed.Instances.Slice.html#2004" data-type="Slice-hom B₁ f px py → Hom B₁ (px .domain) (py .domain)" class="Field">to</a>
<a id="4835" href="Cat.Displayed.Instances.Slice.html#4717" data-type="(B₁ : Precategory o ℓ) → Functor (Fibre (Slices B₁) x) (Slice B₁ x)" class="Function">Fibre→slice</a> <a id="4847" class="Symbol">.</a><a id="4848" href="Cat.Base.html#8017" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="4851" href="Cat.Displayed.Instances.Slice.html#4851" class="Bound">f</a> <a id="4853" class="Symbol">.</a><a id="4854" href="Cat.Instances.Slice.html#2992" data-type="(r : /-Hom a b) → (C ∘ map b) (r .map) ≡ a .map" class="Field">/-Hom.commutes</a> <a id="4869" class="Symbol">=</a> <a id="4871" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="4875" class="Symbol">(</a><a id="4876" href="Cat.Displayed.Instances.Slice.html#4851" class="Bound">f</a> <a id="4878" class="Symbol">.</a><a id="4879" href="Cat.Displayed.Instances.Slice.html#2048" data-type="(r : Slice-hom B₁ f px py) →
(B₁ ∘ f) (px .map) ≡ (B₁ ∘ py .map) (r .to)" class="Field">commute</a><a id="4886" class="Symbol">)</a> <a id="4888" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="4890" href="Cat.Reasoning.html#1009" data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → (C ∘ a) f ≡ f" class="Function">eliml</a> <a id="4896" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
<a id="4901" href="Cat.Displayed.Instances.Slice.html#4717" data-type="(B₁ : Precategory o ℓ) → Functor (Fibre (Slices B₁) x) (Slice B₁ x)" class="Function">Fibre→slice</a> <a id="4913" class="Symbol">.</a><a id="4914" href="Cat.Base.html#8343" data-type="(r : Functor C D) → r .F₁ (C .id) ≡ id D" class="Field">F-id</a> <a id="4919" class="Symbol">=</a> <a id="4921" href="Cat.Instances.Slice.html#3929" data-type="x .map ≡ y .map → x ≡ y" class="Function">/-Hom-path</a> <a id="4932" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
<a id="4937" href="Cat.Displayed.Instances.Slice.html#4717" data-type="(B₁ : Precategory o ℓ) → Functor (Fibre (Slices B₁) x) (Slice B₁ x)" class="Function">Fibre→slice</a> <a id="4949" class="Symbol">.</a><a id="4950" href="Cat.Base.html#8383" data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" class="Field">F-∘</a> <a id="4954" href="Cat.Displayed.Instances.Slice.html#4954" class="Bound">f</a> <a id="4956" href="Cat.Displayed.Instances.Slice.html#4956" class="Bound">g</a> <a id="4958" class="Symbol">=</a> <a id="4960" href="Cat.Instances.Slice.html#3929" data-type="x .map ≡ y .map → x ≡ y" class="Function">/-Hom-path</a> <a id="4971" class="Symbol">(</a><a id="4972" href="1Lab.Path.html#13454" data-type="(x : A) → transport (λ i → A) x ≡ x" class="Function">transport-refl</a> <a id="4987" class="Symbol">_)</a>

<a id="Fibre→slice-is-ff"></a><a id="4991" href="Cat.Displayed.Instances.Slice.html#4991" data-type="(B₁ : Precategory o ℓ) → is-fully-faithful (Fibre→slice B₁)" class="Function">Fibre→slice-is-ff</a> <a id="5009" class="Symbol">:</a> <a id="5011" class="Symbol">∀</a> <a id="5013" class="Symbol">{</a><a id="5014" href="Cat.Displayed.Instances.Slice.html#5014" class="Bound">x</a><a id="5015" class="Symbol">}</a> <a id="5017" class="Symbol">→</a> <a id="5019" href="Cat.Functor.Base.html#1110" data-type="Functor C D → Type (C.o ⊔ C.h ⊔ D.h)" class="Function">is-fully-faithful</a> <a id="5037" class="Symbol">(</a><a id="5038" href="Cat.Displayed.Instances.Slice.html#4717" data-type="(B₁ : Precategory o ℓ) → Functor (Fibre (Slices B₁) x) (Slice B₁ x)" class="Function">Fibre→slice</a> <a id="5050" class="Symbol">{</a><a id="5051" class="Argument">x</a> <a id="5053" class="Symbol">=</a> <a id="5055" href="Cat.Displayed.Instances.Slice.html#5014" class="Bound">x</a><a id="5056" class="Symbol">})</a>
<a id="5059" href="Cat.Displayed.Instances.Slice.html#4991" data-type="(B₁ : Precategory o ℓ) → is-fully-faithful (Fibre→slice B₁)" class="Function">Fibre→slice-is-ff</a> <a id="5077" class="Symbol">{_}</a> <a id="5081" class="Symbol">{</a><a id="5082" href="Cat.Displayed.Instances.Slice.html#5082" class="Bound">x</a><a id="5083" class="Symbol">}</a> <a id="5085" class="Symbol">{</a><a id="5086" href="Cat.Displayed.Instances.Slice.html#5086" class="Bound">y</a><a id="5087" class="Symbol">}</a> <a id="5089" class="Symbol">=</a> <a id="5091" href="1Lab.Equiv.html#19815" data-type="(i : is-iso f) → is-equiv f" class="Function">is-iso→is-equiv</a> <a id="5107" href="Cat.Displayed.Instances.Slice.html#5120" data-type="(B₁ : Precategory o ℓ) → is-iso (Fibre→slice B₁ .F₁)" class="Function">isom</a> <a id="5112" class="Keyword">where</a>
  <a id="5120" href="Cat.Displayed.Instances.Slice.html#5120" data-type="(B₁ : Precategory o ℓ) → is-iso (Fibre→slice B₁ .F₁)" class="Function">isom</a> <a id="5125" class="Symbol">:</a> <a id="5127" href="1Lab.Equiv.html#6026" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-iso</a> <a id="5134" class="Symbol">(</a><a id="5135" href="Cat.Displayed.Instances.Slice.html#4717" data-type="(B₁ : Precategory o ℓ) → Functor (Fibre (Slices B₁) x) (Slice B₁ x)" class="Function">Fibre→slice</a> <a id="5147" class="Symbol">.</a><a id="5148" href="Cat.Base.html#8017" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a><a id="5150" class="Symbol">)</a>
  <a id="5154" href="Cat.Displayed.Instances.Slice.html#5120" data-type="(B₁ : Precategory o ℓ) → is-iso (Fibre→slice B₁ .F₁)" class="Function">isom</a> <a id="5159" class="Symbol">.</a><a id="5160" href="1Lab.Equiv.html#6132" data-type="is-iso f → B₁ → A" class="Field">is-iso.inv</a> <a id="5171" href="Cat.Displayed.Instances.Slice.html#5171" class="Bound">hom</a> <a id="5175" class="Symbol">=</a>
    <a id="5181" href="Cat.Displayed.Instances.Slice.html#1982" data-type="(to₁ : Hom B₁ (px .domain) (py .domain))
(commute : (B₁ ∘ f) (px .map) ≡ (B₁ ∘ py .map) to₁) →
Slice-hom B₁ f px py" class="InductiveConstructor">slice-hom</a> <a id="5191" class="Symbol">(</a><a id="5192" href="Cat.Displayed.Instances.Slice.html#5171" class="Bound">hom</a> <a id="5196" class="Symbol">.</a><a id="5197" href="Cat.Instances.Slice.html#2951" data-type="/-Hom a b → Hom C (a .domain) (domain b)" class="Field">/-Hom.map</a><a id="5206" class="Symbol">)</a> <a id="5208" class="Symbol">(</a><a id="5209" href="Cat.Reasoning.html#1009" data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → (C ∘ a) f ≡ f" class="Function">eliml</a> <a id="5215" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="5220" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="5222" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="5226" class="Symbol">(</a><a id="5227" href="Cat.Displayed.Instances.Slice.html#5171" class="Bound">hom</a> <a id="5231" class="Symbol">.</a><a id="5232" href="Cat.Instances.Slice.html#2992" data-type="(r : /-Hom a b) → (C ∘ map b) (r .map) ≡ a .map" class="Field">/-Hom.commutes</a><a id="5246" class="Symbol">))</a>
  <a id="5251" href="Cat.Displayed.Instances.Slice.html#5120" data-type="(B₁ : Precategory o ℓ) → is-iso (Fibre→slice B₁ .F₁)" class="Function">isom</a> <a id="5256" class="Symbol">.</a><a id="5257" href="1Lab.Equiv.html#6148" data-type="(r : is-iso f) → is-right-inverse (r .inv) f" class="Field">is-iso.rinv</a> <a id="5269" href="Cat.Displayed.Instances.Slice.html#5269" class="Bound">x</a> <a id="5271" class="Symbol">=</a> <a id="5273" href="Cat.Instances.Slice.html#3929" data-type="x .map ≡ y .map → x ≡ y" class="Function">/-Hom-path</a> <a id="5284" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
  <a id="5291" href="Cat.Displayed.Instances.Slice.html#5120" data-type="(B₁ : Precategory o ℓ) → is-iso (Fibre→slice B₁ .F₁)" class="Function">isom</a> <a id="5296" class="Symbol">.</a><a id="5297" href="1Lab.Equiv.html#6182" data-type="(r : is-iso f) → is-left-inverse (r .inv) f" class="Field">is-iso.linv</a> <a id="5309" href="Cat.Displayed.Instances.Slice.html#5309" class="Bound">x</a> <a id="5311" class="Symbol">=</a> <a id="5313" href="Cat.Displayed.Instances.Slice.html#3052" data-type="(B₁ : Precategory o ℓ) (p : f ≡ g) →
f′ .to ≡ g′ .to → PathP (λ i → Slice-hom B₁ (p i) px py) f′ g′" class="Function">Slice-pathp</a> <a id="5325" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="5330" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>

<a id="Fibre→slice-is-equiv"></a><a id="5336" href="Cat.Displayed.Instances.Slice.html#5336" data-type="(B₁ : Precategory o ℓ) → is-equivalence (Fibre→slice B₁)" class="Function">Fibre→slice-is-equiv</a> <a id="5357" class="Symbol">:</a> <a id="5359" class="Symbol">∀</a> <a id="5361" class="Symbol">{</a><a id="5362" href="Cat.Displayed.Instances.Slice.html#5362" class="Bound">x</a><a id="5363" class="Symbol">}</a> <a id="5365" class="Symbol">→</a> <a id="5367" href="Cat.Functor.Equivalence.html#804" data-type="(F : Functor C D) → Type (C.o ⊔ C.h ⊔ D.o ⊔ D.h)" class="Record">is-equivalence</a> <a id="5382" class="Symbol">(</a><a id="5383" href="Cat.Displayed.Instances.Slice.html#4717" data-type="(B₁ : Precategory o ℓ) → Functor (Fibre (Slices B₁) x) (Slice B₁ x)" class="Function">Fibre→slice</a> <a id="5395" class="Symbol">{</a><a id="5396" href="Cat.Displayed.Instances.Slice.html#5362" class="Bound">x</a><a id="5397" class="Symbol">})</a>
<a id="5400" href="Cat.Displayed.Instances.Slice.html#5336" data-type="(B₁ : Precategory o ℓ) → is-equivalence (Fibre→slice B₁)" class="Function">Fibre→slice-is-equiv</a> <a id="5421" class="Symbol">=</a> <a id="5423" href="Cat.Functor.Equivalence.html#18903" data-type="(p : is-precat-iso F) → is-equivalence F" class="Function">is-precat-iso→is-equivalence</a> <a id="5452" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a>
  <a id="5456" class="Keyword">record</a> <a id="5463" class="Symbol">{</a> <a id="5465" href="Cat.Functor.Equivalence.html#18174" data-type="is-precat-iso F → is-fully-faithful F" class="Field">has-is-ff</a> <a id="5475" class="Symbol">=</a> <a id="5477" href="Cat.Displayed.Instances.Slice.html#4991" data-type="(B₁ : Precategory o ℓ) → is-fully-faithful (Fibre→slice B₁)" class="Function">Fibre→slice-is-ff</a>
         <a id="5504" class="Symbol">;</a> <a id="5506" href="Cat.Functor.Equivalence.html#18211" data-type="is-precat-iso F → is-equiv (F₀ F)" class="Field">has-is-iso</a> <a id="5517" class="Symbol">=</a> <a id="5519" href="1Lab.Equiv.html#2524" data-type="is-equiv (λ x → x)" class="Function">id-equiv</a>
         <a id="5537" class="Symbol">}</a>
</pre>
<h2 id="as-a-fibration"><a href="#as-a-fibration" class="header-link">As
a fibration<span class="header-link-emoji">🔗</span></a></h2>
<p>If (and only if)
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">B</mi></mrow><annotation encoding="application/x-tex">\ca{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.03041em;">B</span></span></span></span>
has all <a href="Cat.Diagram.Pullback.html">pullbacks</a>, then the
self-indexing
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">B</mi></mrow><annotation encoding="application/x-tex">\ca{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.03041em;">B</span></span></span></span>
is a <a href="Cat.Displayed.Cartesian.html">Cartesian fibration</a>.
This is almost by definition, and is in fact where the “Cartesian” in
“Cartesian fibration” (recall that another term for “pullback square” is
“cartesian square”). Since the total space
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∫</mo><munder accentunder="true"><mi mathvariant="script">B</mi><mo stretchy="true">‾</mo></munder></mrow><annotation encoding="application/x-tex">\int \underline{\ca{B}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1111em;vertical-align:-0.3061em;"></span><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord underline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6833em;"><span style="top:-2.84em;"><span class="pstrut" style="height:3em;"></span><span class="underline-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.03041em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2em;"><span></span></span></span></span></span></span></span></span>
is equivalently the arrow category of
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">B</mi></mrow><annotation encoding="application/x-tex">\ca{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.03041em;">B</span></span></span></span>,</span>
with the projection functor
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo>:</mo><mo>∫</mo><munder accentunder="true"><mi mathvariant="script">B</mi><mo stretchy="true">‾</mo></munder><mo>→</mo><mi mathvariant="script">B</mi></mrow><annotation encoding="application/x-tex">\pi : \int \underline{\ca{B}} \to \ca{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1111em;vertical-align:-0.3061em;"></span><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord underline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6833em;"><span style="top:-2.84em;"><span class="pstrut" style="height:3em;"></span><span class="underline-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.03041em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.03041em;">B</span></span></span></span>
corresponding under this equivalence to the codomain functor, we refer
to
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munder accentunder="true"><mrow><mi>c</mi><mi>a</mi><mi>B</mi></mrow><mo stretchy="true">‾</mo></munder></mrow><annotation encoding="application/x-tex">\underline{ca{B}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8833em;vertical-align:-0.2em;"></span><span class="mord underline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6833em;"><span style="top:-2.84em;"><span class="pstrut" style="height:3em;"></span><span class="underline-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="mord mathnormal">a</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2em;"><span></span></span></span></span></span></span></span></span>
regarded as a Cartesian fibration as the <strong>codomain
fibration</strong>.</p>
<pre class="Agda"><a id="Codomain-fibration"></a><a id="6169" href="Cat.Displayed.Instances.Slice.html#6169" data-type="(B₁ : Precategory o ℓ) →
((f : Hom B₁ x y) (g : Hom B₁ z y) → Pullback B₁ f g) →
Cartesian-fibration (Slices B₁)" class="Function">Codomain-fibration</a>
  <a id="6190" class="Symbol">:</a> <a id="6192" class="Symbol">(∀</a> <a id="6195" class="Symbol">{</a><a id="6196" href="Cat.Displayed.Instances.Slice.html#6196" class="Bound">x</a> <a id="6198" href="Cat.Displayed.Instances.Slice.html#6198" class="Bound">y</a> <a id="6200" href="Cat.Displayed.Instances.Slice.html#6200" class="Bound">z</a><a id="6201" class="Symbol">}</a> <a id="6203" class="Symbol">(</a><a id="6204" href="Cat.Displayed.Instances.Slice.html#6204" class="Bound">f</a> <a id="6206" class="Symbol">:</a> <a id="6208" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Field">Hom</a> <a id="6212" href="Cat.Displayed.Instances.Slice.html#6196" class="Bound">x</a> <a id="6214" href="Cat.Displayed.Instances.Slice.html#6198" class="Bound">y</a><a id="6215" class="Symbol">)</a> <a id="6217" class="Symbol">(</a><a id="6218" href="Cat.Displayed.Instances.Slice.html#6218" class="Bound">g</a> <a id="6220" class="Symbol">:</a> <a id="6222" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Field">Hom</a> <a id="6226" href="Cat.Displayed.Instances.Slice.html#6200" class="Bound">z</a> <a id="6228" href="Cat.Displayed.Instances.Slice.html#6198" class="Bound">y</a><a id="6229" class="Symbol">)</a> <a id="6231" class="Symbol">→</a> <a id="6233" href="Cat.Diagram.Pullback.html#2946" data-type="(C : Precategory ℓ ℓ′) (f : Hom C X Z) (g : Hom C Y Z) →
Type (ℓ ⊔ ℓ′)" class="Record">Pullback</a> <a id="6242" href="Cat.Displayed.Instances.Slice.html#335" class="Bound">B</a> <a id="6244" href="Cat.Displayed.Instances.Slice.html#6204" class="Bound">f</a> <a id="6246" href="Cat.Displayed.Instances.Slice.html#6218" class="Bound">g</a><a id="6247" class="Symbol">)</a>
  <a id="6251" class="Symbol">→</a> <a id="6253" href="Cat.Displayed.Cartesian.html#958" data-type="(E : Displayed B₁ o′ ℓ′) → Type (o ⊔ ℓ ⊔ o′ ⊔ ℓ′)" class="Record">Cartesian-fibration</a> <a id="6273" href="Cat.Displayed.Instances.Slice.html#3720" data-type="(B₁ : Precategory o ℓ) → Displayed B₁ (o ⊔ ℓ) (o ⊔ ℓ)" class="Function">Slices</a>
<a id="6280" href="Cat.Displayed.Instances.Slice.html#6169" data-type="(B₁ : Precategory o ℓ) →
((f : Hom B₁ x y) (g : Hom B₁ z y) → Pullback B₁ f g) →
Cartesian-fibration (Slices B₁)" class="Function">Codomain-fibration</a> <a id="6299" href="Cat.Displayed.Instances.Slice.html#6299" class="Bound">pullbacks</a> <a id="6309" class="Symbol">.</a><a id="6310" href="Cat.Displayed.Cartesian.html#1039" data-type="Cartesian-fibration E →
(f : B₁ .Hom x y) (y′ : Ob[ E ] y) → Cartesian-lift E f y′" class="Field">has-lift</a> <a id="6319" href="Cat.Displayed.Instances.Slice.html#6319" class="Bound">f</a> <a id="6321" href="Cat.Displayed.Instances.Slice.html#6321" class="Bound">y′</a> <a id="6324" class="Symbol">=</a> <a id="6326" href="Cat.Displayed.Instances.Slice.html#6382" data-type="(B₁ : Precategory o ℓ)
(pullbacks : (f : Hom B₁ x y) (g : Hom B₁ z y) → Pullback B₁ f g)
(f : B₁ .Hom x y) (y′ : Ob[ Slices B₁ ] y) →
Cartesian-lift (Slices B₁) f y′" class="Function">lift-f</a> <a id="6333" class="Keyword">where</a>
  <a id="6341" class="Keyword">open</a> <a id="6346" href="Cat.Diagram.Pullback.html#2946" data-type="(C : Precategory ℓ ℓ′) (f : Hom C X Z) (g : Hom C Y Z) →
Type (ℓ ⊔ ℓ′)" class="Module">Pullback</a> <a id="6355" class="Symbol">(</a><a id="6356" href="Cat.Displayed.Instances.Slice.html#6299" class="Bound">pullbacks</a> <a id="6366" href="Cat.Displayed.Instances.Slice.html#6319" class="Bound">f</a> <a id="6368" class="Symbol">(</a><a id="6369" href="Cat.Displayed.Instances.Slice.html#6321" class="Bound">y′</a> <a id="6372" class="Symbol">.</a><a id="6373" href="Cat.Instances.Slice.html#2306" data-type="(r : /-Obj c) → Hom C (r .domain) c" class="Field">map</a><a id="6376" class="Symbol">))</a>

  <a id="6382" href="Cat.Displayed.Instances.Slice.html#6382" data-type="(B₁ : Precategory o ℓ)
(pullbacks : (f : Hom B₁ x y) (g : Hom B₁ z y) → Pullback B₁ f g)
(f : B₁ .Hom x y) (y′ : Ob[ Slices B₁ ] y) →
Cartesian-lift (Slices B₁) f y′" class="Function">lift-f</a> <a id="6389" class="Symbol">:</a> <a id="6391" href="Cat.Displayed.Cartesian.html#740" data-type="(E : Displayed B₁ o′ ℓ′) (f : B₁ .Hom x y) (y′ : Ob[ E ] y) →
Type (o ⊔ ℓ ⊔ o′ ⊔ ℓ′)" class="Record">Cartesian-lift</a> <a id="6406" href="Cat.Displayed.Instances.Slice.html#3720" data-type="(B₁ : Precategory o ℓ) → Displayed B₁ (o ⊔ ℓ) (o ⊔ ℓ)" class="Function">Slices</a> <a id="6413" href="Cat.Displayed.Instances.Slice.html#6319" class="Bound">f</a> <a id="6415" href="Cat.Displayed.Instances.Slice.html#6321" class="Bound">y′</a>
  <a id="6420" href="Cat.Displayed.Instances.Slice.html#6382" data-type="(B₁ : Precategory o ℓ)
(pullbacks : (f : Hom B₁ x y) (g : Hom B₁ z y) → Pullback B₁ f g)
(f : B₁ .Hom x y) (y′ : Ob[ Slices B₁ ] y) →
Cartesian-lift (Slices B₁) f y′" class="Function">lift-f</a> <a id="6427" class="Symbol">.</a><a id="6428" href="Cat.Displayed.Cartesian.html#852" data-type="Cartesian-lift E f y′ → Ob[ E ] x" class="Field">x′</a> <a id="6431" class="Symbol">=</a> <a id="6433" href="Cat.Instances.Slice.html#2264" data-type="(map₁ : Hom C domain c) → /-Obj c" class="InductiveConstructor">cut</a> <a id="6437" href="Cat.Diagram.Pullback.html#3041" data-type="(r : Pullback C f g) → Hom C (r .apex) X" class="Function">p₁</a>
  <a id="6442" href="Cat.Displayed.Instances.Slice.html#6382" data-type="(B₁ : Precategory o ℓ)
(pullbacks : (f : Hom B₁ x y) (g : Hom B₁ z y) → Pullback B₁ f g)
(f : B₁ .Hom x y) (y′ : Ob[ Slices B₁ ] y) →
Cartesian-lift (Slices B₁) f y′" class="Function">lift-f</a> <a id="6449" class="Symbol">.</a><a id="6450" href="Cat.Displayed.Cartesian.html#875" data-type="(r : Cartesian-lift E f y′) → Hom[ E ] f (r .x′) y′" class="Field">lifting</a> <a id="6458" class="Symbol">.</a><a id="6459" href="Cat.Displayed.Instances.Slice.html#2004" data-type="Slice-hom B₁ f px py → Hom B₁ (px .domain) (py .domain)" class="Field">to</a> <a id="6462" class="Symbol">=</a> <a id="6464" href="Cat.Diagram.Pullback.html#3061" data-type="(r : Pullback C f g) → Hom C (r .apex) Y" class="Function">p₂</a>
  <a id="6469" href="Cat.Displayed.Instances.Slice.html#6382" data-type="(B₁ : Precategory o ℓ)
(pullbacks : (f : Hom B₁ x y) (g : Hom B₁ z y) → Pullback B₁ f g)
(f : B₁ .Hom x y) (y′ : Ob[ Slices B₁ ] y) →
Cartesian-lift (Slices B₁) f y′" class="Function">lift-f</a> <a id="6476" class="Symbol">.</a><a id="6477" href="Cat.Displayed.Cartesian.html#875" data-type="(r : Cartesian-lift E f y′) → Hom[ E ] f (r .x′) y′" class="Field">lifting</a> <a id="6485" class="Symbol">.</a><a id="6486" href="Cat.Displayed.Instances.Slice.html#2048" data-type="(r : Slice-hom B₁ f px py) →
(B₁ ∘ f) (px .map) ≡ (B₁ ∘ py .map) (r .to)" class="Field">commute</a> <a id="6494" class="Symbol">=</a> <a id="6496" href="Cat.Diagram.Pullback.html#733" data-type="is-pullback C p₁ f p₂ g → (C ∘ f) p₁ ≡ (C ∘ g) p₂" class="Function">square</a>
  <a id="6505" href="Cat.Displayed.Instances.Slice.html#6382" data-type="(B₁ : Precategory o ℓ)
(pullbacks : (f : Hom B₁ x y) (g : Hom B₁ z y) → Pullback B₁ f g)
(f : B₁ .Hom x y) (y′ : Ob[ Slices B₁ ] y) →
Cartesian-lift (Slices B₁) f y′" class="Function">lift-f</a> <a id="6512" class="Symbol">.</a><a id="6513" href="Cat.Displayed.Cartesian.html#906" data-type="(r : Cartesian-lift E f y′) → Cartesian E f (r .lifting)" class="Field">cartesian</a> <a id="6523" class="Symbol">.</a><a id="6524" href="Cat.Displayed.Cartesian.html#389" data-type="Cartesian E f f′ →
(m : B₁ .Hom u a) → Hom[ E ] (B₁ ._∘_ f m) u′ y → Hom[ E ] m u′ x" class="Field">universal</a> <a id="6534" href="Cat.Displayed.Instances.Slice.html#6534" class="Bound">m</a> <a id="6536" href="Cat.Displayed.Instances.Slice.html#6536" class="Bound">h′</a> <a id="6539" class="Symbol">.</a><a id="6540" href="Cat.Displayed.Instances.Slice.html#2004" data-type="Slice-hom B₁ f px py → Hom B₁ (px .domain) (py .domain)" class="Field">to</a> <a id="6543" class="Symbol">=</a> <a id="6545" href="Cat.Diagram.Pullback.html#1452" data-type="is-pullback C p₁ f p₂ g → (C ∘ f) p₁&#39; ≡ (C ∘ g) p₂&#39; → Hom C P′ P" class="Function">limiting</a> <a id="6554" class="Symbol">(</a><a id="6555" href="Cat.Base.html#3857" data-type="(r : Precategory o h) (f : r .Hom y z) (g : r .Hom x y)
(h : r .Hom w x) →
r ._∘_ f (r ._∘_ g h) ≡ r ._∘_ (r ._∘_ f g) h" class="Field">assoc</a> <a id="6561" class="Symbol">_</a> <a id="6563" class="Symbol">_</a> <a id="6565" class="Symbol">_</a> <a id="6567" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="6569" href="Cat.Displayed.Instances.Slice.html#6536" class="Bound">h′</a> <a id="6572" class="Symbol">.</a><a id="6573" href="Cat.Displayed.Instances.Slice.html#2048" data-type="(r : Slice-hom B₁ f px py) →
(B₁ ∘ f) (px .map) ≡ (B₁ ∘ py .map) (r .to)" class="Field">commute</a><a id="6580" class="Symbol">)</a>
  <a id="6584" href="Cat.Displayed.Instances.Slice.html#6382" data-type="(B₁ : Precategory o ℓ)
(pullbacks : (f : Hom B₁ x y) (g : Hom B₁ z y) → Pullback B₁ f g)
(f : B₁ .Hom x y) (y′ : Ob[ Slices B₁ ] y) →
Cartesian-lift (Slices B₁) f y′" class="Function">lift-f</a> <a id="6591" class="Symbol">.</a><a id="6592" href="Cat.Displayed.Cartesian.html#906" data-type="(r : Cartesian-lift E f y′) → Cartesian E f (r .lifting)" class="Field">cartesian</a> <a id="6602" class="Symbol">.</a><a id="6603" href="Cat.Displayed.Cartesian.html#389" data-type="Cartesian E f f′ →
(m : B₁ .Hom u a) → Hom[ E ] (B₁ ._∘_ f m) u′ y → Hom[ E ] m u′ x" class="Field">universal</a> <a id="6613" href="Cat.Displayed.Instances.Slice.html#6613" class="Bound">m</a> <a id="6615" href="Cat.Displayed.Instances.Slice.html#6615" class="Bound">h′</a> <a id="6618" class="Symbol">.</a><a id="6619" href="Cat.Displayed.Instances.Slice.html#2048" data-type="(r : Slice-hom B₁ f px py) →
(B₁ ∘ f) (px .map) ≡ (B₁ ∘ py .map) (r .to)" class="Field">commute</a> <a id="6627" class="Symbol">=</a> <a id="6629" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="6633" href="Cat.Diagram.Pullback.html#1552" data-type="(r : is-pullback C p₁ f p₂ g) → (C ∘ p₁) (r .limiting p) ≡ p₁&#39;" class="Function">p₁∘limiting</a>
  <a id="6647" href="Cat.Displayed.Instances.Slice.html#6382" data-type="(B₁ : Precategory o ℓ)
(pullbacks : (f : Hom B₁ x y) (g : Hom B₁ z y) → Pullback B₁ f g)
(f : B₁ .Hom x y) (y′ : Ob[ Slices B₁ ] y) →
Cartesian-lift (Slices B₁) f y′" class="Function">lift-f</a> <a id="6654" class="Symbol">.</a><a id="6655" href="Cat.Displayed.Cartesian.html#906" data-type="(r : Cartesian-lift E f y′) → Cartesian E f (r .lifting)" class="Field">cartesian</a> <a id="6665" class="Symbol">.</a><a id="6666" href="Cat.Displayed.Cartesian.html#471" data-type="(r : Cartesian E f f′) (m : B₁ .Hom u a)
(h′ : Hom[ E ] (B₁ ._∘_ f m) u′ y) →
(E ∘′ f′) (r .universal m h′) ≡ h′" class="Field">commutes</a> <a id="6675" href="Cat.Displayed.Instances.Slice.html#6675" class="Bound">m</a> <a id="6677" href="Cat.Displayed.Instances.Slice.html#6677" class="Bound">h′</a> <a id="6680" class="Symbol">=</a> <a id="6682" href="Cat.Displayed.Instances.Slice.html#3052" data-type="(B₁ : Precategory o ℓ) (p : f ≡ g) →
f′ .to ≡ g′ .to → PathP (λ i → Slice-hom B₁ (p i) px py) f′ g′" class="Function">Slice-pathp</a> <a id="6694" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="6699" href="Cat.Diagram.Pullback.html#1618" data-type="(r : is-pullback C p₁ f p₂ g) → (C ∘ p₂) (r .limiting p) ≡ p₂&#39;" class="Function">p₂∘limiting</a>
  <a id="6713" href="Cat.Displayed.Instances.Slice.html#6382" data-type="(B₁ : Precategory o ℓ)
(pullbacks : (f : Hom B₁ x y) (g : Hom B₁ z y) → Pullback B₁ f g)
(f : B₁ .Hom x y) (y′ : Ob[ Slices B₁ ] y) →
Cartesian-lift (Slices B₁) f y′" class="Function">lift-f</a> <a id="6720" class="Symbol">.</a><a id="6721" href="Cat.Displayed.Cartesian.html#906" data-type="(r : Cartesian-lift E f y′) → Cartesian E f (r .lifting)" class="Field">cartesian</a> <a id="6731" class="Symbol">.</a><a id="6732" href="Cat.Displayed.Cartesian.html#581" data-type="(r : Cartesian E f f′) (m′ : Hom[ E ] m u′ x) →
(E ∘′ f′) m′ ≡ h′ → m′ ≡ r .universal m h′" class="Field">unique</a> <a id="6739" href="Cat.Displayed.Instances.Slice.html#6739" class="Bound">m′</a> <a id="6742" href="Cat.Displayed.Instances.Slice.html#6742" class="Bound">x</a> <a id="6744" class="Symbol">=</a> <a id="6746" href="Cat.Displayed.Instances.Slice.html#3052" data-type="(B₁ : Precategory o ℓ) (p : f ≡ g) →
f′ .to ≡ g′ .to → PathP (λ i → Slice-hom B₁ (p i) px py) f′ g′" class="Function">Slice-pathp</a> <a id="6758" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="6763" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a>
    <a id="6769" href="Cat.Diagram.Pullback.html#1685" data-type="(r : is-pullback C p₁ f p₂ g) →
(C ∘ p₁) lim&#39; ≡ p₁&#39; → (C ∘ p₂) lim&#39; ≡ p₂&#39; → lim&#39; ≡ r .limiting p" class="Function">Pullback.unique</a> <a id="6785" class="Symbol">(</a><a id="6786" href="Cat.Displayed.Instances.Slice.html#6299" class="Bound">pullbacks</a> <a id="6796" href="Cat.Displayed.Instances.Slice.html#6319" class="Bound">f</a> <a id="6798" class="Symbol">(</a><a id="6799" href="Cat.Displayed.Instances.Slice.html#6321" class="Bound">y′</a> <a id="6802" class="Symbol">.</a><a id="6803" href="Cat.Instances.Slice.html#2306" data-type="(r : /-Obj c) → Hom C (r .domain) c" class="Field">map</a><a id="6806" class="Symbol">))</a> <a id="6809" class="Symbol">(</a><a id="6810" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="6814" class="Symbol">(</a><a id="6815" href="Cat.Displayed.Instances.Slice.html#6739" class="Bound">m′</a> <a id="6818" class="Symbol">.</a><a id="6819" href="Cat.Displayed.Instances.Slice.html#2048" data-type="(r : Slice-hom B₁ f px py) →
(B₁ ∘ f) (px .map) ≡ (B₁ ∘ py .map) (r .to)" class="Field">commute</a><a id="6826" class="Symbol">))</a> <a id="6829" class="Symbol">(</a><a id="6830" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="6833" href="Cat.Displayed.Instances.Slice.html#2004" data-type="Slice-hom B₁ f px py → Hom B₁ (px .domain) (py .domain)" class="Field">to</a> <a id="6836" href="Cat.Displayed.Instances.Slice.html#6742" class="Bound">x</a><a id="6837" class="Symbol">)</a>
</pre>
<p>Since the proof that
<span class="Agda"><a href="Cat.Displayed.Instances.Slice.html#3720" class="Function">Slices</a></span>
is a cartesian fibration is given by essentially rearranging the data of
pullbacks in
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">B</mi></mrow><annotation encoding="application/x-tex">\ca{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.03041em;">B</span></span></span></span>,</span>
we also have the converse implication: If
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munder accentunder="true"><mi mathvariant="script">B</mi><mo stretchy="true">‾</mo></munder></mrow><annotation encoding="application/x-tex">\underline{\ca{B}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8833em;vertical-align:-0.2em;"></span><span class="mord underline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6833em;"><span style="top:-2.84em;"><span class="pstrut" style="height:3em;"></span><span class="underline-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.03041em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2em;"><span></span></span></span></span></span></span></span></span>
is a Cartesian fibration, then
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">B</mi></mrow><annotation encoding="application/x-tex">\ca{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.03041em;">B</span></span></span></span>
has all pullbacks.</p>
<pre class="Agda"><a id="Codomain-fibration→pullbacks"></a><a id="7200" href="Cat.Displayed.Instances.Slice.html#7200" data-type="(B₁ : Precategory o ℓ) (f : Hom B₁ x y) (g : Hom B₁ z y) →
Cartesian-fibration (Slices B₁) → Pullback B₁ f g" class="Function">Codomain-fibration→pullbacks</a>
  <a id="7231" class="Symbol">:</a> <a id="7233" class="Symbol">∀</a> <a id="7235" class="Symbol">{</a><a id="7236" href="Cat.Displayed.Instances.Slice.html#7236" class="Bound">x</a> <a id="7238" href="Cat.Displayed.Instances.Slice.html#7238" class="Bound">y</a> <a id="7240" href="Cat.Displayed.Instances.Slice.html#7240" class="Bound">z</a><a id="7241" class="Symbol">}</a> <a id="7243" class="Symbol">(</a><a id="7244" href="Cat.Displayed.Instances.Slice.html#7244" class="Bound">f</a> <a id="7246" class="Symbol">:</a> <a id="7248" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Field">Hom</a> <a id="7252" href="Cat.Displayed.Instances.Slice.html#7236" class="Bound">x</a> <a id="7254" href="Cat.Displayed.Instances.Slice.html#7238" class="Bound">y</a><a id="7255" class="Symbol">)</a> <a id="7257" class="Symbol">(</a><a id="7258" href="Cat.Displayed.Instances.Slice.html#7258" class="Bound">g</a> <a id="7260" class="Symbol">:</a> <a id="7262" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Field">Hom</a> <a id="7266" href="Cat.Displayed.Instances.Slice.html#7240" class="Bound">z</a> <a id="7268" href="Cat.Displayed.Instances.Slice.html#7238" class="Bound">y</a><a id="7269" class="Symbol">)</a>
  <a id="7273" class="Symbol">→</a> <a id="7275" href="Cat.Displayed.Cartesian.html#958" data-type="(E : Displayed B₁ o′ ℓ′) → Type (o ⊔ ℓ ⊔ o′ ⊔ ℓ′)" class="Record">Cartesian-fibration</a> <a id="7295" href="Cat.Displayed.Instances.Slice.html#3720" data-type="(B₁ : Precategory o ℓ) → Displayed B₁ (o ⊔ ℓ) (o ⊔ ℓ)" class="Function">Slices</a>
  <a id="7304" class="Symbol">→</a> <a id="7306" href="Cat.Diagram.Pullback.html#2946" data-type="(C : Precategory ℓ ℓ′) (f : Hom C X Z) (g : Hom C Y Z) →
Type (ℓ ⊔ ℓ′)" class="Record">Pullback</a> <a id="7315" href="Cat.Displayed.Instances.Slice.html#335" class="Bound">B</a> <a id="7317" href="Cat.Displayed.Instances.Slice.html#7244" class="Bound">f</a> <a id="7319" href="Cat.Displayed.Instances.Slice.html#7258" class="Bound">g</a>
<a id="7321" href="Cat.Displayed.Instances.Slice.html#7200" data-type="(B₁ : Precategory o ℓ) (f : Hom B₁ x y) (g : Hom B₁ z y) →
Cartesian-fibration (Slices B₁) → Pullback B₁ f g" class="Function">Codomain-fibration→pullbacks</a> <a id="7350" href="Cat.Displayed.Instances.Slice.html#7350" class="Bound">f</a> <a id="7352" href="Cat.Displayed.Instances.Slice.html#7352" class="Bound">g</a> <a id="7354" href="Cat.Displayed.Instances.Slice.html#7354" class="Bound">lifts</a> <a id="7360" class="Symbol">=</a> <a id="7362" href="Cat.Displayed.Instances.Slice.html#7448" data-type="(B₁ : Precategory o ℓ) (f : Hom B₁ x y) (g : Hom B₁ z y)
(lifts : Cartesian-fibration (Slices B₁)) →
Pullback B₁ f g" class="Function">pb</a> <a id="7365" class="Keyword">where</a>
  <a id="7373" class="Keyword">open</a> <a id="7378" href="Cat.Diagram.Pullback.html#2946" data-type="(C : Precategory ℓ ℓ′) (f : Hom C X Z) (g : Hom C Y Z) →
Type (ℓ ⊔ ℓ′)" class="Module">Pullback</a>
  <a id="7389" class="Keyword">open</a> <a id="7394" href="Cat.Diagram.Pullback.html#622" data-type="(C : Precategory ℓ ℓ′) (p₁ : Hom C P X) (f : Hom C X Z)
(p₂ : Hom C P Y) (g : Hom C Y Z) →
Type (ℓ ⊔ ℓ′)" class="Module">is-pullback</a>
  <a id="7408" href="Cat.Displayed.Instances.Slice.html#7408" data-type="(B₁ : Precategory o ℓ) (f : Hom B₁ x y) (g : Hom B₁ z y)
(lifts : Cartesian-fibration (Slices B₁)) →
Cartesian-lift (Slices B₁) f (cut g)" class="Function">the-lift</a> <a id="7417" class="Symbol">=</a> <a id="7419" href="Cat.Displayed.Instances.Slice.html#7354" class="Bound">lifts</a> <a id="7425" class="Symbol">.</a><a id="7426" href="Cat.Displayed.Cartesian.html#1039" data-type="Cartesian-fibration E →
(f : B₁ .Hom x y) (y′ : Ob[ E ] y) → Cartesian-lift E f y′" class="Field">has-lift</a> <a id="7435" href="Cat.Displayed.Instances.Slice.html#7350" class="Bound">f</a> <a id="7437" class="Symbol">(</a><a id="7438" href="Cat.Instances.Slice.html#2264" data-type="(map₁ : Hom C domain c) → /-Obj c" class="InductiveConstructor">cut</a> <a id="7442" href="Cat.Displayed.Instances.Slice.html#7352" class="Bound">g</a><a id="7443" class="Symbol">)</a>

  <a id="7448" href="Cat.Displayed.Instances.Slice.html#7448" data-type="(B₁ : Precategory o ℓ) (f : Hom B₁ x y) (g : Hom B₁ z y)
(lifts : Cartesian-fibration (Slices B₁)) →
Pullback B₁ f g" class="Function">pb</a> <a id="7451" class="Symbol">:</a> <a id="7453" href="Cat.Diagram.Pullback.html#2946" data-type="(C : Precategory ℓ ℓ′) (f : Hom C X Z) (g : Hom C Y Z) →
Type (ℓ ⊔ ℓ′)" class="Record">Pullback</a> <a id="7462" href="Cat.Displayed.Instances.Slice.html#335" class="Bound">B</a> <a id="7464" href="Cat.Displayed.Instances.Slice.html#7350" class="Bound">f</a> <a id="7466" href="Cat.Displayed.Instances.Slice.html#7352" class="Bound">g</a>
  <a id="7470" href="Cat.Displayed.Instances.Slice.html#7448" data-type="(B₁ : Precategory o ℓ) (f : Hom B₁ x y) (g : Hom B₁ z y)
(lifts : Cartesian-fibration (Slices B₁)) →
Pullback B₁ f g" class="Function">pb</a> <a id="7473" class="Symbol">.</a><a id="7474" href="Cat.Diagram.Pullback.html#3026" data-type="Pullback C f g → Ob C" class="Field">apex</a> <a id="7479" class="Symbol">=</a> <a id="7481" href="Cat.Displayed.Instances.Slice.html#7408" data-type="(B₁ : Precategory o ℓ) (f : Hom B₁ x y) (g : Hom B₁ z y)
(lifts : Cartesian-fibration (Slices B₁)) →
Cartesian-lift (Slices B₁) f (cut g)" class="Function">the-lift</a> <a id="7490" class="Symbol">.</a><a id="7491" href="Cat.Displayed.Cartesian.html#852" data-type="Cartesian-lift E f y′ → Ob[ E ] x" class="Field">x′</a> <a id="7494" class="Symbol">.</a><a id="7495" href="Cat.Instances.Slice.html#2285" data-type="/-Obj c → Ob C" class="Field">domain</a>
  <a id="7504" href="Cat.Displayed.Instances.Slice.html#7448" data-type="(B₁ : Precategory o ℓ) (f : Hom B₁ x y) (g : Hom B₁ z y)
(lifts : Cartesian-fibration (Slices B₁)) →
Pullback B₁ f g" class="Function">pb</a> <a id="7507" class="Symbol">.</a><a id="7508" href="Cat.Diagram.Pullback.html#3041" data-type="(r : Pullback C f g) → Hom C (r .apex) X" class="Field">p₁</a> <a id="7511" class="Symbol">=</a> <a id="7513" href="Cat.Displayed.Instances.Slice.html#7408" data-type="(B₁ : Precategory o ℓ) (f : Hom B₁ x y) (g : Hom B₁ z y)
(lifts : Cartesian-fibration (Slices B₁)) →
Cartesian-lift (Slices B₁) f (cut g)" class="Function">the-lift</a> <a id="7522" class="Symbol">.</a><a id="7523" href="Cat.Displayed.Cartesian.html#852" data-type="Cartesian-lift E f y′ → Ob[ E ] x" class="Field">x′</a> <a id="7526" class="Symbol">.</a><a id="7527" href="Cat.Instances.Slice.html#2306" data-type="(r : /-Obj c) → Hom C (r .domain) c" class="Field">map</a>
  <a id="7533" href="Cat.Displayed.Instances.Slice.html#7448" data-type="(B₁ : Precategory o ℓ) (f : Hom B₁ x y) (g : Hom B₁ z y)
(lifts : Cartesian-fibration (Slices B₁)) →
Pullback B₁ f g" class="Function">pb</a> <a id="7536" class="Symbol">.</a><a id="7537" href="Cat.Diagram.Pullback.html#3061" data-type="(r : Pullback C f g) → Hom C (r .apex) Y" class="Field">p₂</a> <a id="7540" class="Symbol">=</a> <a id="7542" href="Cat.Displayed.Instances.Slice.html#7408" data-type="(B₁ : Precategory o ℓ) (f : Hom B₁ x y) (g : Hom B₁ z y)
(lifts : Cartesian-fibration (Slices B₁)) →
Cartesian-lift (Slices B₁) f (cut g)" class="Function">the-lift</a> <a id="7551" class="Symbol">.</a><a id="7552" href="Cat.Displayed.Cartesian.html#875" data-type="(r : Cartesian-lift E f y′) → Hom[ E ] f (r .x′) y′" class="Field">lifting</a> <a id="7560" class="Symbol">.</a><a id="7561" href="Cat.Displayed.Instances.Slice.html#2004" data-type="Slice-hom B₁ f px py → Hom B₁ (px .domain) (py .domain)" class="Field">to</a>
  <a id="7566" href="Cat.Displayed.Instances.Slice.html#7448" data-type="(B₁ : Precategory o ℓ) (f : Hom B₁ x y) (g : Hom B₁ z y)
(lifts : Cartesian-fibration (Slices B₁)) →
Pullback B₁ f g" class="Function">pb</a> <a id="7569" class="Symbol">.</a><a id="7570" href="Cat.Diagram.Pullback.html#3081" data-type="(r : Pullback C f g) → is-pullback C (r .p₁) f (r .p₂) g" class="Field">has-is-pb</a> <a id="7580" class="Symbol">.</a><a id="7581" href="Cat.Diagram.Pullback.html#733" data-type="is-pullback C p₁ f p₂ g → (C ∘ f) p₁ ≡ (C ∘ g) p₂" class="Field">square</a> <a id="7588" class="Symbol">=</a> <a id="7590" href="Cat.Displayed.Instances.Slice.html#7408" data-type="(B₁ : Precategory o ℓ) (f : Hom B₁ x y) (g : Hom B₁ z y)
(lifts : Cartesian-fibration (Slices B₁)) →
Cartesian-lift (Slices B₁) f (cut g)" class="Function">the-lift</a> <a id="7599" class="Symbol">.</a><a id="7600" href="Cat.Displayed.Cartesian.html#875" data-type="(r : Cartesian-lift E f y′) → Hom[ E ] f (r .x′) y′" class="Field">lifting</a> <a id="7608" class="Symbol">.</a><a id="7609" href="Cat.Displayed.Instances.Slice.html#2048" data-type="(r : Slice-hom B₁ f px py) →
(B₁ ∘ f) (px .map) ≡ (B₁ ∘ py .map) (r .to)" class="Field">commute</a>
  <a id="7619" href="Cat.Displayed.Instances.Slice.html#7448" data-type="(B₁ : Precategory o ℓ) (f : Hom B₁ x y) (g : Hom B₁ z y)
(lifts : Cartesian-fibration (Slices B₁)) →
Pullback B₁ f g" class="Function">pb</a> <a id="7622" class="Symbol">.</a><a id="7623" href="Cat.Diagram.Pullback.html#3081" data-type="(r : Pullback C f g) → is-pullback C (r .p₁) f (r .p₂) g" class="Field">has-is-pb</a> <a id="7633" class="Symbol">.</a><a id="7634" href="Cat.Diagram.Pullback.html#1452" data-type="is-pullback C p₁ f p₂ g → (C ∘ f) p₁&#39; ≡ (C ∘ g) p₂&#39; → Hom C P′ P" class="Field">limiting</a> <a id="7643" class="Symbol">{</a><a id="7644" class="Argument">p₁&#39;</a> <a id="7648" class="Symbol">=</a> <a id="7650" href="Cat.Displayed.Instances.Slice.html#7650" class="Bound">p₁&#39;</a><a id="7653" class="Symbol">}</a> <a id="7655" class="Symbol">{</a><a id="7656" href="Cat.Displayed.Instances.Slice.html#7656" class="Bound">p₂&#39;</a><a id="7659" class="Symbol">}</a> <a id="7661" href="Cat.Displayed.Instances.Slice.html#7661" class="Bound">p</a> <a id="7663" class="Symbol">=</a>
    <a id="7669" href="Cat.Displayed.Instances.Slice.html#7408" data-type="(B₁ : Precategory o ℓ) (f : Hom B₁ x y) (g : Hom B₁ z y)
(lifts : Cartesian-fibration (Slices B₁)) →
Cartesian-lift (Slices B₁) f (cut g)" class="Function">the-lift</a> <a id="7678" class="Symbol">.</a><a id="7679" href="Cat.Displayed.Cartesian.html#906" data-type="(r : Cartesian-lift E f y′) → Cartesian E f (r .lifting)" class="Field">cartesian</a> <a id="7689" class="Symbol">.</a><a id="7690" href="Cat.Displayed.Cartesian.html#389" data-type="Cartesian E f f′ →
(m : B₁ .Hom u a) → Hom[ E ] (B₁ ._∘_ f m) u′ y → Hom[ E ] m u′ x" class="Field">universal</a> <a id="7700" class="Symbol">{</a><a id="7701" class="Argument">u′</a> <a id="7704" class="Symbol">=</a> <a id="7706" href="Cat.Instances.Slice.html#2264" data-type="(map₁ : Hom C domain c) → /-Obj c" class="InductiveConstructor">cut</a> <a id="7710" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Field">id</a><a id="7712" class="Symbol">}</a>
      <a id="7720" href="Cat.Displayed.Instances.Slice.html#7650" class="Bound">p₁&#39;</a> <a id="7724" class="Symbol">(</a><a id="7725" href="Cat.Displayed.Instances.Slice.html#1982" data-type="(to₁ : Hom B₁ (px .domain) (py .domain))
(commute : (B₁ ∘ f) (px .map) ≡ (B₁ ∘ py .map) to₁) →
Slice-hom B₁ f px py" class="InductiveConstructor">slice-hom</a> <a id="7735" href="Cat.Displayed.Instances.Slice.html#7656" class="Bound">p₂&#39;</a> <a id="7739" class="Symbol">(</a><a id="7740" href="Cat.Reasoning.html#1678" data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ (C ∘ f) a) b ≡ (C ∘ f) c" class="Function">pullr</a> <a id="7746" class="Symbol">(</a><a id="7747" href="Cat.Base.html#3437" data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ f (r .id) ≡ f" class="Field">idr</a> <a id="7751" class="Symbol">_)</a> <a id="7754" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="7756" href="Cat.Displayed.Instances.Slice.html#7661" class="Bound">p</a><a id="7757" class="Symbol">))</a> <a id="7760" class="Symbol">.</a><a id="7761" href="Cat.Displayed.Instances.Slice.html#2004" data-type="Slice-hom B₁ f px py → Hom B₁ (px .domain) (py .domain)" class="Field">to</a>
  <a id="7766" href="Cat.Displayed.Instances.Slice.html#7448" data-type="(B₁ : Precategory o ℓ) (f : Hom B₁ x y) (g : Hom B₁ z y)
(lifts : Cartesian-fibration (Slices B₁)) →
Pullback B₁ f g" class="Function">pb</a> <a id="7769" class="Symbol">.</a><a id="7770" href="Cat.Diagram.Pullback.html#3081" data-type="(r : Pullback C f g) → is-pullback C (r .p₁) f (r .p₂) g" class="Field">has-is-pb</a> <a id="7780" class="Symbol">.</a><a id="7781" href="Cat.Diagram.Pullback.html#1552" data-type="(r : is-pullback C p₁ f p₂ g) → (C ∘ p₁) (r .limiting p) ≡ p₁&#39;" class="Field">p₁∘limiting</a> <a id="7793" class="Symbol">=</a>
    <a id="7799" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="7803" class="Symbol">(</a><a id="7804" href="Cat.Displayed.Instances.Slice.html#7408" data-type="(B₁ : Precategory o ℓ) (f : Hom B₁ x y) (g : Hom B₁ z y)
(lifts : Cartesian-fibration (Slices B₁)) →
Cartesian-lift (Slices B₁) f (cut g)" class="Function">the-lift</a> <a id="7813" class="Symbol">.</a><a id="7814" href="Cat.Displayed.Cartesian.html#906" data-type="(r : Cartesian-lift E f y′) → Cartesian E f (r .lifting)" class="Field">cartesian</a> <a id="7824" class="Symbol">.</a><a id="7825" href="Cat.Displayed.Cartesian.html#389" data-type="Cartesian E f f′ →
(m : B₁ .Hom u a) → Hom[ E ] (B₁ ._∘_ f m) u′ y → Hom[ E ] m u′ x" class="Field">universal</a> <a id="7835" class="Symbol">_</a> <a id="7837" class="Symbol">_</a> <a id="7839" class="Symbol">.</a><a id="7840" href="Cat.Displayed.Instances.Slice.html#2048" data-type="(r : Slice-hom B₁ f px py) →
(B₁ ∘ f) (px .map) ≡ (B₁ ∘ py .map) (r .to)" class="Field">commute</a><a id="7847" class="Symbol">)</a> <a id="7849" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="7851" href="Cat.Base.html#3437" data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ f (r .id) ≡ f" class="Field">idr</a> <a id="7855" class="Symbol">_</a>
  <a id="7859" href="Cat.Displayed.Instances.Slice.html#7448" data-type="(B₁ : Precategory o ℓ) (f : Hom B₁ x y) (g : Hom B₁ z y)
(lifts : Cartesian-fibration (Slices B₁)) →
Pullback B₁ f g" class="Function">pb</a> <a id="7862" class="Symbol">.</a><a id="7863" href="Cat.Diagram.Pullback.html#3081" data-type="(r : Pullback C f g) → is-pullback C (r .p₁) f (r .p₂) g" class="Field">has-is-pb</a> <a id="7873" class="Symbol">.</a><a id="7874" href="Cat.Diagram.Pullback.html#1618" data-type="(r : is-pullback C p₁ f p₂ g) → (C ∘ p₂) (r .limiting p) ≡ p₂&#39;" class="Field">p₂∘limiting</a> <a id="7886" class="Symbol">=</a> <a id="7888" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="7891" href="Cat.Displayed.Instances.Slice.html#2004" data-type="Slice-hom B₁ f px py → Hom B₁ (px .domain) (py .domain)" class="Field">to</a> <a id="7894" class="Symbol">(</a><a id="7895" href="Cat.Displayed.Instances.Slice.html#7408" data-type="(B₁ : Precategory o ℓ) (f : Hom B₁ x y) (g : Hom B₁ z y)
(lifts : Cartesian-fibration (Slices B₁)) →
Cartesian-lift (Slices B₁) f (cut g)" class="Function">the-lift</a> <a id="7904" class="Symbol">.</a><a id="7905" href="Cat.Displayed.Cartesian.html#906" data-type="(r : Cartesian-lift E f y′) → Cartesian E f (r .lifting)" class="Field">cartesian</a> <a id="7915" class="Symbol">.</a><a id="7916" href="Cat.Displayed.Cartesian.html#471" data-type="(r : Cartesian E f f′) (m : B₁ .Hom u a)
(h′ : Hom[ E ] (B₁ ._∘_ f m) u′ y) →
(E ∘′ f′) (r .universal m h′) ≡ h′" class="Field">commutes</a> <a id="7925" class="Symbol">_</a> <a id="7927" class="Symbol">_)</a>
  <a id="7932" href="Cat.Displayed.Instances.Slice.html#7448" data-type="(B₁ : Precategory o ℓ) (f : Hom B₁ x y) (g : Hom B₁ z y)
(lifts : Cartesian-fibration (Slices B₁)) →
Pullback B₁ f g" class="Function">pb</a> <a id="7935" class="Symbol">.</a><a id="7936" href="Cat.Diagram.Pullback.html#3081" data-type="(r : Pullback C f g) → is-pullback C (r .p₁) f (r .p₂) g" class="Field">has-is-pb</a> <a id="7946" class="Symbol">.</a><a id="7947" href="Cat.Diagram.Pullback.html#1685" data-type="(r : is-pullback C p₁ f p₂ g) →
(C ∘ p₁) lim&#39; ≡ p₁&#39; → (C ∘ p₂) lim&#39; ≡ p₂&#39; → lim&#39; ≡ r .limiting p" class="Field">unique</a> <a id="7954" href="Cat.Displayed.Instances.Slice.html#7954" class="Bound">p</a> <a id="7956" href="Cat.Displayed.Instances.Slice.html#7956" class="Bound">q</a> <a id="7958" class="Symbol">=</a> <a id="7960" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="7963" href="Cat.Displayed.Instances.Slice.html#2004" data-type="Slice-hom B₁ f px py → Hom B₁ (px .domain) (py .domain)" class="Field">to</a> <a id="7966" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="7968" href="Cat.Displayed.Instances.Slice.html#7408" data-type="(B₁ : Precategory o ℓ) (f : Hom B₁ x y) (g : Hom B₁ z y)
(lifts : Cartesian-fibration (Slices B₁)) →
Cartesian-lift (Slices B₁) f (cut g)" class="Function">the-lift</a> <a id="7977" class="Symbol">.</a><a id="7978" href="Cat.Displayed.Cartesian.html#906" data-type="(r : Cartesian-lift E f y′) → Cartesian E f (r .lifting)" class="Field">cartesian</a> <a id="7988" class="Symbol">.</a><a id="7989" href="Cat.Displayed.Cartesian.html#581" data-type="(r : Cartesian E f f′) (m′ : Hom[ E ] m u′ x) →
(E ∘′ f′) m′ ≡ h′ → m′ ≡ r .universal m h′" class="Field">unique</a>
    <a id="8000" class="Symbol">(</a><a id="8001" href="Cat.Displayed.Instances.Slice.html#1982" data-type="(to₁ : Hom B₁ (px .domain) (py .domain))
(commute : (B₁ ∘ f) (px .map) ≡ (B₁ ∘ py .map) to₁) →
Slice-hom B₁ f px py" class="InductiveConstructor">slice-hom</a> <a id="8011" class="Symbol">_</a> <a id="8013" class="Symbol">(</a><a id="8014" href="Cat.Base.html#3437" data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ f (r .id) ≡ f" class="Field">idr</a> <a id="8018" class="Symbol">_</a> <a id="8020" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="8022" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="8026" href="Cat.Displayed.Instances.Slice.html#7954" class="Bound">p</a><a id="8027" class="Symbol">))</a> <a id="8030" class="Symbol">(</a><a id="8031" href="Cat.Displayed.Instances.Slice.html#3052" data-type="(B₁ : Precategory o ℓ) (p : f ≡ g) →
f′ .to ≡ g′ .to → PathP (λ i → Slice-hom B₁ (p i) px py) f′ g′" class="Function">Slice-pathp</a> <a id="8043" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="8048" href="Cat.Displayed.Instances.Slice.html#7956" class="Bound">q</a><a id="8049" class="Symbol">)</a>
</pre>
<p>Since the fibres of the codomain fibration are given by slice
categories, then the interpretation of Cartesian fibrations as
“displayed categories whose fibres vary functorially” leads us to
reinterpret the above results as, essentially, giving the <a href="Cat.Functor.Pullback.html">pullback functors</a> between slice
categories.</p>
<hr />
<section id="refs" role="doc-bibliography">
<h2>References</h2>
<ul>
<li id="ref-relativect" role="doc-biblioentry">Sterling, Jonathan, and Carlo Angiuli. 2022. <span>“Foundations of
Relative Category Theory.”</span> <a href="https://www.jonmsterling.com/math/lectures/categorical-foundations.html">https://www.jonmsterling.com/math/lectures/categorical-foundations.html</a>.</li>
</ul>
</section>
  </article>
</div>
</main>
</body>
</html>
