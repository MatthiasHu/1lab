<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="keywords" content="Agda,categories,topos" />

  <title>SHT.Base - 1Lab</title>

  <link rel="stylesheet" href="/css/default.css" />
  <link rel="stylesheet" href="/css/katex.min.css" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="SHT.Base - 1Lab" />
  <meta name="twitter:image" content="https://1lab.dev/static/cube-128x.png" />

  <meta name="og:title" content="SHT.Base - 1Lab" />
  <meta name="og:image" content="https://1lab.dev/static/cube-128x.png" />
  <meta name="og:site-name" content="1Lab" />
  <meta name="og:type" content="website" />

    <meta name="og:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="twitter:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  
  <script defer src="/main.js"></script>

  <noscript>
    <style>
      body span.reasoning-step .as-written {
        display: inline;
      }

      body span.reasoning-step .alternate {
        display: none;
      }
    </style>
  </noscript>

  <!-- Google font embeds -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;0,800;1,400;1,500;1,600;1,700;1,800&amp;family=Inria+Sans:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&amp;display=swap" rel="stylesheet">
</head>

<body class="text-page">
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <!-- Table of contents (only if the page has a table of contents) -->
    <aside id="toc">
    <div id="toc-container" style="min-width: 10em; font-size: 15pt;">
      <!-- Title for the page -->
      <h3 class="Agda" style="margin-top: 0; margin-bottom: 0; white-space: pre;">
                <a class="Module">SHT.Base</a>
              </h3>

      <!-- Cube logo -->
      <a id="logo" href="/">
        <img alt="1Lab" src="/static/cube-72x.png" style="display: block; margin-bottom: 1em; margin: auto;" width="32px" height="32px" />
      </a>

      <!-- Actual table of contents (separated from the rest by
      horizontal rules) -->
      <hr />
      <ul>
      <li><a href="#synthetic-homotopy-theory"><a href="#synthetic-homotopy-theory" class="header-link">Synthetic
      homotopy theory<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#the-suspension-loop-space-adjunction"><a href="#the-suspension-loop-space-adjunction" class="header-link">The
      suspension-loop space
      adjunction<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#loop-spaces-are-equivalently-based-maps-out-of-spheres"><a href="#loop-spaces-are-equivalently-based-maps-out-of-spheres" class="header-link">Loop
      spaces are equivalently based maps out of
      spheres<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      <li><a href="#hubs-and-spokes"><a href="#hubs-and-spokes" class="header-link">Hubs
      and spokes<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      </ul>
      <hr />

      <!-- Sidebar controls -->
      <div style="display: flex; gap: 0.25em; flex-flow: row wrap;">
        <!-- Sidebar equations control -->
        <span class="equations" style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-eqns" type="checkbox" class="equations" id="sidebar-eqns">
          <label for="sidebar-eqns">Equations</label>
        </span>

        <!-- Sidebar fonts control -->
        <span style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-font" type="checkbox" id="toggle-fonts">
          <label for="toggle-fonts">Serif Font</label>
        </span>

        <!-- Sidebar footnotes control -->
        <span class="inline-footnotes" style="display: none; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-fns" type="checkbox" class="inline-footnotes" id="sidebar-fns">
          <label for="sidebar-fns">Inline Footnotes</label>
        </span>
      </div>

      <hr />

      <!-- Navbar navigation (lol) -->
      <div id="return" style="white-space: nowrap;">
        <div class="search-form search-form-proxy" role="form">
          <input id="search-box-proxy" type_="text" placeholder="Search..." autocomplete="off" tabindex="0"></input>
        </div>

              <a href="/">back to index</a> <br />
              <a href="all-pages.html">view all pages</a> <br />
        <a href="https://github.com/plt-amy/cubical-1lab/blob/478ebb9bd5b26275b0ac6339c7316fdf3132fb98/src/SHT/Base.lagda.md">link to source</a> <br />
                <hr /> <div class="author-list">Written by Amélia Liao</div> <br />
              </div>
    </div>
  </aside>
  
  <article>
    <!-- Article navigation (narrow screens only) -->
    <div class="narrow-only" id="article-nav">
      <!-- Index return anchor (only if the page is not the index) -->
            <div id="return">
        <a href="/">back to index</a>
      </div>
      
      <!-- Navbar equations control -->
      <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-eqns" type="checkbox" class="equations" id="navbar-eqns">
        <label for="navbar-eqns">Equations</label>
      </span>

      <!-- Navbar footnotes control -->
      <span class="inline-footnotes" style="display: none; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-fns" type="checkbox" class="inline-footnotes" id="navbar-fns">
        <label for="navbar-fns">Inline Footnotes</label>
      </span>
    </div>

<pre class="Agda"><a id="9" class="Keyword">open</a> <a id="14" class="Keyword">import</a> <a id="21" href="1Lab.HIT.Suspension.html" class="Module">1Lab.HIT.Suspension</a>
<a id="41" class="Keyword">open</a> <a id="46" class="Keyword">import</a> <a id="53" href="1Lab.HIT.Sphere.html" class="Module">1Lab.HIT.Sphere</a>
<a id="69" class="Keyword">open</a> <a id="74" class="Keyword">import</a> <a id="81" href="1Lab.Prelude.html" class="Module">1Lab.Prelude</a>

<a id="95" class="Keyword">open</a> <a id="100" class="Keyword">import</a> <a id="107" href="Algebra.Group.Homotopy.html" class="Module">Algebra.Group.Homotopy</a>

<a id="131" class="Keyword">module</a> <a id="138" href="SHT.Base.html" class="Module">SHT.Base</a> <a id="147" class="Keyword">where</a>
</pre>
<h1 id="synthetic-homotopy-theory"><a href="#synthetic-homotopy-theory" class="header-link">Synthetic
homotopy theory<span class="header-link-emoji">🔗</span></a></h1>
<p>This module contains the basic definitions for the study of synthetic
homotopy theory. Synthetic homotopy theory is the name given to studying
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">∞</span></span></span></span>-groupoids</span>
in their own terms, i.e., the application of homotopy theory to
computing homotopy invariants of spaces. Central to the theory is the
concept of <em>pointed type</em> and <em>pointed map</em>. After all, <a href="Algebra.Group.Homotopy.html">homotopy groups</a> are no more than
the set-truncations of n-fold iterated loop spaces, and loop spaces are
always relative to a basepoint.</p>
<p>If we have pointed types
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(A, a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mclose">)</span></span></span></span>
and
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>B</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(B, b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>,</span>
the most natural notion of function between them is not simply the type
of functions
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \to B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>,</span>
but rather those functions
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \to B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>
which <em>preserve the basepoint</em>, i.e. the functions
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">f : A \to B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>
equipped with paths
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo>≡</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">f(a) \equiv b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>.</span></p>
<pre class="Agda"><a id="_→∙_"></a><a id="1019" href="SHT.Base.html#1019" data-type="Type∙ ℓ → Type∙ ℓ′ → Type (ℓ ⊔ ℓ′)" class="Function Operator">_→∙_</a> <a id="1024" class="Symbol">:</a> <a id="1026" class="Symbol">∀</a> <a id="1028" class="Symbol">{</a><a id="1029" href="SHT.Base.html#1029" class="Bound">ℓ</a> <a id="1031" href="SHT.Base.html#1031" class="Bound">ℓ′</a><a id="1033" class="Symbol">}</a> <a id="1035" class="Symbol">→</a> <a id="1037" href="1Lab.Type.html#2800" data-type="(ℓ : Level) → Type (lsuc ℓ)" class="Function">Type∙</a> <a id="1043" href="SHT.Base.html#1029" class="Bound">ℓ</a> <a id="1045" class="Symbol">→</a> <a id="1047" href="1Lab.Type.html#2800" data-type="(ℓ : Level) → Type (lsuc ℓ)" class="Function">Type∙</a> <a id="1053" href="SHT.Base.html#1031" class="Bound">ℓ′</a> <a id="1056" class="Symbol">→</a> <a id="1058" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="1063" class="Symbol">_</a>
<a id="1065" class="Symbol">(</a><a id="1066" href="SHT.Base.html#1066" class="Bound">A</a> <a id="1068" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="1070" href="SHT.Base.html#1070" class="Bound">a</a><a id="1071" class="Symbol">)</a> <a id="1073" href="SHT.Base.html#1019" data-type="Type∙ ℓ → Type∙ ℓ′ → Type (ℓ ⊔ ℓ′)" class="Function Operator">→∙</a> <a id="1076" class="Symbol">(</a><a id="1077" href="SHT.Base.html#1077" class="Bound">B</a> <a id="1079" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="1081" href="SHT.Base.html#1081" class="Bound">b</a><a id="1082" class="Symbol">)</a> <a id="1084" class="Symbol">=</a> <a id="1086" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">Σ[</a> <a id="1089" href="SHT.Base.html#1089" class="Bound">f</a> <a id="1091" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">∈</a> <a id="1093" class="Symbol">(</a><a id="1094" href="SHT.Base.html#1066" class="Bound">A</a> <a id="1096" class="Symbol">→</a> <a id="1098" href="SHT.Base.html#1077" class="Bound">B</a><a id="1099" class="Symbol">)</a> <a id="1101" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">]</a> <a id="1103" class="Symbol">(</a><a id="1104" href="SHT.Base.html#1089" class="Bound">f</a> <a id="1106" href="SHT.Base.html#1070" class="Bound">a</a> <a id="1108" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="1110" href="SHT.Base.html#1081" class="Bound">b</a><a id="1111" class="Symbol">)</a>
</pre>
<p>A helper that will come in handy is
<span class="Agda"><a href="SHT.Base.html#1247" class="Function">Σ∙</a></span>,
which attaches the north pole as the basepoint of the suspended
space.</p>
<pre class="Agda"><a id="Σ∙"></a><a id="1247" href="SHT.Base.html#1247" data-type="Type∙ ℓ → Type∙ ℓ" class="Function">Σ∙</a> <a id="1250" class="Symbol">:</a> <a id="1252" class="Symbol">∀</a> <a id="1254" class="Symbol">{</a><a id="1255" href="SHT.Base.html#1255" class="Bound">ℓ</a><a id="1256" class="Symbol">}</a> <a id="1258" class="Symbol">→</a> <a id="1260" href="1Lab.Type.html#2800" data-type="(ℓ : Level) → Type (lsuc ℓ)" class="Function">Type∙</a> <a id="1266" href="SHT.Base.html#1255" class="Bound">ℓ</a> <a id="1268" class="Symbol">→</a> <a id="1270" href="1Lab.Type.html#2800" data-type="(ℓ : Level) → Type (lsuc ℓ)" class="Function">Type∙</a> <a id="1276" href="SHT.Base.html#1255" class="Bound">ℓ</a>
<a id="1278" href="SHT.Base.html#1247" data-type="Type∙ ℓ → Type∙ ℓ" class="Function">Σ∙</a> <a id="1281" href="SHT.Base.html#1281" class="Bound">A</a> <a id="1283" class="Symbol">=</a> <a id="1285" href="1Lab.HIT.Suspension.html#273" data-type="Type ℓ → Type ℓ" class="Datatype">Susp</a> <a id="1290" class="Symbol">(</a><a id="1291" href="SHT.Base.html#1281" class="Bound">A</a> <a id="1293" class="Symbol">.</a><a id="1294" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a><a id="1297" class="Symbol">)</a> <a id="1299" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="1301" href="1Lab.HIT.Suspension.html#312" data-type="Susp A" class="InductiveConstructor">N</a>

<a id="Ω∙"></a><a id="1304" href="SHT.Base.html#1304" data-type="Type∙ ℓ → Type∙ ℓ" class="Function">Ω∙</a> <a id="1307" class="Symbol">:</a> <a id="1309" class="Symbol">∀</a> <a id="1311" class="Symbol">{</a><a id="1312" href="SHT.Base.html#1312" class="Bound">ℓ</a><a id="1313" class="Symbol">}</a> <a id="1315" class="Symbol">→</a> <a id="1317" href="1Lab.Type.html#2800" data-type="(ℓ : Level) → Type (lsuc ℓ)" class="Function">Type∙</a> <a id="1323" href="SHT.Base.html#1312" class="Bound">ℓ</a> <a id="1325" class="Symbol">→</a> <a id="1327" href="1Lab.Type.html#2800" data-type="(ℓ : Level) → Type (lsuc ℓ)" class="Function">Type∙</a> <a id="1333" href="SHT.Base.html#1312" class="Bound">ℓ</a>
<a id="1335" href="SHT.Base.html#1304" data-type="Type∙ ℓ → Type∙ ℓ" class="Function">Ω∙</a> <a id="1338" class="Symbol">(</a><a id="1339" href="SHT.Base.html#1339" class="Bound">A</a> <a id="1341" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="1343" href="SHT.Base.html#1343" class="Bound">a</a><a id="1344" class="Symbol">)</a> <a id="1346" class="Symbol">=</a> <a id="1348" href="1Lab.Path.html#2466" data-type="(A : Type ℓ) → A → A → Type ℓ" class="Function">Path</a> <a id="1353" href="SHT.Base.html#1339" class="Bound">A</a> <a id="1355" href="SHT.Base.html#1343" class="Bound">a</a> <a id="1357" href="SHT.Base.html#1343" class="Bound">a</a> <a id="1359" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="1361" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
</pre>
<h2 id="the-suspension-loop-space-adjunction"><a href="#the-suspension-loop-space-adjunction" class="header-link">The
suspension-loop space
adjunction<span class="header-link-emoji">🔗</span></a></h2>
<p>An important stepping stone in calculating loop spaces of higher
types is the <em>suspension-loop space</em> <a href="Cat.Functor.Adjoint.hmtl">adjunction</a>: basepoint-preserving
maps <em>from</em> a suspension are the same thing as
basepoint-preserving maps <em>into</em> a loop space. We construct the
equivalence in two steps, but both halves are constructed in elementary
terms.</p>
<p>First, we’ll prove that</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">Σ</mi><mi>A</mi><msub><mo>→</mo><mo>∗</mo></msub><mi>B</mi><mo stretchy="false">)</mo><mo>≃</mo><mrow><mo fence="true">(</mo><munder><mo>∑</mo><mrow><msub><mi>b</mi><mi>s</mi></msub><mo>:</mo><mi>B</mi></mrow></munder><mi>A</mi><mo>→</mo><msub><mi>b</mi><mn>0</mn></msub><mo>≡</mo><msub><mi>b</mi><mi>s</mi></msub><mo fence="true">)</mo></mrow><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">
(\Sigma A \to_* B) \simeq \left(\sum_{b_s : B} A \to b_0 \equiv b_s\right),
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">Σ</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel">→</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1757em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≃</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.1522em;vertical-align:-1.4022em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">(</span></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8479em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mrel mtight">:</span><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4022em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size4">)</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span></span></span></span></span></p>
<p>which is slightly involved, but not too much. The actual equivalence
is very straightforward to construct, but proving that the two maps
<code>Σ-map→loops</code> and <code>loops→Σ-map</code> are inverses
involves nontrivial path algebra.</p>
<pre class="Agda"><a id="2113" class="Keyword">module</a> <a id="2120" href="SHT.Base.html#2120" class="Module">_</a> <a id="2122" class="Symbol">{</a><a id="2123" href="SHT.Base.html#2123" class="Bound">ℓ</a> <a id="2125" href="SHT.Base.html#2125" class="Bound">ℓ′</a><a id="2127" class="Symbol">}</a> <a id="2129" class="Symbol">{</a><a id="2130" href="SHT.Base.html#2130" class="Bound">A</a> <a id="2132" class="Symbol">:</a> <a id="2134" href="1Lab.Type.html#2800" data-type="(ℓ : Level) → Type (lsuc ℓ)" class="Function">Type∙</a> <a id="2140" href="SHT.Base.html#2123" class="Bound">ℓ</a><a id="2141" class="Symbol">}</a> <a id="2143" class="Symbol">{</a><a id="2144" href="SHT.Base.html#2144" class="Bound">B</a> <a id="2146" class="Symbol">:</a> <a id="2148" href="1Lab.Type.html#2800" data-type="(ℓ : Level) → Type (lsuc ℓ)" class="Function">Type∙</a> <a id="2154" href="SHT.Base.html#2125" class="Bound">ℓ′</a><a id="2156" class="Symbol">}</a> <a id="2158" class="Keyword">where</a>
  <a id="2166" href="SHT.Base.html#2166" data-type="Σ∙ A →∙ B₁ → Σ (λ bs → A .fst → B₁ .snd ≡ bs)" class="Function">Σ-map∙→loops</a> <a id="2179" class="Symbol">:</a> <a id="2181" class="Symbol">(</a><a id="2182" href="SHT.Base.html#1247" data-type="Type∙ ℓ → Type∙ ℓ" class="Function">Σ∙</a> <a id="2185" href="SHT.Base.html#2130" class="Bound">A</a> <a id="2187" href="SHT.Base.html#1019" data-type="Type∙ ℓ → Type∙ ℓ′ → Type (ℓ ⊔ ℓ′)" class="Function Operator">→∙</a> <a id="2190" href="SHT.Base.html#2144" class="Bound">B</a><a id="2191" class="Symbol">)</a> <a id="2193" class="Symbol">→</a> <a id="2195" class="Symbol">(</a><a id="2196" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">Σ</a> <a id="2198" class="Symbol">λ</a> <a id="2200" href="SHT.Base.html#2200" class="Bound">bs</a> <a id="2203" class="Symbol">→</a> <a id="2205" href="SHT.Base.html#2130" class="Bound">A</a> <a id="2207" class="Symbol">.</a><a id="2208" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="2212" class="Symbol">→</a> <a id="2214" href="SHT.Base.html#2144" class="Bound">B</a> <a id="2216" class="Symbol">.</a><a id="2217" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="2221" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="2223" href="SHT.Base.html#2200" class="Bound">bs</a><a id="2225" class="Symbol">)</a>
  <a id="2229" href="SHT.Base.html#2166" data-type="Σ∙ A →∙ B₁ → Σ (λ bs → A .fst → B₁ .snd ≡ bs)" class="Function">Σ-map∙→loops</a> <a id="2242" href="SHT.Base.html#2242" class="Bound">f</a> <a id="2244" class="Symbol">.</a><a id="2245" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="2249" class="Symbol">=</a> <a id="2251" href="SHT.Base.html#2242" class="Bound">f</a> <a id="2253" class="Symbol">.</a><a id="2254" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="2258" href="1Lab.HIT.Suspension.html#314" data-type="Susp A" class="InductiveConstructor">S</a>
  <a id="2262" href="SHT.Base.html#2166" data-type="Σ∙ A →∙ B₁ → Σ (λ bs → A .fst → B₁ .snd ≡ bs)" class="Function">Σ-map∙→loops</a> <a id="2275" href="SHT.Base.html#2275" class="Bound">f</a> <a id="2277" class="Symbol">.</a><a id="2278" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="2282" href="SHT.Base.html#2282" class="Bound">a</a> <a id="2284" class="Symbol">=</a> <a id="2286" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="2290" class="Symbol">(</a><a id="2291" href="SHT.Base.html#2275" class="Bound">f</a> <a id="2293" class="Symbol">.</a><a id="2294" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a><a id="2297" class="Symbol">)</a> <a id="2299" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="2301" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="2304" class="Symbol">(</a><a id="2305" href="SHT.Base.html#2275" class="Bound">f</a> <a id="2307" class="Symbol">.</a><a id="2308" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a><a id="2311" class="Symbol">)</a> <a id="2313" class="Symbol">(</a><a id="2314" href="1Lab.HIT.Suspension.html#329" data-type="A → N ≡ S" class="InductiveConstructor">merid</a> <a id="2320" href="SHT.Base.html#2282" class="Bound">a</a><a id="2321" class="Symbol">)</a>

  <a id="2326" href="SHT.Base.html#2326" data-type="Σ (λ bs → A .fst → B₁ .snd ≡ bs) → Σ∙ A →∙ B₁" class="Function">loops→Σ-map∙</a> <a id="2339" class="Symbol">:</a> <a id="2341" class="Symbol">(</a><a id="2342" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">Σ</a> <a id="2344" class="Symbol">λ</a> <a id="2346" href="SHT.Base.html#2346" class="Bound">bs</a> <a id="2349" class="Symbol">→</a> <a id="2351" href="SHT.Base.html#2130" class="Bound">A</a> <a id="2353" class="Symbol">.</a><a id="2354" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="2358" class="Symbol">→</a> <a id="2360" href="SHT.Base.html#2144" class="Bound">B</a> <a id="2362" class="Symbol">.</a><a id="2363" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="2367" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="2369" href="SHT.Base.html#2346" class="Bound">bs</a><a id="2371" class="Symbol">)</a> <a id="2373" class="Symbol">→</a> <a id="2375" class="Symbol">(</a><a id="2376" href="SHT.Base.html#1247" data-type="Type∙ ℓ → Type∙ ℓ" class="Function">Σ∙</a> <a id="2379" href="SHT.Base.html#2130" class="Bound">A</a> <a id="2381" href="SHT.Base.html#1019" data-type="Type∙ ℓ → Type∙ ℓ′ → Type (ℓ ⊔ ℓ′)" class="Function Operator">→∙</a> <a id="2384" href="SHT.Base.html#2144" class="Bound">B</a><a id="2385" class="Symbol">)</a>
  <a id="2389" href="SHT.Base.html#2326" data-type="Σ (λ bs → A .fst → B₁ .snd ≡ bs) → Σ∙ A →∙ B₁" class="Function">loops→Σ-map∙</a> <a id="2402" href="SHT.Base.html#2402" class="Bound">pair</a> <a id="2407" class="Symbol">.</a><a id="2408" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="2412" href="1Lab.HIT.Suspension.html#312" data-type="Susp A" class="InductiveConstructor">N</a>           <a id="2424" class="Symbol">=</a> <a id="2426" href="SHT.Base.html#2144" class="Bound">B</a> <a id="2428" class="Symbol">.</a><a id="2429" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a>
  <a id="2435" href="SHT.Base.html#2326" data-type="Σ (λ bs → A .fst → B₁ .snd ≡ bs) → Σ∙ A →∙ B₁" class="Function">loops→Σ-map∙</a> <a id="2448" href="SHT.Base.html#2448" class="Bound">pair</a> <a id="2453" class="Symbol">.</a><a id="2454" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="2458" href="1Lab.HIT.Suspension.html#314" data-type="Susp A" class="InductiveConstructor">S</a>           <a id="2470" class="Symbol">=</a> <a id="2472" href="SHT.Base.html#2448" class="Bound">pair</a> <a id="2477" class="Symbol">.</a><a id="2478" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a>
  <a id="2484" href="SHT.Base.html#2326" data-type="Σ (λ bs → A .fst → B₁ .snd ≡ bs) → Σ∙ A →∙ B₁" class="Function">loops→Σ-map∙</a> <a id="2497" href="SHT.Base.html#2497" class="Bound">pair</a> <a id="2502" class="Symbol">.</a><a id="2503" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="2507" class="Symbol">(</a><a id="2508" href="1Lab.HIT.Suspension.html#329" data-type="A → N ≡ S" class="InductiveConstructor">merid</a> <a id="2514" href="SHT.Base.html#2514" class="Bound">x</a> <a id="2516" href="SHT.Base.html#2516" class="Bound">i</a><a id="2517" class="Symbol">)</a> <a id="2519" class="Symbol">=</a> <a id="2521" href="SHT.Base.html#2497" class="Bound">pair</a> <a id="2526" class="Symbol">.</a><a id="2527" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="2531" href="SHT.Base.html#2514" class="Bound">x</a> <a id="2533" href="SHT.Base.html#2516" class="Bound">i</a>
  <a id="2537" href="SHT.Base.html#2326" data-type="Σ (λ bs → A .fst → B₁ .snd ≡ bs) → Σ∙ A →∙ B₁" class="Function">loops→Σ-map∙</a> <a id="2550" href="SHT.Base.html#2550" class="Bound">pair</a> <a id="2555" class="Symbol">.</a><a id="2556" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="2560" class="Symbol">=</a> <a id="2562" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
</pre>
<p>The construction for turning a family of loops into a
basepoint-preserving map into
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Ω</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">\Omega B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Ω</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>
is even simpler, perhaps because these are almost definitionally the
same thing.</p>
<pre class="Agda">  <a id="2759" href="SHT.Base.html#2759" data-type="Σ (λ bs → A .fst → B₁ .snd ≡ bs) → A →∙ Ω∙ B₁" class="Function">loops→map∙-Ω</a> <a id="2772" class="Symbol">:</a> <a id="2774" class="Symbol">(</a><a id="2775" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">Σ</a> <a id="2777" class="Symbol">λ</a> <a id="2779" href="SHT.Base.html#2779" class="Bound">bs</a> <a id="2782" class="Symbol">→</a> <a id="2784" href="SHT.Base.html#2130" class="Bound">A</a> <a id="2786" class="Symbol">.</a><a id="2787" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="2791" class="Symbol">→</a> <a id="2793" href="SHT.Base.html#2144" class="Bound">B</a> <a id="2795" class="Symbol">.</a><a id="2796" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="2800" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="2802" href="SHT.Base.html#2779" class="Bound">bs</a><a id="2804" class="Symbol">)</a> <a id="2806" class="Symbol">→</a> <a id="2808" class="Symbol">(</a><a id="2809" href="SHT.Base.html#2130" class="Bound">A</a> <a id="2811" href="SHT.Base.html#1019" data-type="Type∙ ℓ → Type∙ ℓ′ → Type (ℓ ⊔ ℓ′)" class="Function Operator">→∙</a> <a id="2814" href="SHT.Base.html#1304" data-type="Type∙ ℓ → Type∙ ℓ" class="Function">Ω∙</a> <a id="2817" href="SHT.Base.html#2144" class="Bound">B</a><a id="2818" class="Symbol">)</a>
  <a id="2822" href="SHT.Base.html#2759" data-type="Σ (λ bs → A .fst → B₁ .snd ≡ bs) → A →∙ Ω∙ B₁" class="Function">loops→map∙-Ω</a> <a id="2835" class="Symbol">(</a><a id="2836" href="SHT.Base.html#2836" class="Bound">b</a> <a id="2838" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="2840" href="SHT.Base.html#2840" class="Bound">x</a><a id="2841" class="Symbol">)</a> <a id="2843" class="Symbol">.</a><a id="2844" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="2848" href="SHT.Base.html#2848" class="Bound">a</a> <a id="2850" class="Symbol">=</a> <a id="2852" href="SHT.Base.html#2840" class="Bound">x</a> <a id="2854" href="SHT.Base.html#2848" class="Bound">a</a> <a id="2856" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="2858" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="2862" class="Symbol">(</a><a id="2863" href="SHT.Base.html#2840" class="Bound">x</a> <a id="2865" class="Symbol">(</a><a id="2866" href="SHT.Base.html#2130" class="Bound">A</a> <a id="2868" class="Symbol">.</a><a id="2869" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a><a id="2872" class="Symbol">))</a>
  <a id="2877" href="SHT.Base.html#2759" data-type="Σ (λ bs → A .fst → B₁ .snd ≡ bs) → A →∙ Ω∙ B₁" class="Function">loops→map∙-Ω</a> <a id="2890" class="Symbol">(</a><a id="2891" href="SHT.Base.html#2891" class="Bound">b</a> <a id="2893" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="2895" href="SHT.Base.html#2895" class="Bound">x</a><a id="2896" class="Symbol">)</a> <a id="2898" class="Symbol">.</a><a id="2899" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a>   <a id="2905" class="Symbol">=</a> <a id="2907" href="1Lab.Path.Groupoid.html#5058" data-type="(p : x ≡ y) → p ∙ sym p ≡ refl" class="Function">∙-inv-r</a> <a id="2915" class="Symbol">(</a><a id="2916" href="SHT.Base.html#2895" class="Bound">x</a> <a id="2918" class="Symbol">(</a><a id="2919" href="SHT.Base.html#2130" class="Bound">A</a> <a id="2921" class="Symbol">.</a><a id="2922" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a><a id="2925" class="Symbol">))</a>

  <a id="2931" href="SHT.Base.html#2931" data-type="A →∙ Ω∙ B₁ → Σ (λ bs → A .fst → B₁ .snd ≡ bs)" class="Function">map∙-Ω→loops</a> <a id="2944" class="Symbol">:</a> <a id="2946" class="Symbol">(</a><a id="2947" href="SHT.Base.html#2130" class="Bound">A</a> <a id="2949" href="SHT.Base.html#1019" data-type="Type∙ ℓ → Type∙ ℓ′ → Type (ℓ ⊔ ℓ′)" class="Function Operator">→∙</a> <a id="2952" href="SHT.Base.html#1304" data-type="Type∙ ℓ → Type∙ ℓ" class="Function">Ω∙</a> <a id="2955" href="SHT.Base.html#2144" class="Bound">B</a><a id="2956" class="Symbol">)</a> <a id="2958" class="Symbol">→</a> <a id="2960" class="Symbol">(</a><a id="2961" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">Σ</a> <a id="2963" class="Symbol">λ</a> <a id="2965" href="SHT.Base.html#2965" class="Bound">bs</a> <a id="2968" class="Symbol">→</a> <a id="2970" href="SHT.Base.html#2130" class="Bound">A</a> <a id="2972" class="Symbol">.</a><a id="2973" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="2977" class="Symbol">→</a> <a id="2979" href="SHT.Base.html#2144" class="Bound">B</a> <a id="2981" class="Symbol">.</a><a id="2982" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="2986" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="2988" href="SHT.Base.html#2965" class="Bound">bs</a><a id="2990" class="Symbol">)</a>
  <a id="2994" href="SHT.Base.html#2931" data-type="A →∙ Ω∙ B₁ → Σ (λ bs → A .fst → B₁ .snd ≡ bs)" class="Function">map∙-Ω→loops</a> <a id="3007" href="SHT.Base.html#3007" class="Bound">pair</a> <a id="3012" class="Symbol">.</a><a id="3013" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="3017" class="Symbol">=</a> <a id="3019" href="SHT.Base.html#2144" class="Bound">B</a> <a id="3021" class="Symbol">.</a><a id="3022" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a>
  <a id="3028" href="SHT.Base.html#2931" data-type="A →∙ Ω∙ B₁ → Σ (λ bs → A .fst → B₁ .snd ≡ bs)" class="Function">map∙-Ω→loops</a> <a id="3041" href="SHT.Base.html#3041" class="Bound">pair</a> <a id="3046" class="Symbol">.</a><a id="3047" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="3051" class="Symbol">=</a> <a id="3053" href="SHT.Base.html#3041" class="Bound">pair</a> <a id="3058" class="Symbol">.</a><a id="3059" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a>
</pre>
<details>
<summary>
The path algebra for showing these are both pairs of inverse
equivalences is not very interesting, so I’ve kept it hidden.
</summary>
<pre class="Agda">  <a id="3231" href="SHT.Base.html#3231" data-type="(Σ∙ A →∙ B₁) ≃ Σ (λ b → A .fst → B₁ .snd ≡ b)" class="Function">Σ-map∙≃loops</a> <a id="3244" class="Symbol">:</a> <a id="3246" class="Symbol">(</a><a id="3247" href="SHT.Base.html#1247" data-type="Type∙ ℓ → Type∙ ℓ" class="Function">Σ∙</a> <a id="3250" href="SHT.Base.html#2130" class="Bound">A</a> <a id="3252" href="SHT.Base.html#1019" data-type="Type∙ ℓ → Type∙ ℓ′ → Type (ℓ ⊔ ℓ′)" class="Function Operator">→∙</a> <a id="3255" href="SHT.Base.html#2144" class="Bound">B</a><a id="3256" class="Symbol">)</a> <a id="3258" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="3260" class="Symbol">(</a><a id="3261" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">Σ</a> <a id="3263" class="Symbol">λ</a> <a id="3265" href="SHT.Base.html#3265" class="Bound">b</a> <a id="3267" class="Symbol">→</a> <a id="3269" href="SHT.Base.html#2130" class="Bound">A</a> <a id="3271" class="Symbol">.</a><a id="3272" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="3276" class="Symbol">→</a> <a id="3278" href="SHT.Base.html#2144" class="Bound">B</a> <a id="3280" class="Symbol">.</a><a id="3281" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="3285" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="3287" href="SHT.Base.html#3265" class="Bound">b</a><a id="3288" class="Symbol">)</a>
  <a id="3292" href="SHT.Base.html#3231" data-type="(Σ∙ A →∙ B₁) ≃ Σ (λ b → A .fst → B₁ .snd ≡ b)" class="Function">Σ-map∙≃loops</a> <a id="3305" class="Symbol">=</a> <a id="3307" href="1Lab.Equiv.html#20503" data-type="Iso A B₁ → A ≃ B₁" class="Function">Iso→Equiv</a> <a id="3317" class="Symbol">(</a><a id="3318" href="SHT.Base.html#2166" data-type="Σ∙ A →∙ B₁ → Σ (λ bs → A .fst → B₁ .snd ≡ bs)" class="Function">Σ-map∙→loops</a> <a id="3331" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="3333" href="1Lab.Equiv.html#6116" data-type="(inv₁ : B₁ → A) (rinv₁ : is-right-inverse inv₁ f)
(linv₁ : is-left-inverse inv₁ f) →
is-iso f" class="InductiveConstructor">iso</a> <a id="3337" href="SHT.Base.html#2326" data-type="Σ (λ bs → A .fst → B₁ .snd ≡ bs) → Σ∙ A →∙ B₁" class="Function">loops→Σ-map∙</a> <a id="3350" href="SHT.Base.html#3371" data-type="is-right-inverse loops→Σ-map∙ Σ-map∙→loops" class="Function">invr</a> <a id="3355" href="SHT.Base.html#4456" data-type="is-left-inverse loops→Σ-map∙ Σ-map∙→loops" class="Function">invl</a><a id="3359" class="Symbol">)</a> <a id="3361" class="Keyword">where</a>
    <a id="3371" href="SHT.Base.html#3371" data-type="is-right-inverse loops→Σ-map∙ Σ-map∙→loops" class="Function">invr</a> <a id="3376" class="Symbol">:</a> <a id="3378" href="1Lab.Equiv.html#5739" data-type="(B₁ → A) → (A → B₁) → Type B.ℓ₁" class="Function">is-right-inverse</a> <a id="3395" href="SHT.Base.html#2326" data-type="Σ (λ bs → A .fst → B₁ .snd ≡ bs) → Σ∙ A →∙ B₁" class="Function">loops→Σ-map∙</a> <a id="3408" href="SHT.Base.html#2166" data-type="Σ∙ A →∙ B₁ → Σ (λ bs → A .fst → B₁ .snd ≡ bs)" class="Function">Σ-map∙→loops</a>
    <a id="3425" href="SHT.Base.html#3371" data-type="is-right-inverse loops→Σ-map∙ Σ-map∙→loops" class="Function">invr</a> <a id="3430" class="Symbol">(</a><a id="3431" href="SHT.Base.html#3431" class="Bound">p</a> <a id="3433" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="3435" href="SHT.Base.html#3435" class="Bound">q</a><a id="3436" class="Symbol">)</a> <a id="3438" class="Symbol">=</a> <a id="3440" href="1Lab.Path.html#57276" data-type="(p : x .fst ≡ y .fst) →
PathP (λ i → B₁ (p i)) (x .snd) (y .snd) → x ≡ y" class="Function">Σ-pathp</a> <a id="3448" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
      <a id="3459" class="Symbol">(</a><a id="3460" href="1Lab.Path.html#55976" data-type="coe0→1 A x ≡ y → PathP A x y" class="Function">to-pathp</a> <a id="3469" class="Symbol">(</a><a id="3470" href="1Lab.Path.html#58474" data-type="((x : A) → f x ≡ g x) → f ≡ g" class="Function">funext</a> <a id="3477" class="Symbol">(λ</a> <a id="3480" href="SHT.Base.html#3480" class="Bound">a</a> <a id="3482" class="Symbol">→</a> <a id="3484" href="1Lab.Path.html#61401" data-type="(loop₁ : x ≡ z) (adj : z ≡ y) →
subst (_≡_ x) adj loop₁ ≡ loop₁ ∙ adj" class="Function">subst-path-right</a> <a id="3501" class="Symbol">_</a> <a id="3503" class="Symbol">_</a> <a id="3505" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="3507" href="1Lab.Path.Groupoid.html#4549" data-type="(p : x ≡ y) → p ∙ refl ≡ p" class="Function">∙-id-r</a> <a id="3514" class="Symbol">_</a> <a id="3516" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="3518" href="1Lab.Path.Groupoid.html#4623" data-type="(p : x ≡ y) → refl ∙ p ≡ p" class="Function">∙-id-l</a> <a id="3525" class="Symbol">_</a> <a id="3527" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="3529" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="3532" href="SHT.Base.html#3435" class="Bound">q</a> <a id="3534" class="Symbol">(</a><a id="3535" href="1Lab.Path.html#13454" data-type="(x : A) → transport (λ i → A) x ≡ x" class="Function">transport-refl</a> <a id="3550" class="Symbol">_))))</a>

    <a id="3561" href="SHT.Base.html#3561" data-type="(f : Σ∙ A →∙ B₁) (x : A .fst) →
Square (sym (f .snd) ∙ ap (f .fst) (merid x)) (sym (f .snd)) refl
(ap (f .fst) (merid x))" class="Function">lemma</a> <a id="3567" class="Symbol">:</a> <a id="3569" class="Symbol">∀</a> <a id="3571" class="Symbol">(</a><a id="3572" href="SHT.Base.html#3572" class="Bound">f</a> <a id="3574" class="Symbol">:</a> <a id="3576" href="SHT.Base.html#1247" data-type="Type∙ ℓ → Type∙ ℓ" class="Function">Σ∙</a> <a id="3579" href="SHT.Base.html#2130" class="Bound">A</a> <a id="3581" href="SHT.Base.html#1019" data-type="Type∙ ℓ → Type∙ ℓ′ → Type (ℓ ⊔ ℓ′)" class="Function Operator">→∙</a> <a id="3584" href="SHT.Base.html#2144" class="Bound">B</a><a id="3585" class="Symbol">)</a> <a id="3587" href="SHT.Base.html#3587" class="Bound">x</a> <a id="3589" class="Symbol">→</a> <a id="3591" href="1Lab.Path.html#9409" data-type="a00 ≡ a01 → a00 ≡ a10 → a01 ≡ a11 → a10 ≡ a11 → Type ℓ" class="Function">Square</a>
      <a id="3604" class="Symbol">(</a><a id="3605" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="3609" class="Symbol">(</a><a id="3610" href="SHT.Base.html#3572" class="Bound">f</a> <a id="3612" class="Symbol">.</a><a id="3613" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a><a id="3616" class="Symbol">)</a> <a id="3618" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="3620" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="3623" class="Symbol">(</a><a id="3624" href="SHT.Base.html#3572" class="Bound">f</a> <a id="3626" class="Symbol">.</a><a id="3627" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a><a id="3630" class="Symbol">)</a> <a id="3632" class="Symbol">(</a><a id="3633" href="1Lab.HIT.Suspension.html#329" data-type="A → N ≡ S" class="InductiveConstructor">merid</a> <a id="3639" href="SHT.Base.html#3587" class="Bound">x</a><a id="3640" class="Symbol">))</a>
      <a id="3649" class="Symbol">(</a><a id="3650" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="3654" class="Symbol">(</a><a id="3655" href="SHT.Base.html#3572" class="Bound">f</a> <a id="3657" class="Symbol">.</a><a id="3658" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a><a id="3661" class="Symbol">))</a> <a id="3664" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="3669" class="Symbol">(</a><a id="3670" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="3673" class="Symbol">(</a><a id="3674" href="SHT.Base.html#3572" class="Bound">f</a> <a id="3676" class="Symbol">.</a><a id="3677" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a><a id="3680" class="Symbol">)</a> <a id="3682" class="Symbol">(</a><a id="3683" href="1Lab.HIT.Suspension.html#329" data-type="A → N ≡ S" class="InductiveConstructor">merid</a> <a id="3689" href="SHT.Base.html#3587" class="Bound">x</a><a id="3690" class="Symbol">))</a>
    <a id="3697" href="SHT.Base.html#3561" data-type="(f : Σ∙ A →∙ B₁) (x : A .fst) →
Square (sym (f .snd) ∙ ap (f .fst) (merid x)) (sym (f .snd)) refl
(ap (f .fst) (merid x))" class="Function">lemma</a> <a id="3703" href="SHT.Base.html#3703" class="Bound">f</a> <a id="3705" href="SHT.Base.html#3705" class="Bound">x</a> <a id="3707" class="Symbol">=</a> <a id="3709" href="1Lab.Path.html#11776" data-type="A ≡ B₁ → A → B₁" class="Function">transport</a> <a id="3719" class="Symbol">(</a><a id="3720" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="3724" href="1Lab.Path.html#62329" data-type="Square p q s r ≡ ((sym p ·· q ·· r) ≡ s)" class="Function">Square≡double-composite-path</a><a id="3752" class="Symbol">)</a> <a id="3754" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a>
      <a id="3762" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="3766" class="Symbol">(</a><a id="3767" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="3771" class="Symbol">(</a><a id="3772" href="SHT.Base.html#3703" class="Bound">f</a> <a id="3774" class="Symbol">.</a><a id="3775" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a><a id="3778" class="Symbol">)</a> <a id="3780" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="3782" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="3785" class="Symbol">(</a><a id="3786" href="SHT.Base.html#3703" class="Bound">f</a> <a id="3788" class="Symbol">.</a><a id="3789" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a><a id="3792" class="Symbol">)</a> <a id="3794" class="Symbol">(</a><a id="3795" href="1Lab.HIT.Suspension.html#329" data-type="A → N ≡ S" class="InductiveConstructor">merid</a> <a id="3801" href="SHT.Base.html#3705" class="Bound">x</a><a id="3802" class="Symbol">))</a> <a id="3805" href="1Lab.Path.html#38293" data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" class="Function Operator">··</a> <a id="3808" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="3812" class="Symbol">(</a><a id="3813" href="SHT.Base.html#3703" class="Bound">f</a> <a id="3815" class="Symbol">.</a><a id="3816" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a><a id="3819" class="Symbol">)</a> <a id="3821" href="1Lab.Path.html#38293" data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" class="Function Operator">··</a> <a id="3824" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="3827" class="Symbol">(</a><a id="3828" href="SHT.Base.html#3703" class="Bound">f</a> <a id="3830" class="Symbol">.</a><a id="3831" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a><a id="3834" class="Symbol">)</a> <a id="3836" class="Symbol">(</a><a id="3837" href="1Lab.HIT.Suspension.html#329" data-type="A → N ≡ S" class="InductiveConstructor">merid</a> <a id="3843" href="SHT.Base.html#3705" class="Bound">x</a><a id="3844" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function"><a id="3846" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="3849" href="1Lab.Path.html#63044" data-type="(p : x ≡ y) (q : y ≡ z) (r : z ≡ w) → (p ·· q ·· r) ≡ p ∙ q ∙ r" class="Function">double-composite</a> <a id="3866" class="Symbol">(</a><a id="3867" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="3871" class="Symbol">_)</a> <a id="3874" class="Symbol">_</a> <a id="3876" class="Symbol">_</a> <a id="3878" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="3886" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="3890" class="Symbol">(</a><a id="3891" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="3895" class="Symbol">(</a><a id="3896" href="SHT.Base.html#3703" class="Bound">f</a> <a id="3898" class="Symbol">.</a><a id="3899" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a><a id="3902" class="Symbol">)</a> <a id="3904" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="3906" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="3909" class="Symbol">(</a><a id="3910" href="SHT.Base.html#3703" class="Bound">f</a> <a id="3912" class="Symbol">.</a><a id="3913" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a><a id="3916" class="Symbol">)</a> <a id="3918" class="Symbol">(</a><a id="3919" href="1Lab.HIT.Suspension.html#329" data-type="A → N ≡ S" class="InductiveConstructor">merid</a> <a id="3925" href="SHT.Base.html#3705" class="Bound">x</a><a id="3926" class="Symbol">))</a> <a id="3929" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="3931" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="3935" class="Symbol">(</a><a id="3936" href="SHT.Base.html#3703" class="Bound">f</a> <a id="3938" class="Symbol">.</a><a id="3939" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a><a id="3942" class="Symbol">)</a> <a id="3944" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="3946" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="3949" class="Symbol">(</a><a id="3950" href="SHT.Base.html#3703" class="Bound">f</a> <a id="3952" class="Symbol">.</a><a id="3953" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a><a id="3956" class="Symbol">)</a> <a id="3958" class="Symbol">(</a><a id="3959" href="1Lab.HIT.Suspension.html#329" data-type="A → N ≡ S" class="InductiveConstructor">merid</a> <a id="3965" href="SHT.Base.html#3705" class="Bound">x</a><a id="3966" class="Symbol">)</a>   <span class="reasoning-step"><span class="as-written Function"><a id="3970" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="3973" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="3977" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">_∙_</a> <a id="3981" class="Symbol">(</a><a id="3982" href="1Lab.Path.html#63945" data-type="(p : x ≡ y) (q : y ≡ z) → sym (p ∙ q) ≡ sym q ∙ sym p" class="Function">sym-∙</a> <a id="3988" class="Symbol">(</a><a id="3989" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="3993" class="Symbol">_)</a> <a id="3996" class="Symbol">_)</a> <a id="3999" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="4004" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="4012" class="Symbol">(</a><a id="4013" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="4016" class="Symbol">(</a><a id="4017" href="SHT.Base.html#3703" class="Bound">f</a> <a id="4019" class="Symbol">.</a><a id="4020" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a><a id="4023" class="Symbol">)</a> <a id="4025" class="Symbol">(</a><a id="4026" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="4030" class="Symbol">(</a><a id="4031" href="1Lab.HIT.Suspension.html#329" data-type="A → N ≡ S" class="InductiveConstructor">merid</a> <a id="4037" href="SHT.Base.html#3705" class="Bound">x</a><a id="4038" class="Symbol">))</a> <a id="4041" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="4043" class="Symbol">(</a><a id="4044" href="SHT.Base.html#3703" class="Bound">f</a> <a id="4046" class="Symbol">.</a><a id="4047" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a><a id="4050" class="Symbol">))</a> <a id="4053" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="4055" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="4059" class="Symbol">(</a><a id="4060" href="SHT.Base.html#3703" class="Bound">f</a> <a id="4062" class="Symbol">.</a><a id="4063" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a><a id="4066" class="Symbol">)</a> <a id="4068" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="4070" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="4073" class="Symbol">(</a><a id="4074" href="SHT.Base.html#3703" class="Bound">f</a> <a id="4076" class="Symbol">.</a><a id="4077" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a><a id="4080" class="Symbol">)</a> <a id="4082" class="Symbol">(</a><a id="4083" href="1Lab.HIT.Suspension.html#329" data-type="A → N ≡ S" class="InductiveConstructor">merid</a> <a id="4089" href="SHT.Base.html#3705" class="Bound">x</a><a id="4090" class="Symbol">)</a>     <span class="reasoning-step"><span class="as-written Function Operator"><a id="4096" href="1Lab.Path.html#46771" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">≡˘⟨</a> <a id="4100" href="1Lab.Path.Groupoid.html#4743" data-type="(p : w ≡ x) (q : x ≡ y) (r : y ≡ z) → p ∙ q ∙ r ≡ (p ∙ q) ∙ r" class="Function">∙-assoc</a> <a id="4108" class="Symbol">_</a> <a id="4110" class="Symbol">_</a> <a id="4112" class="Symbol">_</a> <a id="4114" href="1Lab.Path.html#46771" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡˘</span></span>
      <a id="4122" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="4125" class="Symbol">(</a><a id="4126" href="SHT.Base.html#3703" class="Bound">f</a> <a id="4128" class="Symbol">.</a><a id="4129" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a><a id="4132" class="Symbol">)</a> <a id="4134" class="Symbol">(</a><a id="4135" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="4139" class="Symbol">(</a><a id="4140" href="1Lab.HIT.Suspension.html#329" data-type="A → N ≡ S" class="InductiveConstructor">merid</a> <a id="4146" href="SHT.Base.html#3705" class="Bound">x</a><a id="4147" class="Symbol">))</a> <a id="4150" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="4152" class="Symbol">((</a><a id="4154" href="SHT.Base.html#3703" class="Bound">f</a> <a id="4156" class="Symbol">.</a><a id="4157" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a><a id="4160" class="Symbol">)</a> <a id="4162" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="4164" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="4168" class="Symbol">(</a><a id="4169" href="SHT.Base.html#3703" class="Bound">f</a> <a id="4171" class="Symbol">.</a><a id="4172" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a><a id="4175" class="Symbol">)</a> <a id="4177" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="4179" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="4182" class="Symbol">(</a><a id="4183" href="SHT.Base.html#3703" class="Bound">f</a> <a id="4185" class="Symbol">.</a><a id="4186" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a><a id="4189" class="Symbol">)</a> <a id="4191" class="Symbol">(</a><a id="4192" href="1Lab.HIT.Suspension.html#329" data-type="A → N ≡ S" class="InductiveConstructor">merid</a> <a id="4198" href="SHT.Base.html#3705" class="Bound">x</a><a id="4199" class="Symbol">))</a>     <span class="reasoning-step"><span class="as-written Function"><a id="4206" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="4209" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="4213" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">_∙_</a> <a id="4217" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="4222" class="Symbol">(</a><a id="4223" href="1Lab.Path.Groupoid.html#6877" data-type="(p : x ≡ y) (q : y ≡ z) → sym p ∙ p ∙ q ≡ q" class="Function">∙-cancel-l</a> <a id="4234" class="Symbol">(</a><a id="4235" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="4239" class="Symbol">(</a><a id="4240" href="SHT.Base.html#3703" class="Bound">f</a> <a id="4242" class="Symbol">.</a><a id="4243" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a><a id="4246" class="Symbol">))</a> <a id="4249" class="Symbol">_)</a> <a id="4252" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="4260" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="4263" class="Symbol">(</a><a id="4264" href="SHT.Base.html#3703" class="Bound">f</a> <a id="4266" class="Symbol">.</a><a id="4267" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a><a id="4270" class="Symbol">)</a> <a id="4272" class="Symbol">(</a><a id="4273" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="4277" class="Symbol">(</a><a id="4278" href="1Lab.HIT.Suspension.html#329" data-type="A → N ≡ S" class="InductiveConstructor">merid</a> <a id="4284" href="SHT.Base.html#3705" class="Bound">x</a><a id="4285" class="Symbol">))</a> <a id="4288" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="4290" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="4293" class="Symbol">(</a><a id="4294" href="SHT.Base.html#3703" class="Bound">f</a> <a id="4296" class="Symbol">.</a><a id="4297" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a><a id="4300" class="Symbol">)</a> <a id="4302" class="Symbol">(</a><a id="4303" href="1Lab.HIT.Suspension.html#329" data-type="A → N ≡ S" class="InductiveConstructor">merid</a> <a id="4309" href="SHT.Base.html#3705" class="Bound">x</a><a id="4310" class="Symbol">)</a>                                 <span class="reasoning-step"><span class="as-written Function"><a id="4344" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="4347" href="1Lab.Path.Groupoid.html#5500" data-type="(p : x ≡ y) → sym p ∙ p ≡ refl" class="Function">∙-inv-l</a> <a id="4355" class="Symbol">_</a> <a id="4357" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="4365" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>                                                                                <a id="4449" href="1Lab.Path.html#46945" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>

    <a id="4456" href="SHT.Base.html#4456" data-type="is-left-inverse loops→Σ-map∙ Σ-map∙→loops" class="Function">invl</a> <a id="4461" class="Symbol">:</a> <a id="4463" href="1Lab.Equiv.html#5649" data-type="(B₁ → A) → (A → B₁) → Type A.ℓ₁" class="Function">is-left-inverse</a> <a id="4479" href="SHT.Base.html#2326" data-type="Σ (λ bs → A .fst → B₁ .snd ≡ bs) → Σ∙ A →∙ B₁" class="Function">loops→Σ-map∙</a> <a id="4492" href="SHT.Base.html#2166" data-type="Σ∙ A →∙ B₁ → Σ (λ bs → A .fst → B₁ .snd ≡ bs)" class="Function">Σ-map∙→loops</a>
    <a id="4509" href="SHT.Base.html#4456" data-type="is-left-inverse loops→Σ-map∙ Σ-map∙→loops" class="Function">invl</a> <a id="4514" href="SHT.Base.html#4514" class="Bound">f</a> <a id="4516" class="Symbol">=</a> <a id="4518" href="1Lab.Path.html#57276" data-type="(p : x .fst ≡ y .fst) →
PathP (λ i → B₁ (p i)) (x .snd) (y .snd) → x ≡ y" class="Function">Σ-pathp</a> <a id="4526" class="Symbol">(</a><a id="4527" href="1Lab.Path.html#58474" data-type="((x : A) → f x ≡ g x) → f ≡ g" class="Function">funext</a> <a id="4534" class="Symbol">(λ</a> <a id="4537" class="Symbol">{</a> <a id="4539" href="1Lab.HIT.Suspension.html#312" data-type="Susp A" class="InductiveConstructor">N</a> <a id="4541" class="Symbol">→</a> <a id="4543" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="4547" class="Symbol">(</a><a id="4548" href="SHT.Base.html#4514" class="Bound">f</a> <a id="4550" class="Symbol">.</a><a id="4551" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a><a id="4554" class="Symbol">)</a>
                                <a id="4588" class="Symbol">;</a> <a id="4590" href="1Lab.HIT.Suspension.html#314" data-type="Susp A" class="InductiveConstructor">S</a> <a id="4592" class="Symbol">→</a> <a id="4594" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
                                <a id="4631" class="Symbol">;</a> <a id="4633" class="Symbol">(</a><a id="4634" href="1Lab.HIT.Suspension.html#329" data-type="A → N ≡ S" class="InductiveConstructor">merid</a> <a id="4640" href="SHT.Base.html#4640" class="Bound">x</a> <a id="4642" href="SHT.Base.html#4642" class="Bound">i</a><a id="4643" class="Symbol">)</a> <a id="4645" class="Symbol">→</a> <a id="4647" class="Symbol">λ</a> <a id="4649" href="SHT.Base.html#4649" class="Bound">j</a> <a id="4651" class="Symbol">→</a> <a id="4653" href="SHT.Base.html#3561" data-type="(f : Σ∙ A →∙ B₁) (x : A .fst) →
Square (sym (f .snd) ∙ ap (f .fst) (merid x)) (sym (f .snd)) refl
(ap (f .fst) (merid x))" class="Function">lemma</a> <a id="4659" href="SHT.Base.html#4514" class="Bound">f</a> <a id="4661" href="SHT.Base.html#4640" class="Bound">x</a> <a id="4663" href="SHT.Base.html#4642" class="Bound">i</a> <a id="4665" href="SHT.Base.html#4649" class="Bound">j</a> <a id="4667" class="Symbol">}))</a>
                      <a id="4693" class="Symbol">(</a><a id="4694" href="1Lab.Path.html#55976" data-type="coe0→1 A x ≡ y → PathP A x y" class="Function">to-pathp</a> <a id="4703" class="Symbol">(</a><a id="4704" href="1Lab.Path.html#60701" data-type="(loop₁ : x ≡ z) (adj : x ≡ y) →
subst (λ e → e ≡ z) adj loop₁ ≡ sym adj ∙ loop₁" class="Function">subst-path-left</a> <a id="4720" class="Symbol">_</a> <a id="4722" class="Symbol">_</a> <a id="4724" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="4726" href="1Lab.Path.Groupoid.html#4549" data-type="(p : x ≡ y) → p ∙ refl ≡ p" class="Function">∙-id-r</a> <a id="4733" class="Symbol">_</a> <a id="4735" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="4737" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a><a id="4741" class="Symbol">))</a>

  <a id="4747" href="SHT.Base.html#4747" data-type="Σ (λ bs → A .fst → B₁ .snd ≡ bs) ≃ (A →∙ Ω∙ B₁)" class="Function">loops≃map∙-Ω</a> <a id="4760" class="Symbol">:</a> <a id="4762" class="Symbol">(</a><a id="4763" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">Σ</a> <a id="4765" class="Symbol">λ</a> <a id="4767" href="SHT.Base.html#4767" class="Bound">bs</a> <a id="4770" class="Symbol">→</a> <a id="4772" href="SHT.Base.html#2130" class="Bound">A</a> <a id="4774" class="Symbol">.</a><a id="4775" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="4779" class="Symbol">→</a> <a id="4781" href="SHT.Base.html#2144" class="Bound">B</a> <a id="4783" class="Symbol">.</a><a id="4784" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="4788" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="4790" href="SHT.Base.html#4767" class="Bound">bs</a><a id="4792" class="Symbol">)</a> <a id="4794" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="4796" class="Symbol">(</a><a id="4797" href="SHT.Base.html#2130" class="Bound">A</a> <a id="4799" href="SHT.Base.html#1019" data-type="Type∙ ℓ → Type∙ ℓ′ → Type (ℓ ⊔ ℓ′)" class="Function Operator">→∙</a> <a id="4802" href="SHT.Base.html#1304" data-type="Type∙ ℓ → Type∙ ℓ" class="Function">Ω∙</a> <a id="4805" href="SHT.Base.html#2144" class="Bound">B</a><a id="4806" class="Symbol">)</a>
  <a id="4810" href="SHT.Base.html#4747" data-type="Σ (λ bs → A .fst → B₁ .snd ≡ bs) ≃ (A →∙ Ω∙ B₁)" class="Function">loops≃map∙-Ω</a> <a id="4823" class="Symbol">=</a> <a id="4825" href="1Lab.Equiv.html#20503" data-type="Iso A B₁ → A ≃ B₁" class="Function">Iso→Equiv</a> <a id="4835" class="Symbol">(</a><a id="4836" href="SHT.Base.html#2759" data-type="Σ (λ bs → A .fst → B₁ .snd ≡ bs) → A →∙ Ω∙ B₁" class="Function">loops→map∙-Ω</a> <a id="4849" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="4851" href="1Lab.Equiv.html#6116" data-type="(inv₁ : B₁ → A) (rinv₁ : is-right-inverse inv₁ f)
(linv₁ : is-left-inverse inv₁ f) →
is-iso f" class="InductiveConstructor">iso</a> <a id="4855" href="SHT.Base.html#2931" data-type="A →∙ Ω∙ B₁ → Σ (λ bs → A .fst → B₁ .snd ≡ bs)" class="Function">map∙-Ω→loops</a> <a id="4868" href="SHT.Base.html#5163" data-type="is-right-inverse map∙-Ω→loops loops→map∙-Ω" class="Function">invr</a> <a id="4873" href="SHT.Base.html#5998" data-type="is-left-inverse map∙-Ω→loops loops→map∙-Ω" class="Function">invl</a><a id="4877" class="Symbol">)</a> <a id="4879" class="Keyword">where</a>
    <a id="4889" href="SHT.Base.html#4889" data-type="(q : x ≡ x) (r : refl ≡ q) →
ap (λ p → q ∙ sym p) r ∙ ∙-inv-r q ≡ ∙-id-r q ∙ sym r" class="Function">lemma′</a> <a id="4896" class="Symbol">:</a> <a id="4898" class="Symbol">∀</a> <a id="4900" class="Symbol">{</a><a id="4901" href="SHT.Base.html#4901" class="Bound">ℓ</a><a id="4902" class="Symbol">}</a> <a id="4904" class="Symbol">{</a><a id="4905" href="SHT.Base.html#4905" class="Bound">A</a> <a id="4907" class="Symbol">:</a> <a id="4909" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="4914" href="SHT.Base.html#4901" class="Bound">ℓ</a><a id="4915" class="Symbol">}</a> <a id="4917" class="Symbol">{</a><a id="4918" href="SHT.Base.html#4918" class="Bound">x</a> <a id="4920" class="Symbol">:</a> <a id="4922" href="SHT.Base.html#4905" class="Bound">A</a><a id="4923" class="Symbol">}</a> <a id="4925" class="Symbol">(</a><a id="4926" href="SHT.Base.html#4926" class="Bound">q</a> <a id="4928" class="Symbol">:</a> <a id="4930" href="SHT.Base.html#4918" class="Bound">x</a> <a id="4932" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="4934" href="SHT.Base.html#4918" class="Bound">x</a><a id="4935" class="Symbol">)</a> <a id="4937" class="Symbol">(</a><a id="4938" href="SHT.Base.html#4938" class="Bound">r</a> <a id="4940" class="Symbol">:</a> <a id="4942" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="4947" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="4949" href="SHT.Base.html#4926" class="Bound">q</a><a id="4950" class="Symbol">)</a>
           <a id="4963" class="Symbol">→</a> <a id="4965" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="4968" class="Symbol">(λ</a> <a id="4971" href="SHT.Base.html#4971" class="Bound">p</a> <a id="4973" class="Symbol">→</a> <a id="4975" href="SHT.Base.html#4926" class="Bound">q</a> <a id="4977" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="4979" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="4983" href="SHT.Base.html#4971" class="Bound">p</a><a id="4984" class="Symbol">)</a> <a id="4986" href="SHT.Base.html#4938" class="Bound">r</a> <a id="4988" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="4990" href="1Lab.Path.Groupoid.html#5058" data-type="(p : x ≡ y) → p ∙ sym p ≡ refl" class="Function">∙-inv-r</a> <a id="4998" href="SHT.Base.html#4926" class="Bound">q</a> <a id="5000" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="5002" href="1Lab.Path.Groupoid.html#4549" data-type="(p : x ≡ y) → p ∙ refl ≡ p" class="Function">∙-id-r</a> <a id="5009" href="SHT.Base.html#4926" class="Bound">q</a> <a id="5011" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="5013" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="5017" href="SHT.Base.html#4938" class="Bound">r</a>
    <a id="5023" href="SHT.Base.html#4889" data-type="(q : x ≡ x) (r : refl ≡ q) →
ap (λ p → q ∙ sym p) r ∙ ∙-inv-r q ≡ ∙-id-r q ∙ sym r" class="Function">lemma′</a> <a id="5030" href="SHT.Base.html#5030" class="Bound">q</a> <a id="5032" href="SHT.Base.html#5032" class="Bound">r</a> <a id="5034" class="Symbol">=</a>
      <a id="5042" href="1Lab.Path.html#19544" data-type="(P : (y : A) → x ≡ y → Type ℓ₂) → P x refl → (p : x ≡ y) → P y p" class="Function">J</a> <a id="5044" class="Symbol">(λ</a> <a id="5047" href="SHT.Base.html#5047" class="Bound">q′</a> <a id="5050" href="SHT.Base.html#5050" class="Bound">r</a> <a id="5052" class="Symbol">→</a> <a id="5054" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="5057" class="Symbol">(λ</a> <a id="5060" href="SHT.Base.html#5060" class="Bound">p</a> <a id="5062" class="Symbol">→</a> <a id="5064" href="SHT.Base.html#5047" class="Bound">q′</a> <a id="5067" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="5069" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="5073" href="SHT.Base.html#5060" class="Bound">p</a><a id="5074" class="Symbol">)</a> <a id="5076" href="SHT.Base.html#5050" class="Bound">r</a> <a id="5078" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="5080" href="1Lab.Path.Groupoid.html#5058" data-type="(p : x ≡ y) → p ∙ sym p ≡ refl" class="Function">∙-inv-r</a> <a id="5088" href="SHT.Base.html#5047" class="Bound">q′</a> <a id="5091" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="5093" href="1Lab.Path.Groupoid.html#4549" data-type="(p : x ≡ y) → p ∙ refl ≡ p" class="Function">∙-id-r</a> <a id="5100" href="SHT.Base.html#5047" class="Bound">q′</a> <a id="5103" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="5105" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="5109" href="SHT.Base.html#5050" class="Bound">r</a><a id="5110" class="Symbol">)</a>
        <a id="5120" class="Symbol">(</a><a id="5121" href="1Lab.Path.Groupoid.html#4623" data-type="(p : x ≡ y) → refl ∙ p ≡ p" class="Function">∙-id-l</a> <a id="5128" class="Symbol">_</a> <a id="5130" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="5132" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="5136" class="Symbol">(</a><a id="5137" href="1Lab.Path.Groupoid.html#4549" data-type="(p : x ≡ y) → p ∙ refl ≡ p" class="Function">∙-id-r</a> <a id="5144" class="Symbol">_))</a>
        <a id="5156" href="SHT.Base.html#5032" class="Bound">r</a>

    <a id="5163" href="SHT.Base.html#5163" data-type="is-right-inverse map∙-Ω→loops loops→map∙-Ω" class="Function">invr</a> <a id="5168" class="Symbol">:</a> <a id="5170" href="1Lab.Equiv.html#5739" data-type="(B₁ → A) → (A → B₁) → Type B.ℓ₁" class="Function">is-right-inverse</a> <a id="5187" href="SHT.Base.html#2931" data-type="A →∙ Ω∙ B₁ → Σ (λ bs → A .fst → B₁ .snd ≡ bs)" class="Function">map∙-Ω→loops</a> <a id="5200" href="SHT.Base.html#2759" data-type="Σ (λ bs → A .fst → B₁ .snd ≡ bs) → A →∙ Ω∙ B₁" class="Function">loops→map∙-Ω</a>
    <a id="5217" href="SHT.Base.html#5163" data-type="is-right-inverse map∙-Ω→loops loops→map∙-Ω" class="Function">invr</a> <a id="5222" class="Symbol">(</a><a id="5223" href="SHT.Base.html#5223" class="Bound">b</a> <a id="5225" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="5227" href="SHT.Base.html#5227" class="Bound">x</a><a id="5228" class="Symbol">)</a> <a id="5230" class="Symbol">=</a> <a id="5232" href="1Lab.Path.html#57276" data-type="(p : x .fst ≡ y .fst) →
PathP (λ i → B₁ (p i)) (x .snd) (y .snd) → x ≡ y" class="Function">Σ-pathp</a> <a id="5240" class="Symbol">(</a><a id="5241" href="1Lab.Path.html#58474" data-type="((x : A) → f x ≡ g x) → f ≡ g" class="Function">funext</a> <a id="5248" class="Symbol">(λ</a> <a id="5251" href="SHT.Base.html#5251" class="Bound">a</a> <a id="5253" class="Symbol">→</a> <a id="5255" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="5259" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">_∙_</a> <a id="5263" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="5268" class="Symbol">(</a><a id="5269" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="5272" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="5276" href="SHT.Base.html#5227" class="Bound">x</a><a id="5277" class="Symbol">)</a> <a id="5279" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="5281" href="1Lab.Path.Groupoid.html#4549" data-type="(p : x ≡ y) → p ∙ refl ≡ p" class="Function">∙-id-r</a> <a id="5288" class="Symbol">_))</a>
      <a id="5298" class="Symbol">(</a><a id="5299" href="1Lab.Path.html#55976" data-type="coe0→1 A x ≡ y → PathP A x y" class="Function">to-pathp</a> <a id="5308" class="Symbol">(</a><a id="5309" href="1Lab.Path.html#60701" data-type="(loop₁ : x ≡ z) (adj : x ≡ y) →
subst (λ e → e ≡ z) adj loop₁ ≡ sym adj ∙ loop₁" class="Function">subst-path-left</a> <a id="5325" class="Symbol">_</a> <a id="5327" class="Symbol">_</a> <a id="5329" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="5331" href="SHT.Base.html#5359" data-type="(b : A .fst → Ω∙ B₁ .fst) (x : b (A .snd) ≡ Ω∙ B₁ .snd) →
sym (ap₂ _∙_ refl (ap sym x) ∙ ∙-id-r (b (A .snd))) ∙
∙-inv-r (b (A .snd))
≡ x" class="Function">lemma</a><a id="5336" class="Symbol">))</a>
      <a id="5345" class="Keyword">where</a>
        <a id="5359" href="SHT.Base.html#5359" data-type="(b : A .fst → Ω∙ B₁ .fst) (x : b (A .snd) ≡ Ω∙ B₁ .snd) →
sym (ap₂ _∙_ refl (ap sym x) ∙ ∙-id-r (b (A .snd))) ∙
∙-inv-r (b (A .snd))
≡ x" class="Function">lemma</a> <a id="5365" class="Symbol">=</a>
          <a id="5377" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="5381" class="Symbol">(</a><a id="5382" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="5386" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">_∙_</a> <a id="5390" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="5395" class="Symbol">(</a><a id="5396" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="5399" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="5403" href="SHT.Base.html#5227" class="Bound">x</a><a id="5404" class="Symbol">)</a> <a id="5406" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="5408" href="1Lab.Path.Groupoid.html#4549" data-type="(p : x ≡ y) → p ∙ refl ≡ p" class="Function">∙-id-r</a> <a id="5415" class="Symbol">(</a><a id="5416" href="SHT.Base.html#5223" class="Bound">b</a> <a id="5418" class="Symbol">(</a><a id="5419" href="SHT.Base.html#2130" class="Bound">A</a> <a id="5421" class="Symbol">.</a><a id="5422" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a><a id="5425" class="Symbol">)))</a> <a id="5429" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="5431" href="1Lab.Path.Groupoid.html#5058" data-type="(p : x ≡ y) → p ∙ sym p ≡ refl" class="Function">∙-inv-r</a> <a id="5439" class="Symbol">(</a><a id="5440" href="SHT.Base.html#5223" class="Bound">b</a> <a id="5442" class="Symbol">(</a><a id="5443" href="SHT.Base.html#2130" class="Bound">A</a> <a id="5445" class="Symbol">.</a><a id="5446" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a><a id="5449" class="Symbol">))</a>               <span class="reasoning-step"><span class="as-written Function"><a id="5466" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="5469" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="5473" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">_∙_</a> <a id="5477" class="Symbol">(</a><a id="5478" href="1Lab.Path.html#63945" data-type="(p : x ≡ y) (q : y ≡ z) → sym (p ∙ q) ≡ sym q ∙ sym p" class="Function">sym-∙</a> <a id="5484" class="Symbol">(</a><a id="5485" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="5489" class="Symbol">_)</a> <a id="5492" class="Symbol">_)</a> <a id="5495" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="5500" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
          <a id="5512" class="Symbol">(</a><a id="5513" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="5517" class="Symbol">(</a><a id="5518" href="1Lab.Path.Groupoid.html#4549" data-type="(p : x ≡ y) → p ∙ refl ≡ p" class="Function">∙-id-r</a> <a id="5525" class="Symbol">(</a><a id="5526" href="SHT.Base.html#5223" class="Bound">b</a> <a id="5528" class="Symbol">(</a><a id="5529" href="SHT.Base.html#2130" class="Bound">A</a> <a id="5531" class="Symbol">.</a><a id="5532" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a><a id="5535" class="Symbol">)))</a> <a id="5539" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="5541" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="5544" class="Symbol">(</a><a id="5545" href="SHT.Base.html#5223" class="Bound">b</a> <a id="5547" class="Symbol">(</a><a id="5548" href="SHT.Base.html#2130" class="Bound">A</a> <a id="5550" class="Symbol">.</a><a id="5551" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a><a id="5554" class="Symbol">)</a> <a id="5556" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙_</a><a id="5558" class="Symbol">)</a> <a id="5560" class="Symbol">(</a><a id="5561" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="5564" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="5568" class="Symbol">(</a><a id="5569" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="5573" href="SHT.Base.html#5227" class="Bound">x</a><a id="5574" class="Symbol">)))</a> <a id="5578" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="5580" href="1Lab.Path.Groupoid.html#5058" data-type="(p : x ≡ y) → p ∙ sym p ≡ refl" class="Function">∙-inv-r</a> <a id="5588" class="Symbol">(</a><a id="5589" href="SHT.Base.html#5223" class="Bound">b</a> <a id="5591" class="Symbol">(</a><a id="5592" href="SHT.Base.html#2130" class="Bound">A</a> <a id="5594" class="Symbol">.</a><a id="5595" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a><a id="5598" class="Symbol">))</a> <span class="reasoning-step"><span class="as-written Function"><a id="5601" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="5604" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="5608" class="Symbol">(</a><a id="5609" href="1Lab.Path.Groupoid.html#4743" data-type="(p : w ≡ x) (q : x ≡ y) (r : y ≡ z) → p ∙ q ∙ r ≡ (p ∙ q) ∙ r" class="Function">∙-assoc</a> <a id="5617" class="Symbol">_</a> <a id="5619" class="Symbol">_</a> <a id="5621" class="Symbol">_)</a> <a id="5624" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
          <a id="5636" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="5640" class="Symbol">(</a><a id="5641" href="1Lab.Path.Groupoid.html#4549" data-type="(p : x ≡ y) → p ∙ refl ≡ p" class="Function">∙-id-r</a> <a id="5648" class="Symbol">(</a><a id="5649" href="SHT.Base.html#5223" class="Bound">b</a> <a id="5651" class="Symbol">(</a><a id="5652" href="SHT.Base.html#2130" class="Bound">A</a> <a id="5654" class="Symbol">.</a><a id="5655" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a><a id="5658" class="Symbol">)))</a> <a id="5662" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="5664" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="5667" class="Symbol">(λ</a> <a id="5670" href="SHT.Base.html#5670" class="Bound">p</a> <a id="5672" class="Symbol">→</a> <a id="5674" href="SHT.Base.html#5223" class="Bound">b</a> <a id="5676" class="Symbol">(</a><a id="5677" href="SHT.Base.html#2130" class="Bound">A</a> <a id="5679" class="Symbol">.</a><a id="5680" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a><a id="5683" class="Symbol">)</a> <a id="5685" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="5687" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="5691" href="SHT.Base.html#5670" class="Bound">p</a><a id="5692" class="Symbol">)</a> <a id="5694" class="Symbol">(</a><a id="5695" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="5699" href="SHT.Base.html#5227" class="Bound">x</a><a id="5700" class="Symbol">)</a> <a id="5702" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="5704" href="1Lab.Path.Groupoid.html#5058" data-type="(p : x ≡ y) → p ∙ sym p ≡ refl" class="Function">∙-inv-r</a> <a id="5712" class="Symbol">(</a><a id="5713" href="SHT.Base.html#5223" class="Bound">b</a> <a id="5715" class="Symbol">(</a><a id="5716" href="SHT.Base.html#2130" class="Bound">A</a> <a id="5718" class="Symbol">.</a><a id="5719" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a><a id="5722" class="Symbol">))</a> <span class="reasoning-step"><span class="as-written Function"><a id="5725" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="5728" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="5732" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">_∙_</a> <a id="5736" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="5741" class="Symbol">(</a><a id="5742" href="SHT.Base.html#4889" data-type="(q : x ≡ x) (r : refl ≡ q) →
ap (λ p → q ∙ sym p) r ∙ ∙-inv-r q ≡ ∙-id-r q ∙ sym r" class="Function">lemma′</a> <a id="5749" class="Symbol">(</a><a id="5750" href="SHT.Base.html#5223" class="Bound">b</a> <a id="5752" class="Symbol">(</a><a id="5753" href="SHT.Base.html#2130" class="Bound">A</a> <a id="5755" class="Symbol">.</a><a id="5756" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a><a id="5759" class="Symbol">))</a> <a id="5762" class="Symbol">(</a><a id="5763" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="5767" href="SHT.Base.html#5227" class="Bound">x</a><a id="5768" class="Symbol">))</a> <a id="5771" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
          <a id="5783" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="5787" class="Symbol">(</a><a id="5788" href="1Lab.Path.Groupoid.html#4549" data-type="(p : x ≡ y) → p ∙ refl ≡ p" class="Function">∙-id-r</a> <a id="5795" class="Symbol">(</a><a id="5796" href="SHT.Base.html#5223" class="Bound">b</a> <a id="5798" class="Symbol">(</a><a id="5799" href="SHT.Base.html#2130" class="Bound">A</a> <a id="5801" class="Symbol">.</a><a id="5802" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a><a id="5805" class="Symbol">)))</a> <a id="5809" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="5811" href="1Lab.Path.Groupoid.html#4549" data-type="(p : x ≡ y) → p ∙ refl ≡ p" class="Function">∙-id-r</a> <a id="5818" class="Symbol">(</a><a id="5819" href="SHT.Base.html#5223" class="Bound">b</a> <a id="5821" class="Symbol">(</a><a id="5822" href="SHT.Base.html#2130" class="Bound">A</a> <a id="5824" class="Symbol">.</a><a id="5825" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a><a id="5828" class="Symbol">))</a> <a id="5831" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="5833" href="SHT.Base.html#5227" class="Bound">x</a>                                      <span class="reasoning-step"><span class="as-written Function"><a id="5872" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="5875" href="1Lab.Path.Groupoid.html#6877" data-type="(p : x ≡ y) (q : y ≡ z) → sym p ∙ p ∙ q ≡ q" class="Function">∙-cancel-l</a> <a id="5886" class="Symbol">_</a> <a id="5888" class="Symbol">_</a> <a id="5890" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
          <a id="5902" href="SHT.Base.html#5227" class="Bound">x</a>                                                                                        <a id="5991" href="1Lab.Path.html#46945" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>

    <a id="5998" href="SHT.Base.html#5998" data-type="is-left-inverse map∙-Ω→loops loops→map∙-Ω" class="Function">invl</a> <a id="6003" class="Symbol">:</a> <a id="6005" href="1Lab.Equiv.html#5649" data-type="(B₁ → A) → (A → B₁) → Type A.ℓ₁" class="Function">is-left-inverse</a> <a id="6021" href="SHT.Base.html#2931" data-type="A →∙ Ω∙ B₁ → Σ (λ bs → A .fst → B₁ .snd ≡ bs)" class="Function">map∙-Ω→loops</a> <a id="6034" href="SHT.Base.html#2759" data-type="Σ (λ bs → A .fst → B₁ .snd ≡ bs) → A →∙ Ω∙ B₁" class="Function">loops→map∙-Ω</a>
    <a id="6051" href="SHT.Base.html#5998" data-type="is-left-inverse map∙-Ω→loops loops→map∙-Ω" class="Function">invl</a> <a id="6056" class="Symbol">(</a><a id="6057" href="SHT.Base.html#6057" class="Bound">f</a> <a id="6059" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="6061" href="SHT.Base.html#6061" class="Bound">p</a><a id="6062" class="Symbol">)</a> <a id="6064" class="Symbol">=</a> <a id="6066" href="1Lab.Path.html#57276" data-type="(p : x .fst ≡ y .fst) →
PathP (λ i → B₁ (p i)) (x .snd) (y .snd) → x ≡ y" class="Function">Σ-pathp</a> <a id="6074" class="Symbol">(</a><a id="6075" href="SHT.Base.html#6061" class="Bound">p</a> <a id="6077" class="Symbol">(</a><a id="6078" href="SHT.Base.html#2130" class="Bound">A</a> <a id="6080" class="Symbol">.</a><a id="6081" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a><a id="6084" class="Symbol">))</a> <a id="6087" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="6089" href="1Lab.Path.html#55976" data-type="coe0→1 A x ≡ y → PathP A x y" class="Function">to-pathp</a> <a id="6098" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="6100" href="1Lab.Path.html#58474" data-type="((x : A) → f x ≡ g x) → f ≡ g" class="Function">funext</a> <a id="6107" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="6109" class="Symbol">λ</a> <a id="6111" href="SHT.Base.html#6111" class="Bound">x</a> <a id="6113" class="Symbol">→</a>
        <a id="6123" href="1Lab.Path.html#61401" data-type="(loop₁ : x ≡ z) (adj : z ≡ y) →
subst (_≡_ x) adj loop₁ ≡ loop₁ ∙ adj" class="Function">subst-path-right</a> <a id="6140" class="Symbol">_</a> <a id="6142" class="Symbol">_</a> <a id="6144" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="6146" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="6150" class="Symbol">(</a><a id="6151" href="1Lab.Path.Groupoid.html#4743" data-type="(p : w ≡ x) (q : x ≡ y) (r : y ≡ z) → p ∙ q ∙ r ≡ (p ∙ q) ∙ r" class="Function">∙-assoc</a> <a id="6159" class="Symbol">_</a> <a id="6161" class="Symbol">_</a> <a id="6163" class="Symbol">_)</a>
      <a id="6172" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="6174" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="6178" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">_∙_</a> <a id="6182" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="6187" class="Symbol">(</a><a id="6188" href="1Lab.Path.Groupoid.html#5500" data-type="(p : x ≡ y) → sym p ∙ p ≡ refl" class="Function">∙-inv-l</a> <a id="6196" class="Symbol">(</a><a id="6197" href="SHT.Base.html#6061" class="Bound">p</a> <a id="6199" class="Symbol">(</a><a id="6200" href="SHT.Base.html#2130" class="Bound">A</a> <a id="6202" class="Symbol">.</a><a id="6203" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a><a id="6206" class="Symbol">)))</a> <a id="6210" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="6212" href="1Lab.Path.Groupoid.html#4549" data-type="(p : x ≡ y) → p ∙ refl ≡ p" class="Function">∙-id-r</a> <a id="6219" class="Symbol">_</a>
      <a id="6227" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="6229" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="6232" href="SHT.Base.html#6061" class="Bound">p</a> <a id="6234" class="Symbol">(</a><a id="6235" href="1Lab.Path.html#13454" data-type="(x : A) → transport (λ i → A) x ≡ x" class="Function">transport-refl</a> <a id="6250" href="SHT.Base.html#6111" class="Bound">x</a><a id="6251" class="Symbol">)</a>
</pre>
</details>
<p>Composing these equivalences, we get the adjunction:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">Σ</mi><mi>A</mi><msub><mo>→</mo><mo>∗</mo></msub><mi>B</mi><mo stretchy="false">)</mo><mo>≃</mo><mo stretchy="false">(</mo><mi>A</mi><mo>→</mo><mo>∗</mo><mi mathvariant="normal">Ω</mi><mi>B</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">
(\Sigma A \to_* B) \simeq (A \to* \Omega B).
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">Σ</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel">→</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1757em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≃</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∗</span><span class="mord">Ω</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mord">.</span></span></span></span></span></p>
<pre class="Agda">  <a id="6385" href="SHT.Base.html#6385" data-type="(Σ∙ A →∙ B₁) ≃ (A →∙ Ωⁿ 1 B₁)" class="Function">Σ-map∙≃map∙-Ω</a> <a id="6399" class="Symbol">:</a> <a id="6401" class="Symbol">(</a><a id="6402" href="SHT.Base.html#1247" data-type="Type∙ ℓ → Type∙ ℓ" class="Function">Σ∙</a> <a id="6405" href="SHT.Base.html#2130" class="Bound">A</a> <a id="6407" href="SHT.Base.html#1019" data-type="Type∙ ℓ → Type∙ ℓ′ → Type (ℓ ⊔ ℓ′)" class="Function Operator">→∙</a> <a id="6410" href="SHT.Base.html#2144" class="Bound">B</a><a id="6411" class="Symbol">)</a> <a id="6413" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="6415" class="Symbol">(</a><a id="6416" href="SHT.Base.html#2130" class="Bound">A</a> <a id="6418" href="SHT.Base.html#1019" data-type="Type∙ ℓ → Type∙ ℓ′ → Type (ℓ ⊔ ℓ′)" class="Function Operator">→∙</a> <a id="6421" href="Algebra.Group.Homotopy.html#616" data-type="Nat → Type∙ ℓ → Type∙ ℓ" class="Function">Ωⁿ</a> <a id="6424" class="Number">1</a> <a id="6426" href="SHT.Base.html#2144" class="Bound">B</a><a id="6427" class="Symbol">)</a>
  <a id="6431" href="SHT.Base.html#6385" data-type="(Σ∙ A →∙ B₁) ≃ (A →∙ Ωⁿ 1 B₁)" class="Function">Σ-map∙≃map∙-Ω</a> <a id="6445" class="Symbol">=</a> <a id="6447" href="SHT.Base.html#3231" data-type="(Σ∙ A →∙ B₁) ≃ Σ (λ b → A .fst → B₁ .snd ≡ b)" class="Function">Σ-map∙≃loops</a> <a id="6460" href="1Lab.Equiv.html#21607" data-type="A ≃ B₁ → B₁ ≃ C → A ≃ C" class="Function Operator">∙e</a> <a id="6463" href="SHT.Base.html#4747" data-type="Σ (λ bs → A .fst → B₁ .snd ≡ bs) ≃ (A →∙ Ω∙ B₁)" class="Function">loops≃map∙-Ω</a>
</pre>
<h3 id="loop-spaces-are-equivalently-based-maps-out-of-spheres"><a href="#loop-spaces-are-equivalently-based-maps-out-of-spheres" class="header-link">Loop
spaces are equivalently based maps out of
spheres<span class="header-link-emoji">🔗</span></a></h3>
<p>Repeatedly applying the equivalence we just built, we can build an
equivalence</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><msup><mi>S</mi><mi>n</mi></msup><msub><mo>→</mo><mo>∗</mo></msub><mi>A</mi><mo stretchy="false">)</mo><mo>≃</mo><mo stretchy="false">(</mo><mi mathvariant="normal">Σ</mi><msup><mi>S</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup><msub><mo>→</mo><mo>∗</mo></msub><mi mathvariant="normal">Ω</mi><mi>A</mi><mo stretchy="false">)</mo><mo>≃</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>≃</mo><msup><mi mathvariant="normal">Ω</mi><mi>n</mi></msup><mi>A</mi><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">
(S^n \to_* A) \simeq (\Sigma S^{n - 1} \to_* \Omega A) \simeq ... \simeq \Omega^n A,
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel">→</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1757em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≃</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1141em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">Σ</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel">→</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1757em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Ω</span><span class="mord mathnormal">A</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≃</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4637em;"></span><span class="mord">...</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≃</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9088em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord">Ω</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mord mathnormal">A</span><span class="mpunct">,</span></span></span></span></span></p>
<p>thus characterising
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>-fold</span>
loop spaces as basepoint-preserving maps out of
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>S</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">S^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>,</span>
the
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>-dimensional</span>
sphere.</p>
<!--
<pre class="Agda"><a id="reassoc-Ω"></a><a id="6839" href="SHT.Base.html#6839" data-type="(n : Nat) → Ωⁿ n (Ω∙ A) ≡ Ωⁿ (suc n) A" class="Function">reassoc-Ω</a> <a id="6849" class="Symbol">:</a> <a id="6851" class="Symbol">∀</a> <a id="6853" class="Symbol">{</a><a id="6854" href="SHT.Base.html#6854" class="Bound">ℓ</a><a id="6855" class="Symbol">}</a> <a id="6857" class="Symbol">{</a><a id="6858" href="SHT.Base.html#6858" class="Bound">A</a> <a id="6860" class="Symbol">:</a> <a id="6862" href="1Lab.Type.html#2800" data-type="(ℓ : Level) → Type (lsuc ℓ)" class="Function">Type∙</a> <a id="6868" href="SHT.Base.html#6854" class="Bound">ℓ</a><a id="6869" class="Symbol">}</a> <a id="6871" href="SHT.Base.html#6871" class="Bound">n</a> <a id="6873" class="Symbol">→</a> <a id="6875" href="Algebra.Group.Homotopy.html#616" data-type="Nat → Type∙ ℓ → Type∙ ℓ" class="Function">Ωⁿ</a> <a id="6878" href="SHT.Base.html#6871" class="Bound">n</a> <a id="6880" class="Symbol">(</a><a id="6881" href="SHT.Base.html#1304" data-type="Type∙ ℓ → Type∙ ℓ" class="Function">Ω∙</a> <a id="6884" href="SHT.Base.html#6858" class="Bound">A</a><a id="6885" class="Symbol">)</a> <a id="6887" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="6889" href="Algebra.Group.Homotopy.html#616" data-type="Nat → Type∙ ℓ → Type∙ ℓ" class="Function">Ωⁿ</a> <a id="6892" class="Symbol">(</a><a id="6893" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="6897" href="SHT.Base.html#6871" class="Bound">n</a><a id="6898" class="Symbol">)</a> <a id="6900" href="SHT.Base.html#6858" class="Bound">A</a>
<a id="6902" href="SHT.Base.html#6839" data-type="(n : Nat) → Ωⁿ n (Ω∙ A) ≡ Ωⁿ (suc n) A" class="Function">reassoc-Ω</a> <a id="6912" href="Agda.Builtin.Nat.html#195" data-type="Nat" class="InductiveConstructor">zero</a> <a id="6917" class="Symbol">=</a> <a id="6919" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
<a id="6924" href="SHT.Base.html#6839" data-type="(n : Nat) → Ωⁿ n (Ω∙ A) ≡ Ωⁿ (suc n) A" class="Function">reassoc-Ω</a> <a id="6934" class="Symbol">{</a><a id="6935" class="Argument">A</a> <a id="6937" class="Symbol">=</a> <a id="6939" href="SHT.Base.html#6939" class="Bound">A</a><a id="6940" class="Symbol">}</a> <a id="6942" class="Symbol">(</a><a id="6943" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="6947" href="SHT.Base.html#6947" class="Bound">n</a><a id="6948" class="Symbol">)</a> <a id="6950" class="Symbol">=</a>
  <a id="6954" href="Algebra.Group.Homotopy.html#616" data-type="Nat → Type∙ ℓ → Type∙ ℓ" class="Function">Ωⁿ</a> <a id="6957" class="Number">1</a> <a id="6959" class="Symbol">(</a><a id="6960" href="Algebra.Group.Homotopy.html#616" data-type="Nat → Type∙ ℓ → Type∙ ℓ" class="Function">Ωⁿ</a> <a id="6963" href="SHT.Base.html#6947" class="Bound">n</a> <a id="6965" class="Symbol">(</a><a id="6966" href="Algebra.Group.Homotopy.html#616" data-type="Nat → Type∙ ℓ → Type∙ ℓ" class="Function">Ωⁿ</a> <a id="6969" class="Number">1</a> <a id="6971" href="SHT.Base.html#6939" class="Bound">A</a><a id="6972" class="Symbol">))</a> <a id="6975" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="6978" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="6981" class="Symbol">(</a><a id="6982" href="Algebra.Group.Homotopy.html#616" data-type="Nat → Type∙ ℓ → Type∙ ℓ" class="Function">Ωⁿ</a> <a id="6985" class="Number">1</a><a id="6986" class="Symbol">)</a> <a id="6988" class="Symbol">(</a><a id="6989" href="SHT.Base.html#6839" data-type="(n : Nat) → Ωⁿ n (Ω∙ A) ≡ Ωⁿ (suc n) A" class="Function">reassoc-Ω</a> <a id="6999" href="SHT.Base.html#6947" class="Bound">n</a><a id="7000" class="Symbol">)</a> <a id="7002" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
  <a id="7006" href="Algebra.Group.Homotopy.html#616" data-type="Nat → Type∙ ℓ → Type∙ ℓ" class="Function">Ωⁿ</a> <a id="7009" class="Number">1</a> <a id="7011" class="Symbol">(</a><a id="7012" href="Algebra.Group.Homotopy.html#616" data-type="Nat → Type∙ ℓ → Type∙ ℓ" class="Function">Ωⁿ</a> <a id="7015" class="Symbol">(</a><a id="7016" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="7020" href="SHT.Base.html#6947" class="Bound">n</a><a id="7021" class="Symbol">)</a> <a id="7023" href="SHT.Base.html#6939" class="Bound">A</a><a id="7024" class="Symbol">)</a>  <a id="7027" href="1Lab.Path.html#46945" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>

<a id="Sⁿ"></a><a id="7030" href="SHT.Base.html#7030" data-type="Nat → Type∙ lzero" class="Function">Sⁿ</a> <a id="7033" class="Symbol">:</a> <a id="7035" href="Agda.Builtin.Nat.html#177" data-type="Type" class="Datatype">Nat</a> <a id="7039" class="Symbol">→</a> <a id="7041" href="1Lab.Type.html#2800" data-type="(ℓ : Level) → Type (lsuc ℓ)" class="Function">Type∙</a> <a id="7047" href="Agda.Primitive.html#749" data-type="Level" class="Primitive">lzero</a>
<a id="7053" href="SHT.Base.html#7030" data-type="Nat → Type∙ lzero" class="Function">Sⁿ</a> <a id="7056" href="SHT.Base.html#7056" class="Bound">n</a> <a id="7058" class="Symbol">=</a> <a id="7060" href="1Lab.HIT.Sphere.html#1729" data-type="Nat → Type" class="Function">Sⁿ⁻¹</a> <a id="7065" class="Symbol">(</a><a id="7066" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="7070" href="SHT.Base.html#7056" class="Bound">n</a><a id="7071" class="Symbol">)</a> <a id="7073" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="7075" href="1Lab.HIT.Suspension.html#312" data-type="Susp A" class="InductiveConstructor">N</a>
</pre>-->
<p>As a special case, in the zeroth dimension, we conclude that
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><msub><mo>→</mo><mo>∗</mo></msub><mi>A</mi><mo stretchy="false">)</mo><mo>≡</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">(2 \to_* A) \equiv A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel">→</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1757em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>,</span>
i.e., basepoint-preserving maps from the booleans (based at either
point) are the same thing as points of
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>.</span></p>
<pre class="Agda"><a id="Ωⁿ≃Sⁿ-map"></a><a id="7291" href="SHT.Base.html#7291" data-type="(n : Nat) → (Sⁿ n →∙ A) ≃ Ωⁿ n A .fst" class="Function">Ωⁿ≃Sⁿ-map</a> <a id="7301" class="Symbol">:</a> <a id="7303" class="Symbol">∀</a> <a id="7305" class="Symbol">{</a><a id="7306" href="SHT.Base.html#7306" class="Bound">ℓ</a><a id="7307" class="Symbol">}</a> <a id="7309" class="Symbol">{</a><a id="7310" href="SHT.Base.html#7310" class="Bound">A</a> <a id="7312" class="Symbol">:</a> <a id="7314" href="1Lab.Type.html#2800" data-type="(ℓ : Level) → Type (lsuc ℓ)" class="Function">Type∙</a> <a id="7320" href="SHT.Base.html#7306" class="Bound">ℓ</a><a id="7321" class="Symbol">}</a> <a id="7323" href="SHT.Base.html#7323" class="Bound">n</a> <a id="7325" class="Symbol">→</a> <a id="7327" class="Symbol">(</a><a id="7328" href="SHT.Base.html#7030" data-type="Nat → Type∙ lzero" class="Function">Sⁿ</a> <a id="7331" href="SHT.Base.html#7323" class="Bound">n</a> <a id="7333" href="SHT.Base.html#1019" data-type="Type∙ ℓ → Type∙ ℓ′ → Type (ℓ ⊔ ℓ′)" class="Function Operator">→∙</a> <a id="7336" href="SHT.Base.html#7310" class="Bound">A</a><a id="7337" class="Symbol">)</a> <a id="7339" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="7341" href="Algebra.Group.Homotopy.html#616" data-type="Nat → Type∙ ℓ → Type∙ ℓ" class="Function">Ωⁿ</a> <a id="7344" href="SHT.Base.html#7323" class="Bound">n</a> <a id="7346" href="SHT.Base.html#7310" class="Bound">A</a> <a id="7348" class="Symbol">.</a><a id="7349" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a>
<a id="7353" href="SHT.Base.html#7291" data-type="(n : Nat) → (Sⁿ n →∙ A) ≃ Ωⁿ n A .fst" class="Function">Ωⁿ≃Sⁿ-map</a> <a id="7363" class="Symbol">{</a><a id="7364" class="Argument">A</a> <a id="7366" class="Symbol">=</a> <a id="7368" href="SHT.Base.html#7368" class="Bound">A</a><a id="7369" class="Symbol">}</a> <a id="7371" href="Agda.Builtin.Nat.html#195" data-type="Nat" class="InductiveConstructor">zero</a>    <a id="7379" class="Symbol">=</a> <a id="7381" href="1Lab.Equiv.html#20503" data-type="Iso A B₁ → A ≃ B₁" class="Function">Iso→Equiv</a> <a id="7391" class="Symbol">(</a><a id="7392" href="SHT.Base.html#7530" data-type="(Susp ⊥ , N) →∙ A → A .fst" class="Function">from</a> <a id="7397" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="7399" href="1Lab.Equiv.html#6116" data-type="(inv₁ : B₁ → A) (rinv₁ : is-right-inverse inv₁ f)
(linv₁ : is-left-inverse inv₁ f) →
is-iso f" class="InductiveConstructor">iso</a> <a id="7403" href="SHT.Base.html#7433" data-type="A .fst → (Susp ⊥ , N) →∙ A" class="Function">to</a> <a id="7406" class="Symbol">(λ</a> <a id="7409" href="SHT.Base.html#7409" class="Bound">_</a> <a id="7411" class="Symbol">→</a> <a id="7413" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a><a id="7417" class="Symbol">)</a> <a id="7419" href="SHT.Base.html#7589" data-type="is-right-inverse from to" class="Function">invr</a><a id="7423" class="Symbol">)</a> <a id="7425" class="Keyword">where</a>
  <a id="7433" href="SHT.Base.html#7433" data-type="A .fst → (Susp ⊥ , N) →∙ A" class="Function">to</a> <a id="7436" class="Symbol">:</a> <a id="7438" href="SHT.Base.html#7368" class="Bound">A</a> <a id="7440" class="Symbol">.</a><a id="7441" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="7445" class="Symbol">→</a> <a id="7447" class="Symbol">((</a><a id="7449" href="1Lab.HIT.Suspension.html#273" data-type="Type ℓ → Type ℓ" class="Datatype">Susp</a> <a id="7454" href="1Lab.Type.html#1336" data-type="Type" class="Datatype">⊥</a> <a id="7456" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="7458" href="1Lab.HIT.Suspension.html#312" data-type="Susp A" class="InductiveConstructor">N</a><a id="7459" class="Symbol">)</a> <a id="7461" href="SHT.Base.html#1019" data-type="Type∙ ℓ → Type∙ ℓ′ → Type (ℓ ⊔ ℓ′)" class="Function Operator">→∙</a> <a id="7464" href="SHT.Base.html#7368" class="Bound">A</a><a id="7465" class="Symbol">)</a>
  <a id="7469" href="SHT.Base.html#7433" data-type="A .fst → (Susp ⊥ , N) →∙ A" class="Function">to</a> <a id="7472" href="SHT.Base.html#7472" class="Bound">x</a> <a id="7474" class="Symbol">.</a><a id="7475" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="7479" href="1Lab.HIT.Suspension.html#312" data-type="Susp A" class="InductiveConstructor">N</a> <a id="7481" class="Symbol">=</a> <a id="7483" href="SHT.Base.html#7368" class="Bound">A</a> <a id="7485" class="Symbol">.</a><a id="7486" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a>
  <a id="7492" href="SHT.Base.html#7433" data-type="A .fst → (Susp ⊥ , N) →∙ A" class="Function">to</a> <a id="7495" href="SHT.Base.html#7495" class="Bound">x</a> <a id="7497" class="Symbol">.</a><a id="7498" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="7502" href="1Lab.HIT.Suspension.html#314" data-type="Susp A" class="InductiveConstructor">S</a> <a id="7504" class="Symbol">=</a> <a id="7506" href="SHT.Base.html#7495" class="Bound">x</a>
  <a id="7510" href="SHT.Base.html#7433" data-type="A .fst → (Susp ⊥ , N) →∙ A" class="Function">to</a> <a id="7513" href="SHT.Base.html#7513" class="Bound">x</a> <a id="7515" class="Symbol">.</a><a id="7516" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="7520" class="Symbol">=</a> <a id="7522" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>

  <a id="7530" href="SHT.Base.html#7530" data-type="(Susp ⊥ , N) →∙ A → A .fst" class="Function">from</a> <a id="7535" class="Symbol">:</a> <a id="7537" class="Symbol">((</a><a id="7539" href="1Lab.HIT.Suspension.html#273" data-type="Type ℓ → Type ℓ" class="Datatype">Susp</a> <a id="7544" href="1Lab.Type.html#1336" data-type="Type" class="Datatype">⊥</a> <a id="7546" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="7548" href="1Lab.HIT.Suspension.html#312" data-type="Susp A" class="InductiveConstructor">N</a><a id="7549" class="Symbol">)</a> <a id="7551" href="SHT.Base.html#1019" data-type="Type∙ ℓ → Type∙ ℓ′ → Type (ℓ ⊔ ℓ′)" class="Function Operator">→∙</a> <a id="7554" href="SHT.Base.html#7368" class="Bound">A</a><a id="7555" class="Symbol">)</a> <a id="7557" class="Symbol">→</a> <a id="7559" href="SHT.Base.html#7368" class="Bound">A</a> <a id="7561" class="Symbol">.</a><a id="7562" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a>
  <a id="7568" href="SHT.Base.html#7530" data-type="(Susp ⊥ , N) →∙ A → A .fst" class="Function">from</a> <a id="7573" href="SHT.Base.html#7573" class="Bound">f</a> <a id="7575" class="Symbol">=</a> <a id="7577" href="SHT.Base.html#7573" class="Bound">f</a> <a id="7579" class="Symbol">.</a><a id="7580" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="7584" href="1Lab.HIT.Suspension.html#314" data-type="Susp A" class="InductiveConstructor">S</a>

  <a id="7589" href="SHT.Base.html#7589" data-type="is-right-inverse from to" class="Function">invr</a> <a id="7594" class="Symbol">:</a> <a id="7596" href="1Lab.Equiv.html#5739" data-type="(B₁ → A) → (A → B₁) → Type B.ℓ₁" class="Function">is-right-inverse</a> <a id="7613" href="SHT.Base.html#7530" data-type="(Susp ⊥ , N) →∙ A → A .fst" class="Function">from</a> <a id="7618" href="SHT.Base.html#7433" data-type="A .fst → (Susp ⊥ , N) →∙ A" class="Function">to</a>
  <a id="7623" href="SHT.Base.html#7589" data-type="is-right-inverse from to" class="Function">invr</a> <a id="7628" class="Symbol">(</a><a id="7629" href="SHT.Base.html#7629" class="Bound">x</a> <a id="7631" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="7633" href="SHT.Base.html#7633" class="Bound">p</a><a id="7634" class="Symbol">)</a> <a id="7636" class="Symbol">=</a>
    <a id="7642" href="1Lab.Path.html#57276" data-type="(p : x .fst ≡ y .fst) →
PathP (λ i → B₁ (p i)) (x .snd) (y .snd) → x ≡ y" class="Function">Σ-pathp</a> <a id="7650" class="Symbol">(</a><a id="7651" href="1Lab.Path.html#58474" data-type="((x : A) → f x ≡ g x) → f ≡ g" class="Function">funext</a> <a id="7658" class="Symbol">(λ</a> <a id="7661" class="Symbol">{</a> <a id="7663" href="1Lab.HIT.Suspension.html#312" data-type="Susp A" class="InductiveConstructor">N</a> <a id="7665" class="Symbol">→</a> <a id="7667" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="7671" href="SHT.Base.html#7633" class="Bound">p</a>
                       <a id="7696" class="Symbol">;</a> <a id="7698" href="1Lab.HIT.Suspension.html#314" data-type="Susp A" class="InductiveConstructor">S</a> <a id="7700" class="Symbol">→</a> <a id="7702" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="7707" class="Symbol">}))</a>
            <a id="7723" class="Symbol">λ</a> <a id="7725" href="SHT.Base.html#7725" class="Bound">i</a> <a id="7727" href="SHT.Base.html#7727" class="Bound">j</a> <a id="7729" class="Symbol">→</a> <a id="7731" href="SHT.Base.html#7633" class="Bound">p</a> <a id="7733" class="Symbol">(</a><a id="7734" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="7736" href="SHT.Base.html#7725" class="Bound">i</a> <a id="7738" href="1Lab.Path.html#2226" class="Primitive Operator">∨</a> <a id="7740" href="SHT.Base.html#7727" class="Bound">j</a><a id="7741" class="Symbol">)</a>
<a id="7743" href="SHT.Base.html#7291" data-type="(n : Nat) → (Sⁿ n →∙ A) ≃ Ωⁿ n A .fst" class="Function">Ωⁿ≃Sⁿ-map</a> <a id="7753" class="Symbol">{</a><a id="7754" class="Argument">A</a> <a id="7756" class="Symbol">=</a> <a id="7758" href="SHT.Base.html#7758" class="Bound">A</a><a id="7759" class="Symbol">}</a> <a id="7761" class="Symbol">(</a><a id="7762" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="7766" href="SHT.Base.html#7766" class="Bound">n</a><a id="7767" class="Symbol">)</a> <a id="7769" class="Symbol">=</a>
  <a id="7773" class="Symbol">(</a><a id="7774" href="SHT.Base.html#1247" data-type="Type∙ ℓ → Type∙ ℓ" class="Function">Σ∙</a> <a id="7777" class="Symbol">(</a><a id="7778" href="1Lab.HIT.Suspension.html#273" data-type="Type ℓ → Type ℓ" class="Datatype">Susp</a> <a id="7783" class="Symbol">_</a> <a id="7785" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="7787" href="1Lab.HIT.Suspension.html#312" data-type="Susp A" class="InductiveConstructor">N</a><a id="7788" class="Symbol">)</a> <a id="7790" href="SHT.Base.html#1019" data-type="Type∙ ℓ → Type∙ ℓ′ → Type (ℓ ⊔ ℓ′)" class="Function Operator">→∙</a> <a id="7793" href="SHT.Base.html#7758" class="Bound">A</a><a id="7794" class="Symbol">)</a>          <span class="reasoning-step"><span class="as-written Function Operator"><a id="7805" href="1Lab.Equiv.html#23316" data-type="(A : Type ℓ) → A ≃ B₁ → B₁ ≃ C → A ≃ C" class="Function Operator">≃⟨</a> <a id="7808" href="SHT.Base.html#6385" data-type="(Σ∙ A →∙ B₁) ≃ (A →∙ Ωⁿ 1 B₁)" class="Function">Σ-map∙≃map∙-Ω</a> <a id="7822" href="1Lab.Equiv.html#23316" data-type="(A : Type ℓ) → A ≃ B₁ → B₁ ≃ C → A ≃ C" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span>
  <a id="7826" class="Symbol">((</a><a id="7828" href="1Lab.HIT.Suspension.html#273" data-type="Type ℓ → Type ℓ" class="Datatype">Susp</a> <a id="7833" class="Symbol">(</a><a id="7834" href="1Lab.HIT.Sphere.html#1729" data-type="Nat → Type" class="Function">Sⁿ⁻¹</a> <a id="7839" href="SHT.Base.html#7766" class="Bound">n</a><a id="7840" class="Symbol">)</a> <a id="7842" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="7844" href="1Lab.HIT.Suspension.html#312" data-type="Susp A" class="InductiveConstructor">N</a><a id="7845" class="Symbol">)</a> <a id="7847" href="SHT.Base.html#1019" data-type="Type∙ ℓ → Type∙ ℓ′ → Type (ℓ ⊔ ℓ′)" class="Function Operator">→∙</a> <a id="7850" href="Algebra.Group.Homotopy.html#616" data-type="Nat → Type∙ ℓ → Type∙ ℓ" class="Function">Ωⁿ</a> <a id="7853" class="Number">1</a> <a id="7855" href="SHT.Base.html#7758" class="Bound">A</a><a id="7856" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function Operator"><a id="7858" href="1Lab.Equiv.html#23316" data-type="(A : Type ℓ) → A ≃ B₁ → B₁ ≃ C → A ≃ C" class="Function Operator">≃⟨</a> <a id="7861" href="SHT.Base.html#7291" data-type="(n : Nat) → (Sⁿ n →∙ A) ≃ Ωⁿ n A .fst" class="Function">Ωⁿ≃Sⁿ-map</a> <a id="7871" href="SHT.Base.html#7766" class="Bound">n</a> <a id="7873" href="1Lab.Equiv.html#23316" data-type="(A : Type ℓ) → A ≃ B₁ → B₁ ≃ C → A ≃ C" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span>
  <a id="7877" href="Algebra.Group.Homotopy.html#616" data-type="Nat → Type∙ ℓ → Type∙ ℓ" class="Function">Ωⁿ</a> <a id="7880" href="SHT.Base.html#7766" class="Bound">n</a> <a id="7882" class="Symbol">(</a><a id="7883" href="Algebra.Group.Homotopy.html#616" data-type="Nat → Type∙ ℓ → Type∙ ℓ" class="Function">Ωⁿ</a> <a id="7886" class="Number">1</a> <a id="7888" href="SHT.Base.html#7758" class="Bound">A</a><a id="7889" class="Symbol">)</a> <a id="7891" class="Symbol">.</a><a id="7892" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a>              <span class="reasoning-step"><span class="as-written Function Operator"><a id="7909" href="1Lab.Equiv.html#23316" data-type="(A : Type ℓ) → A ≃ B₁ → B₁ ≃ C → A ≃ C" class="Function Operator">≃⟨</a> <a id="7912" href="1Lab.Univalence.html#15737" data-type="A ≡ B₁ → A ≃ B₁" class="Function">path→equiv</a> <a id="7923" class="Symbol">(</a><a id="7924" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="7927" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="7931" class="Symbol">(</a><a id="7932" href="SHT.Base.html#6839" data-type="(n : Nat) → Ωⁿ n (Ω∙ A) ≡ Ωⁿ (suc n) A" class="Function">reassoc-Ω</a> <a id="7942" href="SHT.Base.html#7766" class="Bound">n</a><a id="7943" class="Symbol">))</a> <a id="7946" href="1Lab.Equiv.html#23316" data-type="(A : Type ℓ) → A ≃ B₁ → B₁ ≃ C → A ≃ C" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span>
  <a id="7950" href="Algebra.Group.Homotopy.html#616" data-type="Nat → Type∙ ℓ → Type∙ ℓ" class="Function">Ωⁿ</a> <a id="7953" class="Symbol">(</a><a id="7954" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="7958" href="SHT.Base.html#7766" class="Bound">n</a><a id="7959" class="Symbol">)</a> <a id="7961" href="SHT.Base.html#7758" class="Bound">A</a> <a id="7963" class="Symbol">.</a><a id="7964" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a>               <a id="7982" href="1Lab.Equiv.html#23507" data-type="(A : Type ℓ) → A ≃ A" class="Function Operator">≃∎</a>
</pre>
<h2 id="hubs-and-spokes"><a href="#hubs-and-spokes" class="header-link">Hubs
and spokes<span class="header-link-emoji">🔗</span></a></h2>
<p>Inspired by the equivalence built above, although <em>not</em> using
it directly, we can characterise <a href="1Lab.HLevel.html">h-levels</a>
in terms of maps of spheres, too. The idea is that, since a map
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><msup><mi>S</mi><mi>n</mi></msup><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">f : S^n \to A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>
is equivalently <em>some</em> loop in
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>, we can characterise the
<em>trivial</em> loops as the constant functions
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>S</mi><mi>n</mi></msup><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">S^n \to A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>.</span>
Correspondingly, if every function
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>S</mi><mi>n</mi></msup><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">S^n \to A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>
is trivial, this means that all
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>-loops</span>
in
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>
are trivial, so that
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>
is
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>-truncated!</span></p>
<p>We refer to a trivialisation of a map
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><msup><mi>S</mi><mi>n</mi></msup><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">f : S^n \to A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>
as being a “hubs-and-spokes” construction. Geometrically, a trivial loop
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><msup><mi>S</mi><mi>n</mi></msup><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">f : S^n \to A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>
can be understood as a map from the
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>-</span><em>disc</em>
rather than the
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>-sphere,</span>
where the
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>-disc</span>
is the type generated by attaching a new point to the sphere (the
“hub”), and paths connecting the hub to each point along the sphere (the
“spokes”). The resulting type is contractible, whence every function out
of it is constant.</p>
<pre class="Agda"><a id="hlevel→hubs-and-spokes"></a><a id="9078" href="SHT.Base.html#9078" data-type="(n : Nat) →
is-hlevel A (suc n) →
(sph : Sⁿ n .fst → A) → Σ (λ hub₁ → (x : Sⁿ n .fst) → sph x ≡ hub₁)" class="Function">hlevel→hubs-and-spokes</a>
  <a id="9103" class="Symbol">:</a> <a id="9105" class="Symbol">∀</a> <a id="9107" class="Symbol">{</a><a id="9108" href="SHT.Base.html#9108" class="Bound">ℓ</a><a id="9109" class="Symbol">}</a> <a id="9111" class="Symbol">{</a><a id="9112" href="SHT.Base.html#9112" class="Bound">A</a> <a id="9114" class="Symbol">:</a> <a id="9116" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="9121" href="SHT.Base.html#9108" class="Bound">ℓ</a><a id="9122" class="Symbol">}</a> <a id="9124" class="Symbol">(</a><a id="9125" href="SHT.Base.html#9125" class="Bound">n</a> <a id="9127" class="Symbol">:</a> <a id="9129" href="Agda.Builtin.Nat.html#177" data-type="Type" class="Datatype">Nat</a><a id="9132" class="Symbol">)</a> <a id="9134" class="Symbol">→</a> <a id="9136" href="1Lab.HLevel.html#2813" data-type="Type ℓ → Nat → Type ℓ" class="Function">is-hlevel</a> <a id="9146" href="SHT.Base.html#9112" class="Bound">A</a> <a id="9148" class="Symbol">(</a><a id="9149" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="9153" href="SHT.Base.html#9125" class="Bound">n</a><a id="9154" class="Symbol">)</a>
  <a id="9158" class="Symbol">→</a> <a id="9160" class="Symbol">(</a><a id="9161" href="SHT.Base.html#9161" class="Bound">sph</a> <a id="9165" class="Symbol">:</a> <a id="9167" href="SHT.Base.html#7030" data-type="Nat → Type∙ lzero" class="Function">Sⁿ</a> <a id="9170" href="SHT.Base.html#9125" class="Bound">n</a> <a id="9172" class="Symbol">.</a><a id="9173" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="9177" class="Symbol">→</a> <a id="9179" href="SHT.Base.html#9112" class="Bound">A</a><a id="9180" class="Symbol">)</a>
  <a id="9184" class="Symbol">→</a> <a id="9186" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">Σ[</a> <a id="9189" href="SHT.Base.html#9189" class="Bound">hub</a> <a id="9193" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">∈</a> <a id="9195" href="SHT.Base.html#9112" class="Bound">A</a> <a id="9197" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">]</a> <a id="9199" class="Symbol">(∀</a> <a id="9202" href="SHT.Base.html#9202" class="Bound">x</a> <a id="9204" class="Symbol">→</a> <a id="9206" href="SHT.Base.html#9161" class="Bound">sph</a> <a id="9210" href="SHT.Base.html#9202" class="Bound">x</a> <a id="9212" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="9214" href="SHT.Base.html#9189" class="Bound">hub</a><a id="9217" class="Symbol">)</a>

<a id="hubs-and-spokes→hlevel"></a><a id="9220" href="SHT.Base.html#9220" data-type="(n : Nat) →
((sph : Sⁿ n .fst → A) →
 Σ (λ hub₁ → (x : Sⁿ n .fst) → sph x ≡ hub₁)) →
is-hlevel A (suc n)" class="Function">hubs-and-spokes→hlevel</a>
  <a id="9245" class="Symbol">:</a> <a id="9247" class="Symbol">∀</a> <a id="9249" class="Symbol">{</a><a id="9250" href="SHT.Base.html#9250" class="Bound">ℓ</a><a id="9251" class="Symbol">}</a> <a id="9253" class="Symbol">{</a><a id="9254" href="SHT.Base.html#9254" class="Bound">A</a> <a id="9256" class="Symbol">:</a> <a id="9258" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="9263" href="SHT.Base.html#9250" class="Bound">ℓ</a><a id="9264" class="Symbol">}</a> <a id="9266" class="Symbol">(</a><a id="9267" href="SHT.Base.html#9267" class="Bound">n</a> <a id="9269" class="Symbol">:</a> <a id="9271" href="Agda.Builtin.Nat.html#177" data-type="Type" class="Datatype">Nat</a><a id="9274" class="Symbol">)</a>
  <a id="9278" class="Symbol">→</a> <a id="9280" class="Symbol">((</a><a id="9282" href="SHT.Base.html#9282" class="Bound">sph</a> <a id="9286" class="Symbol">:</a> <a id="9288" href="SHT.Base.html#7030" data-type="Nat → Type∙ lzero" class="Function">Sⁿ</a> <a id="9291" href="SHT.Base.html#9267" class="Bound">n</a> <a id="9293" class="Symbol">.</a><a id="9294" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="9298" class="Symbol">→</a> <a id="9300" href="SHT.Base.html#9254" class="Bound">A</a><a id="9301" class="Symbol">)</a> <a id="9303" class="Symbol">→</a> <a id="9305" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">Σ[</a> <a id="9308" href="SHT.Base.html#9308" class="Bound">hub</a> <a id="9312" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">∈</a> <a id="9314" href="SHT.Base.html#9254" class="Bound">A</a> <a id="9316" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">]</a> <a id="9318" class="Symbol">(∀</a> <a id="9321" href="SHT.Base.html#9321" class="Bound">x</a> <a id="9323" class="Symbol">→</a> <a id="9325" href="SHT.Base.html#9282" class="Bound">sph</a> <a id="9329" href="SHT.Base.html#9321" class="Bound">x</a> <a id="9331" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="9333" href="SHT.Base.html#9308" class="Bound">hub</a><a id="9336" class="Symbol">))</a>
  <a id="9341" class="Symbol">→</a> <a id="9343" href="1Lab.HLevel.html#2813" data-type="Type ℓ → Nat → Type ℓ" class="Function">is-hlevel</a> <a id="9353" href="SHT.Base.html#9254" class="Bound">A</a> <a id="9355" class="Symbol">(</a><a id="9356" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="9360" href="SHT.Base.html#9267" class="Bound">n</a><a id="9361" class="Symbol">)</a>
</pre>
<!--
<pre class="Agda"><a id="9381" href="SHT.Base.html#9078" data-type="(n : Nat) →
is-hlevel A (suc n) →
(sph : Sⁿ n .fst → A) → Σ (λ hub₁ → (x : Sⁿ n .fst) → sph x ≡ hub₁)" class="Function">hlevel→hubs-and-spokes</a> <a id="9404" class="Number">0</a> <a id="9406" href="SHT.Base.html#9406" class="Bound">prop</a> <a id="9411" href="SHT.Base.html#9411" class="Bound">sph</a> <a id="9415" class="Symbol">=</a> <a id="9417" href="SHT.Base.html#9411" class="Bound">sph</a> <a id="9421" href="1Lab.HIT.Suspension.html#312" data-type="Susp A" class="InductiveConstructor">N</a> <a id="9423" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="9425" class="Symbol">λ</a> <a id="9427" href="SHT.Base.html#9427" class="Bound">x</a> <a id="9429" class="Symbol">→</a> <a id="9431" href="SHT.Base.html#9406" class="Bound">prop</a> <a id="9436" class="Symbol">(</a><a id="9437" href="SHT.Base.html#9411" class="Bound">sph</a> <a id="9441" href="SHT.Base.html#9427" class="Bound">x</a><a id="9442" class="Symbol">)</a> <a id="9444" class="Symbol">(</a><a id="9445" href="SHT.Base.html#9411" class="Bound">sph</a> <a id="9449" href="1Lab.HIT.Suspension.html#312" data-type="Susp A" class="InductiveConstructor">N</a><a id="9450" class="Symbol">)</a>
<a id="9452" href="SHT.Base.html#9078" data-type="(n : Nat) →
is-hlevel A (suc n) →
(sph : Sⁿ n .fst → A) → Σ (λ hub₁ → (x : Sⁿ n .fst) → sph x ≡ hub₁)" class="Function">hlevel→hubs-and-spokes</a> <a id="9475" class="Symbol">{</a><a id="9476" class="Argument">A</a> <a id="9478" class="Symbol">=</a> <a id="9480" href="SHT.Base.html#9480" class="Bound">A</a><a id="9481" class="Symbol">}</a> <a id="9483" class="Symbol">(</a><a id="9484" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="9488" href="SHT.Base.html#9488" class="Bound">n</a><a id="9489" class="Symbol">)</a> <a id="9491" href="SHT.Base.html#9491" class="Bound">h</a> <a id="9493" class="Symbol">=</a>
  <a id="9497" href="SHT.Base.html#9555" data-type="(n : Nat) →
is-hlevel A (suc (suc n)) →
((a b : A) (sph : Sⁿ⁻¹ (1 + n) → a ≡ b) →
 Σ (λ hub₁ → (x : Sⁿ⁻¹ (1 + n)) → sph x ≡ hub₁)) →
(sph : Sⁿ⁻¹ (2 + n) → A) →
Σ (λ hub₁ → (x : Sⁿ⁻¹ (2 + n)) → sph x ≡ hub₁)" class="Function">helper</a> <a id="9504" class="Symbol">λ</a> <a id="9506" href="SHT.Base.html#9506" class="Bound">x</a> <a id="9508" href="SHT.Base.html#9508" class="Bound">y</a> <a id="9510" class="Symbol">→</a> <a id="9512" href="SHT.Base.html#9078" data-type="(n : Nat) →
is-hlevel A (suc n) →
(sph : Sⁿ n .fst → A) → Σ (λ hub₁ → (x : Sⁿ n .fst) → sph x ≡ hub₁)" class="Function">hlevel→hubs-and-spokes</a> <a id="9535" href="SHT.Base.html#9488" class="Bound">n</a> <a id="9537" class="Symbol">(</a><a id="9538" href="SHT.Base.html#9491" class="Bound">h</a> <a id="9540" href="SHT.Base.html#9506" class="Bound">x</a> <a id="9542" href="SHT.Base.html#9508" class="Bound">y</a><a id="9543" class="Symbol">)</a>
  <a id="9547" class="Keyword">where</a>
  <a id="9555" href="SHT.Base.html#9555" data-type="(n : Nat) →
is-hlevel A (suc (suc n)) →
((a b : A) (sph : Sⁿ⁻¹ (1 + n) → a ≡ b) →
 Σ (λ hub₁ → (x : Sⁿ⁻¹ (1 + n)) → sph x ≡ hub₁)) →
(sph : Sⁿ⁻¹ (2 + n) → A) →
Σ (λ hub₁ → (x : Sⁿ⁻¹ (2 + n)) → sph x ≡ hub₁)" class="Function">helper</a>
    <a id="9566" class="Symbol">:</a> <a id="9568" class="Symbol">((</a><a id="9570" href="SHT.Base.html#9570" class="Bound">a</a> <a id="9572" href="SHT.Base.html#9572" class="Bound">b</a> <a id="9574" class="Symbol">:</a> <a id="9576" href="SHT.Base.html#9480" class="Bound">A</a><a id="9577" class="Symbol">)</a> <a id="9579" class="Symbol">→</a> <a id="9581" class="Symbol">(</a><a id="9582" href="SHT.Base.html#9582" class="Bound">sph</a> <a id="9586" class="Symbol">:</a> <a id="9588" href="1Lab.HIT.Sphere.html#1729" data-type="Nat → Type" class="Function">Sⁿ⁻¹</a> <a id="9593" class="Symbol">(</a><a id="9594" class="Number">1</a> <a id="9596" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="9598" href="SHT.Base.html#9488" class="Bound">n</a><a id="9599" class="Symbol">)</a> <a id="9601" class="Symbol">→</a> <a id="9603" href="SHT.Base.html#9570" class="Bound">a</a> <a id="9605" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="9607" href="SHT.Base.html#9572" class="Bound">b</a><a id="9608" class="Symbol">)</a> <a id="9610" class="Symbol">→</a> <a id="9612" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">Σ</a> <a id="9614" class="Symbol">λ</a> <a id="9616" href="SHT.Base.html#9616" class="Bound">hub</a> <a id="9620" class="Symbol">→</a> <a id="9622" class="Symbol">∀</a> <a id="9624" href="SHT.Base.html#9624" class="Bound">x</a> <a id="9626" class="Symbol">→</a> <a id="9628" href="SHT.Base.html#9582" class="Bound">sph</a> <a id="9632" href="SHT.Base.html#9624" class="Bound">x</a> <a id="9634" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="9636" href="SHT.Base.html#9616" class="Bound">hub</a><a id="9639" class="Symbol">)</a>
    <a id="9645" class="Symbol">→</a> <a id="9647" class="Symbol">(</a><a id="9648" href="SHT.Base.html#9648" class="Bound">sph</a> <a id="9652" class="Symbol">:</a> <a id="9654" href="1Lab.HIT.Sphere.html#1729" data-type="Nat → Type" class="Function">Sⁿ⁻¹</a> <a id="9659" class="Symbol">(</a><a id="9660" class="Number">2</a> <a id="9662" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="9664" href="SHT.Base.html#9488" class="Bound">n</a><a id="9665" class="Symbol">)</a> <a id="9667" class="Symbol">→</a> <a id="9669" href="SHT.Base.html#9480" class="Bound">A</a><a id="9670" class="Symbol">)</a>
    <a id="9676" class="Symbol">→</a> <a id="9678" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">Σ</a> <a id="9680" class="Symbol">λ</a> <a id="9682" href="SHT.Base.html#9682" class="Bound">hub</a> <a id="9686" class="Symbol">→</a> <a id="9688" class="Symbol">∀</a> <a id="9690" href="SHT.Base.html#9690" class="Bound">x</a> <a id="9692" class="Symbol">→</a> <a id="9694" href="SHT.Base.html#9648" class="Bound">sph</a> <a id="9698" href="SHT.Base.html#9690" class="Bound">x</a> <a id="9700" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="9702" href="SHT.Base.html#9682" class="Bound">hub</a>
  <a id="9708" href="SHT.Base.html#9555" data-type="(n : Nat) →
is-hlevel A (suc (suc n)) →
((a b : A) (sph : Sⁿ⁻¹ (1 + n) → a ≡ b) →
 Σ (λ hub₁ → (x : Sⁿ⁻¹ (1 + n)) → sph x ≡ hub₁)) →
(sph : Sⁿ⁻¹ (2 + n) → A) →
Σ (λ hub₁ → (x : Sⁿ⁻¹ (2 + n)) → sph x ≡ hub₁)" class="Function">helper</a> <a id="9715" href="SHT.Base.html#9715" class="Bound">h</a> <a id="9717" href="SHT.Base.html#9717" class="Bound">f</a> <a id="9719" class="Symbol">=</a> <a id="9721" href="SHT.Base.html#9717" class="Bound">f</a> <a id="9723" href="1Lab.HIT.Suspension.html#312" data-type="Susp A" class="InductiveConstructor">N</a> <a id="9725" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="9727" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="9731" href="1Lab.Type.html#2227" data-type="((y : B₁ x) → C x y) → (f : (x : A) → B₁ x) (x : A) → C x (f x)" class="Function Operator">∘</a> <a id="9733" href="SHT.Base.html#9745" data-type="(n : Nat) →
is-hlevel A (suc (suc n)) →
((a b : A) (sph : Sⁿ⁻¹ (1 + n) → a ≡ b) →
 Σ (λ hub₁ → (x : Sⁿ⁻¹ (1 + n)) → sph x ≡ hub₁)) →
(f : Sⁿ⁻¹ (2 + n) → A) (x : Sⁿ⁻¹ (2 + n)) → f N ≡ f x" class="Function">r</a> <a id="9735" class="Keyword">where</a>
    <a id="9745" href="SHT.Base.html#9745" data-type="(n : Nat) →
is-hlevel A (suc (suc n)) →
((a b : A) (sph : Sⁿ⁻¹ (1 + n) → a ≡ b) →
 Σ (λ hub₁ → (x : Sⁿ⁻¹ (1 + n)) → sph x ≡ hub₁)) →
(f : Sⁿ⁻¹ (2 + n) → A) (x : Sⁿ⁻¹ (2 + n)) → f N ≡ f x" class="Function">r</a> <a id="9747" class="Symbol">:</a> <a id="9749" class="Symbol">(</a><a id="9750" href="SHT.Base.html#9750" class="Bound">x</a> <a id="9752" class="Symbol">:</a> <a id="9754" href="1Lab.HIT.Sphere.html#1729" data-type="Nat → Type" class="Function">Sⁿ⁻¹</a> <a id="9759" class="Symbol">(</a><a id="9760" class="Number">2</a> <a id="9762" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="9764" href="SHT.Base.html#9488" class="Bound">n</a><a id="9765" class="Symbol">))</a> <a id="9768" class="Symbol">→</a> <a id="9770" href="SHT.Base.html#9717" class="Bound">f</a> <a id="9772" href="1Lab.HIT.Suspension.html#312" data-type="Susp A" class="InductiveConstructor">N</a> <a id="9774" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="9776" href="SHT.Base.html#9717" class="Bound">f</a> <a id="9778" href="SHT.Base.html#9750" class="Bound">x</a>
    <a id="9784" href="SHT.Base.html#9745" data-type="(n : Nat) →
is-hlevel A (suc (suc n)) →
((a b : A) (sph : Sⁿ⁻¹ (1 + n) → a ≡ b) →
 Σ (λ hub₁ → (x : Sⁿ⁻¹ (1 + n)) → sph x ≡ hub₁)) →
(f : Sⁿ⁻¹ (2 + n) → A) (x : Sⁿ⁻¹ (2 + n)) → f N ≡ f x" class="Function">r</a> <a id="9786" href="1Lab.HIT.Suspension.html#312" data-type="Susp A" class="InductiveConstructor">N</a> <a id="9788" class="Symbol">=</a> <a id="9790" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
    <a id="9799" href="SHT.Base.html#9745" data-type="(n : Nat) →
is-hlevel A (suc (suc n)) →
((a b : A) (sph : Sⁿ⁻¹ (1 + n) → a ≡ b) →
 Σ (λ hub₁ → (x : Sⁿ⁻¹ (1 + n)) → sph x ≡ hub₁)) →
(f : Sⁿ⁻¹ (2 + n) → A) (x : Sⁿ⁻¹ (2 + n)) → f N ≡ f x" class="Function">r</a> <a id="9801" href="1Lab.HIT.Suspension.html#314" data-type="Susp A" class="InductiveConstructor">S</a> <a id="9803" class="Symbol">=</a> <a id="9805" href="SHT.Base.html#9715" class="Bound">h</a> <a id="9807" class="Symbol">(</a><a id="9808" href="SHT.Base.html#9717" class="Bound">f</a> <a id="9810" href="1Lab.HIT.Suspension.html#312" data-type="Susp A" class="InductiveConstructor">N</a><a id="9811" class="Symbol">)</a> <a id="9813" class="Symbol">(</a><a id="9814" href="SHT.Base.html#9717" class="Bound">f</a> <a id="9816" href="1Lab.HIT.Suspension.html#314" data-type="Susp A" class="InductiveConstructor">S</a><a id="9817" class="Symbol">)</a> <a id="9819" class="Symbol">(λ</a> <a id="9822" href="SHT.Base.html#9822" class="Bound">x</a> <a id="9824" href="SHT.Base.html#9824" class="Bound">i</a> <a id="9826" class="Symbol">→</a> <a id="9828" href="SHT.Base.html#9717" class="Bound">f</a> <a id="9830" class="Symbol">(</a><a id="9831" href="1Lab.HIT.Suspension.html#329" data-type="A → N ≡ S" class="InductiveConstructor">merid</a> <a id="9837" href="SHT.Base.html#9822" class="Bound">x</a> <a id="9839" href="SHT.Base.html#9824" class="Bound">i</a><a id="9840" class="Symbol">))</a> <a id="9843" class="Symbol">.</a><a id="9844" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a>
    <a id="9852" href="SHT.Base.html#9745" data-type="(n : Nat) →
is-hlevel A (suc (suc n)) →
((a b : A) (sph : Sⁿ⁻¹ (1 + n) → a ≡ b) →
 Σ (λ hub₁ → (x : Sⁿ⁻¹ (1 + n)) → sph x ≡ hub₁)) →
(f : Sⁿ⁻¹ (2 + n) → A) (x : Sⁿ⁻¹ (2 + n)) → f N ≡ f x" class="Function">r</a> <a id="9854" class="Symbol">(</a><a id="9855" href="1Lab.HIT.Suspension.html#329" data-type="A → N ≡ S" class="InductiveConstructor">merid</a> <a id="9861" href="SHT.Base.html#9861" class="Bound">x</a> <a id="9863" href="SHT.Base.html#9863" class="Bound">i</a><a id="9864" class="Symbol">)</a> <a id="9866" href="SHT.Base.html#9866" class="Bound">j</a> <a id="9868" class="Symbol">=</a>
      <a id="9876" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="9882" class="Symbol">(λ</a> <a id="9885" class="Symbol">{</a> <a id="9887" href="SHT.Base.html#9887" class="Bound">k</a> <a id="9889" class="Symbol">(</a><a id="9890" href="SHT.Base.html#9863" class="Bound">i</a> <a id="9892" class="Symbol">=</a> <a id="9894" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="9896" class="Symbol">)</a> <a id="9898" class="Symbol">→</a> <a id="9900" href="SHT.Base.html#9717" class="Bound">f</a> <a id="9902" href="1Lab.HIT.Suspension.html#312" data-type="Susp A" class="InductiveConstructor">N</a>
               <a id="9919" class="Symbol">;</a> <a id="9921" href="SHT.Base.html#9921" class="Bound">k</a> <a id="9923" class="Symbol">(</a><a id="9924" href="SHT.Base.html#9863" class="Bound">i</a> <a id="9926" class="Symbol">=</a> <a id="9928" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="9930" class="Symbol">)</a> <a id="9932" class="Symbol">→</a> <a id="9934" href="SHT.Base.html#9715" class="Bound">h</a> <a id="9936" class="Symbol">(</a><a id="9937" href="SHT.Base.html#9717" class="Bound">f</a> <a id="9939" href="1Lab.HIT.Suspension.html#312" data-type="Susp A" class="InductiveConstructor">N</a><a id="9940" class="Symbol">)</a> <a id="9942" class="Symbol">(</a><a id="9943" href="SHT.Base.html#9717" class="Bound">f</a> <a id="9945" href="1Lab.HIT.Suspension.html#314" data-type="Susp A" class="InductiveConstructor">S</a><a id="9946" class="Symbol">)</a> <a id="9948" class="Symbol">(λ</a> <a id="9951" href="SHT.Base.html#9951" class="Bound">x</a> <a id="9953" href="SHT.Base.html#9953" class="Bound">i</a> <a id="9955" class="Symbol">→</a> <a id="9957" href="SHT.Base.html#9717" class="Bound">f</a> <a id="9959" class="Symbol">(</a><a id="9960" href="1Lab.HIT.Suspension.html#329" data-type="A → N ≡ S" class="InductiveConstructor">merid</a> <a id="9966" href="SHT.Base.html#9951" class="Bound">x</a> <a id="9968" href="SHT.Base.html#9953" class="Bound">i</a><a id="9969" class="Symbol">))</a> <a id="9972" class="Symbol">.</a><a id="9973" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="9977" href="SHT.Base.html#9861" class="Bound">x</a> <a id="9979" href="SHT.Base.html#9921" class="Bound">k</a> <a id="9981" href="SHT.Base.html#9866" class="Bound">j</a>
               <a id="9998" class="Symbol">;</a> <a id="10000" href="SHT.Base.html#10000" class="Bound">k</a> <a id="10002" class="Symbol">(</a><a id="10003" href="SHT.Base.html#9866" class="Bound">j</a> <a id="10005" class="Symbol">=</a> <a id="10007" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="10009" class="Symbol">)</a> <a id="10011" class="Symbol">→</a> <a id="10013" href="SHT.Base.html#9717" class="Bound">f</a> <a id="10015" href="1Lab.HIT.Suspension.html#312" data-type="Susp A" class="InductiveConstructor">N</a>
               <a id="10032" class="Symbol">;</a> <a id="10034" href="SHT.Base.html#10034" class="Bound">k</a> <a id="10036" class="Symbol">(</a><a id="10037" href="SHT.Base.html#9866" class="Bound">j</a> <a id="10039" class="Symbol">=</a> <a id="10041" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="10043" class="Symbol">)</a> <a id="10045" class="Symbol">→</a> <a id="10047" href="SHT.Base.html#9717" class="Bound">f</a> <a id="10049" class="Symbol">(</a><a id="10050" href="1Lab.HIT.Suspension.html#329" data-type="A → N ≡ S" class="InductiveConstructor">merid</a> <a id="10056" href="SHT.Base.html#9861" class="Bound">x</a> <a id="10058" href="SHT.Base.html#9863" class="Bound">i</a><a id="10059" class="Symbol">)</a>
               <a id="10076" class="Symbol">})</a>
            <a id="10091" class="Symbol">(</a><a id="10092" href="SHT.Base.html#9717" class="Bound">f</a> <a id="10094" class="Symbol">(</a><a id="10095" href="1Lab.HIT.Suspension.html#329" data-type="A → N ≡ S" class="InductiveConstructor">merid</a> <a id="10101" href="SHT.Base.html#9861" class="Bound">x</a> <a id="10103" class="Symbol">(</a><a id="10104" href="SHT.Base.html#9863" class="Bound">i</a> <a id="10106" href="1Lab.Path.html#2191" class="Primitive Operator">∧</a> <a id="10108" href="SHT.Base.html#9866" class="Bound">j</a><a id="10109" class="Symbol">)))</a>

<a id="10114" href="SHT.Base.html#9220" data-type="(n : Nat) →
((sph : Sⁿ n .fst → A) →
 Σ (λ hub₁ → (x : Sⁿ n .fst) → sph x ≡ hub₁)) →
is-hlevel A (suc n)" class="Function">hubs-and-spokes→hlevel</a> <a id="10137" class="Symbol">{</a><a id="10138" class="Argument">A</a> <a id="10140" class="Symbol">=</a> <a id="10142" href="SHT.Base.html#10142" class="Bound">A</a><a id="10143" class="Symbol">}</a> <a id="10145" href="Agda.Builtin.Nat.html#195" data-type="Nat" class="InductiveConstructor">zero</a> <a id="10150" href="SHT.Base.html#10150" class="Bound">spheres</a> <a id="10158" href="SHT.Base.html#10158" class="Bound">x</a> <a id="10160" href="SHT.Base.html#10160" class="Bound">y</a>
  <a id="10164" class="Symbol">=</a> <a id="10166" href="SHT.Base.html#10150" class="Bound">spheres</a> <a id="10174" href="SHT.Base.html#10222" data-type="(spheres
 : (sph : Sⁿ zero .fst → A) →
   Σ (λ hub₁ → (x : Sⁿ zero .fst) → sph x ≡ hub₁))
(x y : A) →
Sⁿ⁻¹ 1 → A" class="Function">map</a> <a id="10178" class="Symbol">.</a><a id="10179" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="10183" href="1Lab.HIT.Suspension.html#312" data-type="Susp A" class="InductiveConstructor">N</a> <a id="10185" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="10187" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="10191" class="Symbol">(</a><a id="10192" href="SHT.Base.html#10150" class="Bound">spheres</a> <a id="10200" href="SHT.Base.html#10222" data-type="(spheres
 : (sph : Sⁿ zero .fst → A) →
   Σ (λ hub₁ → (x : Sⁿ zero .fst) → sph x ≡ hub₁))
(x y : A) →
Sⁿ⁻¹ 1 → A" class="Function">map</a> <a id="10204" class="Symbol">.</a><a id="10205" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="10209" href="1Lab.HIT.Suspension.html#314" data-type="Susp A" class="InductiveConstructor">S</a><a id="10210" class="Symbol">)</a> <a id="10212" class="Keyword">where</a>
    <a id="10222" href="SHT.Base.html#10222" data-type="(spheres
 : (sph : Sⁿ zero .fst → A) →
   Σ (λ hub₁ → (x : Sⁿ zero .fst) → sph x ≡ hub₁))
(x y : A) →
Sⁿ⁻¹ 1 → A" class="Function">map</a> <a id="10226" class="Symbol">:</a> <a id="10228" href="1Lab.HIT.Sphere.html#1729" data-type="Nat → Type" class="Function">Sⁿ⁻¹</a> <a id="10233" class="Number">1</a> <a id="10235" class="Symbol">→</a> <a id="10237" href="SHT.Base.html#10142" class="Bound">A</a>
    <a id="10243" href="SHT.Base.html#10222" data-type="(spheres
 : (sph : Sⁿ zero .fst → A) →
   Σ (λ hub₁ → (x : Sⁿ zero .fst) → sph x ≡ hub₁))
(x y : A) →
Sⁿ⁻¹ 1 → A" class="Function">map</a> <a id="10247" href="1Lab.HIT.Suspension.html#312" data-type="Susp A" class="InductiveConstructor">N</a> <a id="10249" class="Symbol">=</a> <a id="10251" href="SHT.Base.html#10158" class="Bound">x</a>
    <a id="10257" href="SHT.Base.html#10222" data-type="(spheres
 : (sph : Sⁿ zero .fst → A) →
   Σ (λ hub₁ → (x : Sⁿ zero .fst) → sph x ≡ hub₁))
(x y : A) →
Sⁿ⁻¹ 1 → A" class="Function">map</a> <a id="10261" href="1Lab.HIT.Suspension.html#314" data-type="Susp A" class="InductiveConstructor">S</a> <a id="10263" class="Symbol">=</a> <a id="10265" href="SHT.Base.html#10160" class="Bound">y</a>
<a id="10267" href="SHT.Base.html#9220" data-type="(n : Nat) →
((sph : Sⁿ n .fst → A) →
 Σ (λ hub₁ → (x : Sⁿ n .fst) → sph x ≡ hub₁)) →
is-hlevel A (suc n)" class="Function">hubs-and-spokes→hlevel</a> <a id="10290" class="Symbol">{</a><a id="10291" class="Argument">A</a> <a id="10293" class="Symbol">=</a> <a id="10295" href="SHT.Base.html#10295" class="Bound">A</a><a id="10296" class="Symbol">}</a> <a id="10298" class="Symbol">(</a><a id="10299" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="10303" href="SHT.Base.html#10303" class="Bound">n</a><a id="10304" class="Symbol">)</a> <a id="10306" href="SHT.Base.html#10306" class="Bound">spheres</a> <a id="10314" href="SHT.Base.html#10314" class="Bound">x</a> <a id="10316" href="SHT.Base.html#10316" class="Bound">y</a> <a id="10318" class="Symbol">=</a>
  <a id="10322" href="SHT.Base.html#9220" data-type="(n : Nat) →
((sph : Sⁿ n .fst → A) →
 Σ (λ hub₁ → (x : Sⁿ n .fst) → sph x ≡ hub₁)) →
is-hlevel A (suc n)" class="Function">hubs-and-spokes→hlevel</a> <a id="10345" href="SHT.Base.html#10303" class="Bound">n</a> <a id="10347" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="10349" href="SHT.Base.html#10376" data-type="(n : Nat)
(spheres
 : (sph : Sⁿ (suc n) .fst → A) →
   Σ (λ hub₁ → (x : Sⁿ (suc n) .fst) → sph x ≡ hub₁))
(x y : A) →
((sph : Sⁿ⁻¹ (2 + n) → A) →
 Σ (λ hub₁ → (x₁ : Sⁿ⁻¹ (2 + n)) → sph x₁ ≡ hub₁)) →
(a b : A) (sph : Sⁿ⁻¹ (1 + n) → a ≡ b) →
Σ (λ hub₁ → (x₁ : Sⁿ⁻¹ (1 + n)) → sph x₁ ≡ hub₁)" class="Function">helper</a> <a id="10356" href="SHT.Base.html#10306" class="Bound">spheres</a> <a id="10364" href="SHT.Base.html#10314" class="Bound">x</a> <a id="10366" href="SHT.Base.html#10316" class="Bound">y</a> <a id="10368" class="Keyword">where</a>
  <a id="10376" href="SHT.Base.html#10376" data-type="(n : Nat)
(spheres
 : (sph : Sⁿ (suc n) .fst → A) →
   Σ (λ hub₁ → (x : Sⁿ (suc n) .fst) → sph x ≡ hub₁))
(x y : A) →
((sph : Sⁿ⁻¹ (2 + n) → A) →
 Σ (λ hub₁ → (x₁ : Sⁿ⁻¹ (2 + n)) → sph x₁ ≡ hub₁)) →
(a b : A) (sph : Sⁿ⁻¹ (1 + n) → a ≡ b) →
Σ (λ hub₁ → (x₁ : Sⁿ⁻¹ (1 + n)) → sph x₁ ≡ hub₁)" class="Function">helper</a>
    <a id="10387" class="Symbol">:</a> <a id="10389" class="Symbol">((</a><a id="10391" href="SHT.Base.html#10391" class="Bound">sph</a> <a id="10395" class="Symbol">:</a> <a id="10397" href="1Lab.HIT.Sphere.html#1729" data-type="Nat → Type" class="Function">Sⁿ⁻¹</a> <a id="10402" class="Symbol">(</a><a id="10403" class="Number">2</a> <a id="10405" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="10407" href="SHT.Base.html#10303" class="Bound">n</a><a id="10408" class="Symbol">)</a> <a id="10410" class="Symbol">→</a> <a id="10412" href="SHT.Base.html#10295" class="Bound">A</a><a id="10413" class="Symbol">)</a> <a id="10415" class="Symbol">→</a> <a id="10417" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">Σ</a> <a id="10419" class="Symbol">λ</a> <a id="10421" href="SHT.Base.html#10421" class="Bound">hub</a> <a id="10425" class="Symbol">→</a> <a id="10427" class="Symbol">∀</a> <a id="10429" href="SHT.Base.html#10429" class="Bound">x</a> <a id="10431" class="Symbol">→</a> <a id="10433" href="SHT.Base.html#10391" class="Bound">sph</a> <a id="10437" href="SHT.Base.html#10429" class="Bound">x</a> <a id="10439" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="10441" href="SHT.Base.html#10421" class="Bound">hub</a><a id="10444" class="Symbol">)</a>
    <a id="10450" class="Symbol">→</a> <a id="10452" class="Symbol">∀</a> <a id="10454" href="SHT.Base.html#10454" class="Bound">a</a> <a id="10456" href="SHT.Base.html#10456" class="Bound">b</a>
    <a id="10462" class="Symbol">→</a> <a id="10464" class="Symbol">(</a><a id="10465" href="SHT.Base.html#10465" class="Bound">sph</a> <a id="10469" class="Symbol">:</a> <a id="10471" href="1Lab.HIT.Sphere.html#1729" data-type="Nat → Type" class="Function">Sⁿ⁻¹</a> <a id="10476" class="Symbol">(</a><a id="10477" class="Number">1</a> <a id="10479" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="10481" href="SHT.Base.html#10303" class="Bound">n</a><a id="10482" class="Symbol">)</a> <a id="10484" class="Symbol">→</a> <a id="10486" href="SHT.Base.html#10454" class="Bound">a</a> <a id="10488" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="10490" href="SHT.Base.html#10456" class="Bound">b</a><a id="10491" class="Symbol">)</a>
    <a id="10497" class="Symbol">→</a> <a id="10499" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">Σ</a> <a id="10501" class="Symbol">λ</a> <a id="10503" href="SHT.Base.html#10503" class="Bound">hub</a> <a id="10507" class="Symbol">→</a> <a id="10509" class="Symbol">∀</a> <a id="10511" href="SHT.Base.html#10511" class="Bound">x</a> <a id="10513" class="Symbol">→</a> <a id="10515" href="SHT.Base.html#10465" class="Bound">sph</a> <a id="10519" href="SHT.Base.html#10511" class="Bound">x</a> <a id="10521" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="10523" href="SHT.Base.html#10503" class="Bound">hub</a>
  <a id="10529" href="SHT.Base.html#10376" data-type="(n : Nat)
(spheres
 : (sph : Sⁿ (suc n) .fst → A) →
   Σ (λ hub₁ → (x : Sⁿ (suc n) .fst) → sph x ≡ hub₁))
(x y : A) →
((sph : Sⁿ⁻¹ (2 + n) → A) →
 Σ (λ hub₁ → (x₁ : Sⁿ⁻¹ (2 + n)) → sph x₁ ≡ hub₁)) →
(a b : A) (sph : Sⁿ⁻¹ (1 + n) → a ≡ b) →
Σ (λ hub₁ → (x₁ : Sⁿ⁻¹ (1 + n)) → sph x₁ ≡ hub₁)" class="Function">helper</a> <a id="10536" href="SHT.Base.html#10536" class="Bound">h</a> <a id="10538" href="SHT.Base.html#10538" class="Bound">x</a> <a id="10540" href="SHT.Base.html#10540" class="Bound">y</a> <a id="10542" href="SHT.Base.html#10542" class="Bound">f</a> <a id="10544" class="Symbol">=</a> <a id="10546" class="Symbol">_</a> <a id="10548" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="10550" href="SHT.Base.html#10643" data-type="(n : Nat)
(spheres
 : (sph : Sⁿ (suc n) .fst → A) →
   Σ (λ hub₁ → (x : Sⁿ (suc n) .fst) → sph x ≡ hub₁))
(x y : A)
(h
 : (sph : Sⁿ⁻¹ (2 + n) → A) →
   Σ (λ hub₁ → (x₁ : Sⁿ⁻¹ (2 + n)) → sph x₁ ≡ hub₁))
(x₁ y₁ : A) (f : Sⁿ⁻¹ (1 + n) → x₁ ≡ y₁) (s : Sⁿ⁻¹ (1 + n)) →
f s ≡
h (f&#39; n spheres x y h x₁ y₁ f) .snd N ∙
sym (h (f&#39; n spheres x y h x₁ y₁ f) .snd S)" class="Function">r</a>  <a id="10553" class="Keyword">where</a>
    <a id="10563" href="SHT.Base.html#10563" data-type="(n : Nat)
(spheres
 : (sph : Sⁿ (suc n) .fst → A) →
   Σ (λ hub₁ → (x : Sⁿ (suc n) .fst) → sph x ≡ hub₁))
(x y : A)
(h
 : (sph : Sⁿ⁻¹ (2 + n) → A) →
   Σ (λ hub₁ → (x₁ : Sⁿ⁻¹ (2 + n)) → sph x₁ ≡ hub₁))
(x₁ y₁ : A) (f : Sⁿ⁻¹ (1 + n) → x₁ ≡ y₁) →
Sⁿ⁻¹ (2 + n) → A" class="Function">f&#39;</a> <a id="10566" class="Symbol">:</a> <a id="10568" href="1Lab.HIT.Sphere.html#1729" data-type="Nat → Type" class="Function">Sⁿ⁻¹</a> <a id="10573" class="Symbol">(</a><a id="10574" class="Number">2</a> <a id="10576" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="10578" href="SHT.Base.html#10303" class="Bound">n</a><a id="10579" class="Symbol">)</a> <a id="10581" class="Symbol">→</a> <a id="10583" href="SHT.Base.html#10295" class="Bound">A</a>
    <a id="10589" href="SHT.Base.html#10563" data-type="(n : Nat)
(spheres
 : (sph : Sⁿ (suc n) .fst → A) →
   Σ (λ hub₁ → (x : Sⁿ (suc n) .fst) → sph x ≡ hub₁))
(x y : A)
(h
 : (sph : Sⁿ⁻¹ (2 + n) → A) →
   Σ (λ hub₁ → (x₁ : Sⁿ⁻¹ (2 + n)) → sph x₁ ≡ hub₁))
(x₁ y₁ : A) (f : Sⁿ⁻¹ (1 + n) → x₁ ≡ y₁) →
Sⁿ⁻¹ (2 + n) → A" class="Function">f&#39;</a> <a id="10592" href="1Lab.HIT.Suspension.html#312" data-type="Susp A" class="InductiveConstructor">N</a> <a id="10594" class="Symbol">=</a> <a id="10596" href="SHT.Base.html#10538" class="Bound">x</a>
    <a id="10602" href="SHT.Base.html#10563" data-type="(n : Nat)
(spheres
 : (sph : Sⁿ (suc n) .fst → A) →
   Σ (λ hub₁ → (x : Sⁿ (suc n) .fst) → sph x ≡ hub₁))
(x y : A)
(h
 : (sph : Sⁿ⁻¹ (2 + n) → A) →
   Σ (λ hub₁ → (x₁ : Sⁿ⁻¹ (2 + n)) → sph x₁ ≡ hub₁))
(x₁ y₁ : A) (f : Sⁿ⁻¹ (1 + n) → x₁ ≡ y₁) →
Sⁿ⁻¹ (2 + n) → A" class="Function">f&#39;</a> <a id="10605" href="1Lab.HIT.Suspension.html#314" data-type="Susp A" class="InductiveConstructor">S</a> <a id="10607" class="Symbol">=</a> <a id="10609" href="SHT.Base.html#10540" class="Bound">y</a>
    <a id="10615" href="SHT.Base.html#10563" data-type="(n : Nat)
(spheres
 : (sph : Sⁿ (suc n) .fst → A) →
   Σ (λ hub₁ → (x : Sⁿ (suc n) .fst) → sph x ≡ hub₁))
(x y : A)
(h
 : (sph : Sⁿ⁻¹ (2 + n) → A) →
   Σ (λ hub₁ → (x₁ : Sⁿ⁻¹ (2 + n)) → sph x₁ ≡ hub₁))
(x₁ y₁ : A) (f : Sⁿ⁻¹ (1 + n) → x₁ ≡ y₁) →
Sⁿ⁻¹ (2 + n) → A" class="Function">f&#39;</a> <a id="10618" class="Symbol">(</a><a id="10619" href="1Lab.HIT.Suspension.html#329" data-type="A → N ≡ S" class="InductiveConstructor">merid</a> <a id="10625" href="SHT.Base.html#10625" class="Bound">u</a> <a id="10627" href="SHT.Base.html#10627" class="Bound">i</a><a id="10628" class="Symbol">)</a> <a id="10630" class="Symbol">=</a> <a id="10632" href="SHT.Base.html#10542" class="Bound">f</a> <a id="10634" href="SHT.Base.html#10625" class="Bound">u</a> <a id="10636" href="SHT.Base.html#10627" class="Bound">i</a>

    <a id="10643" href="SHT.Base.html#10643" data-type="(n : Nat)
(spheres
 : (sph : Sⁿ (suc n) .fst → A) →
   Σ (λ hub₁ → (x : Sⁿ (suc n) .fst) → sph x ≡ hub₁))
(x y : A)
(h
 : (sph : Sⁿ⁻¹ (2 + n) → A) →
   Σ (λ hub₁ → (x₁ : Sⁿ⁻¹ (2 + n)) → sph x₁ ≡ hub₁))
(x₁ y₁ : A) (f : Sⁿ⁻¹ (1 + n) → x₁ ≡ y₁) (s : Sⁿ⁻¹ (1 + n)) →
f s ≡
h (f&#39; n spheres x y h x₁ y₁ f) .snd N ∙
sym (h (f&#39; n spheres x y h x₁ y₁ f) .snd S)" class="Function">r</a> <a id="10645" class="Symbol">:</a> <a id="10647" class="Symbol">(</a><a id="10648" href="SHT.Base.html#10648" class="Bound">s</a> <a id="10650" class="Symbol">:</a> <a id="10652" href="1Lab.HIT.Sphere.html#1729" data-type="Nat → Type" class="Function">Sⁿ⁻¹</a> <a id="10657" class="Symbol">(</a><a id="10658" class="Number">1</a> <a id="10660" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="10662" href="SHT.Base.html#10303" class="Bound">n</a><a id="10663" class="Symbol">))</a> <a id="10666" class="Symbol">→</a> <a id="10668" href="SHT.Base.html#10542" class="Bound">f</a> <a id="10670" href="SHT.Base.html#10648" class="Bound">s</a> <a id="10672" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="10674" href="SHT.Base.html#10536" class="Bound">h</a> <a id="10676" href="SHT.Base.html#10563" data-type="(n : Nat)
(spheres
 : (sph : Sⁿ (suc n) .fst → A) →
   Σ (λ hub₁ → (x : Sⁿ (suc n) .fst) → sph x ≡ hub₁))
(x y : A)
(h
 : (sph : Sⁿ⁻¹ (2 + n) → A) →
   Σ (λ hub₁ → (x₁ : Sⁿ⁻¹ (2 + n)) → sph x₁ ≡ hub₁))
(x₁ y₁ : A) (f : Sⁿ⁻¹ (1 + n) → x₁ ≡ y₁) →
Sⁿ⁻¹ (2 + n) → A" class="Function">f&#39;</a> <a id="10679" class="Symbol">.</a><a id="10680" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="10684" href="1Lab.HIT.Suspension.html#312" data-type="Susp A" class="InductiveConstructor">N</a> <a id="10686" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="10688" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="10692" class="Symbol">(</a><a id="10693" href="SHT.Base.html#10536" class="Bound">h</a> <a id="10695" href="SHT.Base.html#10563" data-type="(n : Nat)
(spheres
 : (sph : Sⁿ (suc n) .fst → A) →
   Σ (λ hub₁ → (x : Sⁿ (suc n) .fst) → sph x ≡ hub₁))
(x y : A)
(h
 : (sph : Sⁿ⁻¹ (2 + n) → A) →
   Σ (λ hub₁ → (x₁ : Sⁿ⁻¹ (2 + n)) → sph x₁ ≡ hub₁))
(x₁ y₁ : A) (f : Sⁿ⁻¹ (1 + n) → x₁ ≡ y₁) →
Sⁿ⁻¹ (2 + n) → A" class="Function">f&#39;</a> <a id="10698" class="Symbol">.</a><a id="10699" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="10703" href="1Lab.HIT.Suspension.html#314" data-type="Susp A" class="InductiveConstructor">S</a><a id="10704" class="Symbol">)</a>
    <a id="10710" href="SHT.Base.html#10643" data-type="(n : Nat)
(spheres
 : (sph : Sⁿ (suc n) .fst → A) →
   Σ (λ hub₁ → (x : Sⁿ (suc n) .fst) → sph x ≡ hub₁))
(x y : A)
(h
 : (sph : Sⁿ⁻¹ (2 + n) → A) →
   Σ (λ hub₁ → (x₁ : Sⁿ⁻¹ (2 + n)) → sph x₁ ≡ hub₁))
(x₁ y₁ : A) (f : Sⁿ⁻¹ (1 + n) → x₁ ≡ y₁) (s : Sⁿ⁻¹ (1 + n)) →
f s ≡
h (f&#39; n spheres x y h x₁ y₁ f) .snd N ∙
sym (h (f&#39; n spheres x y h x₁ y₁ f) .snd S)" class="Function">r</a> <a id="10712" href="SHT.Base.html#10712" class="Bound">s</a> <a id="10714" href="SHT.Base.html#10714" class="Bound">i</a> <a id="10716" href="SHT.Base.html#10716" class="Bound">j</a> <a id="10718" class="Symbol">=</a> <a id="10720" href="1Lab.Path.html#2368" class="Primitive">hcomp</a>
      <a id="10732" class="Symbol">(λ</a> <a id="10735" class="Symbol">{</a> <a id="10737" href="SHT.Base.html#10737" class="Bound">k</a> <a id="10739" class="Symbol">(</a><a id="10740" href="SHT.Base.html#10714" class="Bound">i</a> <a id="10742" class="Symbol">=</a> <a id="10744" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="10746" class="Symbol">)</a> <a id="10748" class="Symbol">→</a> <a id="10750" href="SHT.Base.html#10536" class="Bound">h</a> <a id="10752" href="SHT.Base.html#10563" data-type="(n : Nat)
(spheres
 : (sph : Sⁿ (suc n) .fst → A) →
   Σ (λ hub₁ → (x : Sⁿ (suc n) .fst) → sph x ≡ hub₁))
(x y : A)
(h
 : (sph : Sⁿ⁻¹ (2 + n) → A) →
   Σ (λ hub₁ → (x₁ : Sⁿ⁻¹ (2 + n)) → sph x₁ ≡ hub₁))
(x₁ y₁ : A) (f : Sⁿ⁻¹ (1 + n) → x₁ ≡ y₁) →
Sⁿ⁻¹ (2 + n) → A" class="Function">f&#39;</a> <a id="10755" class="Symbol">.</a><a id="10756" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="10760" class="Symbol">(</a><a id="10761" href="1Lab.HIT.Suspension.html#329" data-type="A → N ≡ S" class="InductiveConstructor">merid</a> <a id="10767" href="SHT.Base.html#10712" class="Bound">s</a> <a id="10769" href="SHT.Base.html#10716" class="Bound">j</a><a id="10770" class="Symbol">)</a> <a id="10772" class="Symbol">(</a><a id="10773" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="10775" href="SHT.Base.html#10737" class="Bound">k</a><a id="10776" class="Symbol">)</a>
         <a id="10787" class="Symbol">;</a> <a id="10789" href="SHT.Base.html#10789" class="Bound">k</a> <a id="10791" class="Symbol">(</a><a id="10792" href="SHT.Base.html#10714" class="Bound">i</a> <a id="10794" class="Symbol">=</a> <a id="10796" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="10798" class="Symbol">)</a> <a id="10800" class="Symbol">→</a>
          <a id="10812" href="1Lab.Path.html#35481" data-type="(u : I → Partial φ A) (u0 : A [ φ ↦ u i0 ]) →
outS u0 ≡ hcomp u (outS u0)" class="Function">hfill</a> <a id="10818" class="Symbol">(λ</a> <a id="10821" class="Symbol">{</a> <a id="10823" href="SHT.Base.html#10823" class="Bound">l</a> <a id="10825" class="Symbol">(</a><a id="10826" href="SHT.Base.html#10716" class="Bound">j</a> <a id="10828" class="Symbol">=</a> <a id="10830" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="10832" class="Symbol">)</a> <a id="10834" class="Symbol">→</a> <a id="10836" href="SHT.Base.html#10538" class="Bound">x</a>
                   <a id="10857" class="Symbol">;</a> <a id="10859" href="SHT.Base.html#10859" class="Bound">l</a> <a id="10861" class="Symbol">(</a><a id="10862" href="SHT.Base.html#10716" class="Bound">j</a> <a id="10864" class="Symbol">=</a> <a id="10866" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="10868" class="Symbol">)</a> <a id="10870" class="Symbol">→</a> <a id="10872" href="SHT.Base.html#10536" class="Bound">h</a> <a id="10874" href="SHT.Base.html#10563" data-type="(n : Nat)
(spheres
 : (sph : Sⁿ (suc n) .fst → A) →
   Σ (λ hub₁ → (x : Sⁿ (suc n) .fst) → sph x ≡ hub₁))
(x y : A)
(h
 : (sph : Sⁿ⁻¹ (2 + n) → A) →
   Σ (λ hub₁ → (x₁ : Sⁿ⁻¹ (2 + n)) → sph x₁ ≡ hub₁))
(x₁ y₁ : A) (f : Sⁿ⁻¹ (1 + n) → x₁ ≡ y₁) →
Sⁿ⁻¹ (2 + n) → A" class="Function">f&#39;</a> <a id="10877" class="Symbol">.</a><a id="10878" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="10882" href="1Lab.HIT.Suspension.html#314" data-type="Susp A" class="InductiveConstructor">S</a> <a id="10884" class="Symbol">(</a><a id="10885" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="10887" href="SHT.Base.html#10859" class="Bound">l</a><a id="10888" class="Symbol">)</a>
                   <a id="10909" class="Symbol">})</a>
            <a id="10924" class="Symbol">(</a><a id="10925" href="1Lab.Path.html#2069" class="Postulate">inS</a> <a id="10929" class="Symbol">(</a><a id="10930" href="SHT.Base.html#10536" class="Bound">h</a> <a id="10932" href="SHT.Base.html#10563" data-type="(n : Nat)
(spheres
 : (sph : Sⁿ (suc n) .fst → A) →
   Σ (λ hub₁ → (x : Sⁿ (suc n) .fst) → sph x ≡ hub₁))
(x y : A)
(h
 : (sph : Sⁿ⁻¹ (2 + n) → A) →
   Σ (λ hub₁ → (x₁ : Sⁿ⁻¹ (2 + n)) → sph x₁ ≡ hub₁))
(x₁ y₁ : A) (f : Sⁿ⁻¹ (1 + n) → x₁ ≡ y₁) →
Sⁿ⁻¹ (2 + n) → A" class="Function">f&#39;</a> <a id="10935" class="Symbol">.</a><a id="10936" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="10940" href="1Lab.HIT.Suspension.html#312" data-type="Susp A" class="InductiveConstructor">N</a> <a id="10942" href="SHT.Base.html#10716" class="Bound">j</a><a id="10943" class="Symbol">))</a> <a id="10946" href="SHT.Base.html#10789" class="Bound">k</a>
         <a id="10957" class="Symbol">;</a> <a id="10959" href="SHT.Base.html#10959" class="Bound">k</a> <a id="10961" class="Symbol">(</a><a id="10962" href="SHT.Base.html#10716" class="Bound">j</a> <a id="10964" class="Symbol">=</a> <a id="10966" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="10968" class="Symbol">)</a> <a id="10970" class="Symbol">→</a> <a id="10972" href="SHT.Base.html#10536" class="Bound">h</a> <a id="10974" href="SHT.Base.html#10563" data-type="(n : Nat)
(spheres
 : (sph : Sⁿ (suc n) .fst → A) →
   Σ (λ hub₁ → (x : Sⁿ (suc n) .fst) → sph x ≡ hub₁))
(x y : A)
(h
 : (sph : Sⁿ⁻¹ (2 + n) → A) →
   Σ (λ hub₁ → (x₁ : Sⁿ⁻¹ (2 + n)) → sph x₁ ≡ hub₁))
(x₁ y₁ : A) (f : Sⁿ⁻¹ (1 + n) → x₁ ≡ y₁) →
Sⁿ⁻¹ (2 + n) → A" class="Function">f&#39;</a> <a id="10977" class="Symbol">.</a><a id="10978" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="10982" href="1Lab.HIT.Suspension.html#312" data-type="Susp A" class="InductiveConstructor">N</a> <a id="10984" class="Symbol">(</a><a id="10985" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="10987" href="SHT.Base.html#10714" class="Bound">i</a> <a id="10989" href="1Lab.Path.html#2191" class="Primitive Operator">∧</a> <a id="10991" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="10993" href="SHT.Base.html#10959" class="Bound">k</a><a id="10994" class="Symbol">)</a>
         <a id="11005" class="Symbol">;</a> <a id="11007" href="SHT.Base.html#11007" class="Bound">k</a> <a id="11009" class="Symbol">(</a><a id="11010" href="SHT.Base.html#10716" class="Bound">j</a> <a id="11012" class="Symbol">=</a> <a id="11014" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="11016" class="Symbol">)</a> <a id="11018" class="Symbol">→</a> <a id="11020" href="SHT.Base.html#10536" class="Bound">h</a> <a id="11022" href="SHT.Base.html#10563" data-type="(n : Nat)
(spheres
 : (sph : Sⁿ (suc n) .fst → A) →
   Σ (λ hub₁ → (x : Sⁿ (suc n) .fst) → sph x ≡ hub₁))
(x y : A)
(h
 : (sph : Sⁿ⁻¹ (2 + n) → A) →
   Σ (λ hub₁ → (x₁ : Sⁿ⁻¹ (2 + n)) → sph x₁ ≡ hub₁))
(x₁ y₁ : A) (f : Sⁿ⁻¹ (1 + n) → x₁ ≡ y₁) →
Sⁿ⁻¹ (2 + n) → A" class="Function">f&#39;</a> <a id="11025" class="Symbol">.</a><a id="11026" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="11030" href="1Lab.HIT.Suspension.html#314" data-type="Susp A" class="InductiveConstructor">S</a> <a id="11032" class="Symbol">(</a><a id="11033" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="11035" href="SHT.Base.html#11007" class="Bound">k</a><a id="11036" class="Symbol">)</a>
         <a id="11047" class="Symbol">})</a>
      <a id="11056" class="Symbol">(</a><a id="11057" href="SHT.Base.html#10536" class="Bound">h</a> <a id="11059" href="SHT.Base.html#10563" data-type="(n : Nat)
(spheres
 : (sph : Sⁿ (suc n) .fst → A) →
   Σ (λ hub₁ → (x : Sⁿ (suc n) .fst) → sph x ≡ hub₁))
(x y : A)
(h
 : (sph : Sⁿ⁻¹ (2 + n) → A) →
   Σ (λ hub₁ → (x₁ : Sⁿ⁻¹ (2 + n)) → sph x₁ ≡ hub₁))
(x₁ y₁ : A) (f : Sⁿ⁻¹ (1 + n) → x₁ ≡ y₁) →
Sⁿ⁻¹ (2 + n) → A" class="Function">f&#39;</a> <a id="11062" class="Symbol">.</a><a id="11063" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="11067" href="1Lab.HIT.Suspension.html#312" data-type="Susp A" class="InductiveConstructor">N</a> <a id="11069" class="Symbol">(</a><a id="11070" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="11072" href="SHT.Base.html#10714" class="Bound">i</a> <a id="11074" href="1Lab.Path.html#2226" class="Primitive Operator">∨</a> <a id="11076" href="SHT.Base.html#10716" class="Bound">j</a><a id="11077" class="Symbol">))</a>
</pre>-->
<p>Using this idea, we can define a general
<em><span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>-truncation</span></em>
type, as a joint generalisation of the <a href="1Lab.HIT.Truncation.html">propositional</a> and <a href="Data.Set.Truncation.html">set</a> truncations. While can not
<em>directly</em> build a type with a constructor saying the type is
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>-truncated,</span>
what we <em>can</em> do is freely generate
<span class="Agda"><a href="SHT.Base.html#9189" class="Bound">hub</a></span>s
and
<span class="Agda"><a href="SHT.Base.html#11704" class="InductiveConstructor">spokes</a></span>
for any
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>-sphere</span>
drawn on the
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>-truncation</span>
of
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>.</span>
The result is the universal
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>-type</span>
admitting a map from
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>.</span></p>
<pre class="Agda"><a id="11588" class="Keyword">data</a> <a id="n-Tr"></a><a id="11593" href="SHT.Base.html#11593" data-type="(A : Type ℓ) → Nat → Type ℓ" class="Datatype">n-Tr</a> <a id="11598" class="Symbol">{</a><a id="11599" href="SHT.Base.html#11599" class="Bound">ℓ</a><a id="11600" class="Symbol">}</a> <a id="11602" class="Symbol">(</a><a id="11603" href="SHT.Base.html#11603" class="Bound">A</a> <a id="11605" class="Symbol">:</a> <a id="11607" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="11612" href="SHT.Base.html#11599" class="Bound">ℓ</a><a id="11613" class="Symbol">)</a> <a id="11615" href="SHT.Base.html#11615" class="Bound">n</a> <a id="11617" class="Symbol">:</a> <a id="11619" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="11624" href="SHT.Base.html#11599" class="Bound">ℓ</a> <a id="11626" class="Keyword">where</a>
  <a id="n-Tr.inc"></a><a id="11634" href="SHT.Base.html#11634" data-type="A → n-Tr A n" class="InductiveConstructor">inc</a>    <a id="11641" class="Symbol">:</a> <a id="11643" href="SHT.Base.html#11603" class="Bound">A</a> <a id="11645" class="Symbol">→</a> <a id="11647" href="SHT.Base.html#11593" data-type="(A : Type ℓ) → Nat → Type ℓ" class="Datatype">n-Tr</a> <a id="11652" href="SHT.Base.html#11603" class="Bound">A</a> <a id="11654" href="SHT.Base.html#11615" class="Bound">n</a>
  <a id="n-Tr.hub"></a><a id="11658" href="SHT.Base.html#11658" data-type="(Sⁿ⁻¹ n → n-Tr A n) → n-Tr A n" class="InductiveConstructor">hub</a>    <a id="11665" class="Symbol">:</a> <a id="11667" class="Symbol">(</a><a id="11668" href="SHT.Base.html#11668" class="Bound">r</a> <a id="11670" class="Symbol">:</a> <a id="11672" href="1Lab.HIT.Sphere.html#1729" data-type="Nat → Type" class="Function">Sⁿ⁻¹</a> <a id="11677" href="SHT.Base.html#11615" class="Bound">n</a> <a id="11679" class="Symbol">→</a> <a id="11681" href="SHT.Base.html#11593" data-type="(A : Type ℓ) → Nat → Type ℓ" class="Datatype">n-Tr</a> <a id="11686" href="SHT.Base.html#11603" class="Bound">A</a> <a id="11688" href="SHT.Base.html#11615" class="Bound">n</a><a id="11689" class="Symbol">)</a> <a id="11691" class="Symbol">→</a> <a id="11693" href="SHT.Base.html#11593" data-type="(A : Type ℓ) → Nat → Type ℓ" class="Datatype">n-Tr</a> <a id="11698" href="SHT.Base.html#11603" class="Bound">A</a> <a id="11700" href="SHT.Base.html#11615" class="Bound">n</a>
  <a id="n-Tr.spokes"></a><a id="11704" href="SHT.Base.html#11704" data-type="(r : Sⁿ⁻¹ n → n-Tr A n) (x : Sⁿ⁻¹ n) → r x ≡ hub r" class="InductiveConstructor">spokes</a> <a id="11711" class="Symbol">:</a> <a id="11713" class="Symbol">(</a><a id="11714" href="SHT.Base.html#11714" class="Bound">r</a> <a id="11716" class="Symbol">:</a> <a id="11718" href="1Lab.HIT.Sphere.html#1729" data-type="Nat → Type" class="Function">Sⁿ⁻¹</a> <a id="11723" href="SHT.Base.html#11615" class="Bound">n</a> <a id="11725" class="Symbol">→</a> <a id="11727" href="SHT.Base.html#11593" data-type="(A : Type ℓ) → Nat → Type ℓ" class="Datatype">n-Tr</a> <a id="11732" href="SHT.Base.html#11603" class="Bound">A</a> <a id="11734" href="SHT.Base.html#11615" class="Bound">n</a><a id="11735" class="Symbol">)</a> <a id="11737" class="Symbol">→</a> <a id="11739" class="Symbol">∀</a> <a id="11741" href="SHT.Base.html#11741" class="Bound">x</a> <a id="11743" class="Symbol">→</a> <a id="11745" href="SHT.Base.html#11714" class="Bound">r</a> <a id="11747" href="SHT.Base.html#11741" class="Bound">x</a> <a id="11749" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="11751" href="SHT.Base.html#11658" data-type="(Sⁿ⁻¹ n → n-Tr A n) → n-Tr A n" class="InductiveConstructor">hub</a> <a id="11755" href="SHT.Base.html#11714" class="Bound">r</a>
</pre>
<p>For both proving that the
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>-truncation</span>
has the right h-level, and proving that one can eliminate from it to
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>-types,</span>
we use the characterisations of truncation in terms of
hubs-and-spokes.</p>
<pre class="Agda"><a id="n-Tr-is-hlevel"></a><a id="11964" href="SHT.Base.html#11964" data-type="(n : Nat) → is-hlevel (n-Tr A (suc n)) (suc n)" class="Function">n-Tr-is-hlevel</a>
  <a id="11981" class="Symbol">:</a> <a id="11983" class="Symbol">∀</a> <a id="11985" class="Symbol">{</a><a id="11986" href="SHT.Base.html#11986" class="Bound">ℓ</a><a id="11987" class="Symbol">}</a> <a id="11989" class="Symbol">{</a><a id="11990" href="SHT.Base.html#11990" class="Bound">A</a> <a id="11992" class="Symbol">:</a> <a id="11994" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="11999" href="SHT.Base.html#11986" class="Bound">ℓ</a><a id="12000" class="Symbol">}</a> <a id="12002" href="SHT.Base.html#12002" class="Bound">n</a> <a id="12004" class="Symbol">→</a> <a id="12006" href="1Lab.HLevel.html#2813" data-type="Type ℓ → Nat → Type ℓ" class="Function">is-hlevel</a> <a id="12016" class="Symbol">(</a><a id="12017" href="SHT.Base.html#11593" data-type="(A : Type ℓ) → Nat → Type ℓ" class="Datatype">n-Tr</a> <a id="12022" href="SHT.Base.html#11990" class="Bound">A</a> <a id="12024" class="Symbol">(</a><a id="12025" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="12029" href="SHT.Base.html#12002" class="Bound">n</a><a id="12030" class="Symbol">))</a> <a id="12033" class="Symbol">(</a><a id="12034" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="12038" href="SHT.Base.html#12002" class="Bound">n</a><a id="12039" class="Symbol">)</a>
<a id="12041" href="SHT.Base.html#11964" data-type="(n : Nat) → is-hlevel (n-Tr A (suc n)) (suc n)" class="Function">n-Tr-is-hlevel</a> <a id="12056" href="SHT.Base.html#12056" class="Bound">n</a> <a id="12058" class="Symbol">=</a> <a id="12060" href="SHT.Base.html#9220" data-type="(n : Nat) →
((sph : Sⁿ n .fst → A) →
 Σ (λ hub₁ → (x : Sⁿ n .fst) → sph x ≡ hub₁)) →
is-hlevel A (suc n)" class="Function">hubs-and-spokes→hlevel</a> <a id="12083" href="SHT.Base.html#12056" class="Bound">n</a> <a id="12085" class="Symbol">λ</a> <a id="12087" href="SHT.Base.html#12087" class="Bound">sph</a> <a id="12091" class="Symbol">→</a> <a id="12093" href="SHT.Base.html#11658" data-type="(Sⁿ⁻¹ n → n-Tr A n) → n-Tr A n" class="InductiveConstructor">hub</a> <a id="12097" href="SHT.Base.html#12087" class="Bound">sph</a> <a id="12101" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="12103" href="SHT.Base.html#11704" data-type="(r : Sⁿ⁻¹ n → n-Tr A n) (x : Sⁿ⁻¹ n) → r x ≡ hub r" class="InductiveConstructor">spokes</a> <a id="12110" href="SHT.Base.html#12087" class="Bound">sph</a>

<a id="n-Tr-elim"></a><a id="12115" href="SHT.Base.html#12115" data-type="(P : n-Tr A (suc n) → Type ℓ′) →
((x : n-Tr A (suc n)) → is-hlevel (P x) (suc n)) →
((x : A) → P (inc x)) → (x : n-Tr A (suc n)) → P x" class="Function">n-Tr-elim</a>
  <a id="12127" class="Symbol">:</a> <a id="12129" class="Symbol">∀</a> <a id="12131" class="Symbol">{</a><a id="12132" href="SHT.Base.html#12132" class="Bound">ℓ</a> <a id="12134" href="SHT.Base.html#12134" class="Bound">ℓ′</a><a id="12136" class="Symbol">}</a> <a id="12138" class="Symbol">{</a><a id="12139" href="SHT.Base.html#12139" class="Bound">A</a> <a id="12141" class="Symbol">:</a> <a id="12143" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="12148" href="SHT.Base.html#12132" class="Bound">ℓ</a><a id="12149" class="Symbol">}</a> <a id="12151" class="Symbol">{</a><a id="12152" href="SHT.Base.html#12152" class="Bound">n</a><a id="12153" class="Symbol">}</a>
  <a id="12157" class="Symbol">→</a> <a id="12159" class="Symbol">(</a><a id="12160" href="SHT.Base.html#12160" class="Bound">P</a> <a id="12162" class="Symbol">:</a> <a id="12164" href="SHT.Base.html#11593" data-type="(A : Type ℓ) → Nat → Type ℓ" class="Datatype">n-Tr</a> <a id="12169" href="SHT.Base.html#12139" class="Bound">A</a> <a id="12171" class="Symbol">(</a><a id="12172" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="12176" href="SHT.Base.html#12152" class="Bound">n</a><a id="12177" class="Symbol">)</a> <a id="12179" class="Symbol">→</a> <a id="12181" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="12186" href="SHT.Base.html#12134" class="Bound">ℓ′</a><a id="12188" class="Symbol">)</a>
  <a id="12192" class="Symbol">→</a> <a id="12194" class="Symbol">(∀</a> <a id="12197" href="SHT.Base.html#12197" class="Bound">x</a> <a id="12199" class="Symbol">→</a> <a id="12201" href="1Lab.HLevel.html#2813" data-type="Type ℓ → Nat → Type ℓ" class="Function">is-hlevel</a> <a id="12211" class="Symbol">(</a><a id="12212" href="SHT.Base.html#12160" class="Bound">P</a> <a id="12214" href="SHT.Base.html#12197" class="Bound">x</a><a id="12215" class="Symbol">)</a> <a id="12217" class="Symbol">(</a><a id="12218" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="12222" href="SHT.Base.html#12152" class="Bound">n</a><a id="12223" class="Symbol">))</a>
  <a id="12228" class="Symbol">→</a> <a id="12230" class="Symbol">(∀</a> <a id="12233" href="SHT.Base.html#12233" class="Bound">x</a> <a id="12235" class="Symbol">→</a> <a id="12237" href="SHT.Base.html#12160" class="Bound">P</a> <a id="12239" class="Symbol">(</a><a id="12240" class="InductiveConstructor">inc</a> <a id="12244" href="SHT.Base.html#12233" class="Bound">x</a><a id="12245" class="Symbol">))</a>
  <a id="12250" class="Symbol">→</a> <a id="12252" class="Symbol">∀</a> <a id="12254" href="SHT.Base.html#12254" class="Bound">x</a> <a id="12256" class="Symbol">→</a> <a id="12258" href="SHT.Base.html#12160" class="Bound">P</a> <a id="12260" href="SHT.Base.html#12254" class="Bound">x</a>
<a id="12262" href="SHT.Base.html#12115" data-type="(P : n-Tr A (suc n) → Type ℓ′) →
((x : n-Tr A (suc n)) → is-hlevel (P x) (suc n)) →
((x : A) → P (inc x)) → (x : n-Tr A (suc n)) → P x" class="Function">n-Tr-elim</a> <a id="12272" class="Symbol">{</a><a id="12273" class="Argument">A</a> <a id="12275" class="Symbol">=</a> <a id="12277" href="SHT.Base.html#12277" class="Bound">A</a><a id="12278" class="Symbol">}</a> <a id="12280" class="Symbol">{</a><a id="12281" href="SHT.Base.html#12281" class="Bound">n</a><a id="12282" class="Symbol">}</a> <a id="12284" href="SHT.Base.html#12284" class="Bound">P</a> <a id="12286" href="SHT.Base.html#12286" class="Bound">ptrunc</a> <a id="12293" href="SHT.Base.html#12293" class="Bound">pbase</a> <a id="12299" class="Symbol">=</a> <a id="12301" href="SHT.Base.html#12720" data-type="(P : n-Tr A (suc n) → Type ℓ′) →
((x : n-Tr A (suc n)) → is-hlevel (P x) (suc n)) →
((x : A) → P (inc x)) → (x : n-Tr A (suc n)) → P x" class="Function">go</a> <a id="12304" class="Keyword">where</a>
  <a id="12312" class="Keyword">module</a> <a id="12319" href="SHT.Base.html#12319" class="Module">_</a> <a id="12321" class="Symbol">(</a><a id="12322" href="SHT.Base.html#12322" class="Bound">r</a> <a id="12324" class="Symbol">:</a> <a id="12326" href="SHT.Base.html#7030" data-type="Nat → Type∙ lzero" class="Function">Sⁿ</a> <a id="12329" href="SHT.Base.html#12281" class="Bound">n</a> <a id="12331" class="Symbol">.</a><a id="12332" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="12336" class="Symbol">→</a> <a id="12338" href="SHT.Base.html#11593" data-type="(A : Type ℓ) → Nat → Type ℓ" class="Datatype">n-Tr</a> <a id="12343" href="SHT.Base.html#12277" class="Bound">A</a> <a id="12345" class="Symbol">(</a><a id="12346" class="Number">1</a> <a id="12348" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12350" href="SHT.Base.html#12281" class="Bound">n</a><a id="12351" class="Symbol">))</a>
           <a id="12365" class="Symbol">(</a><a id="12366" href="SHT.Base.html#12366" class="Bound">w</a> <a id="12368" class="Symbol">:</a> <a id="12370" class="Symbol">(</a><a id="12371" href="SHT.Base.html#12371" class="Bound">x</a> <a id="12373" class="Symbol">:</a> <a id="12375" href="SHT.Base.html#7030" data-type="Nat → Type∙ lzero" class="Function">Sⁿ</a> <a id="12378" href="SHT.Base.html#12281" class="Bound">n</a> <a id="12380" class="Symbol">.</a><a id="12381" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a><a id="12384" class="Symbol">)</a> <a id="12386" class="Symbol">→</a> <a id="12388" href="SHT.Base.html#12284" class="Bound">P</a> <a id="12390" class="Symbol">(</a><a id="12391" href="SHT.Base.html#12322" class="Bound">r</a> <a id="12393" href="SHT.Base.html#12371" class="Bound">x</a><a id="12394" class="Symbol">))</a>
    <a id="12401" class="Keyword">where</a>
      <a id="12413" href="SHT.Base.html#12413" data-type="(P : n-Tr A (suc n) → Type ℓ′)
(ptrunc : (x : n-Tr A (suc n)) → is-hlevel (P x) (suc n))
(pbase : (x : A) → P (inc x)) (r : Sⁿ n .fst → n-Tr A (1 + n))
(w : (x : Sⁿ n .fst) → P (r x)) →
Sⁿ⁻¹ (1 + n) → P (hub r)" class="Function">circle</a> <a id="12420" class="Symbol">:</a> <a id="12422" href="1Lab.HIT.Sphere.html#1729" data-type="Nat → Type" class="Function">Sⁿ⁻¹</a> <a id="12427" class="Symbol">(</a><a id="12428" class="Number">1</a> <a id="12430" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12432" href="SHT.Base.html#12281" class="Bound">n</a><a id="12433" class="Symbol">)</a> <a id="12435" class="Symbol">→</a> <a id="12437" href="SHT.Base.html#12284" class="Bound">P</a> <a id="12439" class="Symbol">(</a><a id="12440" href="SHT.Base.html#11658" data-type="(Sⁿ⁻¹ n → n-Tr A n) → n-Tr A n" class="InductiveConstructor">hub</a> <a id="12444" href="SHT.Base.html#12322" class="Bound">r</a><a id="12445" class="Symbol">)</a>
      <a id="12453" href="SHT.Base.html#12413" data-type="(P : n-Tr A (suc n) → Type ℓ′)
(ptrunc : (x : n-Tr A (suc n)) → is-hlevel (P x) (suc n))
(pbase : (x : A) → P (inc x)) (r : Sⁿ n .fst → n-Tr A (1 + n))
(w : (x : Sⁿ n .fst) → P (r x)) →
Sⁿ⁻¹ (1 + n) → P (hub r)" class="Function">circle</a> <a id="12460" href="SHT.Base.html#12460" class="Bound">x</a> <a id="12462" class="Symbol">=</a> <a id="12464" href="1Lab.Path.html#15309" data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" class="Function">subst</a> <a id="12470" href="SHT.Base.html#12284" class="Bound">P</a> <a id="12472" class="Symbol">(</a><a id="12473" href="SHT.Base.html#11704" data-type="(r : Sⁿ⁻¹ n → n-Tr A n) (x : Sⁿ⁻¹ n) → r x ≡ hub r" class="InductiveConstructor">spokes</a> <a id="12480" href="SHT.Base.html#12322" class="Bound">r</a> <a id="12482" href="SHT.Base.html#12460" class="Bound">x</a><a id="12483" class="Symbol">)</a> <a id="12485" class="Symbol">(</a><a id="12486" href="SHT.Base.html#12366" class="Bound">w</a> <a id="12488" href="SHT.Base.html#12460" class="Bound">x</a><a id="12489" class="Symbol">)</a>

      <a id="12498" href="SHT.Base.html#12498" data-type="(P : n-Tr A (suc n) → Type ℓ′)
(ptrunc : (x : n-Tr A (suc n)) → is-hlevel (P x) (suc n))
(pbase : (x : A) → P (inc x)) (r : Sⁿ n .fst → n-Tr A (1 + n))
(w : (x : Sⁿ n .fst) → P (r x)) →
P (hub r)" class="Function">hub′</a> <a id="12503" class="Symbol">=</a> <a id="12505" href="SHT.Base.html#9078" data-type="(n : Nat) →
is-hlevel A (suc n) →
(sph : Sⁿ n .fst → A) → Σ (λ hub₁ → (x : Sⁿ n .fst) → sph x ≡ hub₁)" class="Function">hlevel→hubs-and-spokes</a> <a id="12528" href="SHT.Base.html#12281" class="Bound">n</a> <a id="12530" class="Symbol">(</a><a id="12531" href="SHT.Base.html#12286" class="Bound">ptrunc</a> <a id="12538" class="Symbol">(</a><a id="12539" href="SHT.Base.html#11658" data-type="(Sⁿ⁻¹ n → n-Tr A n) → n-Tr A n" class="InductiveConstructor">hub</a> <a id="12543" href="SHT.Base.html#12322" class="Bound">r</a><a id="12544" class="Symbol">))</a> <a id="12547" href="SHT.Base.html#12413" data-type="(P : n-Tr A (suc n) → Type ℓ′)
(ptrunc : (x : n-Tr A (suc n)) → is-hlevel (P x) (suc n))
(pbase : (x : A) → P (inc x)) (r : Sⁿ n .fst → n-Tr A (1 + n))
(w : (x : Sⁿ n .fst) → P (r x)) →
Sⁿ⁻¹ (1 + n) → P (hub r)" class="Function">circle</a> <a id="12554" class="Symbol">.</a><a id="12555" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a>

      <a id="12566" href="SHT.Base.html#12566" data-type="(P : n-Tr A (suc n) → Type ℓ′)
(ptrunc : (x : n-Tr A (suc n)) → is-hlevel (P x) (suc n))
(pbase : (x : A) → P (inc x)) (r : Sⁿ n .fst → n-Tr A (1 + n))
(w : (x : Sⁿ n .fst) → P (r x)) (x : Sⁿ⁻¹ (suc n)) →
PathP (λ i → P (spokes r x i)) (w x) (hub′ P ptrunc pbase r w)" class="Function">spokes′</a> <a id="12574" class="Symbol">:</a> <a id="12576" class="Symbol">∀</a> <a id="12578" href="SHT.Base.html#12578" class="Bound">x</a> <a id="12580" class="Symbol">→</a> <a id="12582" href="Agda.Primitive.Cubical.html#2013" class="Postulate">PathP</a> <a id="12588" class="Symbol">(λ</a> <a id="12591" href="SHT.Base.html#12591" class="Bound">i</a> <a id="12593" class="Symbol">→</a> <a id="12595" href="SHT.Base.html#12284" class="Bound">P</a> <a id="12597" class="Symbol">(</a><a id="12598" href="SHT.Base.html#11704" data-type="(r : Sⁿ⁻¹ n → n-Tr A n) (x : Sⁿ⁻¹ n) → r x ≡ hub r" class="InductiveConstructor">spokes</a> <a id="12605" href="SHT.Base.html#12322" class="Bound">r</a> <a id="12607" href="SHT.Base.html#12578" class="Bound">x</a> <a id="12609" href="SHT.Base.html#12591" class="Bound">i</a><a id="12610" class="Symbol">))</a> <a id="12613" class="Symbol">(</a><a id="12614" href="SHT.Base.html#12366" class="Bound">w</a> <a id="12616" href="SHT.Base.html#12578" class="Bound">x</a><a id="12617" class="Symbol">)</a> <a id="12619" href="SHT.Base.html#12498" data-type="(P : n-Tr A (suc n) → Type ℓ′)
(ptrunc : (x : n-Tr A (suc n)) → is-hlevel (P x) (suc n))
(pbase : (x : A) → P (inc x)) (r : Sⁿ n .fst → n-Tr A (1 + n))
(w : (x : Sⁿ n .fst) → P (r x)) →
P (hub r)" class="Function">hub′</a>
      <a id="12630" href="SHT.Base.html#12566" data-type="(P : n-Tr A (suc n) → Type ℓ′)
(ptrunc : (x : n-Tr A (suc n)) → is-hlevel (P x) (suc n))
(pbase : (x : A) → P (inc x)) (r : Sⁿ n .fst → n-Tr A (1 + n))
(w : (x : Sⁿ n .fst) → P (r x)) (x : Sⁿ⁻¹ (suc n)) →
PathP (λ i → P (spokes r x i)) (w x) (hub′ P ptrunc pbase r w)" class="Function">spokes′</a> <a id="12638" href="SHT.Base.html#12638" class="Bound">x</a> <a id="12640" class="Symbol">=</a> <a id="12642" href="1Lab.Path.html#55976" data-type="coe0→1 A x ≡ y → PathP A x y" class="Function">to-pathp</a> <a id="12651" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a>
        <a id="12661" href="SHT.Base.html#9078" data-type="(n : Nat) →
is-hlevel A (suc n) →
(sph : Sⁿ n .fst → A) → Σ (λ hub₁ → (x : Sⁿ n .fst) → sph x ≡ hub₁)" class="Function">hlevel→hubs-and-spokes</a> <a id="12684" href="SHT.Base.html#12281" class="Bound">n</a> <a id="12686" class="Symbol">(</a><a id="12687" href="SHT.Base.html#12286" class="Bound">ptrunc</a> <a id="12694" class="Symbol">(</a><a id="12695" href="SHT.Base.html#11658" data-type="(Sⁿ⁻¹ n → n-Tr A n) → n-Tr A n" class="InductiveConstructor">hub</a> <a id="12699" href="SHT.Base.html#12322" class="Bound">r</a><a id="12700" class="Symbol">))</a> <a id="12703" href="SHT.Base.html#12413" data-type="(P : n-Tr A (suc n) → Type ℓ′)
(ptrunc : (x : n-Tr A (suc n)) → is-hlevel (P x) (suc n))
(pbase : (x : A) → P (inc x)) (r : Sⁿ n .fst → n-Tr A (1 + n))
(w : (x : Sⁿ n .fst) → P (r x)) →
Sⁿ⁻¹ (1 + n) → P (hub r)" class="Function">circle</a> <a id="12710" class="Symbol">.</a><a id="12711" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="12715" href="SHT.Base.html#12638" class="Bound">x</a>

  <a id="12720" href="SHT.Base.html#12720" data-type="(P : n-Tr A (suc n) → Type ℓ′) →
((x : n-Tr A (suc n)) → is-hlevel (P x) (suc n)) →
((x : A) → P (inc x)) → (x : n-Tr A (suc n)) → P x" class="Function">go</a> <a id="12723" class="Symbol">:</a> <a id="12725" class="Symbol">∀</a> <a id="12727" href="SHT.Base.html#12727" class="Bound">x</a> <a id="12729" class="Symbol">→</a> <a id="12731" href="SHT.Base.html#12284" class="Bound">P</a> <a id="12733" href="SHT.Base.html#12727" class="Bound">x</a>
  <a id="12737" href="SHT.Base.html#12720" data-type="(P : n-Tr A (suc n) → Type ℓ′) →
((x : n-Tr A (suc n)) → is-hlevel (P x) (suc n)) →
((x : A) → P (inc x)) → (x : n-Tr A (suc n)) → P x" class="Function">go</a> <a id="12740" class="Symbol">(</a><a id="12741" href="SHT.Base.html#11634" data-type="A → n-Tr A n" class="InductiveConstructor">inc</a> <a id="12745" href="SHT.Base.html#12745" class="Bound">x</a><a id="12746" class="Symbol">)</a>        <a id="12755" class="Symbol">=</a> <a id="12757" href="SHT.Base.html#12293" class="Bound">pbase</a> <a id="12763" href="SHT.Base.html#12745" class="Bound">x</a>
  <a id="12767" href="SHT.Base.html#12720" data-type="(P : n-Tr A (suc n) → Type ℓ′) →
((x : n-Tr A (suc n)) → is-hlevel (P x) (suc n)) →
((x : A) → P (inc x)) → (x : n-Tr A (suc n)) → P x" class="Function">go</a> <a id="12770" class="Symbol">(</a><a id="12771" href="SHT.Base.html#11658" data-type="(Sⁿ⁻¹ n → n-Tr A n) → n-Tr A n" class="InductiveConstructor">hub</a> <a id="12775" href="SHT.Base.html#12775" class="Bound">r</a><a id="12776" class="Symbol">)</a>        <a id="12785" class="Symbol">=</a> <a id="12787" href="SHT.Base.html#12498" data-type="(P : n-Tr A (suc n) → Type ℓ′)
(ptrunc : (x : n-Tr A (suc n)) → is-hlevel (P x) (suc n))
(pbase : (x : A) → P (inc x)) (r : Sⁿ n .fst → n-Tr A (1 + n))
(w : (x : Sⁿ n .fst) → P (r x)) →
P (hub r)" class="Function">hub′</a> <a id="12792" href="SHT.Base.html#12775" class="Bound">r</a> <a id="12794" class="Symbol">(λ</a> <a id="12797" href="SHT.Base.html#12797" class="Bound">x</a> <a id="12799" class="Symbol">→</a> <a id="12801" href="SHT.Base.html#12720" data-type="(P : n-Tr A (suc n) → Type ℓ′) →
((x : n-Tr A (suc n)) → is-hlevel (P x) (suc n)) →
((x : A) → P (inc x)) → (x : n-Tr A (suc n)) → P x" class="Function">go</a> <a id="12804" class="Symbol">(</a><a id="12805" href="SHT.Base.html#12775" class="Bound">r</a> <a id="12807" href="SHT.Base.html#12797" class="Bound">x</a><a id="12808" class="Symbol">))</a>
  <a id="12813" href="SHT.Base.html#12720" data-type="(P : n-Tr A (suc n) → Type ℓ′) →
((x : n-Tr A (suc n)) → is-hlevel (P x) (suc n)) →
((x : A) → P (inc x)) → (x : n-Tr A (suc n)) → P x" class="Function">go</a> <a id="12816" class="Symbol">(</a><a id="12817" href="SHT.Base.html#11704" data-type="(r : Sⁿ⁻¹ n → n-Tr A n) (x : Sⁿ⁻¹ n) → r x ≡ hub r" class="InductiveConstructor">spokes</a> <a id="12824" href="SHT.Base.html#12824" class="Bound">r</a> <a id="12826" href="SHT.Base.html#12826" class="Bound">x</a> <a id="12828" href="SHT.Base.html#12828" class="Bound">i</a><a id="12829" class="Symbol">)</a> <a id="12831" class="Symbol">=</a> <a id="12833" href="SHT.Base.html#12566" data-type="(P : n-Tr A (suc n) → Type ℓ′)
(ptrunc : (x : n-Tr A (suc n)) → is-hlevel (P x) (suc n))
(pbase : (x : A) → P (inc x)) (r : Sⁿ n .fst → n-Tr A (1 + n))
(w : (x : Sⁿ n .fst) → P (r x)) (x : Sⁿ⁻¹ (suc n)) →
PathP (λ i → P (spokes r x i)) (w x) (hub′ P ptrunc pbase r w)" class="Function">spokes′</a> <a id="12841" href="SHT.Base.html#12824" class="Bound">r</a> <a id="12843" class="Symbol">(λ</a> <a id="12846" href="SHT.Base.html#12846" class="Bound">x</a> <a id="12848" class="Symbol">→</a> <a id="12850" href="SHT.Base.html#12720" data-type="(P : n-Tr A (suc n) → Type ℓ′) →
((x : n-Tr A (suc n)) → is-hlevel (P x) (suc n)) →
((x : A) → P (inc x)) → (x : n-Tr A (suc n)) → P x" class="Function">go</a> <a id="12853" class="Symbol">(</a><a id="12854" href="SHT.Base.html#12824" class="Bound">r</a> <a id="12856" href="SHT.Base.html#12846" class="Bound">x</a><a id="12857" class="Symbol">))</a> <a id="12860" href="SHT.Base.html#12826" class="Bound">x</a> <a id="12862" href="SHT.Base.html#12828" class="Bound">i</a>
</pre>
<p>As a simpler case of
<span class="Agda"><a href="SHT.Base.html#12115" class="Function">n-Tr-elim</a></span>,
we have the recursion principle, where the type we are eliminating into
is constant.</p>
<pre class="Agda"><a id="n-Tr-rec"></a><a id="13004" href="SHT.Base.html#13004" data-type="is-hlevel B₁ (suc n) → (A → B₁) → n-Tr A (suc n) → B₁" class="Function">n-Tr-rec</a>
  <a id="13015" class="Symbol">:</a> <a id="13017" class="Symbol">∀</a> <a id="13019" class="Symbol">{</a><a id="13020" href="SHT.Base.html#13020" class="Bound">ℓ</a> <a id="13022" href="SHT.Base.html#13022" class="Bound">ℓ′</a><a id="13024" class="Symbol">}</a> <a id="13026" class="Symbol">{</a><a id="13027" href="SHT.Base.html#13027" class="Bound">A</a> <a id="13029" class="Symbol">:</a> <a id="13031" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="13036" href="SHT.Base.html#13020" class="Bound">ℓ</a><a id="13037" class="Symbol">}</a> <a id="13039" class="Symbol">{</a><a id="13040" href="SHT.Base.html#13040" class="Bound">B</a> <a id="13042" class="Symbol">:</a> <a id="13044" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="13049" href="SHT.Base.html#13022" class="Bound">ℓ′</a><a id="13051" class="Symbol">}</a> <a id="13053" class="Symbol">{</a><a id="13054" href="SHT.Base.html#13054" class="Bound">n</a><a id="13055" class="Symbol">}</a>
  <a id="13059" class="Symbol">→</a> <a id="13061" href="1Lab.HLevel.html#2813" data-type="Type ℓ → Nat → Type ℓ" class="Function">is-hlevel</a> <a id="13071" href="SHT.Base.html#13040" class="Bound">B</a> <a id="13073" class="Symbol">(</a><a id="13074" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="13078" href="SHT.Base.html#13054" class="Bound">n</a><a id="13079" class="Symbol">)</a> <a id="13081" class="Symbol">→</a> <a id="13083" class="Symbol">(</a><a id="13084" href="SHT.Base.html#13027" class="Bound">A</a> <a id="13086" class="Symbol">→</a> <a id="13088" href="SHT.Base.html#13040" class="Bound">B</a><a id="13089" class="Symbol">)</a> <a id="13091" class="Symbol">→</a> <a id="13093" href="SHT.Base.html#11593" data-type="(A : Type ℓ) → Nat → Type ℓ" class="Datatype">n-Tr</a> <a id="13098" href="SHT.Base.html#13027" class="Bound">A</a> <a id="13100" class="Symbol">(</a><a id="13101" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="13105" href="SHT.Base.html#13054" class="Bound">n</a><a id="13106" class="Symbol">)</a> <a id="13108" class="Symbol">→</a> <a id="13110" href="SHT.Base.html#13040" class="Bound">B</a>
<a id="13112" href="SHT.Base.html#13004" data-type="is-hlevel B₁ (suc n) → (A → B₁) → n-Tr A (suc n) → B₁" class="Function">n-Tr-rec</a> <a id="13121" href="SHT.Base.html#13121" class="Bound">hl</a> <a id="13124" class="Symbol">=</a> <a id="13126" href="SHT.Base.html#12115" data-type="(P : n-Tr A (suc n) → Type ℓ′) →
((x : n-Tr A (suc n)) → is-hlevel (P x) (suc n)) →
((x : A) → P (inc x)) → (x : n-Tr A (suc n)) → P x" class="Function">n-Tr-elim</a> <a id="13136" class="Symbol">(λ</a> <a id="13139" href="SHT.Base.html#13139" class="Bound">_</a> <a id="13141" class="Symbol">→</a> <a id="13143" class="Symbol">_)</a> <a id="13146" class="Symbol">(λ</a> <a id="13149" href="SHT.Base.html#13149" class="Bound">_</a> <a id="13151" class="Symbol">→</a> <a id="13153" href="SHT.Base.html#13121" class="Bound">hl</a><a id="13155" class="Symbol">)</a>
</pre>
<p>An initial application of the induction principle for
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>-truncation</span>
of
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>
is characterising its path spaces, at least for the inclusions of points
from
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>.</span>
Identifications between (the images of) points in
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>
in the
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>-truncation</span>
are equivalently
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>-truncated</span>
identifications in
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>:</span></p>
<pre class="Agda"><a id="n-Tr-path-equiv"></a><a id="13465" href="SHT.Base.html#13465" data-type="Path (n-Tr A (2 + n)) (inc x) (inc y) ≃ n-Tr (x ≡ y) (suc n)" class="Function">n-Tr-path-equiv</a>
  <a id="13483" class="Symbol">:</a> <a id="13485" class="Symbol">∀</a> <a id="13487" class="Symbol">{</a><a id="13488" href="SHT.Base.html#13488" class="Bound">ℓ</a><a id="13489" class="Symbol">}</a> <a id="13491" class="Symbol">{</a><a id="13492" href="SHT.Base.html#13492" class="Bound">A</a> <a id="13494" class="Symbol">:</a> <a id="13496" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="13501" href="SHT.Base.html#13488" class="Bound">ℓ</a><a id="13502" class="Symbol">}</a> <a id="13504" class="Symbol">{</a><a id="13505" href="SHT.Base.html#13505" class="Bound">n</a><a id="13506" class="Symbol">}</a> <a id="13508" class="Symbol">{</a><a id="13509" href="SHT.Base.html#13509" class="Bound">x</a> <a id="13511" href="SHT.Base.html#13511" class="Bound">y</a> <a id="13513" class="Symbol">:</a> <a id="13515" href="SHT.Base.html#13492" class="Bound">A</a><a id="13516" class="Symbol">}</a>
  <a id="13520" class="Symbol">→</a> <a id="13522" href="1Lab.Path.html#2466" data-type="(A : Type ℓ) → A → A → Type ℓ" class="Function">Path</a> <a id="13527" class="Symbol">(</a><a id="13528" href="SHT.Base.html#11593" data-type="(A : Type ℓ) → Nat → Type ℓ" class="Datatype">n-Tr</a> <a id="13533" href="SHT.Base.html#13492" class="Bound">A</a> <a id="13535" class="Symbol">(</a><a id="13536" class="Number">2</a> <a id="13538" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="13540" href="SHT.Base.html#13505" class="Bound">n</a><a id="13541" class="Symbol">))</a> <a id="13544" class="Symbol">(</a><a id="13545" class="InductiveConstructor">inc</a> <a id="13549" href="SHT.Base.html#13509" class="Bound">x</a><a id="13550" class="Symbol">)</a> <a id="13552" class="Symbol">(</a><a id="13553" class="InductiveConstructor">inc</a> <a id="13557" href="SHT.Base.html#13511" class="Bound">y</a><a id="13558" class="Symbol">)</a> <a id="13560" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="13562" href="SHT.Base.html#11593" data-type="(A : Type ℓ) → Nat → Type ℓ" class="Datatype">n-Tr</a> <a id="13567" class="Symbol">(</a><a id="13568" href="SHT.Base.html#13509" class="Bound">x</a> <a id="13570" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="13572" href="SHT.Base.html#13511" class="Bound">y</a><a id="13573" class="Symbol">)</a> <a id="13575" class="Symbol">(</a><a id="13576" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="13580" href="SHT.Base.html#13505" class="Bound">n</a><a id="13581" class="Symbol">)</a>
<a id="13583" href="SHT.Base.html#13465" data-type="Path (n-Tr A (2 + n)) (inc x) (inc y) ≃ n-Tr (x ≡ y) (suc n)" class="Function">n-Tr-path-equiv</a> <a id="13599" class="Symbol">{</a><a id="13600" class="Argument">A</a> <a id="13602" class="Symbol">=</a> <a id="13604" href="SHT.Base.html#13604" class="Bound">A</a><a id="13605" class="Symbol">}</a> <a id="13607" class="Symbol">{</a><a id="13608" href="SHT.Base.html#13608" class="Bound">n</a><a id="13609" class="Symbol">}</a> <a id="13611" class="Symbol">{</a><a id="13612" class="Argument">x</a> <a id="13614" class="Symbol">=</a> <a id="13616" href="SHT.Base.html#13616" class="Bound">x</a><a id="13617" class="Symbol">}</a> <a id="13619" class="Symbol">{</a><a id="13620" href="SHT.Base.html#13620" class="Bound">y</a><a id="13621" class="Symbol">}</a> <a id="13623" class="Symbol">=</a> <a id="13625" href="1Lab.Equiv.html#20503" data-type="Iso A B₁ → A ≃ B₁" class="Function">Iso→Equiv</a> <a id="13635" href="SHT.Base.html#15464" data-type="Iso (inc x ≡ inc y) (n-Tr (x ≡ y) (suc n))" class="Function">isom</a> <a id="13640" class="Keyword">where</a>
</pre>
<p>The proof is an application of the encode-decode method. We would
like to characterise the space</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">c</mi></mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><msub><mo>≡</mo><mrow><mi mathvariant="normal">∥</mi><mi>A</mi><msub><mi mathvariant="normal">∥</mi><mrow><mn>2</mn><mo>+</mo><mi>n</mi></mrow></msub></mrow></msub><mi>y</mi><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">
\id{inc}(x) \equiv_{\|A\|_{2+n}} y,
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3552em;"></span><span class="mord"><span class="mord mathrm">inc</span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel">≡</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∥</span><span class="mord mathnormal mtight">A</span><span class="mord mtight"><span class="mord mtight">∥</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2025em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span></span></span></span></span></p>
<p>so we will, for every
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">x : A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>,</span>
define a type family
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">e</mi></mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>:</mo><mi mathvariant="normal">∥</mi><mi>A</mi><msub><mi mathvariant="normal">∥</mi><mrow><mn>2</mn><mo>+</mo><mi>n</mi></mrow></msub><mo>→</mo><mrow><mi mathvariant="normal">T</mi><mi mathvariant="normal">y</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">e</mi></mrow></mrow><annotation encoding="application/x-tex">\mathrm{code}(x) : \|A\|_{2+n} \to \ty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">code</span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∥</span><span class="mord mathnormal">A</span><span class="mord"><span class="mord">∥</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathrm">Type</span></span></span></span></span>,</span>
where the fibre of
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">e</mi></mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{code}(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">code</span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>
over
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">c</mi></mrow><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\id{inc}(y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">inc</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>
should be
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∥</mi><mi>x</mi><mo>≡</mo><mi>y</mi><msub><mi mathvariant="normal">∥</mi><mrow><mn>1</mn><mo>+</mo><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\|x \equiv y\|_{1+n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∥</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord"><span class="mord">∥</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span>.</span>
However, induction principle for
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∥</mi><mi>A</mi><msub><mi mathvariant="normal">∥</mi><mrow><mn>2</mn><mo>+</mo><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\|A\|_{2+n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∥</span><span class="mord mathnormal">A</span><span class="mord"><span class="mord">∥</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span>
only allows us to map into
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(2+n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>-types,</span>
while
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">T</mi><mi mathvariant="normal">y</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">e</mi></mrow><annotation encoding="application/x-tex">\ty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathrm">Type</span></span></span></span></span>
itself is not an
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>-type</span>
for any
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>.</span>
We salvage our definition by instead mapping into
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo><mtext>-</mtext><mrow><mi mathvariant="normal">T</mi><mi mathvariant="normal">y</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">e</mi></mrow></mrow><annotation encoding="application/x-tex">(1+n)\text{-}\ty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mord text"><span class="mord">-</span></span><span class="mord"><span class="mord mathrm">Type</span></span></span></span></span>,</span>
which <em>is</em> a
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(2+n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>-type.</span></p>
<pre class="Agda">  <a id="14225" href="SHT.Base.html#14225" data-type="(x : A) (y′ : n-Tr A (2 + n)) → n-Type ℓ (suc n)" class="Function">code</a> <a id="14230" class="Symbol">:</a> <a id="14232" class="Symbol">(</a><a id="14233" href="SHT.Base.html#14233" class="Bound">x</a> <a id="14235" class="Symbol">:</a> <a id="14237" href="SHT.Base.html#13604" class="Bound">A</a><a id="14238" class="Symbol">)</a> <a id="14240" class="Symbol">(</a><a id="14241" href="SHT.Base.html#14241" class="Bound">y′</a> <a id="14244" class="Symbol">:</a> <a id="14246" href="SHT.Base.html#11593" data-type="(A : Type ℓ) → Nat → Type ℓ" class="Datatype">n-Tr</a> <a id="14251" href="SHT.Base.html#13604" class="Bound">A</a> <a id="14253" class="Symbol">(</a><a id="14254" class="Number">2</a> <a id="14256" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="14258" href="SHT.Base.html#13608" class="Bound">n</a><a id="14259" class="Symbol">))</a> <a id="14262" class="Symbol">→</a> <a id="14264" href="1Lab.HLevel.Universe.html#3129" data-type="(ℓ : Level) (n : Nat) → Type (lsuc ℓ)" class="Record">n-Type</a> <a id="14271" class="Symbol">_</a> <a id="14273" class="Symbol">(</a><a id="14274" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="14278" href="SHT.Base.html#13608" class="Bound">n</a><a id="14279" class="Symbol">)</a>
  <a id="14283" href="SHT.Base.html#14225" data-type="(x : A) (y′ : n-Tr A (2 + n)) → n-Type ℓ (suc n)" class="Function">code</a> <a id="14288" href="SHT.Base.html#14288" class="Bound">x</a> <a id="14290" class="Symbol">=</a>
    <a id="14296" href="SHT.Base.html#12115" data-type="(P : n-Tr A (suc n) → Type ℓ′) →
((x : n-Tr A (suc n)) → is-hlevel (P x) (suc n)) →
((x : A) → P (inc x)) → (x : n-Tr A (suc n)) → P x" class="Function">n-Tr-elim</a>
      <a id="14312" class="Symbol">(λ</a> <a id="14315" href="SHT.Base.html#14315" class="Bound">y′</a> <a id="14318" class="Symbol">→</a> <a id="14320" href="1Lab.HLevel.Universe.html#3129" data-type="(ℓ : Level) (n : Nat) → Type (lsuc ℓ)" class="Record">n-Type</a> <a id="14327" class="Symbol">_</a> <a id="14329" class="Symbol">(</a><a id="14330" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="14334" href="SHT.Base.html#13608" class="Bound">n</a><a id="14335" class="Symbol">))</a>
      <a id="14344" class="Symbol">(λ</a> <a id="14347" href="SHT.Base.html#14347" class="Bound">y′</a> <a id="14350" class="Symbol">→</a> <a id="14352" href="1Lab.HLevel.Universe.html#5051" data-type="(n : Nat) → is-hlevel (n-Type ℓ n) (suc n)" class="Function">n-Type-is-hlevel</a> <a id="14369" class="Symbol">(</a><a id="14370" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="14374" href="SHT.Base.html#13608" class="Bound">n</a><a id="14375" class="Symbol">))</a>
      <a id="14384" class="Symbol">(λ</a> <a id="14387" href="SHT.Base.html#14387" class="Bound">y′</a> <a id="14390" class="Symbol">→</a> <a id="14392" href="SHT.Base.html#11593" data-type="(A : Type ℓ) → Nat → Type ℓ" class="Datatype">n-Tr</a> <a id="14397" class="Symbol">(</a><a id="14398" href="1Lab.Path.html#2466" data-type="(A : Type ℓ) → A → A → Type ℓ" class="Function">Path</a> <a id="14403" href="SHT.Base.html#13604" class="Bound">A</a> <a id="14405" href="SHT.Base.html#14288" class="Bound">x</a> <a id="14407" href="SHT.Base.html#14387" class="Bound">y′</a><a id="14409" class="Symbol">)</a> <a id="14411" class="Symbol">(</a><a id="14412" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="14416" href="SHT.Base.html#13608" class="Bound">n</a><a id="14417" class="Symbol">)</a> <a id="14419" href="1Lab.HLevel.Universe.html#3194" data-type="(∣_∣₁ : Type ℓ) (is-tr₁ : is-hlevel ∣_∣₁ n) → n-Type ℓ n" class="InductiveConstructor Operator">,</a> <a id="14421" href="SHT.Base.html#11964" data-type="(n : Nat) → is-hlevel (n-Tr A (suc n)) (suc n)" class="Function">n-Tr-is-hlevel</a> <a id="14436" href="SHT.Base.html#13608" class="Bound">n</a><a id="14437" class="Symbol">)</a>
</pre>
<p>The rest of the proof boils down to applications of <code class="sourceCode agda" id="J">path induction</code> and the induction
principle for
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∥</mi><mi>A</mi><msub><mi mathvariant="normal">∥</mi><mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\|A\|_{n+2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∥</span><span class="mord mathnormal">A</span><span class="mord"><span class="mord">∥</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span>.</span></p>
<pre class="Agda">  <a id="14583" href="SHT.Base.html#14583" data-type="(x : A) (y : n-Tr A (2 + n)) → inc x ≡ y → ∣ code x y ∣" class="Function">encode′</a> <a id="14591" class="Symbol">:</a> <a id="14593" class="Symbol">∀</a> <a id="14595" href="SHT.Base.html#14595" class="Bound">x</a> <a id="14597" href="SHT.Base.html#14597" class="Bound">y</a> <a id="14599" class="Symbol">→</a> <a id="14601" href="SHT.Base.html#11634" data-type="A → n-Tr A n" class="InductiveConstructor">inc</a> <a id="14605" href="SHT.Base.html#14595" class="Bound">x</a> <a id="14607" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="14609" href="SHT.Base.html#14597" class="Bound">y</a> <a id="14611" class="Symbol">→</a> <a id="14613" href="1Lab.HLevel.Universe.html#3210" data-type="n-Type ℓ n → Type ℓ" class="Field Operator">∣</a> <a id="14615" href="SHT.Base.html#14225" data-type="(x : A) (y′ : n-Tr A (2 + n)) → n-Type ℓ (suc n)" class="Function">code</a> <a id="14620" href="SHT.Base.html#14595" class="Bound">x</a> <a id="14622" href="SHT.Base.html#14597" class="Bound">y</a> <a id="14624" href="1Lab.HLevel.Universe.html#3210" data-type="n-Type ℓ n → Type ℓ" class="Field Operator">∣</a>
  <a id="14628" href="SHT.Base.html#14583" data-type="(x : A) (y : n-Tr A (2 + n)) → inc x ≡ y → ∣ code x y ∣" class="Function">encode′</a> <a id="14636" href="SHT.Base.html#14636" class="Bound">x</a> <a id="14638" class="Symbol">_</a> <a id="14640" class="Symbol">=</a> <a id="14642" href="1Lab.Path.html#19544" data-type="(P : (y : A) → x ≡ y → Type ℓ₂) → P x refl → (p : x ≡ y) → P y p" class="Function">J</a> <a id="14644" class="Symbol">(λ</a> <a id="14647" href="SHT.Base.html#14647" class="Bound">y</a> <a id="14649" href="SHT.Base.html#14649" class="Bound">_</a> <a id="14651" class="Symbol">→</a> <a id="14653" href="1Lab.HLevel.Universe.html#3210" data-type="n-Type ℓ n → Type ℓ" class="Field Operator">∣</a> <a id="14655" href="SHT.Base.html#14225" data-type="(x : A) (y′ : n-Tr A (2 + n)) → n-Type ℓ (suc n)" class="Function">code</a> <a id="14660" href="SHT.Base.html#14636" class="Bound">x</a> <a id="14662" href="SHT.Base.html#14647" class="Bound">y</a> <a id="14664" href="1Lab.HLevel.Universe.html#3210" data-type="n-Type ℓ n → Type ℓ" class="Field Operator">∣</a><a id="14665" class="Symbol">)</a> <a id="14667" class="Symbol">(</a><a id="14668" href="SHT.Base.html#11634" data-type="A → n-Tr A n" class="InductiveConstructor">inc</a> <a id="14672" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a><a id="14676" class="Symbol">)</a>

  <a id="14681" href="SHT.Base.html#14681" data-type="(x : A) (y : n-Tr A (2 + n)) → ∣ code x y ∣ → inc x ≡ y" class="Function">decode′</a> <a id="14689" class="Symbol">:</a> <a id="14691" class="Symbol">∀</a> <a id="14693" href="SHT.Base.html#14693" class="Bound">x</a> <a id="14695" href="SHT.Base.html#14695" class="Bound">y</a> <a id="14697" class="Symbol">→</a> <a id="14699" href="1Lab.HLevel.Universe.html#3210" data-type="n-Type ℓ n → Type ℓ" class="Field Operator">∣</a> <a id="14701" href="SHT.Base.html#14225" data-type="(x : A) (y′ : n-Tr A (2 + n)) → n-Type ℓ (suc n)" class="Function">code</a> <a id="14706" href="SHT.Base.html#14693" class="Bound">x</a> <a id="14708" href="SHT.Base.html#14695" class="Bound">y</a> <a id="14710" href="1Lab.HLevel.Universe.html#3210" data-type="n-Type ℓ n → Type ℓ" class="Field Operator">∣</a> <a id="14712" class="Symbol">→</a> <a id="14714" href="SHT.Base.html#11634" data-type="A → n-Tr A n" class="InductiveConstructor">inc</a> <a id="14718" href="SHT.Base.html#14693" class="Bound">x</a> <a id="14720" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="14722" href="SHT.Base.html#14695" class="Bound">y</a>
  <a id="14726" href="SHT.Base.html#14681" data-type="(x : A) (y : n-Tr A (2 + n)) → ∣ code x y ∣ → inc x ≡ y" class="Function">decode′</a> <a id="14734" href="SHT.Base.html#14734" class="Bound">x</a> <a id="14736" class="Symbol">=</a>
    <a id="14742" href="SHT.Base.html#12115" data-type="(P : n-Tr A (suc n) → Type ℓ′) →
((x : n-Tr A (suc n)) → is-hlevel (P x) (suc n)) →
((x : A) → P (inc x)) → (x : n-Tr A (suc n)) → P x" class="Function">n-Tr-elim</a> <a id="14752" class="Symbol">_</a>
      <a id="14760" class="Symbol">(λ</a> <a id="14763" href="SHT.Base.html#14763" class="Bound">x</a> <a id="14765" class="Symbol">→</a> <a id="14767" href="1Lab.HLevel.Retracts.html#4507" data-type="(n : Nat) →
((x : A) → is-hlevel (B₁ x) n) → is-hlevel ((x : A) → B₁ x) n" class="Function">Π-is-hlevel</a> <a id="14779" class="Symbol">(</a><a id="14780" class="Number">2</a> <a id="14782" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="14784" href="SHT.Base.html#13608" class="Bound">n</a><a id="14785" class="Symbol">)</a>
        <a id="14795" class="Symbol">(λ</a> <a id="14798" href="SHT.Base.html#14798" class="Bound">x</a> <a id="14800" class="Symbol">→</a> <a id="14802" href="1Lab.HLevel.html#9678" data-type="(n : Nat) → is-hlevel A n → is-hlevel (x ≡ y) n" class="Function">Path-is-hlevel</a> <a id="14817" class="Symbol">(</a><a id="14818" class="Number">2</a> <a id="14820" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="14822" href="SHT.Base.html#13608" class="Bound">n</a><a id="14823" class="Symbol">)</a> <a id="14825" class="Symbol">(</a><a id="14826" href="SHT.Base.html#11964" data-type="(n : Nat) → is-hlevel (n-Tr A (suc n)) (suc n)" class="Function">n-Tr-is-hlevel</a> <a id="14841" class="Symbol">(</a><a id="14842" class="Number">1</a> <a id="14844" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="14846" href="SHT.Base.html#13608" class="Bound">n</a><a id="14847" class="Symbol">))))</a>
      <a id="14858" class="Symbol">λ</a> <a id="14860" href="SHT.Base.html#14860" class="Bound">x</a> <a id="14862" class="Symbol">→</a> <a id="14864" href="SHT.Base.html#13004" data-type="is-hlevel B₁ (suc n) → (A → B₁) → n-Tr A (suc n) → B₁" class="Function">n-Tr-rec</a> <a id="14873" class="Symbol">(</a><a id="14874" href="1Lab.HLevel.html#10279" data-type="(n : Nat) → is-hlevel A (suc n) → (x y : A) → is-hlevel (x ≡ y) n" class="Function">Path-is-hlevel&#39;</a> <a id="14890" class="Symbol">(</a><a id="14891" class="Number">1</a> <a id="14893" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="14895" href="SHT.Base.html#13608" class="Bound">n</a><a id="14896" class="Symbol">)</a> <a id="14898" class="Symbol">(</a><a id="14899" href="SHT.Base.html#11964" data-type="(n : Nat) → is-hlevel (n-Tr A (suc n)) (suc n)" class="Function">n-Tr-is-hlevel</a> <a id="14914" class="Symbol">(</a><a id="14915" class="Number">1</a> <a id="14917" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="14919" href="SHT.Base.html#13608" class="Bound">n</a><a id="14920" class="Symbol">))</a> <a id="14923" class="Symbol">_</a> <a id="14925" class="Symbol">_)</a>
              <a id="14942" class="Symbol">(</a><a id="14943" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="14946" href="SHT.Base.html#11634" data-type="A → n-Tr A n" class="InductiveConstructor">inc</a><a id="14949" class="Symbol">)</a>

  <a id="14954" href="SHT.Base.html#14954" data-type="(x : A) (y : n-Tr A (2 + n)) →
is-right-inverse (decode′ x y) (encode′ x y)" class="Function">rinv</a> <a id="14959" class="Symbol">:</a> <a id="14961" class="Symbol">∀</a> <a id="14963" href="SHT.Base.html#14963" class="Bound">x</a> <a id="14965" href="SHT.Base.html#14965" class="Bound">y</a> <a id="14967" class="Symbol">→</a> <a id="14969" href="1Lab.Equiv.html#5739" data-type="(B₁ → A) → (A → B₁) → Type B.ℓ₁" class="Function">is-right-inverse</a> <a id="14986" class="Symbol">(</a><a id="14987" href="SHT.Base.html#14681" data-type="(x : A) (y : n-Tr A (2 + n)) → ∣ code x y ∣ → inc x ≡ y" class="Function">decode′</a> <a id="14995" href="SHT.Base.html#14963" class="Bound">x</a> <a id="14997" href="SHT.Base.html#14965" class="Bound">y</a><a id="14998" class="Symbol">)</a> <a id="15000" class="Symbol">(</a><a id="15001" href="SHT.Base.html#14583" data-type="(x : A) (y : n-Tr A (2 + n)) → inc x ≡ y → ∣ code x y ∣" class="Function">encode′</a> <a id="15009" href="SHT.Base.html#14963" class="Bound">x</a> <a id="15011" href="SHT.Base.html#14965" class="Bound">y</a><a id="15012" class="Symbol">)</a>
  <a id="15016" href="SHT.Base.html#14954" data-type="(x : A) (y : n-Tr A (2 + n)) →
is-right-inverse (decode′ x y) (encode′ x y)" class="Function">rinv</a> <a id="15021" href="SHT.Base.html#15021" class="Bound">x</a> <a id="15023" class="Symbol">=</a> <a id="15025" href="SHT.Base.html#12115" data-type="(P : n-Tr A (suc n) → Type ℓ′) →
((x : n-Tr A (suc n)) → is-hlevel (P x) (suc n)) →
((x : A) → P (inc x)) → (x : n-Tr A (suc n)) → P x" class="Function">n-Tr-elim</a> <a id="15035" class="Symbol">_</a>
    <a id="15041" class="Symbol">(λ</a> <a id="15044" href="SHT.Base.html#15044" class="Bound">y</a> <a id="15046" class="Symbol">→</a> <a id="15048" href="1Lab.HLevel.Retracts.html#4507" data-type="(n : Nat) →
((x : A) → is-hlevel (B₁ x) n) → is-hlevel ((x : A) → B₁ x) n" class="Function">Π-is-hlevel</a> <a id="15060" class="Symbol">(</a><a id="15061" class="Number">2</a> <a id="15063" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="15065" href="SHT.Base.html#13608" class="Bound">n</a><a id="15066" class="Symbol">)</a>
      <a id="15074" class="Symbol">(λ</a> <a id="15077" href="SHT.Base.html#15077" class="Bound">c</a> <a id="15079" class="Symbol">→</a> <a id="15081" href="1Lab.HLevel.html#9678" data-type="(n : Nat) → is-hlevel A n → is-hlevel (x ≡ y) n" class="Function">Path-is-hlevel</a> <a id="15096" class="Symbol">(</a><a id="15097" class="Number">2</a> <a id="15099" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="15101" href="SHT.Base.html#13608" class="Bound">n</a><a id="15102" class="Symbol">)</a> <a id="15104" class="Symbol">(</a><a id="15105" href="1Lab.HLevel.html#8566" data-type="(n : Nat) → is-hlevel A n → is-hlevel A (suc n)" class="Function">is-hlevel-suc</a> <a id="15119" class="Symbol">(</a><a id="15120" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="15124" href="SHT.Base.html#13608" class="Bound">n</a><a id="15125" class="Symbol">)</a> <a id="15127" class="Symbol">(</a><a id="15128" href="SHT.Base.html#14225" data-type="(x : A) (y′ : n-Tr A (2 + n)) → n-Type ℓ (suc n)" class="Function">code</a> <a id="15133" href="SHT.Base.html#15021" class="Bound">x</a> <a id="15135" href="SHT.Base.html#15044" class="Bound">y</a> <a id="15137" class="Symbol">.</a><a id="15138" href="1Lab.HLevel.Universe.html#3229" data-type="(r : n-Type ℓ n) → is-hlevel (r .∣_∣) n" class="Field">is-tr</a><a id="15143" class="Symbol">))))</a>
    <a id="15152" class="Symbol">λ</a> <a id="15154" href="SHT.Base.html#15154" class="Bound">x</a> <a id="15156" class="Symbol">→</a> <a id="15158" href="SHT.Base.html#12115" data-type="(P : n-Tr A (suc n) → Type ℓ′) →
((x : n-Tr A (suc n)) → is-hlevel (P x) (suc n)) →
((x : A) → P (inc x)) → (x : n-Tr A (suc n)) → P x" class="Function">n-Tr-elim</a> <a id="15168" class="Symbol">_</a> <a id="15170" class="Symbol">(λ</a> <a id="15173" href="SHT.Base.html#15173" class="Bound">x</a> <a id="15175" class="Symbol">→</a> <a id="15177" href="1Lab.HLevel.html#9678" data-type="(n : Nat) → is-hlevel A n → is-hlevel (x ≡ y) n" class="Function">Path-is-hlevel</a> <a id="15192" class="Symbol">(</a><a id="15193" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="15197" href="SHT.Base.html#13608" class="Bound">n</a><a id="15198" class="Symbol">)</a> <a id="15200" class="Symbol">(</a><a id="15201" href="SHT.Base.html#11964" data-type="(n : Nat) → is-hlevel (n-Tr A (suc n)) (suc n)" class="Function">n-Tr-is-hlevel</a> <a id="15216" href="SHT.Base.html#13608" class="Bound">n</a><a id="15217" class="Symbol">))</a>
      <a id="15226" class="Symbol">λ</a> <a id="15228" href="SHT.Base.html#15228" class="Bound">p</a> <a id="15230" class="Symbol">→</a> <a id="15232" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="15235" href="SHT.Base.html#11634" data-type="A → n-Tr A n" class="InductiveConstructor">n-Tr.inc</a> <a id="15244" class="Symbol">(</a><a id="15245" href="1Lab.Path.html#61401" data-type="(loop₁ : x ≡ z) (adj : z ≡ y) →
subst (_≡_ x) adj loop₁ ≡ loop₁ ∙ adj" class="Function">subst-path-right</a> <a id="15262" class="Symbol">_</a> <a id="15264" class="Symbol">_</a> <a id="15266" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="15268" href="1Lab.Path.Groupoid.html#4623" data-type="(p : x ≡ y) → refl ∙ p ≡ p" class="Function">∙-id-l</a> <a id="15275" class="Symbol">_)</a>

  <a id="15281" href="SHT.Base.html#15281" data-type="(x : A) (y : n-Tr A (2 + n)) →
is-left-inverse (decode′ x y) (encode′ x y)" class="Function">linv</a> <a id="15286" class="Symbol">:</a> <a id="15288" class="Symbol">∀</a> <a id="15290" href="SHT.Base.html#15290" class="Bound">x</a> <a id="15292" href="SHT.Base.html#15292" class="Bound">y</a> <a id="15294" class="Symbol">→</a> <a id="15296" href="1Lab.Equiv.html#5649" data-type="(B₁ → A) → (A → B₁) → Type A.ℓ₁" class="Function">is-left-inverse</a> <a id="15312" class="Symbol">(</a><a id="15313" href="SHT.Base.html#14681" data-type="(x : A) (y : n-Tr A (2 + n)) → ∣ code x y ∣ → inc x ≡ y" class="Function">decode′</a> <a id="15321" href="SHT.Base.html#15290" class="Bound">x</a> <a id="15323" href="SHT.Base.html#15292" class="Bound">y</a><a id="15324" class="Symbol">)</a> <a id="15326" class="Symbol">(</a><a id="15327" href="SHT.Base.html#14583" data-type="(x : A) (y : n-Tr A (2 + n)) → inc x ≡ y → ∣ code x y ∣" class="Function">encode′</a> <a id="15335" href="SHT.Base.html#15290" class="Bound">x</a> <a id="15337" href="SHT.Base.html#15292" class="Bound">y</a><a id="15338" class="Symbol">)</a>
  <a id="15342" href="SHT.Base.html#15281" data-type="(x : A) (y : n-Tr A (2 + n)) →
is-left-inverse (decode′ x y) (encode′ x y)" class="Function">linv</a> <a id="15347" href="SHT.Base.html#15347" class="Bound">x</a> <a id="15349" class="Symbol">_</a> <a id="15351" class="Symbol">=</a> <a id="15353" href="1Lab.Path.html#19544" data-type="(P : (y : A) → x ≡ y → Type ℓ₂) → P x refl → (p : x ≡ y) → P y p" class="Function">J</a> <a id="15355" class="Symbol">(λ</a> <a id="15358" href="SHT.Base.html#15358" class="Bound">y</a> <a id="15360" href="SHT.Base.html#15360" class="Bound">p</a> <a id="15362" class="Symbol">→</a> <a id="15364" href="SHT.Base.html#14681" data-type="(x : A) (y : n-Tr A (2 + n)) → ∣ code x y ∣ → inc x ≡ y" class="Function">decode′</a> <a id="15372" href="SHT.Base.html#15347" class="Bound">x</a> <a id="15374" href="SHT.Base.html#15358" class="Bound">y</a> <a id="15376" class="Symbol">(</a><a id="15377" href="SHT.Base.html#14583" data-type="(x : A) (y : n-Tr A (2 + n)) → inc x ≡ y → ∣ code x y ∣" class="Function">encode′</a> <a id="15385" href="SHT.Base.html#15347" class="Bound">x</a> <a id="15387" href="SHT.Base.html#15358" class="Bound">y</a> <a id="15389" href="SHT.Base.html#15360" class="Bound">p</a><a id="15390" class="Symbol">)</a> <a id="15392" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="15394" href="SHT.Base.html#15360" class="Bound">p</a><a id="15395" class="Symbol">)</a>
    <a id="15401" class="Symbol">(</a><a id="15402" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="15405" class="Symbol">(</a><a id="15406" href="SHT.Base.html#14681" data-type="(x : A) (y : n-Tr A (2 + n)) → ∣ code x y ∣ → inc x ≡ y" class="Function">decode′</a> <a id="15414" href="SHT.Base.html#15347" class="Bound">x</a> <a id="15416" class="Symbol">(</a><a id="15417" href="SHT.Base.html#11634" data-type="A → n-Tr A n" class="InductiveConstructor">inc</a> <a id="15421" href="SHT.Base.html#15347" class="Bound">x</a><a id="15422" class="Symbol">))</a> <a id="15425" class="Symbol">(</a><a id="15426" href="1Lab.Path.html#13454" data-type="(x : A) → transport (λ i → A) x ≡ x" class="Function">transport-refl</a> <a id="15441" class="Symbol">(</a><a id="15442" href="SHT.Base.html#11634" data-type="A → n-Tr A n" class="InductiveConstructor">inc</a> <a id="15446" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a><a id="15450" class="Symbol">))</a> <a id="15453" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="15455" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a><a id="15459" class="Symbol">)</a>

  <a id="15464" href="SHT.Base.html#15464" data-type="Iso (inc x ≡ inc y) (n-Tr (x ≡ y) (suc n))" class="Function">isom</a> <a id="15469" class="Symbol">:</a> <a id="15471" href="1Lab.Equiv.html#6298" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function">Iso</a> <a id="15475" class="Symbol">(</a><a id="15476" href="SHT.Base.html#11634" data-type="A → n-Tr A n" class="InductiveConstructor">inc</a> <a id="15480" href="SHT.Base.html#13616" class="Bound">x</a> <a id="15482" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="15484" href="SHT.Base.html#11634" data-type="A → n-Tr A n" class="InductiveConstructor">inc</a> <a id="15488" href="SHT.Base.html#13620" class="Bound">y</a><a id="15489" class="Symbol">)</a> <a id="15491" class="Symbol">(</a><a id="15492" href="SHT.Base.html#11593" data-type="(A : Type ℓ) → Nat → Type ℓ" class="Datatype">n-Tr</a> <a id="15497" class="Symbol">(</a><a id="15498" href="SHT.Base.html#13616" class="Bound">x</a> <a id="15500" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="15502" href="SHT.Base.html#13620" class="Bound">y</a><a id="15503" class="Symbol">)</a> <a id="15505" class="Symbol">(</a><a id="15506" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="15510" href="SHT.Base.html#13608" class="Bound">n</a><a id="15511" class="Symbol">))</a>
  <a id="15516" href="SHT.Base.html#15464" data-type="Iso (inc x ≡ inc y) (n-Tr (x ≡ y) (suc n))" class="Function">isom</a> <a id="15521" class="Symbol">=</a> <a id="15523" href="SHT.Base.html#14583" data-type="(x : A) (y : n-Tr A (2 + n)) → inc x ≡ y → ∣ code x y ∣" class="Function">encode′</a> <a id="15531" class="Symbol">_</a> <a id="15533" class="Symbol">(</a><a id="15534" href="SHT.Base.html#11634" data-type="A → n-Tr A n" class="InductiveConstructor">inc</a> <a id="15538" class="Symbol">_)</a>
       <a id="15548" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="15550" href="1Lab.Equiv.html#6116" data-type="(inv₁ : B₁ → A) (rinv₁ : is-right-inverse inv₁ f)
(linv₁ : is-left-inverse inv₁ f) →
is-iso f" class="InductiveConstructor">iso</a> <a id="15554" class="Symbol">(</a><a id="15555" href="SHT.Base.html#14681" data-type="(x : A) (y : n-Tr A (2 + n)) → ∣ code x y ∣ → inc x ≡ y" class="Function">decode′</a> <a id="15563" class="Symbol">_</a> <a id="15565" class="Symbol">(</a><a id="15566" href="SHT.Base.html#11634" data-type="A → n-Tr A n" class="InductiveConstructor">inc</a> <a id="15570" class="Symbol">_))</a> <a id="15574" class="Symbol">(</a><a id="15575" href="SHT.Base.html#14954" data-type="(x : A) (y : n-Tr A (2 + n)) →
is-right-inverse (decode′ x y) (encode′ x y)" class="Function">rinv</a> <a id="15580" class="Symbol">_</a> <a id="15582" class="Symbol">(</a><a id="15583" href="SHT.Base.html#11634" data-type="A → n-Tr A n" class="InductiveConstructor">inc</a> <a id="15587" class="Symbol">_))</a> <a id="15591" class="Symbol">(</a><a id="15592" href="SHT.Base.html#15281" data-type="(x : A) (y : n-Tr A (2 + n)) →
is-left-inverse (decode′ x y) (encode′ x y)" class="Function">linv</a> <a id="15597" class="Symbol">_</a> <a id="15599" class="Symbol">(</a><a id="15600" href="SHT.Base.html#11634" data-type="A → n-Tr A n" class="InductiveConstructor">inc</a> <a id="15604" class="Symbol">_))</a>
</pre>
<section class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>Any map
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><msup><mi>S</mi><mi>n</mi></msup><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">f : S^n \to A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>
can be made basepoint-preserving by letting
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>
be based at
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>.</span><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
  </article>
</div>
</main>
</body>
</html>
