<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="keywords" content="Agda,categories,topos" />

  <title>Data.Int - 1Lab</title>

  <link rel="stylesheet" href="/css/default.css" />
  <link rel="stylesheet" href="/css/katex.min.css" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Data.Int - 1Lab" />
  <meta name="twitter:image" content="https://1lab.dev/static/cube-128x.png" />

  <meta name="og:title" content="Data.Int - 1Lab" />
  <meta name="og:image" content="https://1lab.dev/static/cube-128x.png" />
  <meta name="og:site-name" content="1Lab" />
  <meta name="og:type" content="website" />

    <meta name="og:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="twitter:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  
  <script defer src="/main.js"></script>

  <noscript>
    <style>
      body span.reasoning-step .as-written {
        display: inline;
      }

      body span.reasoning-step .alternate {
        display: none;
      }
    </style>
  </noscript>

  <!-- Google font embeds -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;0,800;1,400;1,500;1,600;1,700;1,800&amp;family=Inria+Sans:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&amp;display=swap" rel="stylesheet">
</head>

<body class="text-page">
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <!-- Table of contents (only if the page has a table of contents) -->
    <aside id="toc">
    <div id="toc-container" style="min-width: 10em; font-size: 15pt;">
      <!-- Title for the page -->
      <h3 class="Agda" style="margin-top: 0; margin-bottom: 0; white-space: pre;">
                <a class="Module">Data.Int</a>
              </h3>

      <!-- Cube logo -->
      <a id="logo" href="/">
        <img alt="1Lab" src="/static/cube-72x.png" style="display: block; margin-bottom: 1em; margin: auto;" width="32px" height="32px" />
      </a>

      <!-- Actual table of contents (separated from the rest by
      horizontal rules) -->
      <hr />
      <ul>
      <li><a href="#integers"><a href="#integers" class="header-link">Integers<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#canonical-representatives"><a href="#canonical-representatives" class="header-link">Canonical
      representatives<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      <li><a href="#recursion"><a href="#recursion" class="header-link">Recursion<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#algebra"><a href="#algebra" class="header-link">Algebra<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#successors"><a href="#successors" class="header-link">Successors<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#addition"><a href="#addition" class="header-link">Addition<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#inverses"><a href="#inverses" class="header-link">Inverses<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#multiplication"><a href="#multiplication" class="header-link">Multiplication<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      </ul>
      <hr />

      <!-- Sidebar controls -->
      <div style="display: flex; gap: 0.25em; flex-flow: row wrap;">
        <!-- Sidebar equations control -->
        <span class="equations" style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-eqns" type="checkbox" class="equations" id="sidebar-eqns">
          <label for="sidebar-eqns">Equations</label>
        </span>

        <!-- Sidebar fonts control -->
        <span style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-font" type="checkbox" id="toggle-fonts">
          <label for="toggle-fonts">Serif Font</label>
        </span>

        <!-- Sidebar footnotes control -->
        <span class="inline-footnotes" style="display: none; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-fns" type="checkbox" class="inline-footnotes" id="sidebar-fns">
          <label for="sidebar-fns">Inline Footnotes</label>
        </span>
      </div>

      <hr />

      <!-- Navbar navigation (lol) -->
      <div id="return" style="white-space: nowrap;">
        <div class="search-form search-form-proxy" role="form">
          <input id="search-box-proxy" type_="text" placeholder="Search..." autocomplete="off" tabindex="0"></input>
        </div>

              <a href="/">back to index</a> <br />
              <a href="all-pages.html">view all pages</a> <br />
        <a href="https://github.com/plt-amy/cubical-1lab/blob/557652231fac237cc9a4fc37c1c3f140b1961cbd/src/Data/Int.lagda.md">link to source</a> <br />
                <hr /> <div class="author-list">Written by Amélia Liao, Jonathan Coates and uni</div> <br />
              </div>
    </div>
  </aside>
  
  <article>
    <!-- Article navigation (narrow screens only) -->
    <div class="narrow-only" id="article-nav">
      <!-- Index return anchor (only if the page is not the index) -->
            <div id="return">
        <a href="/">back to index</a>
      </div>
      
      <!-- Navbar equations control -->
      <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-eqns" type="checkbox" class="equations" id="navbar-eqns">
        <label for="navbar-eqns">Equations</label>
      </span>

      <!-- Navbar footnotes control -->
      <span class="inline-footnotes" style="display: none; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-fns" type="checkbox" class="inline-footnotes" id="navbar-fns">
        <label for="navbar-fns">Inline Footnotes</label>
      </span>
    </div>

<pre class="Agda"><a id="9" class="Keyword">open</a> <a id="14" class="Keyword">import</a> <a id="21" href="1Lab.Prelude.html" class="Module">1Lab.Prelude</a>

<a id="35" class="Keyword">open</a> <a id="40" class="Keyword">import</a> <a id="47" href="Data.Nat.Solver.html" class="Module">Data.Nat.Solver</a>
<a id="63" class="Keyword">open</a> <a id="68" class="Keyword">import</a> <a id="75" href="Data.Nat.html" class="Module">Data.Nat</a>
<a id="84" class="Keyword">open</a> <a id="89" class="Keyword">import</a> <a id="96" href="Data.Sum.html" class="Module">Data.Sum</a>

<a id="106" class="Keyword">module</a> <a id="113" href="Data.Int.html" class="Module">Data.Int</a> <a id="122" class="Keyword">where</a>
</pre>
<h1 id="integers"><a href="#integers" class="header-link">Integers<span class="header-link-emoji">🔗</span></a></h1>
<p>The <strong>integers</strong> are what you get when you complete the
<a href="Algebra.Monoid.html#ℕ-+">additive monoid structure on the
naturals</a> into a <a href="Algebra.Group.html">group</a>. In
non-cubical Agda, a representation of the integers as a coproduct
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">N</mi><mo>∐</mo><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">\bb{N} \coprod \bb{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbb">N</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∐</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathbb">N</span></span></span></span>
with one of the factors offset (to avoid having two zeroes) is adopted.
In Cubical Agda we can adopt a representation much closer to a
“classical” construction of the integers:</p>
<pre class="Agda"><a id="638" class="Keyword">data</a> <a id="Int"></a><a id="643" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a> <a id="647" class="Symbol">:</a> <a id="649" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="654" class="Keyword">where</a>
  <a id="Int.diff"></a><a id="662" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="667" class="Symbol">:</a> <a id="669" class="Symbol">(</a><a id="670" href="Data.Int.html#670" class="Bound">x</a> <a id="672" href="Data.Int.html#672" class="Bound">y</a> <a id="674" class="Symbol">:</a> <a id="676" href="Agda.Builtin.Nat.html#177" data-type="Type" class="Datatype">Nat</a><a id="679" class="Symbol">)</a> <a id="681" class="Symbol">→</a> <a id="683" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a>
  <a id="Int.quot"></a><a id="689" href="Data.Int.html#689" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="694" class="Symbol">:</a> <a id="696" class="Symbol">(</a><a id="697" href="Data.Int.html#697" class="Bound">m</a> <a id="699" href="Data.Int.html#699" class="Bound">n</a> <a id="701" class="Symbol">:</a> <a id="703" href="Agda.Builtin.Nat.html#177" data-type="Type" class="Datatype">Nat</a><a id="706" class="Symbol">)</a> <a id="708" class="Symbol">→</a> <a id="710" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="715" href="Data.Int.html#697" class="Bound">m</a> <a id="717" href="Data.Int.html#699" class="Bound">n</a> <a id="719" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="721" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="726" class="Symbol">(</a><a id="727" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="731" href="Data.Int.html#697" class="Bound">m</a><a id="732" class="Symbol">)</a> <a id="734" class="Symbol">(</a><a id="735" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="739" href="Data.Int.html#699" class="Bound">n</a><a id="740" class="Symbol">)</a>
</pre>
<p>This is an alternative representation of the construction of integers
as pairs
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mspace></mspace><mspace width="0.1111em"></mspace><mo lspace="0em" rspace="0.17em"></mo><mtext> ⁣</mtext><mo lspace="0em" rspace="0em">:</mo><mspace width="0.3333em"></mspace><msup><mi mathvariant="double-struck">N</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">(x , y)\colon \bb{N}^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace nobreak"></span><span class="mspace" style="margin-right:0.1111em;"></span><span class="mpunct"></span><span class="mspace" style="margin-right:-0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mrel">:</span></span><span class="mspace" style="margin-right:0.3333em;"></span><span class="mord"><span class="mord mathbb">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>
where
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a,b) = (c, d)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mclose">)</span></span></span></span>
iff
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>+</mo><mi>d</mi><mo>=</mo><mi>b</mi><mo>+</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a + d = b + c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span>:</span>
An integer is an equivalence class of pairs of naturals, where
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a, b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>
is identified with
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>a</mi><mo separator="true">,</mo><mn>1</mn><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1 + a, 1 + b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>,</span>
or, more type-theoretically, the integers are generated by the
constructor
<span class="Agda"><a href="Data.Int.html#662" class="InductiveConstructor">diff</a></span>
which embeds a pair of naturals, and the path constructor
<span class="Agda"><a href="Data.Int.html#689" class="InductiveConstructor">quot</a></span>
which expresses that
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a, b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>
=
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>a</mi><mo separator="true">,</mo><mn>1</mn><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1 + a, 1 + b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>.</span></p>
<p>This single generating path is enough to recover the “classical”
quotient, which we do in steps. First, we… prove that that
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n - n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>
is
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>:</span></p>
<pre class="Agda"><a id="zeroes"></a><a id="1367" href="Data.Int.html#1367" data-type="(n : Nat) → diff 0 0 ≡ diff n n" class="Function">zeroes</a> <a id="1374" class="Symbol">:</a> <a id="1376" class="Symbol">(</a><a id="1377" href="Data.Int.html#1377" class="Bound">n</a> <a id="1379" class="Symbol">:</a> <a id="1381" href="Agda.Builtin.Nat.html#177" data-type="Type" class="Datatype">Nat</a><a id="1384" class="Symbol">)</a> <a id="1386" class="Symbol">→</a> <a id="1388" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="1393" class="Number">0</a> <a id="1395" class="Number">0</a> <a id="1397" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="1399" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="1404" href="Data.Int.html#1377" class="Bound">n</a> <a id="1406" href="Data.Int.html#1377" class="Bound">n</a>
<a id="1408" href="Data.Int.html#1367" data-type="(n : Nat) → diff 0 0 ≡ diff n n" class="Function">zeroes</a> <a id="1415" href="Agda.Builtin.Nat.html#195" data-type="Nat" class="InductiveConstructor">zero</a> <a id="1420" class="Symbol">=</a> <a id="1422" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
<a id="1427" href="Data.Int.html#1367" data-type="(n : Nat) → diff 0 0 ≡ diff n n" class="Function">zeroes</a> <a id="1434" class="Symbol">(</a><a id="1435" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="1439" href="Data.Int.html#1439" class="Bound">n</a><a id="1440" class="Symbol">)</a> <a id="1442" class="Symbol">=</a> <a id="1444" href="Data.Int.html#1367" data-type="(n : Nat) → diff 0 0 ≡ diff n n" class="Function">zeroes</a> <a id="1451" href="Data.Int.html#1439" class="Bound">n</a> <a id="1453" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="1455" href="Data.Int.html#689" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="1460" class="Symbol">_</a> <a id="1462" class="Symbol">_</a>
</pre>
<p>Additionally, offsetting a difference by a fixed natural, as long as
it’s done on both sides of the difference, does not change which integer
is being represented: That is, considering all three naturals as
integers,
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>−</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>a</mi><mo stretchy="false">)</mo><mo>−</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a - b) = (n + a) - (n + b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>.</span></p>
<pre class="Agda"><a id="cancel"></a><a id="1726" href="Data.Int.html#1726" data-type="(a b n : Nat) → diff a b ≡ diff (n + a) (n + b)" class="Function">cancel</a> <a id="1733" class="Symbol">:</a> <a id="1735" class="Symbol">(</a><a id="1736" href="Data.Int.html#1736" class="Bound">a</a> <a id="1738" href="Data.Int.html#1738" class="Bound">b</a> <a id="1740" href="Data.Int.html#1740" class="Bound">n</a> <a id="1742" class="Symbol">:</a> <a id="1744" href="Agda.Builtin.Nat.html#177" data-type="Type" class="Datatype">Nat</a><a id="1747" class="Symbol">)</a> <a id="1749" class="Symbol">→</a> <a id="1751" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="1756" href="Data.Int.html#1736" class="Bound">a</a> <a id="1758" href="Data.Int.html#1738" class="Bound">b</a> <a id="1760" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="1762" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="1767" class="Symbol">(</a><a id="1768" href="Data.Int.html#1740" class="Bound">n</a> <a id="1770" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="1772" href="Data.Int.html#1736" class="Bound">a</a><a id="1773" class="Symbol">)</a> <a id="1775" class="Symbol">(</a><a id="1776" href="Data.Int.html#1740" class="Bound">n</a> <a id="1778" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="1780" href="Data.Int.html#1738" class="Bound">b</a><a id="1781" class="Symbol">)</a>
<a id="1783" href="Data.Int.html#1726" data-type="(a b n : Nat) → diff a b ≡ diff (n + a) (n + b)" class="Function">cancel</a> <a id="1790" href="Data.Int.html#1790" class="Bound">a</a> <a id="1792" href="Data.Int.html#1792" class="Bound">b</a> <a id="1794" href="Agda.Builtin.Nat.html#195" data-type="Nat" class="InductiveConstructor">zero</a> <a id="1799" class="Symbol">=</a> <a id="1801" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
<a id="1806" href="Data.Int.html#1726" data-type="(a b n : Nat) → diff a b ≡ diff (n + a) (n + b)" class="Function">cancel</a> <a id="1813" href="Data.Int.html#1813" class="Bound">a</a> <a id="1815" href="Data.Int.html#1815" class="Bound">b</a> <a id="1817" class="Symbol">(</a><a id="1818" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="1822" href="Data.Int.html#1822" class="Bound">n</a><a id="1823" class="Symbol">)</a> <a id="1825" class="Symbol">=</a> <a id="1827" href="Data.Int.html#1726" data-type="(a b n : Nat) → diff a b ≡ diff (n + a) (n + b)" class="Function">cancel</a> <a id="1834" href="Data.Int.html#1813" class="Bound">a</a> <a id="1836" href="Data.Int.html#1815" class="Bound">b</a> <a id="1838" href="Data.Int.html#1822" class="Bound">n</a> <a id="1840" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="1842" href="Data.Int.html#689" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="1847" class="Symbol">_</a> <a id="1849" class="Symbol">_</a>
</pre>
<p>As a final pair of helper lemmas, we find that if
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>
and
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>
differ by an absolute value of
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>,</span>
then the values
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">n - k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>
and
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>
are the same (as long as we fix the sign — hence the two lemmas). The
generic situation of “differing by
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>”
is captured by fixing a natural number
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span>
and adding
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>,</span>
because we have
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo><mo>−</mo><mi>a</mi><mo>=</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">(a + b) - a = b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>
and
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>−</mo><mo stretchy="false">(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mo>−</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a - (a + b) = -b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord mathnormal">b</span></span></span></span>.</span></p>
<pre class="Agda"><a id="offset-negative"></a><a id="2224" href="Data.Int.html#2224" data-type="(a b : Nat) → diff a (a + b) ≡ diff 0 b" class="Function">offset-negative</a> <a id="2240" class="Symbol">:</a> <a id="2242" class="Symbol">(</a><a id="2243" href="Data.Int.html#2243" class="Bound">a</a> <a id="2245" href="Data.Int.html#2245" class="Bound">b</a> <a id="2247" class="Symbol">:</a> <a id="2249" href="Agda.Builtin.Nat.html#177" data-type="Type" class="Datatype">Nat</a><a id="2252" class="Symbol">)</a> <a id="2254" class="Symbol">→</a> <a id="2256" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="2261" href="Data.Int.html#2243" class="Bound">a</a> <a id="2263" class="Symbol">(</a><a id="2264" href="Data.Int.html#2243" class="Bound">a</a> <a id="2266" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="2268" href="Data.Int.html#2245" class="Bound">b</a><a id="2269" class="Symbol">)</a> <a id="2271" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="2273" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="2278" class="Number">0</a> <a id="2280" href="Data.Int.html#2245" class="Bound">b</a>
<a id="2282" href="Data.Int.html#2224" data-type="(a b : Nat) → diff a (a + b) ≡ diff 0 b" class="Function">offset-negative</a> <a id="2298" href="Agda.Builtin.Nat.html#195" data-type="Nat" class="InductiveConstructor">zero</a> <a id="2303" href="Data.Int.html#2303" class="Bound">b</a> <a id="2305" class="Symbol">=</a> <a id="2307" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
<a id="2312" href="Data.Int.html#2224" data-type="(a b : Nat) → diff a (a + b) ≡ diff 0 b" class="Function">offset-negative</a> <a id="2328" class="Symbol">(</a><a id="2329" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="2333" href="Data.Int.html#2333" class="Bound">a</a><a id="2334" class="Symbol">)</a> <a id="2336" href="Data.Int.html#2336" class="Bound">b</a> <a id="2338" class="Symbol">=</a>
  <a id="2342" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="2347" class="Symbol">(</a><a id="2348" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="2352" href="Data.Int.html#2333" class="Bound">a</a><a id="2353" class="Symbol">)</a> <a id="2355" class="Symbol">(</a><a id="2356" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="2360" class="Symbol">(</a><a id="2361" href="Data.Int.html#2333" class="Bound">a</a> <a id="2363" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="2365" href="Data.Int.html#2336" class="Bound">b</a><a id="2366" class="Symbol">))</a> <span class="reasoning-step"><span class="as-written Function"><a id="2369" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="2372" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="2376" class="Symbol">(</a><a id="2377" href="Data.Int.html#689" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="2382" class="Symbol">_</a> <a id="2384" class="Symbol">_)</a> <a id="2387" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
  <a id="2391" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="2396" href="Data.Int.html#2333" class="Bound">a</a> <a id="2398" class="Symbol">(</a><a id="2399" href="Data.Int.html#2333" class="Bound">a</a> <a id="2401" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="2403" href="Data.Int.html#2336" class="Bound">b</a><a id="2404" class="Symbol">)</a>             <span class="reasoning-step"><span class="as-written Function"><a id="2418" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="2421" href="Data.Int.html#2224" data-type="(a b : Nat) → diff a (a + b) ≡ diff 0 b" class="Function">offset-negative</a> <a id="2437" href="Data.Int.html#2333" class="Bound">a</a> <a id="2439" href="Data.Int.html#2336" class="Bound">b</a> <a id="2441" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
  <a id="2445" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="2450" class="Number">0</a> <a id="2452" href="Data.Int.html#2336" class="Bound">b</a>                   <a id="2472" href="1Lab.Path.html#46945" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>

<a id="offset-positive"></a><a id="2475" href="Data.Int.html#2475" data-type="(a b : Nat) → diff (a + b) a ≡ diff b 0" class="Function">offset-positive</a> <a id="2491" class="Symbol">:</a> <a id="2493" class="Symbol">(</a><a id="2494" href="Data.Int.html#2494" class="Bound">a</a> <a id="2496" href="Data.Int.html#2496" class="Bound">b</a> <a id="2498" class="Symbol">:</a> <a id="2500" href="Agda.Builtin.Nat.html#177" data-type="Type" class="Datatype">Nat</a><a id="2503" class="Symbol">)</a> <a id="2505" class="Symbol">→</a> <a id="2507" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="2512" class="Symbol">(</a><a id="2513" href="Data.Int.html#2494" class="Bound">a</a> <a id="2515" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="2517" href="Data.Int.html#2496" class="Bound">b</a><a id="2518" class="Symbol">)</a> <a id="2520" href="Data.Int.html#2494" class="Bound">a</a> <a id="2522" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="2524" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="2529" href="Data.Int.html#2496" class="Bound">b</a> <a id="2531" class="Number">0</a>
<a id="2533" href="Data.Int.html#2475" data-type="(a b : Nat) → diff (a + b) a ≡ diff b 0" class="Function">offset-positive</a> <a id="2549" href="Agda.Builtin.Nat.html#195" data-type="Nat" class="InductiveConstructor">zero</a> <a id="2554" href="Data.Int.html#2554" class="Bound">b</a> <a id="2556" class="Symbol">=</a> <a id="2558" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
<a id="2563" href="Data.Int.html#2475" data-type="(a b : Nat) → diff (a + b) a ≡ diff b 0" class="Function">offset-positive</a> <a id="2579" class="Symbol">(</a><a id="2580" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="2584" href="Data.Int.html#2584" class="Bound">a</a><a id="2585" class="Symbol">)</a> <a id="2587" href="Data.Int.html#2587" class="Bound">b</a> <a id="2589" class="Symbol">=</a>
  <a id="2593" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="2598" class="Symbol">(</a><a id="2599" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="2603" class="Symbol">(</a><a id="2604" href="Data.Int.html#2584" class="Bound">a</a> <a id="2606" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="2608" href="Data.Int.html#2587" class="Bound">b</a><a id="2609" class="Symbol">))</a> <a id="2612" class="Symbol">(</a><a id="2613" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="2617" href="Data.Int.html#2584" class="Bound">a</a><a id="2618" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function"><a id="2620" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="2623" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="2627" class="Symbol">(</a><a id="2628" href="Data.Int.html#689" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="2633" class="Symbol">_</a> <a id="2635" class="Symbol">_)</a> <a id="2638" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
  <a id="2642" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="2647" class="Symbol">(</a><a id="2648" href="Data.Int.html#2584" class="Bound">a</a> <a id="2650" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="2652" href="Data.Int.html#2587" class="Bound">b</a><a id="2653" class="Symbol">)</a> <a id="2655" href="Data.Int.html#2584" class="Bound">a</a>             <span class="reasoning-step"><span class="as-written Function"><a id="2669" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="2672" href="Data.Int.html#2475" data-type="(a b : Nat) → diff (a + b) a ≡ diff b 0" class="Function">offset-positive</a> <a id="2688" href="Data.Int.html#2584" class="Bound">a</a> <a id="2690" href="Data.Int.html#2587" class="Bound">b</a> <a id="2692" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
  <a id="2696" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="2701" href="Data.Int.html#2587" class="Bound">b</a> <a id="2703" class="Number">0</a>                   <a id="2723" href="1Lab.Path.html#46945" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
</pre>
<p>Those two are the last two lemmas we need to prove the “if” direction
of “naturals are identified in the quotient iff they represent the same
difference”: the construction
<span class="Agda"><a href="Data.Int.html#2994" class="Function">same-difference</a></span>
below packages everything together with a bow on the top.</p>
<pre class="Agda"><a id="same-difference"></a><a id="2994" href="Data.Int.html#2994" data-type="a + d ≡ b + c → diff a b ≡ diff c d" class="Function">same-difference</a> <a id="3010" class="Symbol">:</a> <a id="3012" class="Symbol">{</a><a id="3013" href="Data.Int.html#3013" class="Bound">a</a> <a id="3015" href="Data.Int.html#3015" class="Bound">b</a> <a id="3017" href="Data.Int.html#3017" class="Bound">c</a> <a id="3019" href="Data.Int.html#3019" class="Bound">d</a> <a id="3021" class="Symbol">:</a> <a id="3023" href="Agda.Builtin.Nat.html#177" data-type="Type" class="Datatype">Nat</a><a id="3026" class="Symbol">}</a> <a id="3028" class="Symbol">→</a> <a id="3030" href="Data.Int.html#3013" class="Bound">a</a> <a id="3032" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3034" href="Data.Int.html#3019" class="Bound">d</a> <a id="3036" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="3038" href="Data.Int.html#3015" class="Bound">b</a> <a id="3040" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3042" href="Data.Int.html#3017" class="Bound">c</a> <a id="3044" class="Symbol">→</a> <a id="3046" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="3051" href="Data.Int.html#3013" class="Bound">a</a> <a id="3053" href="Data.Int.html#3015" class="Bound">b</a> <a id="3055" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="3057" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="3062" href="Data.Int.html#3017" class="Bound">c</a> <a id="3064" href="Data.Int.html#3019" class="Bound">d</a>
<a id="3066" href="Data.Int.html#2994" data-type="a + d ≡ b + c → diff a b ≡ diff c d" class="Function">same-difference</a> <a id="3082" class="Symbol">{</a><a id="3083" href="Agda.Builtin.Nat.html#195" data-type="Nat" class="InductiveConstructor">zero</a><a id="3087" class="Symbol">}</a> <a id="3089" class="Symbol">{</a><a id="3090" href="Data.Int.html#3090" class="Bound">b</a><a id="3091" class="Symbol">}</a> <a id="3093" class="Symbol">{</a><a id="3094" href="Data.Int.html#3094" class="Bound">c</a><a id="3095" class="Symbol">}</a> <a id="3097" class="Symbol">{</a><a id="3098" href="Data.Int.html#3098" class="Bound">d</a><a id="3099" class="Symbol">}</a> <a id="3101" href="Data.Int.html#3101" class="Bound">path</a> <a id="3106" class="Symbol">=</a>
  <a id="3110" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="3114" class="Symbol">(</a> <a id="3116" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="3121" href="Data.Int.html#3094" class="Bound">c</a> <a id="3123" href="Data.Int.html#3098" class="Bound">d</a>       <span class="reasoning-step"><span class="as-written Function"><a id="3131" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="3134" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="3138" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="3143" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="3148" href="Data.Int.html#3101" class="Bound">path</a> <a id="3153" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
        <a id="3163" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="3168" href="Data.Int.html#3094" class="Bound">c</a> <a id="3170" class="Symbol">(</a><a id="3171" href="Data.Int.html#3090" class="Bound">b</a> <a id="3173" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3175" href="Data.Int.html#3094" class="Bound">c</a><a id="3176" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function"><a id="3178" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="3181" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="3185" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="3190" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="3195" class="Symbol">(</a><a id="3196" href="Data.Nat.Properties.html#979" data-type="(x y : Nat) → x + y ≡ y + x" class="Function">+-commutative</a> <a id="3210" href="Data.Int.html#3090" class="Bound">b</a> <a id="3212" href="Data.Int.html#3094" class="Bound">c</a><a id="3213" class="Symbol">)</a> <a id="3215" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
        <a id="3225" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="3230" href="Data.Int.html#3094" class="Bound">c</a> <a id="3232" class="Symbol">(</a><a id="3233" href="Data.Int.html#3094" class="Bound">c</a> <a id="3235" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3237" href="Data.Int.html#3090" class="Bound">b</a><a id="3238" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function"><a id="3240" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="3243" href="Data.Int.html#2224" data-type="(a b : Nat) → diff a (a + b) ≡ diff 0 b" class="Function">offset-negative</a> <a id="3259" class="Symbol">_</a> <a id="3261" class="Symbol">_</a> <a id="3263" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
        <a id="3273" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="3278" class="Number">0</a> <a id="3280" href="Data.Int.html#3090" class="Bound">b</a>       <a id="3288" href="1Lab.Path.html#46945" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
      <a id="3296" class="Symbol">)</a>
<a id="3298" href="Data.Int.html#2994" data-type="a + d ≡ b + c → diff a b ≡ diff c d" class="Function">same-difference</a> <a id="3314" class="Symbol">{</a><a id="3315" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="3319" href="Data.Int.html#3319" class="Bound">a</a><a id="3320" class="Symbol">}</a> <a id="3322" class="Symbol">{</a><a id="3323" href="Agda.Builtin.Nat.html#195" data-type="Nat" class="InductiveConstructor">zero</a><a id="3327" class="Symbol">}</a> <a id="3329" class="Symbol">{</a><a id="3330" href="Data.Int.html#3330" class="Bound">c</a><a id="3331" class="Symbol">}</a> <a id="3333" class="Symbol">{</a><a id="3334" href="Data.Int.html#3334" class="Bound">d</a><a id="3335" class="Symbol">}</a> <a id="3337" href="Data.Int.html#3337" class="Bound">path</a> <a id="3342" class="Symbol">=</a>
  <a id="3346" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="3350" class="Symbol">(</a> <a id="3352" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="3357" href="Data.Int.html#3330" class="Bound">c</a> <a id="3359" href="Data.Int.html#3334" class="Bound">d</a>             <span class="reasoning-step"><span class="as-written Function"><a id="3373" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="3376" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="3380" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="3385" class="Symbol">(</a><a id="3386" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="3390" href="Data.Int.html#3337" class="Bound">path</a><a id="3394" class="Symbol">)</a> <a id="3396" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="3401" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
        <a id="3411" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="3416" class="Symbol">(</a><a id="3417" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="3421" href="Data.Int.html#3319" class="Bound">a</a> <a id="3423" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3425" href="Data.Int.html#3334" class="Bound">d</a><a id="3426" class="Symbol">)</a> <a id="3428" href="Data.Int.html#3334" class="Bound">d</a>   <span class="reasoning-step"><span class="as-written Function"><a id="3432" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="3435" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="3439" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="3444" class="Symbol">(</a><a id="3445" href="Data.Nat.Properties.html#979" data-type="(x y : Nat) → x + y ≡ y + x" class="Function">+-commutative</a> <a id="3459" class="Symbol">(</a><a id="3460" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="3464" href="Data.Int.html#3319" class="Bound">a</a><a id="3465" class="Symbol">)</a> <a id="3467" href="Data.Int.html#3334" class="Bound">d</a><a id="3468" class="Symbol">)</a> <a id="3470" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="3475" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
        <a id="3485" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="3490" class="Symbol">(</a><a id="3491" href="Data.Int.html#3334" class="Bound">d</a> <a id="3493" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3495" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="3499" href="Data.Int.html#3319" class="Bound">a</a><a id="3500" class="Symbol">)</a> <a id="3502" href="Data.Int.html#3334" class="Bound">d</a>   <span class="reasoning-step"><span class="as-written Function"><a id="3506" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="3509" href="Data.Int.html#2475" data-type="(a b : Nat) → diff (a + b) a ≡ diff b 0" class="Function">offset-positive</a> <a id="3525" class="Symbol">_</a> <a id="3527" class="Symbol">_</a> <a id="3529" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
        <a id="3539" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="3544" class="Symbol">(</a><a id="3545" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="3549" href="Data.Int.html#3319" class="Bound">a</a><a id="3550" class="Symbol">)</a> <a id="3552" class="Number">0</a>       <a id="3560" href="1Lab.Path.html#46945" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
      <a id="3568" class="Symbol">)</a>
<a id="3570" href="Data.Int.html#2994" data-type="a + d ≡ b + c → diff a b ≡ diff c d" class="Function">same-difference</a> <a id="3586" class="Symbol">{</a><a id="3587" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="3591" href="Data.Int.html#3591" class="Bound">a</a><a id="3592" class="Symbol">}</a> <a id="3594" class="Symbol">{</a><a id="3595" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="3599" href="Data.Int.html#3599" class="Bound">b</a><a id="3600" class="Symbol">}</a> <a id="3602" class="Symbol">{</a><a id="3603" href="Data.Int.html#3603" class="Bound">c</a><a id="3604" class="Symbol">}</a> <a id="3606" class="Symbol">{</a><a id="3607" href="Data.Int.html#3607" class="Bound">d</a><a id="3608" class="Symbol">}</a> <a id="3610" href="Data.Int.html#3610" class="Bound">path</a> <a id="3615" class="Symbol">=</a>
  <a id="3619" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="3624" class="Symbol">(</a><a id="3625" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="3629" href="Data.Int.html#3591" class="Bound">a</a><a id="3630" class="Symbol">)</a> <a id="3632" class="Symbol">(</a><a id="3633" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="3637" href="Data.Int.html#3599" class="Bound">b</a><a id="3638" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function"><a id="3640" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="3643" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="3647" class="Symbol">(</a><a id="3648" href="Data.Int.html#689" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="3653" class="Symbol">_</a> <a id="3655" class="Symbol">_)</a> <a id="3658" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
  <a id="3662" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="3667" href="Data.Int.html#3591" class="Bound">a</a> <a id="3669" href="Data.Int.html#3599" class="Bound">b</a>             <span class="reasoning-step"><span class="as-written Function"><a id="3683" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="3686" href="Data.Int.html#2994" data-type="a + d ≡ b + c → diff a b ≡ diff c d" class="Function">same-difference</a> <a id="3702" class="Symbol">(</a><a id="3703" href="Data.Nat.Base.html#1668" data-type="suc x ≡ suc y → x ≡ y" class="Function">suc-inj</a> <a id="3711" href="Data.Int.html#3610" class="Bound">path</a><a id="3715" class="Symbol">)</a> <a id="3717" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
  <a id="3721" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="3726" href="Data.Int.html#3603" class="Bound">c</a> <a id="3728" href="Data.Int.html#3607" class="Bound">d</a>             <a id="3742" href="1Lab.Path.html#46945" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
</pre>
<!--
<pre class="Agda"><a id="quot-diamond"></a><a id="3762" href="Data.Int.html#3762" data-type="(a b : Nat) →
Square (quot a b) (quot a b) (quot (suc a) (suc b))
(quot (suc a) (suc b))" class="Function">quot-diamond</a> <a id="3775" class="Symbol">:</a> <a id="3777" class="Symbol">(</a><a id="3778" href="Data.Int.html#3778" class="Bound">a</a> <a id="3780" href="Data.Int.html#3780" class="Bound">b</a> <a id="3782" class="Symbol">:</a> <a id="3784" href="Agda.Builtin.Nat.html#177" data-type="Type" class="Datatype">Nat</a><a id="3787" class="Symbol">)</a>
             <a id="3802" class="Symbol">→</a> <a id="3804" href="1Lab.Path.html#9409" data-type="a00 ≡ a01 → a00 ≡ a10 → a01 ≡ a11 → a10 ≡ a11 → Type ℓ" class="Function">Square</a> <a id="3811" class="Symbol">(</a><a id="3812" href="Data.Int.html#689" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="3817" href="Data.Int.html#3778" class="Bound">a</a> <a id="3819" href="Data.Int.html#3780" class="Bound">b</a><a id="3820" class="Symbol">)</a> <a id="3822" class="Symbol">(</a><a id="3823" href="Data.Int.html#689" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="3828" href="Data.Int.html#3778" class="Bound">a</a> <a id="3830" href="Data.Int.html#3780" class="Bound">b</a><a id="3831" class="Symbol">)</a>
                      <a id="3855" class="Symbol">(</a><a id="3856" href="Data.Int.html#689" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="3861" class="Symbol">(</a><a id="3862" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="3866" href="Data.Int.html#3778" class="Bound">a</a><a id="3867" class="Symbol">)</a> <a id="3869" class="Symbol">(</a><a id="3870" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="3874" href="Data.Int.html#3780" class="Bound">b</a><a id="3875" class="Symbol">))</a>
                      <a id="3900" class="Symbol">(</a><a id="3901" href="Data.Int.html#689" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="3906" class="Symbol">(</a><a id="3907" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="3911" href="Data.Int.html#3778" class="Bound">a</a><a id="3912" class="Symbol">)</a> <a id="3914" class="Symbol">(</a><a id="3915" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="3919" href="Data.Int.html#3780" class="Bound">b</a><a id="3920" class="Symbol">))</a>
<a id="3923" href="Data.Int.html#3762" data-type="(a b : Nat) →
Square (quot a b) (quot a b) (quot (suc a) (suc b))
(quot (suc a) (suc b))" class="Function">quot-diamond</a> <a id="3936" href="Data.Int.html#3936" class="Bound">a</a> <a id="3938" href="Data.Int.html#3938" class="Bound">b</a> <a id="3940" href="Data.Int.html#3940" class="Bound">i</a> <a id="3942" href="Data.Int.html#3942" class="Bound">j</a> <a id="3944" class="Symbol">=</a>
  <a id="3948" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="3954" class="Symbol">(λ</a> <a id="3957" href="Data.Int.html#3957" class="Bound">k</a> <a id="3959" class="Symbol">→</a> <a id="3961" class="Symbol">λ</a> <a id="3963" class="Symbol">{</a> <a id="3965" class="Symbol">(</a><a id="3966" href="Data.Int.html#3940" class="Bound">i</a> <a id="3968" class="Symbol">=</a> <a id="3970" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="3972" class="Symbol">)</a> <a id="3974" class="Symbol">→</a> <a id="3976" href="Data.Int.html#689" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="3981" href="Data.Int.html#3936" class="Bound">a</a> <a id="3983" href="Data.Int.html#3938" class="Bound">b</a> <a id="3985" href="Data.Int.html#3942" class="Bound">j</a>
                 <a id="4004" class="Symbol">;</a> <a id="4006" class="Symbol">(</a><a id="4007" href="Data.Int.html#3940" class="Bound">i</a> <a id="4009" class="Symbol">=</a> <a id="4011" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="4013" class="Symbol">)</a> <a id="4015" class="Symbol">→</a> <a id="4017" href="Data.Int.html#689" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="4022" class="Symbol">(</a><a id="4023" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="4027" href="Data.Int.html#3936" class="Bound">a</a><a id="4028" class="Symbol">)</a> <a id="4030" class="Symbol">(</a><a id="4031" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="4035" href="Data.Int.html#3938" class="Bound">b</a><a id="4036" class="Symbol">)</a> <a id="4038" class="Symbol">(</a><a id="4039" href="Data.Int.html#3942" class="Bound">j</a> <a id="4041" href="1Lab.Path.html#2191" class="Primitive Operator">∧</a> <a id="4043" href="Data.Int.html#3957" class="Bound">k</a><a id="4044" class="Symbol">)</a>
                 <a id="4063" class="Symbol">;</a> <a id="4065" class="Symbol">(</a><a id="4066" href="Data.Int.html#3942" class="Bound">j</a> <a id="4068" class="Symbol">=</a> <a id="4070" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="4072" class="Symbol">)</a> <a id="4074" class="Symbol">→</a> <a id="4076" href="Data.Int.html#689" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="4081" href="Data.Int.html#3936" class="Bound">a</a> <a id="4083" href="Data.Int.html#3938" class="Bound">b</a> <a id="4085" href="Data.Int.html#3940" class="Bound">i</a>
                 <a id="4104" class="Symbol">;</a> <a id="4106" class="Symbol">(</a><a id="4107" href="Data.Int.html#3942" class="Bound">j</a> <a id="4109" class="Symbol">=</a> <a id="4111" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="4113" class="Symbol">)</a> <a id="4115" class="Symbol">→</a> <a id="4117" href="Data.Int.html#689" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="4122" class="Symbol">(</a><a id="4123" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="4127" href="Data.Int.html#3936" class="Bound">a</a><a id="4128" class="Symbol">)</a> <a id="4130" class="Symbol">(</a><a id="4131" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="4135" href="Data.Int.html#3938" class="Bound">b</a><a id="4136" class="Symbol">)</a> <a id="4138" class="Symbol">(</a><a id="4139" href="Data.Int.html#3940" class="Bound">i</a> <a id="4141" href="1Lab.Path.html#2191" class="Primitive Operator">∧</a> <a id="4143" href="Data.Int.html#3957" class="Bound">k</a><a id="4144" class="Symbol">)</a>
                 <a id="4163" class="Symbol">})</a>
        <a id="4174" class="Symbol">(</a><a id="4175" href="Data.Int.html#689" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="4180" href="Data.Int.html#3936" class="Bound">a</a> <a id="4182" href="Data.Int.html#3938" class="Bound">b</a> <a id="4184" class="Symbol">(</a><a id="4185" href="Data.Int.html#3940" class="Bound">i</a> <a id="4187" href="1Lab.Path.html#2226" class="Primitive Operator">∨</a> <a id="4189" href="Data.Int.html#3942" class="Bound">j</a><a id="4190" class="Symbol">))</a>

<a id="quot-triangle"></a><a id="4194" href="Data.Int.html#4194" data-type="(a b : Nat) (i : I) → diff a b ≡ quot a b i" class="Function">quot-triangle</a> <a id="4208" class="Symbol">:</a> <a id="4210" class="Symbol">(</a><a id="4211" href="Data.Int.html#4211" class="Bound">a</a> <a id="4213" href="Data.Int.html#4213" class="Bound">b</a> <a id="4215" class="Symbol">:</a> <a id="4217" href="Agda.Builtin.Nat.html#177" data-type="Type" class="Datatype">Nat</a><a id="4220" class="Symbol">)</a> <a id="4222" class="Symbol">(</a><a id="4223" href="Data.Int.html#4223" class="Bound">i</a> <a id="4225" class="Symbol">:</a> <a id="4227" href="Agda.Primitive.Cubical.html#150" class="Datatype">I</a><a id="4228" class="Symbol">)</a> <a id="4230" class="Symbol">→</a> <a id="4232" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="4237" href="Data.Int.html#4211" class="Bound">a</a> <a id="4239" href="Data.Int.html#4213" class="Bound">b</a> <a id="4241" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="4243" href="Data.Int.html#689" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="4248" href="Data.Int.html#4211" class="Bound">a</a> <a id="4250" href="Data.Int.html#4213" class="Bound">b</a> <a id="4252" href="Data.Int.html#4223" class="Bound">i</a>
<a id="4254" href="Data.Int.html#4194" data-type="(a b : Nat) (i : I) → diff a b ≡ quot a b i" class="Function">quot-triangle</a> <a id="4268" href="Data.Int.html#4268" class="Bound">a</a> <a id="4270" href="Data.Int.html#4270" class="Bound">b</a> <a id="4272" href="Data.Int.html#4272" class="Bound">i</a> <a id="4274" href="Data.Int.html#4274" class="Bound">j</a> <a id="4276" class="Symbol">=</a> <a id="4278" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="4284" class="Symbol">(λ</a> <a id="4287" href="Data.Int.html#4287" class="Bound">k</a> <a id="4289" class="Symbol">→</a> <a id="4291" class="Symbol">λ</a>
  <a id="4295" class="Symbol">{</a> <a id="4297" class="Symbol">(</a><a id="4298" href="Data.Int.html#4272" class="Bound">i</a> <a id="4300" class="Symbol">=</a> <a id="4302" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="4304" class="Symbol">)</a> <a id="4306" class="Symbol">→</a> <a id="4308" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="4313" href="Data.Int.html#4268" class="Bound">a</a> <a id="4315" href="Data.Int.html#4270" class="Bound">b</a>
  <a id="4319" class="Symbol">;</a> <a id="4321" class="Symbol">(</a><a id="4322" href="Data.Int.html#4274" class="Bound">j</a> <a id="4324" class="Symbol">=</a> <a id="4326" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a><a id="4328" class="Symbol">)</a> <a id="4330" class="Symbol">→</a> <a id="4332" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="4337" href="Data.Int.html#4268" class="Bound">a</a> <a id="4339" href="Data.Int.html#4270" class="Bound">b</a>
  <a id="4343" class="Symbol">;</a> <a id="4345" class="Symbol">(</a><a id="4346" href="Data.Int.html#4274" class="Bound">j</a> <a id="4348" class="Symbol">=</a> <a id="4350" href="Agda.Primitive.Cubical.html#221" class="InductiveConstructor">i1</a><a id="4352" class="Symbol">)</a> <a id="4354" class="Symbol">→</a> <a id="4356" href="Data.Int.html#689" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="4361" href="Data.Int.html#4268" class="Bound">a</a> <a id="4363" href="Data.Int.html#4270" class="Bound">b</a> <a id="4365" class="Symbol">(</a><a id="4366" href="Data.Int.html#4272" class="Bound">i</a> <a id="4368" href="1Lab.Path.html#2191" class="Primitive Operator">∧</a> <a id="4370" href="Data.Int.html#4287" class="Bound">k</a><a id="4371" class="Symbol">)</a>
  <a id="4375" class="Symbol">})</a> <a id="4378" class="Symbol">(</a><a id="4379" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="4384" href="Data.Int.html#4268" class="Bound">a</a> <a id="4386" href="Data.Int.html#4270" class="Bound">b</a><a id="4387" class="Symbol">)</a>
</pre>-->
<p>In the other direction, we must be clever: we use path induction,
defining a type family
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">C</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">e</mi></mrow><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\id{Code}_{a,b}(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">Code</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>
such that the fibre of
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">C</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">e</mi></mrow><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\id{Code}_{a,b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">Code</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>
over
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(c, d)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mclose">)</span></span></span></span>
is
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>+</mo><mi>d</mi><mo>=</mo><mi>b</mi><mo>+</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a + d = b + c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span>.</span>
We can then use path induction to construct the map inverse to
<span class="Agda"><a href="Data.Int.html#2994" class="Function">same-difference</a></span>.
On the way, the first thing we establish is a pair of observations about
equalities on the natural numbers:
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>+</mo><mi>n</mi><mo>=</mo><mi>b</mi><mo>+</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">a + n = b + m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>
and
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>+</mo><mn>1</mn><mo>+</mo><mi>n</mi><mo>=</mo><mi>b</mi><mo>+</mo><mn>1</mn><mo>+</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">a + 1 + n = b + 1 + m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>
are equivalent conditions. This can be seen by commutativity and
injectivity of the successor function, but below we prove it using
equational reasoning, without appealing to commutativity.</p>
<pre class="Agda"><a id="5023" class="Keyword">module</a> <a id="ℤ-Path"></a><a id="5030" href="Data.Int.html#5030" class="Module">ℤ-Path</a> <a id="5037" class="Keyword">where</a>
  <a id="5045" class="Keyword">private</a>
    <a id="5057" class="Keyword">variable</a> <a id="5066" href="Data.Int.html#5066" class="Generalizable">a</a> <a id="5068" href="Data.Int.html#5068" class="Generalizable">b</a> <a id="5070" href="Data.Int.html#5070" class="Generalizable">m</a> <a id="5072" href="Data.Int.html#5072" class="Generalizable">n</a> <a id="5074" href="Data.Int.html#5074" class="Generalizable">c</a> <a id="5076" href="Data.Int.html#5076" class="Generalizable">d</a> <a id="5078" class="Symbol">:</a> <a id="5080" href="Agda.Builtin.Nat.html#177" data-type="Type" class="Datatype">Nat</a>
  <a id="ℤ-Path.encode-p-from"></a><a id="5086" href="Data.Int.html#5086" data-type="a + n ≡ b + m → a + suc n ≡ b + suc m" class="Function">encode-p-from</a> <a id="5100" class="Symbol">:</a> <a id="5102" class="Symbol">(</a><a id="5103" href="Data.Int.html#5066" class="Generalizable">a</a> <a id="5105" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="5107" href="Data.Int.html#5072" class="Generalizable">n</a> <a id="5109" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="5111" href="Data.Int.html#5068" class="Generalizable">b</a> <a id="5113" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="5115" href="Data.Int.html#5070" class="Generalizable">m</a><a id="5116" class="Symbol">)</a> <a id="5118" class="Symbol">→</a> <a id="5120" class="Symbol">(</a><a id="5121" href="Data.Int.html#5066" class="Generalizable">a</a> <a id="5123" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="5125" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="5129" href="Data.Int.html#5072" class="Generalizable">n</a> <a id="5131" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="5133" href="Data.Int.html#5068" class="Generalizable">b</a> <a id="5135" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="5137" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="5141" href="Data.Int.html#5070" class="Generalizable">m</a><a id="5142" class="Symbol">)</a>
  <a id="5146" href="Data.Int.html#5086" data-type="a + n ≡ b + m → a + suc n ≡ b + suc m" class="Function">encode-p-from</a> <a id="5160" class="Symbol">{</a><a id="5161" class="Argument">a</a> <a id="5163" class="Symbol">=</a> <a id="5165" href="Data.Int.html#5165" class="Bound">a</a><a id="5166" class="Symbol">}</a> <a id="5168" class="Symbol">{</a><a id="5169" href="Data.Int.html#5169" class="Bound">n</a><a id="5170" class="Symbol">}</a> <a id="5172" class="Symbol">{</a><a id="5173" href="Data.Int.html#5173" class="Bound">b</a><a id="5174" class="Symbol">}</a> <a id="5176" class="Symbol">{</a><a id="5177" href="Data.Int.html#5177" class="Bound">m</a><a id="5178" class="Symbol">}</a> <a id="5180" href="Data.Int.html#5180" class="Bound">p</a> <a id="5182" class="Symbol">=</a>
    <a id="5188" href="Data.Int.html#5165" class="Bound">a</a> <a id="5190" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="5192" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="5196" href="Data.Int.html#5169" class="Bound">n</a>   <span class="reasoning-step"><span class="as-written Function"><a id="5200" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="5203" href="Data.Nat.Properties.html#871" data-type="(x y : Nat) → x + suc y ≡ suc (x + y)" class="Function">+-sucr</a> <a id="5210" href="Data.Int.html#5165" class="Bound">a</a> <a id="5212" href="Data.Int.html#5169" class="Bound">n</a> <a id="5214" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="5220" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="5224" class="Symbol">(</a><a id="5225" href="Data.Int.html#5165" class="Bound">a</a> <a id="5227" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="5229" href="Data.Int.html#5169" class="Bound">n</a><a id="5230" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function"><a id="5232" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="5235" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="5238" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="5242" href="Data.Int.html#5180" class="Bound">p</a> <a id="5244" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="5250" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="5254" class="Symbol">(</a><a id="5255" href="Data.Int.html#5173" class="Bound">b</a> <a id="5257" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="5259" href="Data.Int.html#5177" class="Bound">m</a><a id="5260" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function Operator"><a id="5262" href="1Lab.Path.html#46771" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">≡˘⟨</a> <a id="5266" href="Data.Nat.Properties.html#871" data-type="(x y : Nat) → x + suc y ≡ suc (x + y)" class="Function">+-sucr</a> <a id="5273" href="Data.Int.html#5173" class="Bound">b</a> <a id="5275" href="Data.Int.html#5177" class="Bound">m</a> <a id="5277" href="1Lab.Path.html#46771" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡˘</span></span>
    <a id="5283" href="Data.Int.html#5173" class="Bound">b</a> <a id="5285" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="5287" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="5291" href="Data.Int.html#5177" class="Bound">m</a>   <a id="5295" href="1Lab.Path.html#46945" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>

  <a id="ℤ-Path.encode-p-to"></a><a id="5300" href="Data.Int.html#5300" data-type="a + suc n ≡ b + suc m → a + n ≡ b + m" class="Function">encode-p-to</a> <a id="5312" class="Symbol">:</a> <a id="5314" class="Symbol">(</a><a id="5315" href="Data.Int.html#5066" class="Generalizable">a</a> <a id="5317" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="5319" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="5323" href="Data.Int.html#5072" class="Generalizable">n</a> <a id="5325" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="5327" href="Data.Int.html#5068" class="Generalizable">b</a> <a id="5329" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="5331" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="5335" href="Data.Int.html#5070" class="Generalizable">m</a><a id="5336" class="Symbol">)</a> <a id="5338" class="Symbol">→</a> <a id="5340" class="Symbol">(</a><a id="5341" href="Data.Int.html#5066" class="Generalizable">a</a> <a id="5343" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="5345" href="Data.Int.html#5072" class="Generalizable">n</a> <a id="5347" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="5349" href="Data.Int.html#5068" class="Generalizable">b</a> <a id="5351" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="5353" href="Data.Int.html#5070" class="Generalizable">m</a><a id="5354" class="Symbol">)</a>
  <a id="5358" href="Data.Int.html#5300" data-type="a + suc n ≡ b + suc m → a + n ≡ b + m" class="Function">encode-p-to</a> <a id="5370" class="Symbol">{</a><a id="5371" href="Data.Int.html#5371" class="Bound">a</a><a id="5372" class="Symbol">}</a> <a id="5374" class="Symbol">{</a><a id="5375" href="Data.Int.html#5375" class="Bound">n</a><a id="5376" class="Symbol">}</a> <a id="5378" class="Symbol">{</a><a id="5379" href="Data.Int.html#5379" class="Bound">b</a><a id="5380" class="Symbol">}</a> <a id="5382" class="Symbol">{</a><a id="5383" href="Data.Int.html#5383" class="Bound">m</a><a id="5384" class="Symbol">}</a> <a id="5386" href="Data.Int.html#5386" class="Bound">p</a> <a id="5388" class="Symbol">=</a> <a id="5390" href="Data.Nat.Base.html#1668" data-type="suc x ≡ suc y → x ≡ y" class="Function">suc-inj</a> <a id="5398" class="Symbol">(</a><a id="5399" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="5403" class="Symbol">(</a><a id="5404" href="Data.Nat.Properties.html#871" data-type="(x y : Nat) → x + suc y ≡ suc (x + y)" class="Function">+-sucr</a> <a id="5411" href="Data.Int.html#5371" class="Bound">a</a> <a id="5413" href="Data.Int.html#5375" class="Bound">n</a><a id="5414" class="Symbol">)</a> <a id="5416" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="5418" href="Data.Int.html#5386" class="Bound">p</a> <a id="5420" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="5422" href="Data.Nat.Properties.html#871" data-type="(x y : Nat) → x + suc y ≡ suc (x + y)" class="Function">+-sucr</a> <a id="5429" href="Data.Int.html#5379" class="Bound">b</a> <a id="5431" href="Data.Int.html#5383" class="Bound">m</a><a id="5432" class="Symbol">)</a>
</pre>
<p>We then define, fixing two natural numbers
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a, b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span></span></span></span>,</span>
the family
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">C</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">e</mi></mrow><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\id{Code}_{a,b}(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">Code</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>
by recursion on the integer
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>.</span>
Recall that we want the fibre over
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">d</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">f</mi><mi mathvariant="normal">f</mi></mrow><mo stretchy="false">(</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\id{diff}(c, d)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm" style="margin-right:0.07778em;">diff</span></span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mclose">)</span></span></span></span>
to be
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>+</mo><mi>d</mi><mo>=</mo><mi>b</mi><mo>+</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a + d = b + c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span>,</span>
so that’s our pick. Now, the
<span class="Agda"><a href="Data.Int.html#689" class="InductiveConstructor">quot</a></span>
path constructor mandates that the fibre over
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(c, d)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mclose">)</span></span></span></span>
be the same as that over
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>c</mi><mo separator="true">,</mo><mn>1</mn><mo>+</mo><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1 + c, 1 + d)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mclose">)</span></span></span></span>
— but this follows by propositional extensionality and the pair of
observations above.</p>
<pre class="Agda">  <a id="ℤ-Path.Code"></a><a id="5871" href="Data.Int.html#5871" data-type="Nat → Nat → Int → Type" class="Function">Code</a> <a id="5876" class="Symbol">:</a> <a id="5878" class="Symbol">∀</a> <a id="5880" class="Symbol">(</a><a id="5881" href="Data.Int.html#5881" class="Bound">a</a> <a id="5883" href="Data.Int.html#5883" class="Bound">b</a> <a id="5885" class="Symbol">:</a> <a id="5887" href="Agda.Builtin.Nat.html#177" data-type="Type" class="Datatype">Nat</a><a id="5890" class="Symbol">)</a> <a id="5892" class="Symbol">(</a><a id="5893" href="Data.Int.html#5893" class="Bound">x</a> <a id="5895" class="Symbol">:</a> <a id="5897" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a><a id="5900" class="Symbol">)</a> <a id="5902" class="Symbol">→</a> <a id="5904" href="1Lab.Type.html#391" class="Primitive">Type</a>
  <a id="5911" href="Data.Int.html#5871" data-type="Nat → Nat → Int → Type" class="Function">Code</a> <a id="5916" href="Data.Int.html#5916" class="Bound">a</a> <a id="5918" href="Data.Int.html#5918" class="Bound">b</a> <a id="5920" class="Symbol">(</a><a id="5921" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="5926" href="Data.Int.html#5926" class="Bound">c</a> <a id="5928" href="Data.Int.html#5928" class="Bound">d</a><a id="5929" class="Symbol">)</a> <a id="5931" class="Symbol">=</a> <a id="5933" href="Data.Int.html#5916" class="Bound">a</a> <a id="5935" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="5937" href="Data.Int.html#5928" class="Bound">d</a> <a id="5939" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="5941" href="Data.Int.html#5918" class="Bound">b</a> <a id="5943" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="5945" href="Data.Int.html#5926" class="Bound">c</a>
  <a id="5949" href="Data.Int.html#5871" data-type="Nat → Nat → Int → Type" class="Function">Code</a> <a id="5954" href="Data.Int.html#5954" class="Bound">a</a> <a id="5956" href="Data.Int.html#5956" class="Bound">b</a> <a id="5958" class="Symbol">(</a><a id="5959" href="Data.Int.html#689" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="5964" href="Data.Int.html#5964" class="Bound">m</a> <a id="5966" href="Data.Int.html#5966" class="Bound">n</a> <a id="5968" href="Data.Int.html#5968" class="Bound">i</a><a id="5969" class="Symbol">)</a> <a id="5971" class="Symbol">=</a> <a id="5973" href="Data.Int.html#5990" data-type="(a b m n : Nat) (i : I) → (a + n ≡ b + m) ≡ (a + suc n ≡ b + suc m)" class="Function">path</a> <a id="5978" href="Data.Int.html#5968" class="Bound">i</a> <a id="5980" class="Keyword">where</a>
    <a id="5990" href="Data.Int.html#5990" data-type="(a b m n : Nat) (i : I) → (a + n ≡ b + m) ≡ (a + suc n ≡ b + suc m)" class="Function">path</a> <a id="5995" class="Symbol">:</a> <a id="5997" class="Symbol">(</a><a id="5998" href="Data.Int.html#5954" class="Bound">a</a> <a id="6000" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="6002" href="Data.Int.html#5966" class="Bound">n</a> <a id="6004" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="6006" href="Data.Int.html#5956" class="Bound">b</a> <a id="6008" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="6010" href="Data.Int.html#5964" class="Bound">m</a><a id="6011" class="Symbol">)</a> <a id="6013" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="6015" class="Symbol">(</a><a id="6016" href="Data.Int.html#5954" class="Bound">a</a> <a id="6018" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="6020" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="6024" href="Data.Int.html#5966" class="Bound">n</a> <a id="6026" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="6028" href="Data.Int.html#5956" class="Bound">b</a> <a id="6030" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="6032" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="6036" href="Data.Int.html#5964" class="Bound">m</a><a id="6037" class="Symbol">)</a>
    <a id="6043" href="Data.Int.html#5990" data-type="(a b m n : Nat) (i : I) → (a + n ≡ b + m) ≡ (a + suc n ≡ b + suc m)" class="Function">path</a> <a id="6048" class="Symbol">=</a> <a id="6050" href="1Lab.Univalence.html#9069" data-type="A ≃ B₁ → A ≡ B₁" class="Function">ua</a> <a id="6053" class="Symbol">(</a><a id="6054" href="1Lab.Equiv.html#23791" data-type="is-prop P → is-prop Q → (P → Q) → (Q → P) → P ≃ Q" class="Function">prop-ext</a> <a id="6063" class="Symbol">(</a><a id="6064" href="Data.Nat.Base.html#2563" data-type="is-set Nat" class="Function">Nat-is-set</a> <a id="6075" class="Symbol">_</a> <a id="6077" class="Symbol">_)</a> <a id="6080" class="Symbol">(</a><a id="6081" href="Data.Nat.Base.html#2563" data-type="is-set Nat" class="Function">Nat-is-set</a> <a id="6092" class="Symbol">_</a> <a id="6094" class="Symbol">_)</a> <a id="6097" href="Data.Int.html#5086" data-type="a + n ≡ b + m → a + suc n ≡ b + suc m" class="Function">encode-p-from</a> <a id="6111" href="Data.Int.html#5300" data-type="a + suc n ≡ b + suc m → a + n ≡ b + m" class="Function">encode-p-to</a><a id="6122" class="Symbol">)</a>
</pre>
<p>Hence, if we have a path
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">d</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">f</mi><mi mathvariant="normal">f</mi></mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">\id{diff}(a, b) = x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm" style="margin-right:0.07778em;">diff</span></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>,</span>
we can apply path induction, whence it suffices to consider the case
where
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>
is literally_ the difference of
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span>
and
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>.</span>
To lift this into our
<span class="Agda"><a href="Data.Int.html#5871" class="Function">Code</a></span>
fibration, we must show that
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi><mo>=</mo><mi>b</mi><mo>+</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">a + b = b + a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span>,</span>
but this is exactly commutativity of addition on
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">\bb{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span></span></span></span>.</span></p>
<pre class="Agda">  <a id="ℤ-Path.encode"></a><a id="6453" href="Data.Int.html#6453" data-type="(a b : Nat) (x : Int) → diff a b ≡ x → Code a b x" class="Function">encode</a> <a id="6460" class="Symbol">:</a> <a id="6462" class="Symbol">∀</a> <a id="6464" class="Symbol">(</a><a id="6465" href="Data.Int.html#6465" class="Bound">a</a> <a id="6467" href="Data.Int.html#6467" class="Bound">b</a> <a id="6469" class="Symbol">:</a> <a id="6471" href="Agda.Builtin.Nat.html#177" data-type="Type" class="Datatype">Nat</a><a id="6474" class="Symbol">)</a> <a id="6476" class="Symbol">(</a><a id="6477" href="Data.Int.html#6477" class="Bound">x</a> <a id="6479" class="Symbol">:</a> <a id="6481" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a><a id="6484" class="Symbol">)</a> <a id="6486" class="Symbol">→</a> <a id="6488" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="6493" href="Data.Int.html#6465" class="Bound">a</a> <a id="6495" href="Data.Int.html#6467" class="Bound">b</a> <a id="6497" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="6499" href="Data.Int.html#6477" class="Bound">x</a> <a id="6501" class="Symbol">→</a> <a id="6503" href="Data.Int.html#5871" data-type="Nat → Nat → Int → Type" class="Function">Code</a> <a id="6508" href="Data.Int.html#6465" class="Bound">a</a> <a id="6510" href="Data.Int.html#6467" class="Bound">b</a> <a id="6512" href="Data.Int.html#6477" class="Bound">x</a>
  <a id="6516" href="Data.Int.html#6453" data-type="(a b : Nat) (x : Int) → diff a b ≡ x → Code a b x" class="Function">encode</a> <a id="6523" href="Data.Int.html#6523" class="Bound">a</a> <a id="6525" href="Data.Int.html#6525" class="Bound">b</a> <a id="6527" href="Data.Int.html#6527" class="Bound">x</a> <a id="6529" class="Symbol">=</a> <a id="6531" href="1Lab.Path.html#19544" data-type="(P : (y : A) → x ≡ y → Type ℓ₂) → P x refl → (p : x ≡ y) → P y p" class="Function">J</a> <a id="6533" class="Symbol">(λ</a> <a id="6536" href="Data.Int.html#6536" class="Bound">x</a> <a id="6538" href="Data.Int.html#6538" class="Bound">p</a> <a id="6540" class="Symbol">→</a> <a id="6542" href="Data.Int.html#5871" data-type="Nat → Nat → Int → Type" class="Function">Code</a> <a id="6547" href="Data.Int.html#6523" class="Bound">a</a> <a id="6549" href="Data.Int.html#6525" class="Bound">b</a> <a id="6551" href="Data.Int.html#6536" class="Bound">x</a><a id="6552" class="Symbol">)</a> <a id="6554" class="Symbol">(</a><a id="6555" href="Data.Nat.Properties.html#979" data-type="(x y : Nat) → x + y ≡ y + x" class="Function">+-commutative</a> <a id="6569" href="Data.Int.html#6523" class="Bound">a</a> <a id="6571" href="Data.Int.html#6525" class="Bound">b</a><a id="6572" class="Symbol">)</a>
</pre>
<p>As a finishing touch, we give <code>Int</code> instances for
<span class="Agda"><a href="Agda.Builtin.FromNat.html#170" class="Record">Number</a></span>
and
<span class="Agda"><a href="Agda.Builtin.FromNeg.html#170" class="Record">Negative</a></span>,
meaning that we can use positive and negative integer literals to denote
values of
<span class="Agda"><a href="Data.Int.html#643" class="Datatype">Int</a></span>.</p>
<pre class="Agda"><a id="6774" class="Keyword">instance</a>
  <a id="Number-Int"></a><a id="6785" href="Data.Int.html#6785" data-type="Number Int" class="Function">Number-Int</a> <a id="6796" class="Symbol">:</a> <a id="6798" href="Agda.Builtin.FromNat.html#170" data-type="(A : Type a) → Type (lsuc a)" class="Record">Number</a> <a id="6805" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a>
  <a id="6811" href="Data.Int.html#6785" data-type="Number Int" class="Function">Number-Int</a> <a id="6822" class="Symbol">.</a><a id="6823" href="Agda.Builtin.FromNat.html#226" data-type="Number A → Nat → Type a" class="Field">Number.Constraint</a> <a id="6841" class="Symbol">_</a> <a id="6843" class="Symbol">=</a> <a id="6845" href="Agda.Builtin.Unit.html#149" data-type="Type" class="Record">⊤</a>
  <a id="6849" href="Data.Int.html#6785" data-type="Number Int" class="Function">Number-Int</a> <a id="6860" class="Symbol">.</a><a id="6861" href="Agda.Builtin.FromNat.html#255" data-type="(r : Number A) (n : Nat) ⦃ _ : Constraint r n ⦄ → A" class="Field">Number.fromNat</a> <a id="6876" href="Data.Int.html#6876" class="Bound">n</a> <a id="6878" class="Symbol">=</a> <a id="6880" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="6885" href="Data.Int.html#6876" class="Bound">n</a> <a id="6887" class="Number">0</a>

  <a id="Negative-Int"></a><a id="6892" href="Data.Int.html#6892" data-type="Negative Int" class="Function">Negative-Int</a> <a id="6905" class="Symbol">:</a> <a id="6907" href="Agda.Builtin.FromNeg.html#170" data-type="(A : Type a) → Type (lsuc a)" class="Record">Negative</a> <a id="6916" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a>
  <a id="6922" href="Data.Int.html#6892" data-type="Negative Int" class="Function">Negative-Int</a> <a id="6935" class="Symbol">.</a><a id="6936" href="Agda.Builtin.FromNeg.html#228" data-type="Negative A → Nat → Type a" class="Field">Negative.Constraint</a> <a id="6956" class="Symbol">_</a> <a id="6958" class="Symbol">=</a> <a id="6960" href="Agda.Builtin.Unit.html#149" data-type="Type" class="Record">⊤</a>
  <a id="6964" href="Data.Int.html#6892" data-type="Negative Int" class="Function">Negative-Int</a> <a id="6977" class="Symbol">.</a><a id="6978" href="Agda.Builtin.FromNeg.html#257" data-type="(r : Negative A) (n : Nat) ⦃ _ : Constraint r n ⦄ → A" class="Field">Negative.fromNeg</a> <a id="6995" href="Data.Int.html#6995" class="Bound">n</a> <a id="6997" class="Symbol">=</a> <a id="6999" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="7004" class="Number">0</a> <a id="7006" href="Data.Int.html#6995" class="Bound">n</a>
</pre>
<h2 id="canonical-representatives"><a href="#canonical-representatives" class="header-link">Canonical
representatives<span class="header-link-emoji">🔗</span></a></h2>
<p>Initially, we note that the type of integers admits a surjection from
the type
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">N</mi><mo>→</mo><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">\bb{N} \to \bb{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span></span></span></span>,</span>
given by sending each pair of naturals to their <code class="sourceCode agda">difference</code>.</p>
<pre class="Agda"><a id="7221" class="Keyword">private</a>
  <a id="difference-surjection"></a><a id="7231" href="Data.Int.html#7231" class="Function">difference-surjection</a> <a id="7253" class="Symbol">:</a> <a id="7255" class="Symbol">∀</a> <a id="7257" href="Data.Int.html#7257" class="Bound">x</a> <a id="7259" class="Symbol">→</a> <a id="7261" href="1Lab.HIT.Truncation.html#3953" data-type="(A : Type a) (B₁ : A → Type b) → Type (a ⊔ b)" class="Function">∃[</a> <a id="7264" href="Data.Int.html#7264" class="Bound">(</a><a id="7265" href="Data.Int.html#7265" class="Bound">a</a> <a id="7267" href="Data.Int.html#7264" class="InductiveConstructor Operator">,</a> <a id="7269" href="Data.Int.html#7269" class="Bound">b</a><a id="7270" href="Data.Int.html#7264" class="Bound">)</a> <a id="7272" href="1Lab.HIT.Truncation.html#3953" data-type="(A : Type a) (B₁ : A → Type b) → Type (a ⊔ b)" class="Function">∈</a> <a id="7274" href="Agda.Builtin.Nat.html#177" data-type="Type" class="Datatype">Nat</a> <a id="7278" href="1Lab.Type.html#1846" data-type="Type a → Type b → Type (a ⊔ b)" class="Function Operator">×</a> <a id="7280" href="Agda.Builtin.Nat.html#177" data-type="Type" class="Datatype">Nat</a> <a id="7284" href="1Lab.HIT.Truncation.html#3953" data-type="(A : Type a) (B₁ : A → Type b) → Type (a ⊔ b)" class="Function">]</a> <a id="7286" class="Symbol">(</a><a id="7287" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="7292" href="Data.Int.html#7265" class="Bound">a</a> <a id="7294" href="Data.Int.html#7269" class="Bound">b</a> <a id="7296" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="7298" href="Data.Int.html#7257" class="Bound">x</a><a id="7299" class="Symbol">)</a>
  <a id="7303" href="Data.Int.html#7231" class="Function">difference-surjection</a> <a id="7325" class="Symbol">(</a><a id="7326" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="7331" href="Data.Int.html#7331" class="Bound">x</a> <a id="7333" href="Data.Int.html#7333" class="Bound">y</a><a id="7334" class="Symbol">)</a> <a id="7336" class="Symbol">=</a> <a id="7338" href="1Lab.HIT.Truncation.html#774" data-type="A → ∥ A ∥" class="InductiveConstructor">inc</a> <a id="7342" class="Symbol">((</a><a id="7344" href="Data.Int.html#7331" class="Bound">x</a> <a id="7346" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="7348" href="Data.Int.html#7333" class="Bound">y</a><a id="7349" class="Symbol">)</a> <a id="7351" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="7353" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a><a id="7357" class="Symbol">)</a>
  <a id="7361" href="Data.Int.html#7231" class="Function">difference-surjection</a> <a id="7383" class="Symbol">(</a><a id="7384" href="Data.Int.html#689" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="7389" href="Data.Int.html#7389" class="Bound">m</a> <a id="7391" href="Data.Int.html#7391" class="Bound">n</a> <a id="7393" href="Data.Int.html#7393" class="Bound">i</a><a id="7394" class="Symbol">)</a> <a id="7396" class="Symbol">=</a>
    <a id="7402" href="1Lab.HLevel.html#13498" data-type="((i : I) → is-prop (B₁ i)) →
(b0 : B₁ i0) (b1 : B₁ i1) → PathP B₁ b0 b1" class="Function">is-prop→pathp</a>
      <a id="7422" class="Symbol">(λ</a> <a id="7425" href="Data.Int.html#7425" class="Bound">i</a> <a id="7427" class="Symbol">→</a> <a id="7429" href="1Lab.HIT.Truncation.html#795" data-type="is-prop ∥ A ∥" class="InductiveConstructor">∥_∥.squash</a> <a id="7440" class="Symbol">{</a><a id="7441" class="Argument">A</a> <a id="7443" class="Symbol">=</a> <a id="7445" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">Σ[</a> <a id="7448" href="Data.Int.html#7448" class="Bound">(</a><a id="7449" href="Data.Int.html#7449" class="Bound">a</a> <a id="7451" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="7453" href="Data.Int.html#7453" class="Bound">b</a><a id="7454" href="Data.Int.html#7448" class="Bound">)</a> <a id="7456" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">∈</a> <a id="7458" href="Agda.Builtin.Nat.html#177" data-type="Type" class="Datatype">Nat</a> <a id="7462" href="1Lab.Type.html#1846" data-type="Type a → Type b → Type (a ⊔ b)" class="Function Operator">×</a> <a id="7464" href="Agda.Builtin.Nat.html#177" data-type="Type" class="Datatype">Nat</a> <a id="7468" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">]</a> <a id="7470" class="Symbol">(</a><a id="7471" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="7476" href="Data.Int.html#7449" class="Bound">a</a> <a id="7478" href="Data.Int.html#7453" class="Bound">b</a> <a id="7480" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="7482" href="Data.Int.html#689" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="7487" href="Data.Int.html#7389" class="Bound">m</a> <a id="7489" href="Data.Int.html#7391" class="Bound">n</a> <a id="7491" href="Data.Int.html#7425" class="Bound">i</a><a id="7492" class="Symbol">)})</a>
      <a id="7502" class="Symbol">(</a><a id="7503" href="1Lab.HIT.Truncation.html#774" data-type="A → ∥ A ∥" class="InductiveConstructor">inc</a> <a id="7507" class="Symbol">((</a><a id="7509" href="Data.Int.html#7389" class="Bound">m</a> <a id="7511" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="7513" href="Data.Int.html#7391" class="Bound">n</a><a id="7514" class="Symbol">)</a> <a id="7516" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="7518" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a><a id="7522" class="Symbol">))</a>
      <a id="7531" class="Symbol">(</a><a id="7532" href="1Lab.HIT.Truncation.html#774" data-type="A → ∥ A ∥" class="InductiveConstructor">inc</a> <a id="7536" class="Symbol">((</a><a id="7538" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="7542" href="Data.Int.html#7389" class="Bound">m</a> <a id="7544" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="7546" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="7550" href="Data.Int.html#7391" class="Bound">n</a><a id="7551" class="Symbol">)</a> <a id="7553" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="7555" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a><a id="7559" class="Symbol">))</a>
      <a id="7568" href="Data.Int.html#7393" class="Bound">i</a>
</pre>
<p>What we’ll show is that this surjection actually <em>splits</em>:
Given an integer, we can find out what natural numbers it came from.
Well, not quite: We can find a reduced representation of that
difference. Namely, suppose we’re given the integer
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>−</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a-b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>.</span>
We split by cases:</p>
<ul>
<li>If
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>&lt;</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a &lt; b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>,</span>
then this is the same integer as
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>−</mo><mo stretchy="false">(</mo><mi>b</mi><mo>−</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">0 - (b - a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mclose">)</span></span></span></span>;</span></li>
<li>If
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>&gt;</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a &gt; b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>,</span>
then this is the same integer as
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>−</mo><mi>b</mi><mo stretchy="false">)</mo><mo>−</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">(a - b) - 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>;</span></li>
<li>If
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a = b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>,</span>
then this is the same integer as
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>−</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">0 - 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>.</span></li>
</ul>
<p>A “canonical form” for an integer is a pair of natural numbers that
represent (under
<span class="Agda"><a href="Data.Int.html#662" class="InductiveConstructor">diff</a></span>)
the same integer we started with. The canonicalisation procedure does
the split we described above, appealing to a battery of three lemmas to
prove the equality.</p>
<pre class="Agda"><a id="Canonical"></a><a id="8296" href="Data.Int.html#8296" data-type="Int → Type" class="Function">Canonical</a> <a id="8306" class="Symbol">:</a> <a id="8308" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a> <a id="8312" class="Symbol">→</a> <a id="8314" href="1Lab.Type.html#391" class="Primitive">Type</a>
<a id="8319" href="Data.Int.html#8296" data-type="Int → Type" class="Function">Canonical</a> <a id="8329" href="Data.Int.html#8329" class="Bound">n</a> <a id="8331" class="Symbol">=</a> <a id="8333" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">Σ[</a> <a id="8336" href="Data.Int.html#8336" class="Bound">x</a> <a id="8338" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">∈</a> <a id="8340" href="Agda.Builtin.Nat.html#177" data-type="Type" class="Datatype">Nat</a> <a id="8344" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">]</a> <a id="8346" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">Σ[</a> <a id="8349" href="Data.Int.html#8349" class="Bound">y</a> <a id="8351" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">∈</a> <a id="8353" href="Agda.Builtin.Nat.html#177" data-type="Type" class="Datatype">Nat</a> <a id="8357" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">]</a> <a id="8359" class="Symbol">(</a><a id="8360" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="8365" href="Data.Int.html#8336" class="Bound">x</a> <a id="8367" href="Data.Int.html#8349" class="Bound">y</a> <a id="8369" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="8371" href="Data.Int.html#8329" class="Bound">n</a><a id="8372" class="Symbol">)</a>

<a id="canonicalise"></a><a id="8375" href="Data.Int.html#8375" data-type="(n : Int) → Canonical n" class="Function">canonicalise</a> <a id="8388" class="Symbol">:</a> <a id="8390" class="Symbol">(</a><a id="8391" href="Data.Int.html#8391" class="Bound">n</a> <a id="8393" class="Symbol">:</a> <a id="8395" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a><a id="8398" class="Symbol">)</a> <a id="8400" class="Symbol">→</a> <a id="8402" href="Data.Int.html#8296" data-type="Int → Type" class="Function">Canonical</a> <a id="8412" href="Data.Int.html#8391" class="Bound">n</a>
<a id="8414" href="Data.Int.html#8375" data-type="(n : Int) → Canonical n" class="Function">canonicalise</a> <a id="8427" class="Symbol">=</a> <a id="8429" href="Data.Int.html#12522" data-type="(n : Int) → Canonical n" class="Function">go</a> <a id="8432" class="Keyword">where</a>
  <a id="8440" href="Data.Int.html#8440" data-type="(x y : Nat) → x &lt; y → diff 0 (y - x) ≡ diff x y" class="Function">lemma₁</a> <a id="8447" class="Symbol">:</a> <a id="8449" class="Symbol">∀</a> <a id="8451" href="Data.Int.html#8451" class="Bound">x</a> <a id="8453" href="Data.Int.html#8453" class="Bound">y</a> <a id="8455" class="Symbol">→</a> <a id="8457" href="Data.Int.html#8451" class="Bound">x</a> <a id="8459" href="Data.Nat.Base.html#4034" data-type="Nat → Nat → Type" class="Function Operator">&lt;</a> <a id="8461" href="Data.Int.html#8453" class="Bound">y</a> <a id="8463" class="Symbol">→</a> <a id="8465" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="8470" class="Number">0</a> <a id="8472" class="Symbol">(</a><a id="8473" href="Data.Int.html#8453" class="Bound">y</a> <a id="8475" href="Agda.Builtin.Nat.html#400" data-type="Nat → Nat → Nat" class="Primitive Operator">-</a> <a id="8477" href="Data.Int.html#8451" class="Bound">x</a><a id="8478" class="Symbol">)</a> <a id="8480" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="8482" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="8487" href="Data.Int.html#8451" class="Bound">x</a> <a id="8489" href="Data.Int.html#8453" class="Bound">y</a>
  <a id="8493" href="Data.Int.html#8493" data-type="(x y : Nat) → y &lt; x → diff (x - y) 0 ≡ diff x y" class="Function">lemma₂</a> <a id="8500" class="Symbol">:</a> <a id="8502" class="Symbol">∀</a> <a id="8504" href="Data.Int.html#8504" class="Bound">x</a> <a id="8506" href="Data.Int.html#8506" class="Bound">y</a> <a id="8508" class="Symbol">→</a> <a id="8510" href="Data.Int.html#8506" class="Bound">y</a> <a id="8512" href="Data.Nat.Base.html#4034" data-type="Nat → Nat → Type" class="Function Operator">&lt;</a> <a id="8514" href="Data.Int.html#8504" class="Bound">x</a> <a id="8516" class="Symbol">→</a> <a id="8518" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="8523" class="Symbol">(</a><a id="8524" href="Data.Int.html#8504" class="Bound">x</a> <a id="8526" href="Agda.Builtin.Nat.html#400" data-type="Nat → Nat → Nat" class="Primitive Operator">-</a> <a id="8528" href="Data.Int.html#8506" class="Bound">y</a><a id="8529" class="Symbol">)</a> <a id="8531" class="Number">0</a> <a id="8533" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="8535" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="8540" href="Data.Int.html#8504" class="Bound">x</a> <a id="8542" href="Data.Int.html#8506" class="Bound">y</a>
  <a id="8546" href="Data.Int.html#8546" data-type="(x y : Nat) → x ≡ y → diff 0 0 ≡ diff x y" class="Function">lemma₃</a> <a id="8553" class="Symbol">:</a> <a id="8555" class="Symbol">∀</a> <a id="8557" href="Data.Int.html#8557" class="Bound">x</a> <a id="8559" href="Data.Int.html#8559" class="Bound">y</a> <a id="8561" class="Symbol">→</a> <a id="8563" href="Data.Int.html#8557" class="Bound">x</a> <a id="8565" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="8567" href="Data.Int.html#8559" class="Bound">y</a> <a id="8569" class="Symbol">→</a> <a id="8571" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="8576" class="Number">0</a> <a id="8578" class="Number">0</a>       <a id="8586" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="8588" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="8593" href="Data.Int.html#8557" class="Bound">x</a> <a id="8595" href="Data.Int.html#8559" class="Bound">y</a>

  <a id="8600" href="Data.Int.html#8600" data-type="(x y : Nat) → Canonical (diff x y)" class="Function">work</a> <a id="8605" class="Symbol">:</a> <a id="8607" class="Symbol">∀</a> <a id="8609" href="Data.Int.html#8609" class="Bound">x</a> <a id="8611" href="Data.Int.html#8611" class="Bound">y</a> <a id="8613" class="Symbol">→</a> <a id="8615" href="Data.Int.html#8296" data-type="Int → Type" class="Function">Canonical</a> <a id="8625" class="Symbol">(</a><a id="8626" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="8631" href="Data.Int.html#8609" class="Bound">x</a> <a id="8633" href="Data.Int.html#8611" class="Bound">y</a><a id="8634" class="Symbol">)</a>
  <a id="8638" href="Data.Int.html#8600" data-type="(x y : Nat) → Canonical (diff x y)" class="Function">work</a> <a id="8643" href="Data.Int.html#8643" class="Bound">x</a> <a id="8645" href="Data.Int.html#8645" class="Bound">y</a> <a id="8647" class="Keyword">with</a> <a id="8652" href="Data.Nat.Properties.html#5777" data-type="(x y : Nat) → x &lt; y ⊎ y &lt; x ⊎ x ≡ y" class="Function">≤-split</a> <a id="8660" href="Data.Int.html#8643" class="Bound">x</a> <a id="8662" href="Data.Int.html#8645" class="Bound">y</a>
  <a id="8666" class="Symbol">...</a> <a id="8670" class="Symbol">|</a> <a id="8672" href="Data.Sum.html#669" data-type="A → A ⊎ B₁" class="InductiveConstructor">inl</a> <a id="8676" href="Data.Int.html#8676" class="Bound">p</a>       <a id="8684" class="Symbol">=</a> <a id="8686" class="Number">0</a>     <a id="8692" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="8694" class="Bound">y</a> <a id="8696" href="Agda.Builtin.Nat.html#400" data-type="Nat → Nat → Nat" class="Primitive Operator">-</a> <a id="8698" class="Bound">x</a> <a id="8700" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="8702" href="Data.Int.html#8440" data-type="(x y : Nat) → x &lt; y → diff 0 (y - x) ≡ diff x y" class="Function">lemma₁</a> <a id="8709" class="Bound">x</a> <a id="8711" class="Bound">y</a> <a id="8713" href="Data.Int.html#8676" class="Bound">p</a>
  <a id="8717" class="Symbol">...</a> <a id="8721" class="Symbol">|</a> <a id="8723" href="Data.Sum.html#687" data-type="B₁ → A ⊎ B₁" class="InductiveConstructor">inr</a> <a id="8727" class="Symbol">(</a><a id="8728" href="Data.Sum.html#669" data-type="A → A ⊎ B₁" class="InductiveConstructor">inl</a> <a id="8732" href="Data.Int.html#8732" class="Bound">p</a><a id="8733" class="Symbol">)</a> <a id="8735" class="Symbol">=</a> <a id="8737" class="Bound">x</a> <a id="8739" href="Agda.Builtin.Nat.html#400" data-type="Nat → Nat → Nat" class="Primitive Operator">-</a> <a id="8741" class="Bound">y</a> <a id="8743" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="8745" class="Number">0</a>     <a id="8751" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="8753" href="Data.Int.html#8493" data-type="(x y : Nat) → y &lt; x → diff (x - y) 0 ≡ diff x y" class="Function">lemma₂</a> <a id="8760" class="Bound">x</a> <a id="8762" class="Bound">y</a> <a id="8764" href="Data.Int.html#8732" class="Bound">p</a>
  <a id="8768" class="Symbol">...</a> <a id="8772" class="Symbol">|</a> <a id="8774" href="Data.Sum.html#687" data-type="B₁ → A ⊎ B₁" class="InductiveConstructor">inr</a> <a id="8778" class="Symbol">(</a><a id="8779" href="Data.Sum.html#687" data-type="B₁ → A ⊎ B₁" class="InductiveConstructor">inr</a> <a id="8783" href="Data.Int.html#8783" class="Bound">p</a><a id="8784" class="Symbol">)</a> <a id="8786" class="Symbol">=</a> <a id="8788" class="Number">0</a>     <a id="8794" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="8796" class="Number">0</a>     <a id="8802" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="8804" href="Data.Int.html#8546" data-type="(x y : Nat) → x ≡ y → diff 0 0 ≡ diff x y" class="Function">lemma₃</a> <a id="8811" class="Bound">x</a> <a id="8813" class="Bound">y</a> <a id="8815" href="Data.Int.html#8783" class="Bound">p</a>
</pre>
<p>It remains to show that the procedure
<span class="Agda"><a href="Data.Int.html#8600" class="Function">work</a></span>
respects the quotient. This is a truly gargantuan amount of work, and so
it’s omitted from this page. You can unfold it below if you dare:</p>
<details>
<summary>
No, really, it’s quite ugly.
</summary>
<pre class="Agda">  <a id="9083" class="Comment">-- I commend your bravery in unfolding this &lt;details&gt;! These three</a>
  <a id="9152" class="Comment">-- lemmas are inductively defined on the natural numbers in a way that</a>
  <a id="9225" class="Comment">-- lets us prove that the paths they return respect the Int quotient</a>
  <a id="9296" class="Comment">-- without using that Int is a set (because we don&#39;t know that yet!)</a>

  <a id="9368" href="Data.Int.html#8440" data-type="(x y : Nat) → x &lt; y → diff 0 (y - x) ≡ diff x y" class="Function">lemma₁</a> <a id="9375" href="Agda.Builtin.Nat.html#195" data-type="Nat" class="InductiveConstructor">zero</a> <a id="9380" class="Symbol">(</a><a id="9381" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="9385" href="Data.Int.html#9385" class="Bound">y</a><a id="9386" class="Symbol">)</a> <a id="9388" href="Data.Int.html#9388" class="Bound">p</a>    <a id="9393" class="Symbol">=</a> <a id="9395" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
  <a id="9402" href="Data.Int.html#8440" data-type="(x y : Nat) → x &lt; y → diff 0 (y - x) ≡ diff x y" class="Function">lemma₁</a> <a id="9409" class="Symbol">(</a><a id="9410" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="9414" href="Data.Int.html#9414" class="Bound">x</a><a id="9415" class="Symbol">)</a> <a id="9417" class="Symbol">(</a><a id="9418" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="9422" href="Data.Int.html#9422" class="Bound">y</a><a id="9423" class="Symbol">)</a> <a id="9425" href="Data.Int.html#9425" class="Bound">p</a> <a id="9427" class="Symbol">=</a> <a id="9429" href="Data.Int.html#8440" data-type="(x y : Nat) → x &lt; y → diff 0 (y - x) ≡ diff x y" class="Function">lemma₁</a> <a id="9436" href="Data.Int.html#9414" class="Bound">x</a> <a id="9438" href="Data.Int.html#9422" class="Bound">y</a> <a id="9440" href="Data.Int.html#9425" class="Bound">p</a> <a id="9442" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="9444" href="Data.Int.html#689" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">Int.quot</a> <a id="9453" href="Data.Int.html#9414" class="Bound">x</a> <a id="9455" href="Data.Int.html#9422" class="Bound">y</a>

  <a id="9460" href="Data.Int.html#8493" data-type="(x y : Nat) → y &lt; x → diff (x - y) 0 ≡ diff x y" class="Function">lemma₂</a> <a id="9467" class="Symbol">(</a><a id="9468" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="9472" href="Data.Int.html#9472" class="Bound">x</a><a id="9473" class="Symbol">)</a> <a id="9475" href="Agda.Builtin.Nat.html#195" data-type="Nat" class="InductiveConstructor">zero</a> <a id="9480" href="Data.Int.html#9480" class="Bound">p</a>    <a id="9485" class="Symbol">=</a> <a id="9487" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
  <a id="9494" href="Data.Int.html#8493" data-type="(x y : Nat) → y &lt; x → diff (x - y) 0 ≡ diff x y" class="Function">lemma₂</a> <a id="9501" class="Symbol">(</a><a id="9502" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="9506" href="Data.Int.html#9506" class="Bound">x</a><a id="9507" class="Symbol">)</a> <a id="9509" class="Symbol">(</a><a id="9510" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="9514" href="Data.Int.html#9514" class="Bound">y</a><a id="9515" class="Symbol">)</a> <a id="9517" href="Data.Int.html#9517" class="Bound">p</a> <a id="9519" class="Symbol">=</a> <a id="9521" href="Data.Int.html#8493" data-type="(x y : Nat) → y &lt; x → diff (x - y) 0 ≡ diff x y" class="Function">lemma₂</a> <a id="9528" href="Data.Int.html#9506" class="Bound">x</a> <a id="9530" href="Data.Int.html#9514" class="Bound">y</a> <a id="9532" href="Data.Int.html#9517" class="Bound">p</a> <a id="9534" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="9536" href="Data.Int.html#689" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">Int.quot</a> <a id="9545" href="Data.Int.html#9506" class="Bound">x</a> <a id="9547" href="Data.Int.html#9514" class="Bound">y</a>

  <a id="9552" href="Data.Int.html#8546" data-type="(x y : Nat) → x ≡ y → diff 0 0 ≡ diff x y" class="Function">lemma₃</a> <a id="9559" href="Agda.Builtin.Nat.html#195" data-type="Nat" class="InductiveConstructor">zero</a> <a id="9564" href="Agda.Builtin.Nat.html#195" data-type="Nat" class="InductiveConstructor">zero</a> <a id="9569" href="Data.Int.html#9569" class="Bound">p</a>       <a id="9577" class="Symbol">=</a> <a id="9579" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
  <a id="9586" href="Data.Int.html#8546" data-type="(x y : Nat) → x ≡ y → diff 0 0 ≡ diff x y" class="Function">lemma₃</a> <a id="9593" href="Agda.Builtin.Nat.html#195" data-type="Nat" class="InductiveConstructor">zero</a> <a id="9598" class="Symbol">(</a><a id="9599" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="9603" href="Data.Int.html#9603" class="Bound">y</a><a id="9604" class="Symbol">)</a> <a id="9606" href="Data.Int.html#9606" class="Bound">p</a>    <a id="9611" class="Symbol">=</a> <a id="9613" href="1Lab.Type.html#1352" data-type="⊥ → A" class="Function">absurd</a> <a id="9620" class="Symbol">(</a><a id="9621" href="Data.Nat.Base.html#1178" data-type="zero ≡ suc n → ⊥" class="Function">zero≠suc</a> <a id="9630" href="Data.Int.html#9606" class="Bound">p</a><a id="9631" class="Symbol">)</a>
  <a id="9635" href="Data.Int.html#8546" data-type="(x y : Nat) → x ≡ y → diff 0 0 ≡ diff x y" class="Function">lemma₃</a> <a id="9642" class="Symbol">(</a><a id="9643" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="9647" href="Data.Int.html#9647" class="Bound">x</a><a id="9648" class="Symbol">)</a> <a id="9650" href="Agda.Builtin.Nat.html#195" data-type="Nat" class="InductiveConstructor">zero</a> <a id="9655" href="Data.Int.html#9655" class="Bound">p</a>    <a id="9660" class="Symbol">=</a> <a id="9662" href="1Lab.Type.html#1352" data-type="⊥ → A" class="Function">absurd</a> <a id="9669" class="Symbol">(</a><a id="9670" href="Data.Nat.Base.html#1178" data-type="zero ≡ suc n → ⊥" class="Function">zero≠suc</a> <a id="9679" class="Symbol">(</a><a id="9680" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="9684" href="Data.Int.html#9655" class="Bound">p</a><a id="9685" class="Symbol">))</a>
  <a id="9690" href="Data.Int.html#8546" data-type="(x y : Nat) → x ≡ y → diff 0 0 ≡ diff x y" class="Function">lemma₃</a> <a id="9697" class="Symbol">(</a><a id="9698" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="9702" href="Data.Int.html#9702" class="Bound">x</a><a id="9703" class="Symbol">)</a> <a id="9705" class="Symbol">(</a><a id="9706" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="9710" href="Data.Int.html#9710" class="Bound">y</a><a id="9711" class="Symbol">)</a> <a id="9713" href="Data.Int.html#9713" class="Bound">p</a> <a id="9715" class="Symbol">=</a> <a id="9717" href="Data.Int.html#8546" data-type="(x y : Nat) → x ≡ y → diff 0 0 ≡ diff x y" class="Function">lemma₃</a> <a id="9724" href="Data.Int.html#9702" class="Bound">x</a> <a id="9726" href="Data.Int.html#9710" class="Bound">y</a> <a id="9728" class="Symbol">(</a><a id="9729" href="Data.Nat.Base.html#1668" data-type="suc x ≡ suc y → x ≡ y" class="Function">suc-inj</a> <a id="9737" href="Data.Int.html#9713" class="Bound">p</a><a id="9738" class="Symbol">)</a> <a id="9740" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="9742" href="Data.Int.html#689" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">Int.quot</a> <a id="9751" href="Data.Int.html#9702" class="Bound">x</a> <a id="9753" href="Data.Int.html#9710" class="Bound">y</a>

  <a id="9758" class="Keyword">abstract</a>
    <a id="9771" href="Data.Int.html#9771" data-type="(x y : Nat) →
PathP (λ i → Canonical (quot x y i)) (work x y)
(work (suc x) (suc y))" class="Function">work-respects-quot</a>
      <a id="9796" class="Symbol">:</a> <a id="9798" class="Symbol">∀</a> <a id="9800" href="Data.Int.html#9800" class="Bound">x</a> <a id="9802" href="Data.Int.html#9802" class="Bound">y</a> <a id="9804" class="Symbol">→</a> <a id="9806" href="Agda.Primitive.Cubical.html#2013" class="Postulate">PathP</a> <a id="9812" class="Symbol">(λ</a> <a id="9815" href="Data.Int.html#9815" class="Bound">i</a> <a id="9817" class="Symbol">→</a> <a id="9819" href="Data.Int.html#8296" data-type="Int → Type" class="Function">Canonical</a> <a id="9829" class="Symbol">(</a><a id="9830" href="Data.Int.html#689" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">Int.quot</a> <a id="9839" href="Data.Int.html#9800" class="Bound">x</a> <a id="9841" href="Data.Int.html#9802" class="Bound">y</a> <a id="9843" href="Data.Int.html#9815" class="Bound">i</a><a id="9844" class="Symbol">))</a>
        <a id="9855" class="Symbol">(</a><a id="9856" href="Data.Int.html#8600" data-type="(x y : Nat) → Canonical (diff x y)" class="Function">work</a> <a id="9861" href="Data.Int.html#9800" class="Bound">x</a> <a id="9863" href="Data.Int.html#9802" class="Bound">y</a><a id="9864" class="Symbol">)</a>
        <a id="9874" class="Symbol">(</a><a id="9875" href="Data.Int.html#8600" data-type="(x y : Nat) → Canonical (diff x y)" class="Function">work</a> <a id="9880" class="Symbol">(</a><a id="9881" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="9885" href="Data.Int.html#9800" class="Bound">x</a><a id="9886" class="Symbol">)</a> <a id="9888" class="Symbol">(</a><a id="9889" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="9893" href="Data.Int.html#9802" class="Bound">y</a><a id="9894" class="Symbol">))</a>
    <a id="9901" class="Comment">-- We split on (x, y) but also (1+x,1+y). This is obviously</a>
    <a id="9965" class="Comment">-- redundant to a human, but to Agda, we must do this: there is no</a>
    <a id="10036" class="Comment">-- link between these two splits.</a>

    <a id="10075" class="Comment">-- These first three cases basically mirror the definition of</a>
    <a id="10141" class="Comment">-- lemma₁, lemma₂, and lemma₃. They show that</a>
    <a id="10191" class="Comment">--    lemma₁₂₃ (suc x) (suc y) p ≡ lemma₁₂₃ (suc x) (suc y) p&#39; ∙ Int.quot x y</a>
    <a id="10273" class="Comment">-- but mediating between SquareP, ··, and ∙.</a>
    <a id="10322" href="Data.Int.html#9771" data-type="(x y : Nat) →
PathP (λ i → Canonical (quot x y i)) (work x y)
(work (suc x) (suc y))" class="Function">work-respects-quot</a> <a id="10341" href="Data.Int.html#10341" class="Bound">x</a> <a id="10343" href="Data.Int.html#10343" class="Bound">y</a> <a id="10345" class="Keyword">with</a> <a id="10350" href="Data.Nat.Properties.html#5777" data-type="(x y : Nat) → x &lt; y ⊎ y &lt; x ⊎ x ≡ y" class="Function">≤-split</a> <a id="10358" href="Data.Int.html#10341" class="Bound">x</a> <a id="10360" href="Data.Int.html#10343" class="Bound">y</a> <a id="10362" class="Symbol">|</a> <a id="10364" href="Data.Nat.Properties.html#5777" data-type="(x y : Nat) → x &lt; y ⊎ y &lt; x ⊎ x ≡ y" class="Function">≤-split</a> <a id="10372" class="Symbol">(</a><a id="10373" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="10377" href="Data.Int.html#10341" class="Bound">x</a><a id="10378" class="Symbol">)</a> <a id="10380" class="Symbol">(</a><a id="10381" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="10385" href="Data.Int.html#10343" class="Bound">y</a><a id="10386" class="Symbol">)</a>
    <a id="10392" class="Symbol">...</a> <a id="10396" class="Symbol">|</a> <a id="10398" href="Data.Sum.html#669" data-type="A → A ⊎ B₁" class="InductiveConstructor">inl</a> <a id="10402" href="Data.Int.html#10402" class="Bound">x&lt;y</a> <a id="10406" class="Symbol">|</a> <a id="10408" href="Data.Sum.html#669" data-type="A → A ⊎ B₁" class="InductiveConstructor">inl</a> <a id="10412" href="Data.Int.html#10412" class="Bound">x&lt;y&#39;</a> <a id="10417" class="Symbol">=</a>
      <a id="10425" href="1Lab.Type.Sigma.html#7959" data-type="(p : PathP A (x .fst) (y .fst)) →
PathP (λ i → B₁ i (p i)) (x .snd) (y .snd) →
PathP (λ i → Σ (B₁ i)) x y" class="Function">Σ-pathp-dep</a> <a id="10437" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="10442" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="10444" href="1Lab.Type.Sigma.html#7959" data-type="(p : PathP A (x .fst) (y .fst)) →
PathP (λ i → B₁ i (p i)) (x .snd) (y .snd) →
PathP (λ i → Σ (B₁ i)) x y" class="Function">Σ-pathp-dep</a> <a id="10456" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="10461" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="10463" href="1Lab.Path.html#11776" data-type="A ≡ B₁ → A → B₁" class="Function">transport</a> <a id="10473" class="Symbol">(</a><a id="10474" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="10478" href="1Lab.Path.html#62329" data-type="Square p q s r ≡ ((sym p ·· q ·· r) ≡ s)" class="Function">Square≡double-composite-path</a><a id="10506" class="Symbol">)</a> <a id="10508" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a>
          <a id="10520" href="1Lab.Path.html#63044" data-type="(p : x ≡ y) (q : y ≡ z) (r : z ≡ w) → (p ·· q ·· r) ≡ p ∙ q ∙ r" class="Function">double-composite</a> <a id="10537" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="10542" class="Symbol">_</a> <a id="10544" class="Symbol">_</a>
        <a id="10554" href="1Lab.Path.html#38293" data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" class="Function Operator">··</a> <a id="10557" href="1Lab.Path.Groupoid.html#4623" data-type="(p : x ≡ y) → refl ∙ p ≡ p" class="Function">∙-id-l</a> <a id="10564" class="Symbol">_</a>
        <a id="10574" href="1Lab.Path.html#38293" data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" class="Function Operator">··</a> <a id="10577" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="10580" class="Symbol">(λ</a> <a id="10583" href="Data.Int.html#10583" class="Bound">e</a> <a id="10585" class="Symbol">→</a> <a id="10587" href="Data.Int.html#8440" data-type="(x y : Nat) → x &lt; y → diff 0 (y - x) ≡ diff x y" class="Function">lemma₁</a> <a id="10594" class="Bound">x</a> <a id="10596" class="Bound">y</a> <a id="10598" href="Data.Int.html#10583" class="Bound">e</a> <a id="10600" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="10602" href="Data.Int.html#689" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">Int.quot</a> <a id="10611" class="Bound">x</a> <a id="10613" class="Bound">y</a><a id="10614" class="Symbol">)</a> <a id="10616" class="Symbol">(</a><a id="10617" href="Data.Nat.Base.html#4913" data-type="(x y : Nat) → is-prop (x ≤ y)" class="Function">≤-prop</a> <a id="10624" class="Symbol">(</a><a id="10625" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="10629" class="Bound">x</a><a id="10630" class="Symbol">)</a> <a id="10632" class="Bound">y</a> <a id="10634" href="Data.Int.html#10402" class="Bound">x&lt;y</a> <a id="10638" href="Data.Int.html#10412" class="Bound">x&lt;y&#39;</a><a id="10642" class="Symbol">)</a>
    <a id="10648" class="Symbol">...</a> <a id="10652" class="Symbol">|</a> <a id="10654" href="Data.Sum.html#687" data-type="B₁ → A ⊎ B₁" class="InductiveConstructor">inr</a> <a id="10658" class="Symbol">(</a><a id="10659" href="Data.Sum.html#669" data-type="A → A ⊎ B₁" class="InductiveConstructor">inl</a> <a id="10663" href="Data.Int.html#10663" class="Bound">x&gt;y</a><a id="10666" class="Symbol">)</a> <a id="10668" class="Symbol">|</a> <a id="10670" href="Data.Sum.html#687" data-type="B₁ → A ⊎ B₁" class="InductiveConstructor">inr</a> <a id="10674" class="Symbol">(</a><a id="10675" href="Data.Sum.html#669" data-type="A → A ⊎ B₁" class="InductiveConstructor">inl</a> <a id="10679" href="Data.Int.html#10679" class="Bound">x&gt;y&#39;</a><a id="10683" class="Symbol">)</a> <a id="10685" class="Symbol">=</a>
      <a id="10693" href="1Lab.Type.Sigma.html#7959" data-type="(p : PathP A (x .fst) (y .fst)) →
PathP (λ i → B₁ i (p i)) (x .snd) (y .snd) →
PathP (λ i → Σ (B₁ i)) x y" class="Function">Σ-pathp-dep</a> <a id="10705" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="10710" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="10712" href="1Lab.Type.Sigma.html#7959" data-type="(p : PathP A (x .fst) (y .fst)) →
PathP (λ i → B₁ i (p i)) (x .snd) (y .snd) →
PathP (λ i → Σ (B₁ i)) x y" class="Function">Σ-pathp-dep</a> <a id="10724" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="10729" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="10731" href="1Lab.Path.html#11776" data-type="A ≡ B₁ → A → B₁" class="Function">transport</a> <a id="10741" class="Symbol">(</a><a id="10742" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="10746" href="1Lab.Path.html#62329" data-type="Square p q s r ≡ ((sym p ·· q ·· r) ≡ s)" class="Function">Square≡double-composite-path</a><a id="10774" class="Symbol">)</a> <a id="10776" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a>
          <a id="10788" href="1Lab.Path.html#63044" data-type="(p : x ≡ y) (q : y ≡ z) (r : z ≡ w) → (p ·· q ·· r) ≡ p ∙ q ∙ r" class="Function">double-composite</a> <a id="10805" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="10810" class="Symbol">_</a> <a id="10812" class="Symbol">_</a>
        <a id="10822" href="1Lab.Path.html#38293" data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" class="Function Operator">··</a> <a id="10825" href="1Lab.Path.Groupoid.html#4623" data-type="(p : x ≡ y) → refl ∙ p ≡ p" class="Function">∙-id-l</a> <a id="10832" class="Symbol">_</a>
        <a id="10842" href="1Lab.Path.html#38293" data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" class="Function Operator">··</a> <a id="10845" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="10848" class="Symbol">(λ</a> <a id="10851" href="Data.Int.html#10851" class="Bound">e</a> <a id="10853" class="Symbol">→</a> <a id="10855" href="Data.Int.html#8493" data-type="(x y : Nat) → y &lt; x → diff (x - y) 0 ≡ diff x y" class="Function">lemma₂</a> <a id="10862" class="Bound">x</a> <a id="10864" class="Bound">y</a> <a id="10866" href="Data.Int.html#10851" class="Bound">e</a> <a id="10868" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="10870" href="Data.Int.html#689" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">Int.quot</a> <a id="10879" class="Bound">x</a> <a id="10881" class="Bound">y</a><a id="10882" class="Symbol">)</a> <a id="10884" class="Symbol">(</a><a id="10885" href="Data.Nat.Base.html#4913" data-type="(x y : Nat) → is-prop (x ≤ y)" class="Function">≤-prop</a> <a id="10892" class="Symbol">(</a><a id="10893" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="10897" class="Bound">y</a><a id="10898" class="Symbol">)</a> <a id="10900" class="Bound">x</a> <a id="10902" href="Data.Int.html#10663" class="Bound">x&gt;y</a> <a id="10906" href="Data.Int.html#10679" class="Bound">x&gt;y&#39;</a><a id="10910" class="Symbol">)</a>
    <a id="10916" class="Symbol">...</a> <a id="10920" class="Symbol">|</a> <a id="10922" href="Data.Sum.html#687" data-type="B₁ → A ⊎ B₁" class="InductiveConstructor">inr</a> <a id="10926" class="Symbol">(</a><a id="10927" href="Data.Sum.html#687" data-type="B₁ → A ⊎ B₁" class="InductiveConstructor">inr</a> <a id="10931" href="Data.Int.html#10931" class="Bound">x≡y</a><a id="10934" class="Symbol">)</a> <a id="10936" class="Symbol">|</a> <a id="10938" href="Data.Sum.html#687" data-type="B₁ → A ⊎ B₁" class="InductiveConstructor">inr</a> <a id="10942" class="Symbol">(</a><a id="10943" href="Data.Sum.html#687" data-type="B₁ → A ⊎ B₁" class="InductiveConstructor">inr</a> <a id="10947" href="Data.Int.html#10947" class="Bound">x≡y&#39;</a><a id="10951" class="Symbol">)</a> <a id="10953" class="Symbol">=</a>
      <a id="10961" href="1Lab.Type.Sigma.html#7959" data-type="(p : PathP A (x .fst) (y .fst)) →
PathP (λ i → B₁ i (p i)) (x .snd) (y .snd) →
PathP (λ i → Σ (B₁ i)) x y" class="Function">Σ-pathp-dep</a> <a id="10973" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="10978" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="10980" href="1Lab.Type.Sigma.html#7959" data-type="(p : PathP A (x .fst) (y .fst)) →
PathP (λ i → B₁ i (p i)) (x .snd) (y .snd) →
PathP (λ i → Σ (B₁ i)) x y" class="Function">Σ-pathp-dep</a> <a id="10992" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="10997" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="10999" href="1Lab.Path.html#11776" data-type="A ≡ B₁ → A → B₁" class="Function">transport</a> <a id="11009" class="Symbol">(</a><a id="11010" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="11014" href="1Lab.Path.html#62329" data-type="Square p q s r ≡ ((sym p ·· q ·· r) ≡ s)" class="Function">Square≡double-composite-path</a><a id="11042" class="Symbol">)</a> <a id="11044" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a>
          <a id="11056" href="1Lab.Path.html#63044" data-type="(p : x ≡ y) (q : y ≡ z) (r : z ≡ w) → (p ·· q ·· r) ≡ p ∙ q ∙ r" class="Function">double-composite</a> <a id="11073" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="11078" class="Symbol">_</a> <a id="11080" class="Symbol">_</a>
        <a id="11090" href="1Lab.Path.html#38293" data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" class="Function Operator">··</a> <a id="11093" href="1Lab.Path.Groupoid.html#4623" data-type="(p : x ≡ y) → refl ∙ p ≡ p" class="Function">∙-id-l</a> <a id="11100" class="Symbol">_</a>
        <a id="11110" href="1Lab.Path.html#38293" data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" class="Function Operator">··</a> <a id="11113" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="11116" class="Symbol">(λ</a> <a id="11119" href="Data.Int.html#11119" class="Bound">e</a> <a id="11121" class="Symbol">→</a> <a id="11123" href="Data.Int.html#8546" data-type="(x y : Nat) → x ≡ y → diff 0 0 ≡ diff x y" class="Function">lemma₃</a> <a id="11130" class="Bound">x</a> <a id="11132" class="Bound">y</a> <a id="11134" href="Data.Int.html#11119" class="Bound">e</a> <a id="11136" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="11138" href="Data.Int.html#689" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">Int.quot</a> <a id="11147" class="Bound">x</a> <a id="11149" class="Bound">y</a><a id="11150" class="Symbol">)</a> <a id="11152" class="Symbol">(</a><a id="11153" href="Data.Nat.Base.html#2563" data-type="is-set Nat" class="Function">Nat-is-set</a> <a id="11164" class="Symbol">_</a> <a id="11166" class="Symbol">_</a> <a id="11168" class="Symbol">_</a> <a id="11170" class="Symbol">_)</a>

    <a id="11178" class="Comment">-- This *barrage* of cases is to handle the cases where e.g. (x &lt; y)</a>
    <a id="11251" class="Comment">-- but (1 + x &gt; 1 + y), which is &quot;obviously&quot; impossible. But Agda</a>
    <a id="11321" class="Comment">-- doesn&#39;t care about what humans think is obvious.</a>
    <a id="11377" class="Symbol">...</a> <a id="11381" class="Symbol">|</a> <a id="11383" href="Data.Sum.html#669" data-type="A → A ⊎ B₁" class="InductiveConstructor">inl</a> <a id="11387" href="Data.Int.html#11387" class="Bound">x&lt;y</a> <a id="11391" class="Symbol">|</a> <a id="11393" href="Data.Sum.html#687" data-type="B₁ → A ⊎ B₁" class="InductiveConstructor">inr</a> <a id="11397" class="Symbol">(</a><a id="11398" href="Data.Sum.html#669" data-type="A → A ⊎ B₁" class="InductiveConstructor">inl</a> <a id="11402" href="Data.Int.html#11402" class="Bound">x&gt;y</a><a id="11405" class="Symbol">)</a> <a id="11407" class="Symbol">=</a> <a id="11409" href="1Lab.Type.html#1352" data-type="⊥ → A" class="Function">absurd</a> <a id="11416" class="Symbol">(</a><a id="11417" href="Data.Int.html#11445" data-type="(x y : Nat) →
suc x ≤ y → suc y ≤ x → (x₁ y₁ : Nat) → x₁ &lt; y₁ → y₁ &lt; x₁ → ⊥" class="Function">go</a> <a id="11420" class="Bound">x</a> <a id="11422" class="Bound">y</a> <a id="11424" href="Data.Int.html#11387" class="Bound">x&lt;y</a> <a id="11428" href="Data.Int.html#11402" class="Bound">x&gt;y</a><a id="11431" class="Symbol">)</a> <a id="11433" class="Keyword">where</a>
      <a id="11445" href="Data.Int.html#11445" data-type="(x y : Nat) →
suc x ≤ y → suc y ≤ x → (x₁ y₁ : Nat) → x₁ &lt; y₁ → y₁ &lt; x₁ → ⊥" class="Function">go</a> <a id="11448" class="Symbol">:</a> <a id="11450" class="Symbol">∀</a> <a id="11452" href="Data.Int.html#11452" class="Bound">x</a> <a id="11454" href="Data.Int.html#11454" class="Bound">y</a> <a id="11456" class="Symbol">→</a> <a id="11458" href="Data.Int.html#11452" class="Bound">x</a> <a id="11460" href="Data.Nat.Base.html#4034" data-type="Nat → Nat → Type" class="Function Operator">&lt;</a> <a id="11462" href="Data.Int.html#11454" class="Bound">y</a> <a id="11464" class="Symbol">→</a> <a id="11466" href="Data.Int.html#11454" class="Bound">y</a> <a id="11468" href="Data.Nat.Base.html#4034" data-type="Nat → Nat → Type" class="Function Operator">&lt;</a> <a id="11470" href="Data.Int.html#11452" class="Bound">x</a> <a id="11472" class="Symbol">→</a> <a id="11474" href="1Lab.Type.html#1336" data-type="Type" class="Datatype">⊥</a>
      <a id="11482" href="Data.Int.html#11445" data-type="(x y : Nat) →
suc x ≤ y → suc y ≤ x → (x₁ y₁ : Nat) → x₁ &lt; y₁ → y₁ &lt; x₁ → ⊥" class="Function">go</a> <a id="11485" class="Symbol">(</a><a id="11486" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="11490" href="Data.Int.html#11490" class="Bound">x</a><a id="11491" class="Symbol">)</a> <a id="11493" class="Symbol">(</a><a id="11494" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="11498" href="Data.Int.html#11498" class="Bound">y</a><a id="11499" class="Symbol">)</a> <a id="11501" href="Data.Int.html#11501" class="Bound">p</a> <a id="11503" href="Data.Int.html#11503" class="Bound">q</a> <a id="11505" class="Symbol">=</a> <a id="11507" href="Data.Int.html#11445" data-type="(x y : Nat) →
suc x ≤ y → suc y ≤ x → (x₁ y₁ : Nat) → x₁ &lt; y₁ → y₁ &lt; x₁ → ⊥" class="Function">go</a> <a id="11510" href="Data.Int.html#11490" class="Bound">x</a> <a id="11512" href="Data.Int.html#11498" class="Bound">y</a> <a id="11514" href="Data.Int.html#11501" class="Bound">p</a> <a id="11516" href="Data.Int.html#11503" class="Bound">q</a>
    <a id="11522" class="Symbol">...</a> <a id="11526" class="Symbol">|</a> <a id="11528" href="Data.Sum.html#669" data-type="A → A ⊎ B₁" class="InductiveConstructor">inl</a> <a id="11532" href="Data.Int.html#11532" class="Bound">x&lt;y</a> <a id="11536" class="Symbol">|</a> <a id="11538" href="Data.Sum.html#687" data-type="B₁ → A ⊎ B₁" class="InductiveConstructor">inr</a> <a id="11542" class="Symbol">(</a><a id="11543" href="Data.Sum.html#687" data-type="B₁ → A ⊎ B₁" class="InductiveConstructor">inr</a> <a id="11547" href="Data.Int.html#11547" class="Bound">x≡y</a><a id="11550" class="Symbol">)</a> <a id="11552" class="Symbol">=</a> <a id="11554" href="1Lab.Type.html#1352" data-type="⊥ → A" class="Function">absurd</a> <a id="11561" class="Symbol">(</a><a id="11562" href="Data.Int.html#11600" data-type="(x y : Nat) →
suc x ≤ y → suc x ≡ suc y → (x₁ y₁ : Nat) → x₁ &lt; y₁ → x₁ ≡ y₁ → ⊥" class="Function">go</a> <a id="11565" class="Bound">x</a> <a id="11567" class="Bound">y</a> <a id="11569" href="Data.Int.html#11532" class="Bound">x&lt;y</a> <a id="11573" class="Symbol">(</a><a id="11574" href="Data.Nat.Base.html#1668" data-type="suc x ≡ suc y → x ≡ y" class="Function">suc-inj</a> <a id="11582" href="Data.Int.html#11547" class="Bound">x≡y</a><a id="11585" class="Symbol">))</a> <a id="11588" class="Keyword">where</a>
      <a id="11600" href="Data.Int.html#11600" data-type="(x y : Nat) →
suc x ≤ y → suc x ≡ suc y → (x₁ y₁ : Nat) → x₁ &lt; y₁ → x₁ ≡ y₁ → ⊥" class="Function">go</a> <a id="11603" class="Symbol">:</a> <a id="11605" class="Symbol">∀</a> <a id="11607" href="Data.Int.html#11607" class="Bound">x</a> <a id="11609" href="Data.Int.html#11609" class="Bound">y</a> <a id="11611" class="Symbol">→</a> <a id="11613" href="Data.Int.html#11607" class="Bound">x</a> <a id="11615" href="Data.Nat.Base.html#4034" data-type="Nat → Nat → Type" class="Function Operator">&lt;</a> <a id="11617" href="Data.Int.html#11609" class="Bound">y</a> <a id="11619" class="Symbol">→</a> <a id="11621" href="Data.Int.html#11607" class="Bound">x</a> <a id="11623" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="11625" href="Data.Int.html#11609" class="Bound">y</a> <a id="11627" class="Symbol">→</a> <a id="11629" href="1Lab.Type.html#1336" data-type="Type" class="Datatype">⊥</a>
      <a id="11637" href="Data.Int.html#11600" data-type="(x y : Nat) →
suc x ≤ y → suc x ≡ suc y → (x₁ y₁ : Nat) → x₁ &lt; y₁ → x₁ ≡ y₁ → ⊥" class="Function">go</a> <a id="11640" href="Agda.Builtin.Nat.html#195" data-type="Nat" class="InductiveConstructor">zero</a> <a id="11645" class="Symbol">(</a><a id="11646" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="11650" href="Data.Int.html#11650" class="Bound">y</a><a id="11651" class="Symbol">)</a> <a id="11653" href="Data.Int.html#11653" class="Bound">p</a> <a id="11655" href="Data.Int.html#11655" class="Bound">q</a> <a id="11657" class="Symbol">=</a> <a id="11659" href="1Lab.Type.html#1352" data-type="⊥ → A" class="Function">absurd</a> <a id="11666" class="Symbol">(</a><a id="11667" href="Data.Nat.Base.html#1178" data-type="zero ≡ suc n → ⊥" class="Function">zero≠suc</a> <a id="11676" href="Data.Int.html#11655" class="Bound">q</a><a id="11677" class="Symbol">)</a>
      <a id="11685" href="Data.Int.html#11600" data-type="(x y : Nat) →
suc x ≤ y → suc x ≡ suc y → (x₁ y₁ : Nat) → x₁ &lt; y₁ → x₁ ≡ y₁ → ⊥" class="Function">go</a> <a id="11688" class="Symbol">(</a><a id="11689" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="11693" href="Data.Int.html#11693" class="Bound">x</a><a id="11694" class="Symbol">)</a> <a id="11696" class="Symbol">(</a><a id="11697" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="11701" href="Data.Int.html#11701" class="Bound">y</a><a id="11702" class="Symbol">)</a> <a id="11704" href="Data.Int.html#11704" class="Bound">p</a> <a id="11706" href="Data.Int.html#11706" class="Bound">q</a> <a id="11708" class="Symbol">=</a> <a id="11710" href="Data.Int.html#11600" data-type="(x y : Nat) →
suc x ≤ y → suc x ≡ suc y → (x₁ y₁ : Nat) → x₁ &lt; y₁ → x₁ ≡ y₁ → ⊥" class="Function">go</a> <a id="11713" href="Data.Int.html#11693" class="Bound">x</a> <a id="11715" href="Data.Int.html#11701" class="Bound">y</a> <a id="11717" href="Data.Int.html#11704" class="Bound">p</a> <a id="11719" class="Symbol">(</a><a id="11720" href="Data.Nat.Base.html#1668" data-type="suc x ≡ suc y → x ≡ y" class="Function">suc-inj</a> <a id="11728" href="Data.Int.html#11706" class="Bound">q</a><a id="11729" class="Symbol">)</a>
    <a id="11735" class="Symbol">...</a> <a id="11739" class="Symbol">|</a> <a id="11741" href="Data.Sum.html#687" data-type="B₁ → A ⊎ B₁" class="InductiveConstructor">inr</a> <a id="11745" class="Symbol">(</a><a id="11746" href="Data.Sum.html#669" data-type="A → A ⊎ B₁" class="InductiveConstructor">inl</a> <a id="11750" href="Data.Int.html#11750" class="Bound">x&gt;y</a><a id="11753" class="Symbol">)</a> <a id="11755" class="Symbol">|</a> <a id="11757" href="Data.Sum.html#669" data-type="A → A ⊎ B₁" class="InductiveConstructor">inl</a> <a id="11761" href="Data.Int.html#11761" class="Bound">x&lt;y</a> <a id="11765" class="Symbol">=</a> <a id="11767" href="1Lab.Type.html#1352" data-type="⊥ → A" class="Function">absurd</a> <a id="11774" class="Symbol">(</a><a id="11775" href="Data.Int.html#11803" data-type="(x y : Nat) →
suc y ≤ x → suc x ≤ y → (x₁ y₁ : Nat) → y₁ &lt; x₁ → x₁ &lt; y₁ → ⊥" class="Function">go</a> <a id="11778" class="Bound">x</a> <a id="11780" class="Bound">y</a> <a id="11782" href="Data.Int.html#11750" class="Bound">x&gt;y</a> <a id="11786" href="Data.Int.html#11761" class="Bound">x&lt;y</a><a id="11789" class="Symbol">)</a> <a id="11791" class="Keyword">where</a>
      <a id="11803" href="Data.Int.html#11803" data-type="(x y : Nat) →
suc y ≤ x → suc x ≤ y → (x₁ y₁ : Nat) → y₁ &lt; x₁ → x₁ &lt; y₁ → ⊥" class="Function">go</a> <a id="11806" class="Symbol">:</a> <a id="11808" class="Symbol">∀</a> <a id="11810" href="Data.Int.html#11810" class="Bound">x</a> <a id="11812" href="Data.Int.html#11812" class="Bound">y</a> <a id="11814" class="Symbol">→</a> <a id="11816" href="Data.Int.html#11812" class="Bound">y</a> <a id="11818" href="Data.Nat.Base.html#4034" data-type="Nat → Nat → Type" class="Function Operator">&lt;</a> <a id="11820" href="Data.Int.html#11810" class="Bound">x</a> <a id="11822" class="Symbol">→</a> <a id="11824" href="Data.Int.html#11810" class="Bound">x</a> <a id="11826" href="Data.Nat.Base.html#4034" data-type="Nat → Nat → Type" class="Function Operator">&lt;</a> <a id="11828" href="Data.Int.html#11812" class="Bound">y</a> <a id="11830" class="Symbol">→</a> <a id="11832" href="1Lab.Type.html#1336" data-type="Type" class="Datatype">⊥</a>
      <a id="11840" href="Data.Int.html#11803" data-type="(x y : Nat) →
suc y ≤ x → suc x ≤ y → (x₁ y₁ : Nat) → y₁ &lt; x₁ → x₁ &lt; y₁ → ⊥" class="Function">go</a> <a id="11843" class="Symbol">(</a><a id="11844" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="11848" href="Data.Int.html#11848" class="Bound">x</a><a id="11849" class="Symbol">)</a> <a id="11851" class="Symbol">(</a><a id="11852" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="11856" href="Data.Int.html#11856" class="Bound">y</a><a id="11857" class="Symbol">)</a> <a id="11859" href="Data.Int.html#11859" class="Bound">p</a> <a id="11861" href="Data.Int.html#11861" class="Bound">q</a> <a id="11863" class="Symbol">=</a> <a id="11865" href="Data.Int.html#11803" data-type="(x y : Nat) →
suc y ≤ x → suc x ≤ y → (x₁ y₁ : Nat) → y₁ &lt; x₁ → x₁ &lt; y₁ → ⊥" class="Function">go</a> <a id="11868" href="Data.Int.html#11848" class="Bound">x</a> <a id="11870" href="Data.Int.html#11856" class="Bound">y</a> <a id="11872" href="Data.Int.html#11859" class="Bound">p</a> <a id="11874" href="Data.Int.html#11861" class="Bound">q</a>
    <a id="11880" class="Symbol">...</a> <a id="11884" class="Symbol">|</a> <a id="11886" href="Data.Sum.html#687" data-type="B₁ → A ⊎ B₁" class="InductiveConstructor">inr</a> <a id="11890" class="Symbol">(</a><a id="11891" href="Data.Sum.html#687" data-type="B₁ → A ⊎ B₁" class="InductiveConstructor">inr</a> <a id="11895" href="Data.Int.html#11895" class="Bound">x≡y</a><a id="11898" class="Symbol">)</a> <a id="11900" class="Symbol">|</a> <a id="11902" href="Data.Sum.html#669" data-type="A → A ⊎ B₁" class="InductiveConstructor">inl</a> <a id="11906" href="Data.Int.html#11906" class="Bound">x&lt;y</a> <a id="11910" class="Symbol">=</a> <a id="11912" href="1Lab.Type.html#1352" data-type="⊥ → A" class="Function">absurd</a> <a id="11919" class="Symbol">(</a><a id="11920" href="Data.Int.html#11948" data-type="(x y : Nat) →
x ≡ y → suc x ≤ y → (x₁ y₁ : Nat) → x₁ &lt; y₁ → x₁ ≡ y₁ → ⊥" class="Function">go</a> <a id="11923" class="Bound">x</a> <a id="11925" class="Bound">y</a> <a id="11927" href="Data.Int.html#11906" class="Bound">x&lt;y</a> <a id="11931" href="Data.Int.html#11895" class="Bound">x≡y</a><a id="11934" class="Symbol">)</a> <a id="11936" class="Keyword">where</a>
      <a id="11948" href="Data.Int.html#11948" data-type="(x y : Nat) →
x ≡ y → suc x ≤ y → (x₁ y₁ : Nat) → x₁ &lt; y₁ → x₁ ≡ y₁ → ⊥" class="Function">go</a> <a id="11951" class="Symbol">:</a> <a id="11953" class="Symbol">∀</a> <a id="11955" href="Data.Int.html#11955" class="Bound">x</a> <a id="11957" href="Data.Int.html#11957" class="Bound">y</a> <a id="11959" class="Symbol">→</a> <a id="11961" href="Data.Int.html#11955" class="Bound">x</a> <a id="11963" href="Data.Nat.Base.html#4034" data-type="Nat → Nat → Type" class="Function Operator">&lt;</a> <a id="11965" href="Data.Int.html#11957" class="Bound">y</a> <a id="11967" class="Symbol">→</a> <a id="11969" href="Data.Int.html#11955" class="Bound">x</a> <a id="11971" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="11973" href="Data.Int.html#11957" class="Bound">y</a> <a id="11975" class="Symbol">→</a> <a id="11977" href="1Lab.Type.html#1336" data-type="Type" class="Datatype">⊥</a>
      <a id="11985" href="Data.Int.html#11948" data-type="(x y : Nat) →
x ≡ y → suc x ≤ y → (x₁ y₁ : Nat) → x₁ &lt; y₁ → x₁ ≡ y₁ → ⊥" class="Function">go</a> <a id="11988" href="Agda.Builtin.Nat.html#195" data-type="Nat" class="InductiveConstructor">zero</a> <a id="11993" class="Symbol">(</a><a id="11994" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="11998" href="Data.Int.html#11998" class="Bound">y</a><a id="11999" class="Symbol">)</a> <a id="12001" href="Data.Int.html#12001" class="Bound">p</a> <a id="12003" href="Data.Int.html#12003" class="Bound">q</a> <a id="12005" class="Symbol">=</a> <a id="12007" href="1Lab.Type.html#1352" data-type="⊥ → A" class="Function">absurd</a> <a id="12014" class="Symbol">(</a><a id="12015" href="Data.Nat.Base.html#1178" data-type="zero ≡ suc n → ⊥" class="Function">zero≠suc</a> <a id="12024" href="Data.Int.html#12003" class="Bound">q</a><a id="12025" class="Symbol">)</a>
      <a id="12033" href="Data.Int.html#11948" data-type="(x y : Nat) →
x ≡ y → suc x ≤ y → (x₁ y₁ : Nat) → x₁ &lt; y₁ → x₁ ≡ y₁ → ⊥" class="Function">go</a> <a id="12036" class="Symbol">(</a><a id="12037" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="12041" href="Data.Int.html#12041" class="Bound">x</a><a id="12042" class="Symbol">)</a> <a id="12044" class="Symbol">(</a><a id="12045" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="12049" href="Data.Int.html#12049" class="Bound">y</a><a id="12050" class="Symbol">)</a> <a id="12052" href="Data.Int.html#12052" class="Bound">p</a> <a id="12054" href="Data.Int.html#12054" class="Bound">q</a> <a id="12056" class="Symbol">=</a> <a id="12058" href="Data.Int.html#11948" data-type="(x y : Nat) →
x ≡ y → suc x ≤ y → (x₁ y₁ : Nat) → x₁ &lt; y₁ → x₁ ≡ y₁ → ⊥" class="Function">go</a> <a id="12061" href="Data.Int.html#12041" class="Bound">x</a> <a id="12063" href="Data.Int.html#12049" class="Bound">y</a> <a id="12065" href="Data.Int.html#12052" class="Bound">p</a> <a id="12067" class="Symbol">(</a><a id="12068" href="Data.Nat.Base.html#1668" data-type="suc x ≡ suc y → x ≡ y" class="Function">suc-inj</a> <a id="12076" href="Data.Int.html#12054" class="Bound">q</a><a id="12077" class="Symbol">)</a>
    <a id="12083" class="Symbol">...</a> <a id="12087" class="Symbol">|</a> <a id="12089" href="Data.Sum.html#687" data-type="B₁ → A ⊎ B₁" class="InductiveConstructor">inr</a> <a id="12093" class="Symbol">(</a><a id="12094" href="Data.Sum.html#669" data-type="A → A ⊎ B₁" class="InductiveConstructor">inl</a> <a id="12098" href="Data.Int.html#12098" class="Bound">x&gt;y</a><a id="12101" class="Symbol">)</a> <a id="12103" class="Symbol">|</a> <a id="12105" href="Data.Sum.html#687" data-type="B₁ → A ⊎ B₁" class="InductiveConstructor">inr</a> <a id="12109" class="Symbol">(</a><a id="12110" href="Data.Sum.html#687" data-type="B₁ → A ⊎ B₁" class="InductiveConstructor">inr</a> <a id="12114" href="Data.Int.html#12114" class="Bound">x≡y</a><a id="12117" class="Symbol">)</a> <a id="12119" class="Symbol">=</a> <a id="12121" href="1Lab.Type.html#1352" data-type="⊥ → A" class="Function">absurd</a> <a id="12128" class="Symbol">(</a><a id="12129" href="Data.Int.html#12167" data-type="(x y : Nat) →
suc y ≤ x → suc x ≡ suc y → (x₁ y₁ : Nat) → y₁ &lt; x₁ → x₁ ≡ y₁ → ⊥" class="Function">go</a> <a id="12132" class="Bound">x</a> <a id="12134" class="Bound">y</a> <a id="12136" href="Data.Int.html#12098" class="Bound">x&gt;y</a> <a id="12140" class="Symbol">(</a><a id="12141" href="Data.Nat.Base.html#1668" data-type="suc x ≡ suc y → x ≡ y" class="Function">suc-inj</a> <a id="12149" href="Data.Int.html#12114" class="Bound">x≡y</a><a id="12152" class="Symbol">))</a> <a id="12155" class="Keyword">where</a>
      <a id="12167" href="Data.Int.html#12167" data-type="(x y : Nat) →
suc y ≤ x → suc x ≡ suc y → (x₁ y₁ : Nat) → y₁ &lt; x₁ → x₁ ≡ y₁ → ⊥" class="Function">go</a> <a id="12170" class="Symbol">:</a> <a id="12172" class="Symbol">∀</a> <a id="12174" href="Data.Int.html#12174" class="Bound">x</a> <a id="12176" href="Data.Int.html#12176" class="Bound">y</a> <a id="12178" class="Symbol">→</a> <a id="12180" href="Data.Int.html#12176" class="Bound">y</a> <a id="12182" href="Data.Nat.Base.html#4034" data-type="Nat → Nat → Type" class="Function Operator">&lt;</a> <a id="12184" href="Data.Int.html#12174" class="Bound">x</a> <a id="12186" class="Symbol">→</a> <a id="12188" href="Data.Int.html#12174" class="Bound">x</a> <a id="12190" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="12192" href="Data.Int.html#12176" class="Bound">y</a> <a id="12194" class="Symbol">→</a> <a id="12196" href="1Lab.Type.html#1336" data-type="Type" class="Datatype">⊥</a>
      <a id="12204" href="Data.Int.html#12167" data-type="(x y : Nat) →
suc y ≤ x → suc x ≡ suc y → (x₁ y₁ : Nat) → y₁ &lt; x₁ → x₁ ≡ y₁ → ⊥" class="Function">go</a> <a id="12207" class="Symbol">(</a><a id="12208" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="12212" href="Data.Int.html#12212" class="Bound">x</a><a id="12213" class="Symbol">)</a> <a id="12215" href="Agda.Builtin.Nat.html#195" data-type="Nat" class="InductiveConstructor">zero</a> <a id="12220" href="Data.Int.html#12220" class="Bound">p</a> <a id="12222" href="Data.Int.html#12222" class="Bound">q</a> <a id="12224" class="Symbol">=</a> <a id="12226" href="1Lab.Type.html#1352" data-type="⊥ → A" class="Function">absurd</a> <a id="12233" class="Symbol">(</a><a id="12234" href="Data.Nat.Base.html#1178" data-type="zero ≡ suc n → ⊥" class="Function">zero≠suc</a> <a id="12243" class="Symbol">(</a><a id="12244" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="12248" href="Data.Int.html#12222" class="Bound">q</a><a id="12249" class="Symbol">))</a>
      <a id="12258" href="Data.Int.html#12167" data-type="(x y : Nat) →
suc y ≤ x → suc x ≡ suc y → (x₁ y₁ : Nat) → y₁ &lt; x₁ → x₁ ≡ y₁ → ⊥" class="Function">go</a> <a id="12261" class="Symbol">(</a><a id="12262" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="12266" href="Data.Int.html#12266" class="Bound">x</a><a id="12267" class="Symbol">)</a> <a id="12269" class="Symbol">(</a><a id="12270" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="12274" href="Data.Int.html#12274" class="Bound">y</a><a id="12275" class="Symbol">)</a> <a id="12277" href="Data.Int.html#12277" class="Bound">p</a> <a id="12279" href="Data.Int.html#12279" class="Bound">q</a> <a id="12281" class="Symbol">=</a> <a id="12283" href="Data.Int.html#12167" data-type="(x y : Nat) →
suc y ≤ x → suc x ≡ suc y → (x₁ y₁ : Nat) → y₁ &lt; x₁ → x₁ ≡ y₁ → ⊥" class="Function">go</a> <a id="12286" href="Data.Int.html#12266" class="Bound">x</a> <a id="12288" href="Data.Int.html#12274" class="Bound">y</a> <a id="12290" href="Data.Int.html#12277" class="Bound">p</a> <a id="12292" class="Symbol">(</a><a id="12293" href="Data.Nat.Base.html#1668" data-type="suc x ≡ suc y → x ≡ y" class="Function">suc-inj</a> <a id="12301" href="Data.Int.html#12279" class="Bound">q</a><a id="12302" class="Symbol">)</a>
    <a id="12308" class="Symbol">...</a> <a id="12312" class="Symbol">|</a> <a id="12314" href="Data.Sum.html#687" data-type="B₁ → A ⊎ B₁" class="InductiveConstructor">inr</a> <a id="12318" class="Symbol">(</a><a id="12319" href="Data.Sum.html#687" data-type="B₁ → A ⊎ B₁" class="InductiveConstructor">inr</a> <a id="12323" href="Data.Int.html#12323" class="Bound">x≡y</a><a id="12326" class="Symbol">)</a> <a id="12328" class="Symbol">|</a> <a id="12330" href="Data.Sum.html#687" data-type="B₁ → A ⊎ B₁" class="InductiveConstructor">inr</a> <a id="12334" class="Symbol">(</a><a id="12335" href="Data.Sum.html#669" data-type="A → A ⊎ B₁" class="InductiveConstructor">inl</a> <a id="12339" href="Data.Int.html#12339" class="Bound">x&gt;y</a><a id="12342" class="Symbol">)</a> <a id="12344" class="Symbol">=</a> <a id="12346" href="1Lab.Type.html#1352" data-type="⊥ → A" class="Function">absurd</a> <a id="12353" class="Symbol">(</a><a id="12354" href="Data.Int.html#12382" data-type="(x y : Nat) →
x ≡ y → suc y ≤ x → (x₁ y₁ : Nat) → x₁ ≡ y₁ → y₁ &lt; x₁ → ⊥" class="Function">go</a> <a id="12357" class="Bound">x</a> <a id="12359" class="Bound">y</a> <a id="12361" href="Data.Int.html#12323" class="Bound">x≡y</a> <a id="12365" href="Data.Int.html#12339" class="Bound">x&gt;y</a><a id="12368" class="Symbol">)</a> <a id="12370" class="Keyword">where</a>
      <a id="12382" href="Data.Int.html#12382" data-type="(x y : Nat) →
x ≡ y → suc y ≤ x → (x₁ y₁ : Nat) → x₁ ≡ y₁ → y₁ &lt; x₁ → ⊥" class="Function">go</a> <a id="12385" class="Symbol">:</a> <a id="12387" class="Symbol">∀</a> <a id="12389" href="Data.Int.html#12389" class="Bound">x</a> <a id="12391" href="Data.Int.html#12391" class="Bound">y</a> <a id="12393" class="Symbol">→</a> <a id="12395" href="Data.Int.html#12389" class="Bound">x</a> <a id="12397" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="12399" href="Data.Int.html#12391" class="Bound">y</a> <a id="12401" class="Symbol">→</a> <a id="12403" href="Data.Int.html#12391" class="Bound">y</a> <a id="12405" href="Data.Nat.Base.html#4034" data-type="Nat → Nat → Type" class="Function Operator">&lt;</a> <a id="12407" href="Data.Int.html#12389" class="Bound">x</a> <a id="12409" class="Symbol">→</a> <a id="12411" href="1Lab.Type.html#1336" data-type="Type" class="Datatype">⊥</a>
      <a id="12419" href="Data.Int.html#12382" data-type="(x y : Nat) →
x ≡ y → suc y ≤ x → (x₁ y₁ : Nat) → x₁ ≡ y₁ → y₁ &lt; x₁ → ⊥" class="Function">go</a> <a id="12422" class="Symbol">(</a><a id="12423" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="12427" href="Data.Int.html#12427" class="Bound">x</a><a id="12428" class="Symbol">)</a> <a id="12430" href="Agda.Builtin.Nat.html#195" data-type="Nat" class="InductiveConstructor">zero</a> <a id="12435" href="Data.Int.html#12435" class="Bound">p</a> <a id="12437" href="Data.Int.html#12437" class="Bound">q</a> <a id="12439" class="Symbol">=</a> <a id="12441" href="1Lab.Type.html#1352" data-type="⊥ → A" class="Function">absurd</a> <a id="12448" class="Symbol">(</a><a id="12449" href="Data.Nat.Base.html#1178" data-type="zero ≡ suc n → ⊥" class="Function">zero≠suc</a> <a id="12458" class="Symbol">(</a><a id="12459" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="12463" href="Data.Int.html#12435" class="Bound">p</a><a id="12464" class="Symbol">))</a>
      <a id="12473" href="Data.Int.html#12382" data-type="(x y : Nat) →
x ≡ y → suc y ≤ x → (x₁ y₁ : Nat) → x₁ ≡ y₁ → y₁ &lt; x₁ → ⊥" class="Function">go</a> <a id="12476" class="Symbol">(</a><a id="12477" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="12481" href="Data.Int.html#12481" class="Bound">x</a><a id="12482" class="Symbol">)</a> <a id="12484" class="Symbol">(</a><a id="12485" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="12489" href="Data.Int.html#12489" class="Bound">y</a><a id="12490" class="Symbol">)</a> <a id="12492" href="Data.Int.html#12492" class="Bound">p</a> <a id="12494" href="Data.Int.html#12494" class="Bound">q</a> <a id="12496" class="Symbol">=</a> <a id="12498" href="Data.Int.html#12382" data-type="(x y : Nat) →
x ≡ y → suc y ≤ x → (x₁ y₁ : Nat) → x₁ ≡ y₁ → y₁ &lt; x₁ → ⊥" class="Function">go</a> <a id="12501" href="Data.Int.html#12481" class="Bound">x</a> <a id="12503" href="Data.Int.html#12489" class="Bound">y</a> <a id="12505" class="Symbol">(</a><a id="12506" href="Data.Nat.Base.html#1668" data-type="suc x ≡ suc y → x ≡ y" class="Function">suc-inj</a> <a id="12514" href="Data.Int.html#12492" class="Bound">p</a><a id="12515" class="Symbol">)</a> <a id="12517" href="Data.Int.html#12494" class="Bound">q</a>

  <a id="12522" href="Data.Int.html#12522" data-type="(n : Int) → Canonical n" class="Function">go</a> <a id="12525" class="Symbol">:</a> <a id="12527" class="Symbol">∀</a> <a id="12529" href="Data.Int.html#12529" class="Bound">n</a> <a id="12531" class="Symbol">→</a> <a id="12533" href="Data.Int.html#8296" data-type="Int → Type" class="Function">Canonical</a> <a id="12543" href="Data.Int.html#12529" class="Bound">n</a>
  <a id="12547" href="Data.Int.html#12522" data-type="(n : Int) → Canonical n" class="Function">go</a> <a id="12550" class="Symbol">(</a><a id="12551" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="12556" href="Data.Int.html#12556" class="Bound">x</a> <a id="12558" href="Data.Int.html#12558" class="Bound">y</a><a id="12559" class="Symbol">)</a> <a id="12561" class="Symbol">=</a> <a id="12563" href="Data.Int.html#8600" data-type="(x y : Nat) → Canonical (diff x y)" class="Function">work</a> <a id="12568" href="Data.Int.html#12556" class="Bound">x</a> <a id="12570" href="Data.Int.html#12558" class="Bound">y</a>
  <a id="12574" href="Data.Int.html#12522" data-type="(n : Int) → Canonical n" class="Function">go</a> <a id="12577" class="Symbol">(</a><a id="12578" href="Data.Int.html#689" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">Int.quot</a> <a id="12587" href="Data.Int.html#12587" class="Bound">x</a> <a id="12589" href="Data.Int.html#12589" class="Bound">y</a> <a id="12591" href="Data.Int.html#12591" class="Bound">i</a><a id="12592" class="Symbol">)</a> <a id="12594" class="Symbol">=</a> <a id="12596" href="Data.Int.html#9771" data-type="(x y : Nat) →
PathP (λ i → Canonical (quot x y i)) (work x y)
(work (suc x) (suc y))" class="Function">work-respects-quot</a> <a id="12615" href="Data.Int.html#12587" class="Bound">x</a> <a id="12617" href="Data.Int.html#12589" class="Bound">y</a> <a id="12619" href="Data.Int.html#12591" class="Bound">i</a>
</pre>
</details>
<p>This <em>immediately</em> implies that the type of integers is a set,
because it’s a retract of a set — namely
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">N</mi><mo>×</mo><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">\bb{N} \times \bb{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7722em;vertical-align:-0.0833em;"></span><span class="mord mathbb">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span></span></span></span>!</span></p>
<pre class="Agda"><a id="12777" class="Keyword">instance</a> <a id="12786" class="Keyword">abstract</a>
  <a id="H-Level-Int"></a><a id="12797" href="Data.Int.html#12797" data-type="H-Level Int (2 + n)" class="Function">H-Level-Int</a> <a id="12809" class="Symbol">:</a> <a id="12811" class="Symbol">∀</a> <a id="12813" class="Symbol">{</a><a id="12814" href="Data.Int.html#12814" class="Bound">n</a><a id="12815" class="Symbol">}</a> <a id="12817" class="Symbol">→</a> <a id="12819" href="1Lab.HLevel.Retracts.html#7663" data-type="(T : Type ℓ) (n : Nat) → Type ℓ" class="Record">H-Level</a> <a id="12827" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a> <a id="12831" class="Symbol">(</a><a id="12832" class="Number">2</a> <a id="12834" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12836" href="Data.Int.html#12814" class="Bound">n</a><a id="12837" class="Symbol">)</a>
  <a id="12841" href="Data.Int.html#12797" data-type="H-Level Int (2 + n)" class="Function">H-Level-Int</a> <a id="12853" class="Symbol">=</a>
    <a id="12859" href="1Lab.HLevel.Retracts.html#8750" data-type="(n : Nat) → is-hlevel T n → H-Level T (n + k)" class="Function">basic-instance</a> <a id="12874" class="Number">2</a> <a id="12876" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a>
      <a id="12884" href="1Lab.HLevel.Retracts.html#1933" data-type="(n : Nat) (f : A → B₁) (g : B₁ → A) →
is-left-inverse f g → is-hlevel A n → is-hlevel B₁ n" class="Function">retract→is-hlevel</a> <a id="12902" class="Number">2</a> <a id="12904" href="Data.Int.html#12946" data-type="Nat × Nat → Int" class="Function">into</a> <a id="12909" href="Data.Int.html#13008" data-type="Int → Nat × Nat" class="Function">from</a> <a id="12914" href="Data.Int.html#13101" data-type="(x : Int) → into (from x) ≡ x" class="Function">linv</a> <a id="12919" class="Symbol">(</a><a id="12920" href="1Lab.HLevel.Retracts.html#8061" data-type="(n : Nat) ⦃ x : H-Level T n ⦄ → is-hlevel T n" class="Function">hlevel</a> <a id="12927" class="Number">2</a><a id="12928" class="Symbol">)</a>
    <a id="12934" class="Keyword">where</a>
      <a id="12946" href="Data.Int.html#12946" data-type="Nat × Nat → Int" class="Function">into</a> <a id="12951" class="Symbol">:</a> <a id="12953" class="Symbol">(</a><a id="12954" href="Agda.Builtin.Nat.html#177" data-type="Type" class="Datatype">Nat</a> <a id="12958" href="1Lab.Type.html#1846" data-type="Type a → Type b → Type (a ⊔ b)" class="Function Operator">×</a> <a id="12960" href="Agda.Builtin.Nat.html#177" data-type="Type" class="Datatype">Nat</a><a id="12963" class="Symbol">)</a> <a id="12965" class="Symbol">→</a> <a id="12967" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a>
      <a id="12977" href="Data.Int.html#12946" data-type="Nat × Nat → Int" class="Function">into</a> <a id="12982" class="Symbol">(</a><a id="12983" href="Data.Int.html#12983" class="Bound">x</a> <a id="12985" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="12987" href="Data.Int.html#12987" class="Bound">y</a><a id="12988" class="Symbol">)</a> <a id="12990" class="Symbol">=</a> <a id="12992" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="12997" href="Data.Int.html#12983" class="Bound">x</a> <a id="12999" href="Data.Int.html#12987" class="Bound">y</a>

      <a id="13008" href="Data.Int.html#13008" data-type="Int → Nat × Nat" class="Function">from</a> <a id="13013" class="Symbol">:</a> <a id="13015" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a> <a id="13019" class="Symbol">→</a> <a id="13021" href="Agda.Builtin.Nat.html#177" data-type="Type" class="Datatype">Nat</a> <a id="13025" href="1Lab.Type.html#1846" data-type="Type a → Type b → Type (a ⊔ b)" class="Function Operator">×</a> <a id="13027" href="Agda.Builtin.Nat.html#177" data-type="Type" class="Datatype">Nat</a>
      <a id="13037" href="Data.Int.html#13008" data-type="Int → Nat × Nat" class="Function">from</a> <a id="13042" href="Data.Int.html#13042" class="Bound">x</a> <a id="13044" class="Keyword">with</a> <a id="13049" href="Data.Int.html#8375" data-type="(n : Int) → Canonical n" class="Function">canonicalise</a> <a id="13062" href="Data.Int.html#13042" class="Bound">x</a>
      <a id="13070" class="Symbol">...</a> <a id="13074" class="Symbol">|</a> <a id="13076" href="Data.Int.html#13076" class="Bound">a</a> <a id="13078" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="13080" href="Data.Int.html#13080" class="Bound">b</a> <a id="13082" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="13084" href="Data.Int.html#13084" class="Bound">p</a> <a id="13086" class="Symbol">=</a> <a id="13088" href="Data.Int.html#13076" class="Bound">a</a> <a id="13090" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="13092" href="Data.Int.html#13080" class="Bound">b</a>

      <a id="13101" href="Data.Int.html#13101" data-type="(x : Int) → into (from x) ≡ x" class="Function">linv</a> <a id="13106" class="Symbol">:</a> <a id="13108" class="Symbol">∀</a> <a id="13110" href="Data.Int.html#13110" class="Bound">x</a> <a id="13112" class="Symbol">→</a> <a id="13114" href="Data.Int.html#12946" data-type="Nat × Nat → Int" class="Function">into</a> <a id="13119" class="Symbol">(</a><a id="13120" href="Data.Int.html#13008" data-type="Int → Nat × Nat" class="Function">from</a> <a id="13125" href="Data.Int.html#13110" class="Bound">x</a><a id="13126" class="Symbol">)</a> <a id="13128" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="13130" href="Data.Int.html#13110" class="Bound">x</a>
      <a id="13138" href="Data.Int.html#13101" data-type="(x : Int) → into (from x) ≡ x" class="Function">linv</a> <a id="13143" href="Data.Int.html#13143" class="Bound">x</a> <a id="13145" class="Keyword">with</a> <a id="13150" href="Data.Int.html#8375" data-type="(n : Int) → Canonical n" class="Function">canonicalise</a> <a id="13163" href="Data.Int.html#13143" class="Bound">x</a>
      <a id="13171" class="Symbol">...</a> <a id="13175" class="Symbol">|</a> <a id="13177" href="Data.Int.html#13177" class="Bound">a</a> <a id="13179" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="13181" href="Data.Int.html#13181" class="Bound">b</a> <a id="13183" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="13185" href="Data.Int.html#13185" class="Bound">p</a> <a id="13187" class="Symbol">=</a> <a id="13189" href="Data.Int.html#13185" class="Bound">p</a>
</pre>
<h1 id="recursion"><a href="#recursion" class="header-link">Recursion<span class="header-link-emoji">🔗</span></a></h1>
<p>If we want to define a map
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi mathvariant="double-struck">Z</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">f : \bb{Z} \to X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">Z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>,</span>
it suffices to give a function
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><msup><mi mathvariant="double-struck">N</mi><mn>2</mn></msup><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">f : \bb{N}^2 \to X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathbb">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>
which respects the quotient, in the following sense:</p>
<pre class="Agda"><a id="Int-rec"></a><a id="13370" href="Data.Int.html#13370" data-type="(f : Nat → Nat → X) →
((a b : Nat) → f a b ≡ f (suc a) (suc b)) → Int → X" class="Function">Int-rec</a> <a id="13378" class="Symbol">:</a> <a id="13380" class="Symbol">∀</a> <a id="13382" class="Symbol">{</a><a id="13383" href="Data.Int.html#13383" class="Bound">ℓ</a><a id="13384" class="Symbol">}</a> <a id="13386" class="Symbol">{</a><a id="13387" href="Data.Int.html#13387" class="Bound">X</a> <a id="13389" class="Symbol">:</a> <a id="13391" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="13396" href="Data.Int.html#13383" class="Bound">ℓ</a><a id="13397" class="Symbol">}</a>
        <a id="13407" class="Symbol">→</a> <a id="13409" class="Symbol">(</a><a id="13410" href="Data.Int.html#13410" class="Bound">f</a> <a id="13412" class="Symbol">:</a> <a id="13414" href="Agda.Builtin.Nat.html#177" data-type="Type" class="Datatype">Nat</a> <a id="13418" class="Symbol">→</a> <a id="13420" href="Agda.Builtin.Nat.html#177" data-type="Type" class="Datatype">Nat</a> <a id="13424" class="Symbol">→</a> <a id="13426" href="Data.Int.html#13387" class="Bound">X</a><a id="13427" class="Symbol">)</a>
        <a id="13437" class="Symbol">→</a> <a id="13439" class="Symbol">(</a><a id="13440" href="Data.Int.html#13440" class="Bound">q</a> <a id="13442" class="Symbol">:</a> <a id="13444" class="Symbol">(</a><a id="13445" href="Data.Int.html#13445" class="Bound">a</a> <a id="13447" href="Data.Int.html#13447" class="Bound">b</a> <a id="13449" class="Symbol">:</a> <a id="13451" class="Symbol">_)</a> <a id="13454" class="Symbol">→</a> <a id="13456" href="Data.Int.html#13410" class="Bound">f</a> <a id="13458" href="Data.Int.html#13445" class="Bound">a</a> <a id="13460" href="Data.Int.html#13447" class="Bound">b</a> <a id="13462" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="13464" href="Data.Int.html#13410" class="Bound">f</a> <a id="13466" class="Symbol">(</a><a id="13467" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="13471" href="Data.Int.html#13445" class="Bound">a</a><a id="13472" class="Symbol">)</a> <a id="13474" class="Symbol">(</a><a id="13475" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="13479" href="Data.Int.html#13447" class="Bound">b</a><a id="13480" class="Symbol">))</a>
        <a id="13491" class="Symbol">→</a> <a id="13493" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a> <a id="13497" class="Symbol">→</a> <a id="13499" href="Data.Int.html#13387" class="Bound">X</a>
<a id="13501" href="Data.Int.html#13370" data-type="(f : Nat → Nat → X) →
((a b : Nat) → f a b ≡ f (suc a) (suc b)) → Int → X" class="Function">Int-rec</a> <a id="13509" href="Data.Int.html#13509" class="Bound">f</a> <a id="13511" href="Data.Int.html#13511" class="Bound">q</a> <a id="13513" class="Symbol">(</a><a id="13514" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="13519" href="Data.Int.html#13519" class="Bound">x</a> <a id="13521" href="Data.Int.html#13521" class="Bound">y</a><a id="13522" class="Symbol">)</a> <a id="13524" class="Symbol">=</a> <a id="13526" href="Data.Int.html#13509" class="Bound">f</a> <a id="13528" href="Data.Int.html#13519" class="Bound">x</a> <a id="13530" href="Data.Int.html#13521" class="Bound">y</a>
<a id="13532" href="Data.Int.html#13370" data-type="(f : Nat → Nat → X) →
((a b : Nat) → f a b ≡ f (suc a) (suc b)) → Int → X" class="Function">Int-rec</a> <a id="13540" href="Data.Int.html#13540" class="Bound">f</a> <a id="13542" href="Data.Int.html#13542" class="Bound">q</a> <a id="13544" class="Symbol">(</a><a id="13545" href="Data.Int.html#689" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="13550" href="Data.Int.html#13550" class="Bound">m</a> <a id="13552" href="Data.Int.html#13552" class="Bound">n</a> <a id="13554" href="Data.Int.html#13554" class="Bound">i</a><a id="13555" class="Symbol">)</a> <a id="13557" class="Symbol">=</a> <a id="13559" href="Data.Int.html#13542" class="Bound">q</a> <a id="13561" href="Data.Int.html#13550" class="Bound">m</a> <a id="13563" href="Data.Int.html#13552" class="Bound">n</a> <a id="13565" href="Data.Int.html#13554" class="Bound">i</a>
</pre>
<p>However, since
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>
can be a more general space, not necessarily a <em>set</em>, defining a
<em>binary</em> operation
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>:</mo><msup><mi mathvariant="double-struck">Z</mi><mn>2</mn></msup><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">f&#39; : \bb{Z}^2 \to X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathbb">Z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>
can be quite involved! It doesn’t suffice to exhibit a function from
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="double-struck">N</mi><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\bb{N}^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathbb">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span>
which respects the quotient separately in each argument:</p>
<pre class="Agda"><a id="Int-rec₂"></a><a id="13843" href="Data.Int.html#13843" data-type="(f : Nat × Nat → Nat × Nat → B₁)
(pl
 : (a b x y : Nat) → f (a , b) (x , y) ≡ f (suc a , suc b) (x , y))
(pr
 : (a b x y : Nat) →
   f (a , b) (x , y) ≡ f (a , b) (suc x , suc y)) →
((a b x y : Nat) →
 Square (pl a b x y) (pr a b x y) (pr (suc a) (suc b) x y)
 (pl a b (suc x) (suc y))) →
Int → Int → B₁" class="Function">Int-rec₂</a> <a id="13852" class="Symbol">:</a> <a id="13854" class="Symbol">∀</a> <a id="13856" class="Symbol">{</a><a id="13857" href="Data.Int.html#13857" class="Bound">ℓ</a><a id="13858" class="Symbol">}</a> <a id="13860" class="Symbol">{</a><a id="13861" href="Data.Int.html#13861" class="Bound">B</a> <a id="13863" class="Symbol">:</a> <a id="13865" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="13870" href="Data.Int.html#13857" class="Bound">ℓ</a><a id="13871" class="Symbol">}</a>
         <a id="13882" class="Symbol">→</a> <a id="13884" class="Symbol">(</a><a id="13885" href="Data.Int.html#13885" class="Bound">f</a> <a id="13887" class="Symbol">:</a> <a id="13889" href="Agda.Builtin.Nat.html#177" data-type="Type" class="Datatype">Nat</a> <a id="13893" href="1Lab.Type.html#1846" data-type="Type a → Type b → Type (a ⊔ b)" class="Function Operator">×</a> <a id="13895" href="Agda.Builtin.Nat.html#177" data-type="Type" class="Datatype">Nat</a> <a id="13899" class="Symbol">→</a> <a id="13901" href="Agda.Builtin.Nat.html#177" data-type="Type" class="Datatype">Nat</a> <a id="13905" href="1Lab.Type.html#1846" data-type="Type a → Type b → Type (a ⊔ b)" class="Function Operator">×</a> <a id="13907" href="Agda.Builtin.Nat.html#177" data-type="Type" class="Datatype">Nat</a> <a id="13911" class="Symbol">→</a> <a id="13913" href="Data.Int.html#13861" class="Bound">B</a><a id="13914" class="Symbol">)</a>
         <a id="13925" class="Symbol">→</a> <a id="13927" class="Symbol">(</a><a id="13928" href="Data.Int.html#13928" class="Bound">pl</a>     <a id="13935" class="Symbol">:</a> <a id="13937" class="Symbol">(</a><a id="13938" href="Data.Int.html#13938" class="Bound">a</a> <a id="13940" href="Data.Int.html#13940" class="Bound">b</a> <a id="13942" href="Data.Int.html#13942" class="Bound">x</a> <a id="13944" href="Data.Int.html#13944" class="Bound">y</a> <a id="13946" class="Symbol">:</a> <a id="13948" class="Symbol">_)</a> <a id="13951" class="Symbol">→</a> <a id="13953" href="Data.Int.html#13885" class="Bound">f</a> <a id="13955" class="Symbol">(</a><a id="13956" href="Data.Int.html#13938" class="Bound">a</a> <a id="13958" class="InductiveConstructor Operator">,</a> <a id="13960" href="Data.Int.html#13940" class="Bound">b</a><a id="13961" class="Symbol">)</a> <a id="13963" class="Symbol">(</a><a id="13964" href="Data.Int.html#13942" class="Bound">x</a> <a id="13966" class="InductiveConstructor Operator">,</a> <a id="13968" href="Data.Int.html#13944" class="Bound">y</a><a id="13969" class="Symbol">)</a> <a id="13971" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="13973" href="Data.Int.html#13885" class="Bound">f</a> <a id="13975" class="Symbol">(</a><a id="13976" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="13980" href="Data.Int.html#13938" class="Bound">a</a> <a id="13982" class="InductiveConstructor Operator">,</a> <a id="13984" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="13988" href="Data.Int.html#13940" class="Bound">b</a><a id="13989" class="Symbol">)</a> <a id="13991" class="Symbol">(</a><a id="13992" href="Data.Int.html#13942" class="Bound">x</a> <a id="13994" class="InductiveConstructor Operator">,</a> <a id="13996" href="Data.Int.html#13944" class="Bound">y</a><a id="13997" class="Symbol">))</a>
         <a id="14009" class="Symbol">→</a> <a id="14011" class="Symbol">(</a><a id="14012" href="Data.Int.html#14012" class="Bound">pr</a>     <a id="14019" class="Symbol">:</a> <a id="14021" class="Symbol">(</a><a id="14022" href="Data.Int.html#14022" class="Bound">a</a> <a id="14024" href="Data.Int.html#14024" class="Bound">b</a> <a id="14026" href="Data.Int.html#14026" class="Bound">x</a> <a id="14028" href="Data.Int.html#14028" class="Bound">y</a> <a id="14030" class="Symbol">:</a> <a id="14032" class="Symbol">_)</a> <a id="14035" class="Symbol">→</a> <a id="14037" href="Data.Int.html#13885" class="Bound">f</a> <a id="14039" class="Symbol">(</a><a id="14040" href="Data.Int.html#14022" class="Bound">a</a> <a id="14042" class="InductiveConstructor Operator">,</a> <a id="14044" href="Data.Int.html#14024" class="Bound">b</a><a id="14045" class="Symbol">)</a> <a id="14047" class="Symbol">(</a><a id="14048" href="Data.Int.html#14026" class="Bound">x</a> <a id="14050" class="InductiveConstructor Operator">,</a> <a id="14052" href="Data.Int.html#14028" class="Bound">y</a><a id="14053" class="Symbol">)</a> <a id="14055" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="14057" href="Data.Int.html#13885" class="Bound">f</a> <a id="14059" class="Symbol">(</a><a id="14060" href="Data.Int.html#14022" class="Bound">a</a> <a id="14062" class="InductiveConstructor Operator">,</a> <a id="14064" href="Data.Int.html#14024" class="Bound">b</a><a id="14065" class="Symbol">)</a> <a id="14067" class="Symbol">(</a><a id="14068" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="14072" href="Data.Int.html#14026" class="Bound">x</a> <a id="14074" class="InductiveConstructor Operator">,</a> <a id="14076" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="14080" href="Data.Int.html#14028" class="Bound">y</a><a id="14081" class="Symbol">))</a>
</pre>
<p>In addition, we must have that these two <em>paths</em>
<code>pl</code> and <code>pr</code> are <em>coherent</em>. There are two
ways of obtaining an equality
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi mathvariant="normal">S</mi><mi>a</mi><mo separator="true">,</mo><mi mathvariant="normal">S</mi><mi>b</mi><mo separator="true">,</mo><mi mathvariant="normal">S</mi><mi>x</mi><mo separator="true">,</mo><mi mathvariant="normal">S</mi><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(a, b, x, y) = f(\id{S}a,\id{S}b,\id{S}x,\id{S}y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathrm">S</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathrm">S</span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathrm">S</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathrm">S</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>
(<code>pl</code> after <code>pr</code> and <code>pr</code> after
<code>pl</code>, respectively) and these <em>must</em> be homotopic:</p>
<pre class="Agda">         <a id="14366" class="Symbol">→</a> <a id="14368" class="Symbol">(</a><a id="14369" href="Data.Int.html#14369" class="Bound">square</a> <a id="14376" class="Symbol">:</a> <a id="14378" class="Symbol">(</a><a id="14379" href="Data.Int.html#14379" class="Bound">a</a> <a id="14381" href="Data.Int.html#14381" class="Bound">b</a> <a id="14383" href="Data.Int.html#14383" class="Bound">x</a> <a id="14385" href="Data.Int.html#14385" class="Bound">y</a> <a id="14387" class="Symbol">:</a> <a id="14389" class="Symbol">_)</a> <a id="14392" class="Symbol">→</a>
              <a id="14408" href="1Lab.Path.html#9409" data-type="a00 ≡ a01 → a00 ≡ a10 → a01 ≡ a11 → a10 ≡ a11 → Type ℓ" class="Function">Square</a> <a id="14415" class="Symbol">(</a><a id="14416" href="Data.Int.html#13928" class="Bound">pl</a> <a id="14419" href="Data.Int.html#14379" class="Bound">a</a> <a id="14421" href="Data.Int.html#14381" class="Bound">b</a> <a id="14423" href="Data.Int.html#14383" class="Bound">x</a> <a id="14425" href="Data.Int.html#14385" class="Bound">y</a><a id="14426" class="Symbol">)</a> <a id="14428" class="Symbol">(</a><a id="14429" href="Data.Int.html#14012" class="Bound">pr</a> <a id="14432" href="Data.Int.html#14379" class="Bound">a</a> <a id="14434" href="Data.Int.html#14381" class="Bound">b</a> <a id="14436" href="Data.Int.html#14383" class="Bound">x</a> <a id="14438" href="Data.Int.html#14385" class="Bound">y</a><a id="14439" class="Symbol">)</a>
                     <a id="14462" class="Symbol">(</a><a id="14463" href="Data.Int.html#14012" class="Bound">pr</a> <a id="14466" class="Symbol">(</a><a id="14467" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="14471" href="Data.Int.html#14379" class="Bound">a</a><a id="14472" class="Symbol">)</a> <a id="14474" class="Symbol">(</a><a id="14475" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="14479" href="Data.Int.html#14381" class="Bound">b</a><a id="14480" class="Symbol">)</a> <a id="14482" href="Data.Int.html#14383" class="Bound">x</a> <a id="14484" href="Data.Int.html#14385" class="Bound">y</a><a id="14485" class="Symbol">)</a>
                     <a id="14508" class="Symbol">(</a><a id="14509" href="Data.Int.html#13928" class="Bound">pl</a> <a id="14512" href="Data.Int.html#14379" class="Bound">a</a> <a id="14514" href="Data.Int.html#14381" class="Bound">b</a> <a id="14516" class="Symbol">(</a><a id="14517" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="14521" href="Data.Int.html#14383" class="Bound">x</a><a id="14522" class="Symbol">)</a> <a id="14524" class="Symbol">(</a><a id="14525" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="14529" href="Data.Int.html#14385" class="Bound">y</a><a id="14530" class="Symbol">)))</a>
         <a id="14543" class="Symbol">→</a> <a id="14545" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a> <a id="14549" class="Symbol">→</a> <a id="14551" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a> <a id="14555" class="Symbol">→</a> <a id="14557" href="Data.Int.html#13861" class="Bound">B</a>
</pre>
<p>The type of <code>square</code> says that we need the following
square of paths to commute, which says exactly that <code>pl ∙ pr</code>
and <code>pr ∙ pl</code> are homotopic and imposes no further structure
on
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>:</p>
<div class="diagram-container">
<img src="light-96b44f04dd57b7493b2bae592d6e93413b7af24d.svg" title="commutative diagram" class="diagram diagram-light quiver tall-1" />
<img src="dark-96b44f04dd57b7493b2bae592d6e93413b7af24d.svg" title="commutative diagram" class="diagram diagram-dark quiver tall-1" />
</div>
<pre class="Agda"><a id="15196" href="Data.Int.html#13843" data-type="(f : Nat × Nat → Nat × Nat → B₁)
(pl
 : (a b x y : Nat) → f (a , b) (x , y) ≡ f (suc a , suc b) (x , y))
(pr
 : (a b x y : Nat) →
   f (a , b) (x , y) ≡ f (a , b) (suc x , suc y)) →
((a b x y : Nat) →
 Square (pl a b x y) (pr a b x y) (pr (suc a) (suc b) x y)
 (pl a b (suc x) (suc y))) →
Int → Int → B₁" class="Function">Int-rec₂</a> <a id="15205" href="Data.Int.html#15205" class="Bound">f</a> <a id="15207" href="Data.Int.html#15207" class="Bound">p-l</a> <a id="15211" href="Data.Int.html#15211" class="Bound">p-r</a> <a id="15215" href="Data.Int.html#15215" class="Bound">sq</a> <a id="15218" class="Symbol">(</a><a id="15219" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="15224" href="Data.Int.html#15224" class="Bound">a</a> <a id="15226" href="Data.Int.html#15226" class="Bound">b</a><a id="15227" class="Symbol">)</a> <a id="15229" class="Symbol">(</a><a id="15230" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="15235" href="Data.Int.html#15235" class="Bound">x</a> <a id="15237" href="Data.Int.html#15237" class="Bound">y</a><a id="15238" class="Symbol">)</a>     <a id="15244" class="Symbol">=</a> <a id="15246" href="Data.Int.html#15205" class="Bound">f</a> <a id="15248" class="Symbol">(</a><a id="15249" href="Data.Int.html#15224" class="Bound">a</a> <a id="15251" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="15253" href="Data.Int.html#15226" class="Bound">b</a><a id="15254" class="Symbol">)</a> <a id="15256" class="Symbol">(</a><a id="15257" href="Data.Int.html#15235" class="Bound">x</a> <a id="15259" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="15261" href="Data.Int.html#15237" class="Bound">y</a><a id="15262" class="Symbol">)</a>
<a id="15264" href="Data.Int.html#13843" data-type="(f : Nat × Nat → Nat × Nat → B₁)
(pl
 : (a b x y : Nat) → f (a , b) (x , y) ≡ f (suc a , suc b) (x , y))
(pr
 : (a b x y : Nat) →
   f (a , b) (x , y) ≡ f (a , b) (suc x , suc y)) →
((a b x y : Nat) →
 Square (pl a b x y) (pr a b x y) (pr (suc a) (suc b) x y)
 (pl a b (suc x) (suc y))) →
Int → Int → B₁" class="Function">Int-rec₂</a> <a id="15273" href="Data.Int.html#15273" class="Bound">f</a> <a id="15275" href="Data.Int.html#15275" class="Bound">p-l</a> <a id="15279" href="Data.Int.html#15279" class="Bound">p-r</a> <a id="15283" href="Data.Int.html#15283" class="Bound">sq</a> <a id="15286" class="Symbol">(</a><a id="15287" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="15292" href="Data.Int.html#15292" class="Bound">a</a> <a id="15294" href="Data.Int.html#15294" class="Bound">b</a><a id="15295" class="Symbol">)</a> <a id="15297" class="Symbol">(</a><a id="15298" href="Data.Int.html#689" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="15303" href="Data.Int.html#15303" class="Bound">x</a> <a id="15305" href="Data.Int.html#15305" class="Bound">y</a> <a id="15307" href="Data.Int.html#15307" class="Bound">i</a><a id="15308" class="Symbol">)</a>   <a id="15312" class="Symbol">=</a> <a id="15314" href="Data.Int.html#15279" class="Bound">p-r</a> <a id="15318" href="Data.Int.html#15292" class="Bound">a</a> <a id="15320" href="Data.Int.html#15294" class="Bound">b</a> <a id="15322" href="Data.Int.html#15303" class="Bound">x</a> <a id="15324" href="Data.Int.html#15305" class="Bound">y</a> <a id="15326" href="Data.Int.html#15307" class="Bound">i</a>
<a id="15328" href="Data.Int.html#13843" data-type="(f : Nat × Nat → Nat × Nat → B₁)
(pl
 : (a b x y : Nat) → f (a , b) (x , y) ≡ f (suc a , suc b) (x , y))
(pr
 : (a b x y : Nat) →
   f (a , b) (x , y) ≡ f (a , b) (suc x , suc y)) →
((a b x y : Nat) →
 Square (pl a b x y) (pr a b x y) (pr (suc a) (suc b) x y)
 (pl a b (suc x) (suc y))) →
Int → Int → B₁" class="Function">Int-rec₂</a> <a id="15337" href="Data.Int.html#15337" class="Bound">f</a> <a id="15339" href="Data.Int.html#15339" class="Bound">p-l</a> <a id="15343" href="Data.Int.html#15343" class="Bound">p-r</a> <a id="15347" href="Data.Int.html#15347" class="Bound">sq</a> <a id="15350" class="Symbol">(</a><a id="15351" href="Data.Int.html#689" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="15356" href="Data.Int.html#15356" class="Bound">a</a> <a id="15358" href="Data.Int.html#15358" class="Bound">b</a> <a id="15360" href="Data.Int.html#15360" class="Bound">i</a><a id="15361" class="Symbol">)</a> <a id="15363" class="Symbol">(</a><a id="15364" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="15369" href="Data.Int.html#15369" class="Bound">x</a> <a id="15371" href="Data.Int.html#15371" class="Bound">y</a><a id="15372" class="Symbol">)</a>   <a id="15376" class="Symbol">=</a> <a id="15378" href="Data.Int.html#15339" class="Bound">p-l</a> <a id="15382" href="Data.Int.html#15356" class="Bound">a</a> <a id="15384" href="Data.Int.html#15358" class="Bound">b</a> <a id="15386" href="Data.Int.html#15369" class="Bound">x</a> <a id="15388" href="Data.Int.html#15371" class="Bound">y</a> <a id="15390" href="Data.Int.html#15360" class="Bound">i</a>
<a id="15392" href="Data.Int.html#13843" data-type="(f : Nat × Nat → Nat × Nat → B₁)
(pl
 : (a b x y : Nat) → f (a , b) (x , y) ≡ f (suc a , suc b) (x , y))
(pr
 : (a b x y : Nat) →
   f (a , b) (x , y) ≡ f (a , b) (suc x , suc y)) →
((a b x y : Nat) →
 Square (pl a b x y) (pr a b x y) (pr (suc a) (suc b) x y)
 (pl a b (suc x) (suc y))) →
Int → Int → B₁" class="Function">Int-rec₂</a> <a id="15401" href="Data.Int.html#15401" class="Bound">f</a> <a id="15403" href="Data.Int.html#15403" class="Bound">p-l</a> <a id="15407" href="Data.Int.html#15407" class="Bound">p-r</a> <a id="15411" href="Data.Int.html#15411" class="Bound">sq</a> <a id="15414" class="Symbol">(</a><a id="15415" href="Data.Int.html#689" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="15420" href="Data.Int.html#15420" class="Bound">a</a> <a id="15422" href="Data.Int.html#15422" class="Bound">b</a> <a id="15424" href="Data.Int.html#15424" class="Bound">i</a><a id="15425" class="Symbol">)</a> <a id="15427" class="Symbol">(</a><a id="15428" href="Data.Int.html#689" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="15433" href="Data.Int.html#15433" class="Bound">x</a> <a id="15435" href="Data.Int.html#15435" class="Bound">y</a> <a id="15437" href="Data.Int.html#15437" class="Bound">j</a><a id="15438" class="Symbol">)</a> <a id="15440" class="Symbol">=</a> <a id="15442" href="Data.Int.html#15411" class="Bound">sq</a> <a id="15445" href="Data.Int.html#15420" class="Bound">a</a> <a id="15447" href="Data.Int.html#15422" class="Bound">b</a> <a id="15449" href="Data.Int.html#15433" class="Bound">x</a> <a id="15451" href="Data.Int.html#15435" class="Bound">y</a> <a id="15453" href="Data.Int.html#15424" class="Bound">i</a> <a id="15455" href="Data.Int.html#15437" class="Bound">j</a>
</pre>
<p>However, when the type
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>
we are mapping into <code class="sourceCode agda" data-ident="is-set">is a set</code>, as is the case for the integers
themselves, the square is automatically satisfied, so we can give a
simplified recursion principle:</p>
<pre class="Agda"><a id="Int-rec₂-set"></a><a id="15682" href="Data.Int.html#15682" data-type="⦃ iss-b : H-Level B₁ 2 ⦄ (f : Nat × Nat → Nat × Nat → B₁) →
((a b x y : Nat) → f (a , b) (x , y) ≡ f (suc a , suc b) (x , y)) →
((a b x y : Nat) → f (a , b) (x , y) ≡ f (a , b) (suc x , suc y)) →
Int → Int → B₁" class="Function">Int-rec₂-set</a> <a id="15695" class="Symbol">:</a>
  <a id="15699" class="Symbol">∀</a> <a id="15701" class="Symbol">{</a><a id="15702" href="Data.Int.html#15702" class="Bound">ℓ</a><a id="15703" class="Symbol">}</a> <a id="15705" class="Symbol">{</a><a id="15706" href="Data.Int.html#15706" class="Bound">B</a> <a id="15708" class="Symbol">:</a> <a id="15710" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="15715" href="Data.Int.html#15702" class="Bound">ℓ</a><a id="15716" class="Symbol">}</a> <a id="15718" class="Symbol">⦃</a> <a id="15720" href="Data.Int.html#15720" class="Bound">iss-b</a> <a id="15726" class="Symbol">:</a> <a id="15728" href="1Lab.HLevel.Retracts.html#7663" data-type="(T : Type ℓ) (n : Nat) → Type ℓ" class="Record">H-Level</a> <a id="15736" href="Data.Int.html#15706" class="Bound">B</a> <a id="15738" class="Number">2</a> <a id="15740" class="Symbol">⦄</a>
  <a id="15744" class="Symbol">→</a> <a id="15746" class="Symbol">(</a><a id="15747" href="Data.Int.html#15747" class="Bound">f</a> <a id="15749" class="Symbol">:</a> <a id="15751" href="Agda.Builtin.Nat.html#177" data-type="Type" class="Datatype">Nat</a> <a id="15755" href="1Lab.Type.html#1846" data-type="Type a → Type b → Type (a ⊔ b)" class="Function Operator">×</a> <a id="15757" href="Agda.Builtin.Nat.html#177" data-type="Type" class="Datatype">Nat</a> <a id="15761" class="Symbol">→</a> <a id="15763" href="Agda.Builtin.Nat.html#177" data-type="Type" class="Datatype">Nat</a> <a id="15767" href="1Lab.Type.html#1846" data-type="Type a → Type b → Type (a ⊔ b)" class="Function Operator">×</a> <a id="15769" href="Agda.Builtin.Nat.html#177" data-type="Type" class="Datatype">Nat</a> <a id="15773" class="Symbol">→</a> <a id="15775" href="Data.Int.html#15706" class="Bound">B</a><a id="15776" class="Symbol">)</a>
  <a id="15780" class="Symbol">→</a> <a id="15782" class="Symbol">(</a><a id="15783" href="Data.Int.html#15783" class="Bound">pl</a>     <a id="15790" class="Symbol">:</a> <a id="15792" class="Symbol">(</a><a id="15793" href="Data.Int.html#15793" class="Bound">a</a> <a id="15795" href="Data.Int.html#15795" class="Bound">b</a> <a id="15797" href="Data.Int.html#15797" class="Bound">x</a> <a id="15799" href="Data.Int.html#15799" class="Bound">y</a> <a id="15801" class="Symbol">:</a> <a id="15803" class="Symbol">_)</a> <a id="15806" class="Symbol">→</a> <a id="15808" href="Data.Int.html#15747" class="Bound">f</a> <a id="15810" class="Symbol">(</a><a id="15811" href="Data.Int.html#15793" class="Bound">a</a> <a id="15813" class="InductiveConstructor Operator">,</a> <a id="15815" href="Data.Int.html#15795" class="Bound">b</a><a id="15816" class="Symbol">)</a> <a id="15818" class="Symbol">(</a><a id="15819" href="Data.Int.html#15797" class="Bound">x</a> <a id="15821" class="InductiveConstructor Operator">,</a> <a id="15823" href="Data.Int.html#15799" class="Bound">y</a><a id="15824" class="Symbol">)</a> <a id="15826" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="15828" href="Data.Int.html#15747" class="Bound">f</a> <a id="15830" class="Symbol">(</a><a id="15831" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="15835" href="Data.Int.html#15793" class="Bound">a</a> <a id="15837" class="InductiveConstructor Operator">,</a> <a id="15839" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="15843" href="Data.Int.html#15795" class="Bound">b</a><a id="15844" class="Symbol">)</a> <a id="15846" class="Symbol">(</a><a id="15847" href="Data.Int.html#15797" class="Bound">x</a> <a id="15849" class="InductiveConstructor Operator">,</a> <a id="15851" href="Data.Int.html#15799" class="Bound">y</a><a id="15852" class="Symbol">))</a>
  <a id="15857" class="Symbol">→</a> <a id="15859" class="Symbol">(</a><a id="15860" href="Data.Int.html#15860" class="Bound">pr</a>     <a id="15867" class="Symbol">:</a> <a id="15869" class="Symbol">(</a><a id="15870" href="Data.Int.html#15870" class="Bound">a</a> <a id="15872" href="Data.Int.html#15872" class="Bound">b</a> <a id="15874" href="Data.Int.html#15874" class="Bound">x</a> <a id="15876" href="Data.Int.html#15876" class="Bound">y</a> <a id="15878" class="Symbol">:</a> <a id="15880" class="Symbol">_)</a> <a id="15883" class="Symbol">→</a> <a id="15885" href="Data.Int.html#15747" class="Bound">f</a> <a id="15887" class="Symbol">(</a><a id="15888" href="Data.Int.html#15870" class="Bound">a</a> <a id="15890" class="InductiveConstructor Operator">,</a> <a id="15892" href="Data.Int.html#15872" class="Bound">b</a><a id="15893" class="Symbol">)</a> <a id="15895" class="Symbol">(</a><a id="15896" href="Data.Int.html#15874" class="Bound">x</a> <a id="15898" class="InductiveConstructor Operator">,</a> <a id="15900" href="Data.Int.html#15876" class="Bound">y</a><a id="15901" class="Symbol">)</a> <a id="15903" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="15905" href="Data.Int.html#15747" class="Bound">f</a> <a id="15907" class="Symbol">(</a><a id="15908" href="Data.Int.html#15870" class="Bound">a</a> <a id="15910" class="InductiveConstructor Operator">,</a> <a id="15912" href="Data.Int.html#15872" class="Bound">b</a><a id="15913" class="Symbol">)</a> <a id="15915" class="Symbol">(</a><a id="15916" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="15920" href="Data.Int.html#15874" class="Bound">x</a> <a id="15922" class="InductiveConstructor Operator">,</a> <a id="15924" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="15928" href="Data.Int.html#15876" class="Bound">y</a><a id="15929" class="Symbol">))</a>
  <a id="15934" class="Symbol">→</a> <a id="15936" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a> <a id="15940" class="Symbol">→</a> <a id="15942" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a> <a id="15946" class="Symbol">→</a> <a id="15948" href="Data.Int.html#15706" class="Bound">B</a>
<a id="15950" href="Data.Int.html#15682" data-type="⦃ iss-b : H-Level B₁ 2 ⦄ (f : Nat × Nat → Nat × Nat → B₁) →
((a b x y : Nat) → f (a , b) (x , y) ≡ f (suc a , suc b) (x , y)) →
((a b x y : Nat) → f (a , b) (x , y) ≡ f (a , b) (suc x , suc y)) →
Int → Int → B₁" class="Function">Int-rec₂-set</a> <a id="15963" class="Symbol">⦃</a> <a id="15965" href="Data.Int.html#15965" class="Bound">iss-b</a> <a id="15971" class="Symbol">⦄</a> <a id="15973" href="Data.Int.html#15973" class="Bound">f</a> <a id="15975" href="Data.Int.html#15975" class="Bound">pl</a> <a id="15978" href="Data.Int.html#15978" class="Bound">pr</a> <a id="15981" class="Symbol">=</a> <a id="15983" href="Data.Int.html#13843" data-type="(f : Nat × Nat → Nat × Nat → B₁)
(pl
 : (a b x y : Nat) → f (a , b) (x , y) ≡ f (suc a , suc b) (x , y))
(pr
 : (a b x y : Nat) →
   f (a , b) (x , y) ≡ f (a , b) (suc x , suc y)) →
((a b x y : Nat) →
 Square (pl a b x y) (pr a b x y) (pr (suc a) (suc b) x y)
 (pl a b (suc x) (suc y))) →
Int → Int → B₁" class="Function">Int-rec₂</a> <a id="15992" href="Data.Int.html#15973" class="Bound">f</a> <a id="15994" href="Data.Int.html#15975" class="Bound">pl</a> <a id="15997" href="Data.Int.html#15978" class="Bound">pr</a> <a id="16000" href="Data.Int.html#16024" data-type="⦃ iss-b : H-Level B₁ 2 ⦄ (f : Nat × Nat → Nat × Nat → B₁)
(pl
 : (a b x y : Nat) → f (a , b) (x , y) ≡ f (suc a , suc b) (x , y))
(pr
 : (a b x y : Nat) → f (a , b) (x , y) ≡ f (a , b) (suc x , suc y))
(a b x y : Nat) →
PathP (λ i → pl a b x y i ≡ pl a b (suc x) (suc y) i) (pr a b x y)
(pr (suc a) (suc b) x y)" class="Function">square</a> <a id="16007" class="Keyword">where</a> <a id="16013" class="Keyword">abstract</a>
  <a id="16024" href="Data.Int.html#16024" data-type="⦃ iss-b : H-Level B₁ 2 ⦄ (f : Nat × Nat → Nat × Nat → B₁)
(pl
 : (a b x y : Nat) → f (a , b) (x , y) ≡ f (suc a , suc b) (x , y))
(pr
 : (a b x y : Nat) → f (a , b) (x , y) ≡ f (a , b) (suc x , suc y))
(a b x y : Nat) →
PathP (λ i → pl a b x y i ≡ pl a b (suc x) (suc y) i) (pr a b x y)
(pr (suc a) (suc b) x y)" class="Function">square</a>
    <a id="16035" class="Symbol">:</a> <a id="16037" class="Symbol">(</a><a id="16038" href="Data.Int.html#16038" class="Bound">a</a> <a id="16040" href="Data.Int.html#16040" class="Bound">b</a> <a id="16042" href="Data.Int.html#16042" class="Bound">x</a> <a id="16044" href="Data.Int.html#16044" class="Bound">y</a> <a id="16046" class="Symbol">:</a> <a id="16048" href="Agda.Builtin.Nat.html#177" data-type="Type" class="Datatype">Nat</a><a id="16051" class="Symbol">)</a>
    <a id="16057" class="Symbol">→</a> <a id="16059" href="Agda.Primitive.Cubical.html#2013" class="Postulate">PathP</a> <a id="16065" class="Symbol">(λ</a> <a id="16068" href="Data.Int.html#16068" class="Bound">i</a> <a id="16070" class="Symbol">→</a> <a id="16072" href="Data.Int.html#15975" class="Bound">pl</a> <a id="16075" href="Data.Int.html#16038" class="Bound">a</a> <a id="16077" href="Data.Int.html#16040" class="Bound">b</a> <a id="16079" href="Data.Int.html#16042" class="Bound">x</a> <a id="16081" href="Data.Int.html#16044" class="Bound">y</a> <a id="16083" href="Data.Int.html#16068" class="Bound">i</a> <a id="16085" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="16087" href="Data.Int.html#15975" class="Bound">pl</a> <a id="16090" href="Data.Int.html#16038" class="Bound">a</a> <a id="16092" href="Data.Int.html#16040" class="Bound">b</a> <a id="16094" class="Symbol">(</a><a id="16095" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="16099" href="Data.Int.html#16042" class="Bound">x</a><a id="16100" class="Symbol">)</a> <a id="16102" class="Symbol">(</a><a id="16103" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="16107" href="Data.Int.html#16044" class="Bound">y</a><a id="16108" class="Symbol">)</a> <a id="16110" href="Data.Int.html#16068" class="Bound">i</a><a id="16111" class="Symbol">)</a>
            <a id="16125" class="Symbol">(</a><a id="16126" href="Data.Int.html#15978" class="Bound">pr</a> <a id="16129" href="Data.Int.html#16038" class="Bound">a</a> <a id="16131" href="Data.Int.html#16040" class="Bound">b</a> <a id="16133" href="Data.Int.html#16042" class="Bound">x</a> <a id="16135" href="Data.Int.html#16044" class="Bound">y</a><a id="16136" class="Symbol">)</a> <a id="16138" class="Symbol">(</a><a id="16139" href="Data.Int.html#15978" class="Bound">pr</a> <a id="16142" class="Symbol">(</a><a id="16143" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="16147" href="Data.Int.html#16038" class="Bound">a</a><a id="16148" class="Symbol">)</a> <a id="16150" class="Symbol">(</a><a id="16151" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="16155" href="Data.Int.html#16040" class="Bound">b</a><a id="16156" class="Symbol">)</a> <a id="16158" href="Data.Int.html#16042" class="Bound">x</a> <a id="16160" href="Data.Int.html#16044" class="Bound">y</a><a id="16161" class="Symbol">)</a>
  <a id="16165" href="Data.Int.html#16024" data-type="⦃ iss-b : H-Level B₁ 2 ⦄ (f : Nat × Nat → Nat × Nat → B₁)
(pl
 : (a b x y : Nat) → f (a , b) (x , y) ≡ f (suc a , suc b) (x , y))
(pr
 : (a b x y : Nat) → f (a , b) (x , y) ≡ f (a , b) (suc x , suc y))
(a b x y : Nat) →
PathP (λ i → pl a b x y i ≡ pl a b (suc x) (suc y) i) (pr a b x y)
(pr (suc a) (suc b) x y)" class="Function">square</a> <a id="16172" href="Data.Int.html#16172" class="Bound">a</a> <a id="16174" href="Data.Int.html#16174" class="Bound">b</a> <a id="16176" href="Data.Int.html#16176" class="Bound">x</a> <a id="16178" href="Data.Int.html#16178" class="Bound">y</a> <a id="16180" class="Symbol">=</a> <a id="16182" href="1Lab.HLevel.html#15401" data-type="((i j : I) → is-set (A i j)) →
(p : PathP (λ j → A j i0) a c) (q : PathP (A i0) a b)
(s : PathP (A i1) c d) (r : PathP (λ j → A j i1) b d) →
SquareP A p q s r" class="Function">is-set→squarep</a> <a id="16197" class="Symbol">(λ</a> <a id="16200" href="Data.Int.html#16200" class="Bound">i</a> <a id="16202" href="Data.Int.html#16202" class="Bound">j</a> <a id="16204" class="Symbol">→</a> <a id="16206" href="1Lab.HLevel.Retracts.html#8061" data-type="(n : Nat) ⦃ x : H-Level T n ⦄ → is-hlevel T n" class="Function">hlevel</a> <a id="16213" class="Number">2</a><a id="16214" class="Symbol">)</a> <a id="16216" class="Symbol">_</a> <a id="16218" class="Symbol">_</a> <a id="16220" class="Symbol">_</a> <a id="16222" class="Symbol">_</a>
</pre>
<p>Furthermore, when proving
<em><span class="Agda"><a href="1Lab.HLevel.html#2597" class="Function">propositions</a></span></em>
of the integers, the quotient is automatically respected, so it suffices
to give the case for
<span class="Agda"><a href="Data.Int.html#662" class="InductiveConstructor">diff</a></span>:</p>
<pre class="Agda"><a id="Int-elim-prop"></a><a id="16411" href="Data.Int.html#16411" data-type="((x : Int) → is-prop (P x)) →
((a b : Nat) → P (diff a b)) → (x : Int) → P x" class="Function">Int-elim-prop</a> <a id="16425" class="Symbol">:</a> <a id="16427" class="Symbol">∀</a> <a id="16429" class="Symbol">{</a><a id="16430" href="Data.Int.html#16430" class="Bound">ℓ</a><a id="16431" class="Symbol">}</a> <a id="16433" class="Symbol">{</a><a id="16434" href="Data.Int.html#16434" class="Bound">P</a> <a id="16436" class="Symbol">:</a> <a id="16438" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a> <a id="16442" class="Symbol">→</a> <a id="16444" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="16449" href="Data.Int.html#16430" class="Bound">ℓ</a><a id="16450" class="Symbol">}</a>
              <a id="16466" class="Symbol">→</a> <a id="16468" class="Symbol">((</a><a id="16470" href="Data.Int.html#16470" class="Bound">x</a> <a id="16472" class="Symbol">:</a> <a id="16474" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a><a id="16477" class="Symbol">)</a> <a id="16479" class="Symbol">→</a> <a id="16481" href="1Lab.HLevel.html#2597" data-type="Type ℓ → Type ℓ" class="Function">is-prop</a> <a id="16489" class="Symbol">(</a><a id="16490" href="Data.Int.html#16434" class="Bound">P</a> <a id="16492" href="Data.Int.html#16470" class="Bound">x</a><a id="16493" class="Symbol">))</a>
              <a id="16510" class="Symbol">→</a> <a id="16512" class="Symbol">(</a><a id="16513" href="Data.Int.html#16513" class="Bound">f</a> <a id="16515" class="Symbol">:</a> <a id="16517" class="Symbol">(</a><a id="16518" href="Data.Int.html#16518" class="Bound">a</a> <a id="16520" href="Data.Int.html#16520" class="Bound">b</a> <a id="16522" class="Symbol">:</a> <a id="16524" href="Agda.Builtin.Nat.html#177" data-type="Type" class="Datatype">Nat</a><a id="16527" class="Symbol">)</a> <a id="16529" class="Symbol">→</a> <a id="16531" href="Data.Int.html#16434" class="Bound">P</a> <a id="16533" class="Symbol">(</a><a id="16534" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="16539" href="Data.Int.html#16518" class="Bound">a</a> <a id="16541" href="Data.Int.html#16520" class="Bound">b</a><a id="16542" class="Symbol">))</a>
              <a id="16559" class="Symbol">→</a> <a id="16561" class="Symbol">(</a><a id="16562" href="Data.Int.html#16562" class="Bound">x</a> <a id="16564" class="Symbol">:</a> <a id="16566" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a><a id="16569" class="Symbol">)</a> <a id="16571" class="Symbol">→</a> <a id="16573" href="Data.Int.html#16434" class="Bound">P</a> <a id="16575" href="Data.Int.html#16562" class="Bound">x</a>
<a id="16577" href="Data.Int.html#16411" data-type="((x : Int) → is-prop (P x)) →
((a b : Nat) → P (diff a b)) → (x : Int) → P x" class="Function">Int-elim-prop</a> <a id="16591" href="Data.Int.html#16591" class="Bound">pprop</a> <a id="16597" href="Data.Int.html#16597" class="Bound">f</a> <a id="16599" class="Symbol">(</a><a id="16600" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="16605" href="Data.Int.html#16605" class="Bound">a</a> <a id="16607" href="Data.Int.html#16607" class="Bound">b</a><a id="16608" class="Symbol">)</a> <a id="16610" class="Symbol">=</a> <a id="16612" href="Data.Int.html#16597" class="Bound">f</a> <a id="16614" href="Data.Int.html#16605" class="Bound">a</a> <a id="16616" href="Data.Int.html#16607" class="Bound">b</a>
<a id="16618" href="Data.Int.html#16411" data-type="((x : Int) → is-prop (P x)) →
((a b : Nat) → P (diff a b)) → (x : Int) → P x" class="Function">Int-elim-prop</a> <a id="16632" href="Data.Int.html#16632" class="Bound">pprop</a> <a id="16638" href="Data.Int.html#16638" class="Bound">f</a> <a id="16640" class="Symbol">(</a><a id="16641" href="Data.Int.html#689" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="16646" href="Data.Int.html#16646" class="Bound">m</a> <a id="16648" href="Data.Int.html#16648" class="Bound">n</a> <a id="16650" href="Data.Int.html#16650" class="Bound">i</a><a id="16651" class="Symbol">)</a> <a id="16653" class="Symbol">=</a>
  <a id="16657" href="1Lab.HLevel.html#13498" data-type="((i : I) → is-prop (B₁ i)) →
(b0 : B₁ i0) (b1 : B₁ i1) → PathP B₁ b0 b1" class="Function">is-prop→pathp</a> <a id="16671" class="Symbol">(λ</a> <a id="16674" href="Data.Int.html#16674" class="Bound">i</a> <a id="16676" class="Symbol">→</a> <a id="16678" href="Data.Int.html#16632" class="Bound">pprop</a> <a id="16684" class="Symbol">(</a><a id="16685" href="Data.Int.html#689" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="16690" href="Data.Int.html#16646" class="Bound">m</a> <a id="16692" href="Data.Int.html#16648" class="Bound">n</a> <a id="16694" href="Data.Int.html#16674" class="Bound">i</a><a id="16695" class="Symbol">))</a> <a id="16698" class="Symbol">(</a><a id="16699" href="Data.Int.html#16638" class="Bound">f</a> <a id="16701" href="Data.Int.html#16646" class="Bound">m</a> <a id="16703" href="Data.Int.html#16648" class="Bound">n</a><a id="16704" class="Symbol">)</a> <a id="16706" class="Symbol">(</a><a id="16707" href="Data.Int.html#16638" class="Bound">f</a> <a id="16709" class="Symbol">(</a><a id="16710" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="16714" href="Data.Int.html#16646" class="Bound">m</a><a id="16715" class="Symbol">)</a> <a id="16717" class="Symbol">(</a><a id="16718" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="16722" href="Data.Int.html#16648" class="Bound">n</a><a id="16723" class="Symbol">))</a> <a id="16726" href="Data.Int.html#16650" class="Bound">i</a>
</pre>
<details>
<summary>
There are also variants for binary and ternary predicates.
</summary>
<pre class="Agda"><a id="Int-elim₂-prop"></a><a id="16829" href="Data.Int.html#16829" data-type="((x y : Int) → is-prop (P x y)) →
((a b x y : Nat) → P (diff a b) (diff x y)) → (x y : Int) → P x y" class="Function">Int-elim₂-prop</a> <a id="16844" class="Symbol">:</a> <a id="16846" class="Symbol">∀</a> <a id="16848" class="Symbol">{</a><a id="16849" href="Data.Int.html#16849" class="Bound">ℓ</a><a id="16850" class="Symbol">}</a> <a id="16852" class="Symbol">{</a><a id="16853" href="Data.Int.html#16853" class="Bound">P</a> <a id="16855" class="Symbol">:</a> <a id="16857" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a> <a id="16861" class="Symbol">→</a> <a id="16863" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a> <a id="16867" class="Symbol">→</a> <a id="16869" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="16874" href="Data.Int.html#16849" class="Bound">ℓ</a><a id="16875" class="Symbol">}</a>
               <a id="16892" class="Symbol">→</a> <a id="16894" class="Symbol">((</a><a id="16896" href="Data.Int.html#16896" class="Bound">x</a> <a id="16898" href="Data.Int.html#16898" class="Bound">y</a> <a id="16900" class="Symbol">:</a> <a id="16902" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a><a id="16905" class="Symbol">)</a> <a id="16907" class="Symbol">→</a> <a id="16909" href="1Lab.HLevel.html#2597" data-type="Type ℓ → Type ℓ" class="Function">is-prop</a> <a id="16917" class="Symbol">(</a><a id="16918" href="Data.Int.html#16853" class="Bound">P</a> <a id="16920" href="Data.Int.html#16896" class="Bound">x</a> <a id="16922" href="Data.Int.html#16898" class="Bound">y</a><a id="16923" class="Symbol">))</a>
               <a id="16941" class="Symbol">→</a> <a id="16943" class="Symbol">(</a><a id="16944" href="Data.Int.html#16944" class="Bound">f</a> <a id="16946" class="Symbol">:</a> <a id="16948" class="Symbol">(</a><a id="16949" href="Data.Int.html#16949" class="Bound">a</a> <a id="16951" href="Data.Int.html#16951" class="Bound">b</a> <a id="16953" href="Data.Int.html#16953" class="Bound">x</a> <a id="16955" href="Data.Int.html#16955" class="Bound">y</a> <a id="16957" class="Symbol">:</a> <a id="16959" href="Agda.Builtin.Nat.html#177" data-type="Type" class="Datatype">Nat</a><a id="16962" class="Symbol">)</a> <a id="16964" class="Symbol">→</a> <a id="16966" href="Data.Int.html#16853" class="Bound">P</a> <a id="16968" class="Symbol">(</a><a id="16969" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="16974" href="Data.Int.html#16949" class="Bound">a</a> <a id="16976" href="Data.Int.html#16951" class="Bound">b</a><a id="16977" class="Symbol">)</a> <a id="16979" class="Symbol">(</a><a id="16980" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="16985" href="Data.Int.html#16953" class="Bound">x</a> <a id="16987" href="Data.Int.html#16955" class="Bound">y</a><a id="16988" class="Symbol">))</a>
               <a id="17006" class="Symbol">→</a> <a id="17008" class="Symbol">(</a><a id="17009" href="Data.Int.html#17009" class="Bound">x</a> <a id="17011" class="Symbol">:</a> <a id="17013" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a><a id="17016" class="Symbol">)</a> <a id="17018" class="Symbol">(</a><a id="17019" href="Data.Int.html#17019" class="Bound">y</a> <a id="17021" class="Symbol">:</a> <a id="17023" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a><a id="17026" class="Symbol">)</a> <a id="17028" class="Symbol">→</a> <a id="17030" href="Data.Int.html#16853" class="Bound">P</a> <a id="17032" href="Data.Int.html#17009" class="Bound">x</a> <a id="17034" href="Data.Int.html#17019" class="Bound">y</a>
<a id="17036" href="Data.Int.html#16829" data-type="((x y : Int) → is-prop (P x y)) →
((a b x y : Nat) → P (diff a b) (diff x y)) → (x y : Int) → P x y" class="Function">Int-elim₂-prop</a> <a id="17051" href="Data.Int.html#17051" class="Bound">pprop</a> <a id="17057" href="Data.Int.html#17057" class="Bound">f</a> <a id="17059" class="Symbol">=</a>
  <a id="17063" href="Data.Int.html#16411" data-type="((x : Int) → is-prop (P x)) →
((a b : Nat) → P (diff a b)) → (x : Int) → P x" class="Function">Int-elim-prop</a> <a id="17077" class="Symbol">(λ</a> <a id="17080" href="Data.Int.html#17080" class="Bound">x</a> <a id="17082" class="Symbol">→</a> <a id="17084" href="1Lab.HLevel.Retracts.html#4507" data-type="(n : Nat) →
((x : A) → is-hlevel (B₁ x) n) → is-hlevel ((x : A) → B₁ x) n" class="Function">Π-is-hlevel</a> <a id="17096" class="Number">1</a> <a id="17098" class="Symbol">(</a><a id="17099" href="Data.Int.html#17051" class="Bound">pprop</a> <a id="17105" href="Data.Int.html#17080" class="Bound">x</a><a id="17106" class="Symbol">))</a>
    <a id="17113" class="Symbol">λ</a> <a id="17115" href="Data.Int.html#17115" class="Bound">a</a> <a id="17117" href="Data.Int.html#17117" class="Bound">b</a> <a id="17119" href="Data.Int.html#17119" class="Bound">int</a> <a id="17123" class="Symbol">→</a> <a id="17125" href="Data.Int.html#16411" data-type="((x : Int) → is-prop (P x)) →
((a b : Nat) → P (diff a b)) → (x : Int) → P x" class="Function">Int-elim-prop</a> <a id="17139" class="Symbol">(λ</a> <a id="17142" href="Data.Int.html#17142" class="Bound">x</a> <a id="17144" class="Symbol">→</a> <a id="17146" href="Data.Int.html#17051" class="Bound">pprop</a> <a id="17152" class="Symbol">(</a><a id="17153" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="17158" href="Data.Int.html#17115" class="Bound">a</a> <a id="17160" href="Data.Int.html#17117" class="Bound">b</a><a id="17161" class="Symbol">)</a> <a id="17163" href="Data.Int.html#17142" class="Bound">x</a><a id="17164" class="Symbol">)</a> <a id="17166" class="Symbol">(</a><a id="17167" href="Data.Int.html#17057" class="Bound">f</a> <a id="17169" href="Data.Int.html#17115" class="Bound">a</a> <a id="17171" href="Data.Int.html#17117" class="Bound">b</a><a id="17172" class="Symbol">)</a> <a id="17174" href="Data.Int.html#17119" class="Bound">int</a>

<a id="Int-elim₃-prop"></a><a id="17179" href="Data.Int.html#17179" data-type="((x y z : Int) → is-prop (P x y z)) →
((a b c d e f : Nat) → P (diff a b) (diff c d) (diff e f)) →
(x y z : Int) → P x y z" class="Function">Int-elim₃-prop</a> <a id="17194" class="Symbol">:</a> <a id="17196" class="Symbol">∀</a> <a id="17198" class="Symbol">{</a><a id="17199" href="Data.Int.html#17199" class="Bound">ℓ</a><a id="17200" class="Symbol">}</a> <a id="17202" class="Symbol">{</a><a id="17203" href="Data.Int.html#17203" class="Bound">P</a> <a id="17205" class="Symbol">:</a> <a id="17207" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a> <a id="17211" class="Symbol">→</a> <a id="17213" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a> <a id="17217" class="Symbol">→</a> <a id="17219" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a> <a id="17223" class="Symbol">→</a> <a id="17225" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="17230" href="Data.Int.html#17199" class="Bound">ℓ</a><a id="17231" class="Symbol">}</a>
               <a id="17248" class="Symbol">→</a> <a id="17250" class="Symbol">((</a><a id="17252" href="Data.Int.html#17252" class="Bound">x</a> <a id="17254" href="Data.Int.html#17254" class="Bound">y</a> <a id="17256" href="Data.Int.html#17256" class="Bound">z</a> <a id="17258" class="Symbol">:</a> <a id="17260" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a><a id="17263" class="Symbol">)</a> <a id="17265" class="Symbol">→</a> <a id="17267" href="1Lab.HLevel.html#2597" data-type="Type ℓ → Type ℓ" class="Function">is-prop</a> <a id="17275" class="Symbol">(</a><a id="17276" href="Data.Int.html#17203" class="Bound">P</a> <a id="17278" href="Data.Int.html#17252" class="Bound">x</a> <a id="17280" href="Data.Int.html#17254" class="Bound">y</a> <a id="17282" href="Data.Int.html#17256" class="Bound">z</a><a id="17283" class="Symbol">))</a>
               <a id="17301" class="Symbol">→</a> <a id="17303" class="Symbol">(</a><a id="17304" href="Data.Int.html#17304" class="Bound">f</a> <a id="17306" class="Symbol">:</a> <a id="17308" class="Symbol">(</a><a id="17309" href="Data.Int.html#17309" class="Bound">a</a> <a id="17311" href="Data.Int.html#17311" class="Bound">b</a> <a id="17313" href="Data.Int.html#17313" class="Bound">c</a> <a id="17315" href="Data.Int.html#17315" class="Bound">d</a> <a id="17317" href="Data.Int.html#17317" class="Bound">e</a> <a id="17319" href="Data.Int.html#17319" class="Bound">f</a> <a id="17321" class="Symbol">:</a> <a id="17323" href="Agda.Builtin.Nat.html#177" data-type="Type" class="Datatype">Nat</a><a id="17326" class="Symbol">)</a> <a id="17328" class="Symbol">→</a> <a id="17330" href="Data.Int.html#17203" class="Bound">P</a> <a id="17332" class="Symbol">(</a><a id="17333" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="17338" href="Data.Int.html#17309" class="Bound">a</a> <a id="17340" href="Data.Int.html#17311" class="Bound">b</a><a id="17341" class="Symbol">)</a> <a id="17343" class="Symbol">(</a><a id="17344" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="17349" href="Data.Int.html#17313" class="Bound">c</a> <a id="17351" href="Data.Int.html#17315" class="Bound">d</a><a id="17352" class="Symbol">)</a> <a id="17354" class="Symbol">(</a><a id="17355" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="17360" href="Data.Int.html#17317" class="Bound">e</a> <a id="17362" href="Data.Int.html#17319" class="Bound">f</a><a id="17363" class="Symbol">))</a>
               <a id="17381" class="Symbol">→</a> <a id="17383" class="Symbol">(</a><a id="17384" href="Data.Int.html#17384" class="Bound">x</a> <a id="17386" class="Symbol">:</a> <a id="17388" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a><a id="17391" class="Symbol">)</a> <a id="17393" class="Symbol">(</a><a id="17394" href="Data.Int.html#17394" class="Bound">y</a> <a id="17396" class="Symbol">:</a> <a id="17398" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a><a id="17401" class="Symbol">)</a> <a id="17403" class="Symbol">(</a><a id="17404" href="Data.Int.html#17404" class="Bound">z</a> <a id="17406" class="Symbol">:</a> <a id="17408" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a><a id="17411" class="Symbol">)</a> <a id="17413" class="Symbol">→</a> <a id="17415" href="Data.Int.html#17203" class="Bound">P</a> <a id="17417" href="Data.Int.html#17384" class="Bound">x</a> <a id="17419" href="Data.Int.html#17394" class="Bound">y</a> <a id="17421" href="Data.Int.html#17404" class="Bound">z</a>
<a id="17423" href="Data.Int.html#17179" data-type="((x y z : Int) → is-prop (P x y z)) →
((a b c d e f : Nat) → P (diff a b) (diff c d) (diff e f)) →
(x y z : Int) → P x y z" class="Function">Int-elim₃-prop</a> <a id="17438" href="Data.Int.html#17438" class="Bound">pprop</a> <a id="17444" href="Data.Int.html#17444" class="Bound">f</a> <a id="17446" class="Symbol">=</a>
  <a id="17450" href="Data.Int.html#16829" data-type="((x y : Int) → is-prop (P x y)) →
((a b x y : Nat) → P (diff a b) (diff x y)) → (x y : Int) → P x y" class="Function">Int-elim₂-prop</a> <a id="17465" class="Symbol">(λ</a> <a id="17468" href="Data.Int.html#17468" class="Bound">x</a> <a id="17470" href="Data.Int.html#17470" class="Bound">y</a> <a id="17472" class="Symbol">→</a> <a id="17474" href="1Lab.HLevel.Retracts.html#4507" data-type="(n : Nat) →
((x : A) → is-hlevel (B₁ x) n) → is-hlevel ((x : A) → B₁ x) n" class="Function">Π-is-hlevel</a> <a id="17486" class="Number">1</a> <a id="17488" class="Symbol">(</a><a id="17489" href="Data.Int.html#17438" class="Bound">pprop</a> <a id="17495" href="Data.Int.html#17468" class="Bound">x</a> <a id="17497" href="Data.Int.html#17470" class="Bound">y</a><a id="17498" class="Symbol">))</a>
    <a id="17505" class="Symbol">λ</a> <a id="17507" href="Data.Int.html#17507" class="Bound">a</a> <a id="17509" href="Data.Int.html#17509" class="Bound">b</a> <a id="17511" href="Data.Int.html#17511" class="Bound">c</a> <a id="17513" href="Data.Int.html#17513" class="Bound">d</a> <a id="17515" href="Data.Int.html#17515" class="Bound">int</a> <a id="17519" class="Symbol">→</a> <a id="17521" href="Data.Int.html#16411" data-type="((x : Int) → is-prop (P x)) →
((a b : Nat) → P (diff a b)) → (x : Int) → P x" class="Function">Int-elim-prop</a> <a id="17535" class="Symbol">(λ</a> <a id="17538" href="Data.Int.html#17538" class="Bound">x</a> <a id="17540" class="Symbol">→</a> <a id="17542" href="Data.Int.html#17438" class="Bound">pprop</a> <a id="17548" class="Symbol">(</a><a id="17549" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="17554" href="Data.Int.html#17507" class="Bound">a</a> <a id="17556" href="Data.Int.html#17509" class="Bound">b</a><a id="17557" class="Symbol">)</a> <a id="17559" class="Symbol">(</a><a id="17560" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="17565" href="Data.Int.html#17511" class="Bound">c</a> <a id="17567" href="Data.Int.html#17513" class="Bound">d</a><a id="17568" class="Symbol">)</a> <a id="17570" href="Data.Int.html#17538" class="Bound">x</a><a id="17571" class="Symbol">)</a>
                                  <a id="17607" class="Symbol">(</a><a id="17608" href="Data.Int.html#17444" class="Bound">f</a> <a id="17610" href="Data.Int.html#17507" class="Bound">a</a> <a id="17612" href="Data.Int.html#17509" class="Bound">b</a> <a id="17614" href="Data.Int.html#17511" class="Bound">c</a> <a id="17616" href="Data.Int.html#17513" class="Bound">d</a><a id="17617" class="Symbol">)</a>
                                  <a id="17653" href="Data.Int.html#17515" class="Bound">int</a>
</pre>
</details>
<p>A third possibility for elimination is granted to us by the
canonicalisation procedure: By canonicalising and looking at the
resulting minuend and subtrahend<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>, we can split on an
integer based on its sign:</p>
<!--
<pre class="Agda"><a id="18018" class="Keyword">abstract</a>
  <a id="canonicalise-not-both-suc"></a><a id="18029" href="Data.Int.html#18029" data-type="(x : Int) →
canonicalise x .fst ≡ suc k → canonicalise x .snd .fst ≡ suc n → ⊥" class="Function">canonicalise-not-both-suc</a>
    <a id="18059" class="Symbol">:</a> <a id="18061" class="Symbol">∀</a> <a id="18063" href="Data.Int.html#18063" class="Bound">x</a> <a id="18065" class="Symbol">{</a><a id="18066" href="Data.Int.html#18066" class="Bound">k</a> <a id="18068" href="Data.Int.html#18068" class="Bound">n</a><a id="18069" class="Symbol">}</a>
    <a id="18075" class="Symbol">→</a> <a id="18077" class="Symbol">(</a><a id="18078" href="Data.Int.html#18078" class="Bound">p</a> <a id="18080" class="Symbol">:</a> <a id="18082" href="Data.Int.html#8375" data-type="(n : Int) → Canonical n" class="Function">canonicalise</a> <a id="18095" href="Data.Int.html#18063" class="Bound">x</a> <a id="18097" class="Symbol">.</a><a id="18098" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a>      <a id="18107" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="18109" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="18113" href="Data.Int.html#18066" class="Bound">k</a><a id="18114" class="Symbol">)</a>
    <a id="18120" class="Symbol">→</a> <a id="18122" class="Symbol">(</a><a id="18123" href="Data.Int.html#18123" class="Bound">q</a> <a id="18125" class="Symbol">:</a> <a id="18127" href="Data.Int.html#8375" data-type="(n : Int) → Canonical n" class="Function">canonicalise</a> <a id="18140" href="Data.Int.html#18063" class="Bound">x</a> <a id="18142" class="Symbol">.</a><a id="18143" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="18147" class="Symbol">.</a><a id="18148" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="18152" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="18154" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="18158" href="Data.Int.html#18068" class="Bound">n</a><a id="18159" class="Symbol">)</a>
    <a id="18165" class="Symbol">→</a> <a id="18167" href="1Lab.Type.html#1336" data-type="Type" class="Datatype">⊥</a>
  <a id="18171" href="Data.Int.html#18029" data-type="(x : Int) →
canonicalise x .fst ≡ suc k → canonicalise x .snd .fst ≡ suc n → ⊥" class="Function">canonicalise-not-both-suc</a> <a id="18197" class="Symbol">=</a>
    <a id="18203" href="Data.Int.html#16411" data-type="((x : Int) → is-prop (P x)) →
((a b : Nat) → P (diff a b)) → (x : Int) → P x" class="Function">Int-elim-prop</a> <a id="18217" class="Symbol">{</a><a id="18218" class="Argument">P</a> <a id="18220" class="Symbol">=</a> <a id="18222" class="Symbol">λ</a> <a id="18224" href="Data.Int.html#18224" class="Bound">x</a> <a id="18226" class="Symbol">→</a> <a id="18228" class="Symbol">∀</a> <a id="18230" class="Symbol">{</a><a id="18231" href="Data.Int.html#18231" class="Bound">k</a> <a id="18233" href="Data.Int.html#18233" class="Bound">n</a><a id="18234" class="Symbol">}</a>
                           <a id="18263" class="Symbol">→</a> <a id="18265" class="Symbol">(</a><a id="18266" href="Data.Int.html#18266" class="Bound">p</a> <a id="18268" class="Symbol">:</a> <a id="18270" href="Data.Int.html#8375" data-type="(n : Int) → Canonical n" class="Function">canonicalise</a> <a id="18283" href="Data.Int.html#18224" class="Bound">x</a> <a id="18285" class="Symbol">.</a><a id="18286" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a>      <a id="18295" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="18297" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="18301" href="Data.Int.html#18231" class="Bound">k</a><a id="18302" class="Symbol">)</a>
                             <a id="18333" class="Symbol">(</a><a id="18334" href="Data.Int.html#18334" class="Bound">q</a> <a id="18336" class="Symbol">:</a> <a id="18338" href="Data.Int.html#8375" data-type="(n : Int) → Canonical n" class="Function">canonicalise</a> <a id="18351" href="Data.Int.html#18224" class="Bound">x</a> <a id="18353" class="Symbol">.</a><a id="18354" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="18358" class="Symbol">.</a><a id="18359" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="18363" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="18365" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="18369" href="Data.Int.html#18233" class="Bound">n</a><a id="18370" class="Symbol">)</a>
                           <a id="18399" class="Symbol">→</a> <a id="18401" href="1Lab.Type.html#1336" data-type="Type" class="Datatype">⊥</a> <a id="18403" class="Symbol">}</a>
      <a id="18411" class="Symbol">(λ</a> <a id="18414" href="Data.Int.html#18414" class="Bound">p</a> <a id="18416" class="Symbol">→</a> <a id="18418" href="1Lab.HLevel.Retracts.html#8061" data-type="(n : Nat) ⦃ x : H-Level T n ⦄ → is-hlevel T n" class="Function">hlevel</a> <a id="18425" class="Number">1</a><a id="18426" class="Symbol">)</a>
      <a id="18434" href="Data.Int.html#18453" data-type="(a b : Nat) →
canonicalise (diff a b) .fst ≡ suc k →
canonicalise (diff a b) .snd .fst ≡ suc n → ⊥" class="Function">go</a>
    <a id="18441" class="Keyword">where</a>
      <a id="18453" href="Data.Int.html#18453" data-type="(a b : Nat) →
canonicalise (diff a b) .fst ≡ suc k →
canonicalise (diff a b) .snd .fst ≡ suc n → ⊥" class="Function">go</a> <a id="18456" class="Symbol">:</a> <a id="18458" class="Symbol">∀</a> <a id="18460" href="Data.Int.html#18460" class="Bound">a</a> <a id="18462" href="Data.Int.html#18462" class="Bound">b</a> <a id="18464" class="Symbol">{</a><a id="18465" href="Data.Int.html#18465" class="Bound">k</a> <a id="18467" href="Data.Int.html#18467" class="Bound">n</a><a id="18468" class="Symbol">}</a>
           <a id="18481" class="Symbol">(</a><a id="18482" href="Data.Int.html#18482" class="Bound">p</a> <a id="18484" class="Symbol">:</a> <a id="18486" href="Data.Int.html#8375" data-type="(n : Int) → Canonical n" class="Function">canonicalise</a> <a id="18499" class="Symbol">(</a><a id="18500" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="18505" href="Data.Int.html#18460" class="Bound">a</a> <a id="18507" href="Data.Int.html#18462" class="Bound">b</a><a id="18508" class="Symbol">)</a> <a id="18510" class="Symbol">.</a><a id="18511" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a>      <a id="18520" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="18522" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="18526" href="Data.Int.html#18465" class="Bound">k</a><a id="18527" class="Symbol">)</a>
           <a id="18540" class="Symbol">(</a><a id="18541" href="Data.Int.html#18541" class="Bound">q</a> <a id="18543" class="Symbol">:</a> <a id="18545" href="Data.Int.html#8375" data-type="(n : Int) → Canonical n" class="Function">canonicalise</a> <a id="18558" class="Symbol">(</a><a id="18559" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="18564" href="Data.Int.html#18460" class="Bound">a</a> <a id="18566" href="Data.Int.html#18462" class="Bound">b</a><a id="18567" class="Symbol">)</a> <a id="18569" class="Symbol">.</a><a id="18570" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="18574" class="Symbol">.</a><a id="18575" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="18579" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="18581" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="18585" href="Data.Int.html#18467" class="Bound">n</a><a id="18586" class="Symbol">)</a>
         <a id="18597" class="Symbol">→</a> <a id="18599" href="1Lab.Type.html#1336" data-type="Type" class="Datatype">⊥</a>
      <a id="18607" href="Data.Int.html#18453" data-type="(a b : Nat) →
canonicalise (diff a b) .fst ≡ suc k →
canonicalise (diff a b) .snd .fst ≡ suc n → ⊥" class="Function">go</a> <a id="18610" href="Data.Int.html#18610" class="Bound">a</a> <a id="18612" href="Data.Int.html#18612" class="Bound">b</a> <a id="18614" href="Data.Int.html#18614" class="Bound">p</a> <a id="18616" href="Data.Int.html#18616" class="Bound">q</a> <a id="18618" class="Keyword">with</a> <a id="18623" href="Data.Nat.Properties.html#5777" data-type="(x y : Nat) → x &lt; y ⊎ y &lt; x ⊎ x ≡ y" class="Function">≤-split</a> <a id="18631" href="Data.Int.html#18610" class="Bound">a</a> <a id="18633" href="Data.Int.html#18612" class="Bound">b</a>
      <a id="18641" class="Symbol">...</a> <a id="18645" class="Symbol">|</a> <a id="18647" href="Data.Sum.html#669" data-type="A → A ⊎ B₁" class="InductiveConstructor">inl</a> <a id="18651" href="Data.Int.html#18651" class="Bound">x</a>       <a id="18659" class="Symbol">=</a> <a id="18661" href="1Lab.Type.html#1352" data-type="⊥ → A" class="Function">absurd</a> <a id="18668" class="Symbol">(</a><a id="18669" href="Data.Nat.Base.html#1178" data-type="zero ≡ suc n → ⊥" class="Function">zero≠suc</a> <a id="18678" class="Bound">p</a><a id="18679" class="Symbol">)</a>
      <a id="18687" class="Symbol">...</a> <a id="18691" class="Symbol">|</a> <a id="18693" href="Data.Sum.html#687" data-type="B₁ → A ⊎ B₁" class="InductiveConstructor">inr</a> <a id="18697" class="Symbol">(</a><a id="18698" href="Data.Sum.html#669" data-type="A → A ⊎ B₁" class="InductiveConstructor">inl</a> <a id="18702" href="Data.Int.html#18702" class="Bound">x</a><a id="18703" class="Symbol">)</a> <a id="18705" class="Symbol">=</a> <a id="18707" href="1Lab.Type.html#1352" data-type="⊥ → A" class="Function">absurd</a> <a id="18714" class="Symbol">(</a><a id="18715" href="Data.Nat.Base.html#1178" data-type="zero ≡ suc n → ⊥" class="Function">zero≠suc</a> <a id="18724" class="Bound">q</a><a id="18725" class="Symbol">)</a>
      <a id="18733" class="Symbol">...</a> <a id="18737" class="Symbol">|</a> <a id="18739" href="Data.Sum.html#687" data-type="B₁ → A ⊎ B₁" class="InductiveConstructor">inr</a> <a id="18743" class="Symbol">(</a><a id="18744" href="Data.Sum.html#687" data-type="B₁ → A ⊎ B₁" class="InductiveConstructor">inr</a> <a id="18748" href="Data.Int.html#18748" class="Bound">x</a><a id="18749" class="Symbol">)</a> <a id="18751" class="Symbol">=</a> <a id="18753" href="1Lab.Type.html#1352" data-type="⊥ → A" class="Function">absurd</a> <a id="18760" class="Symbol">(</a><a id="18761" href="Data.Nat.Base.html#1178" data-type="zero ≡ suc n → ⊥" class="Function">zero≠suc</a> <a id="18770" class="Bound">q</a><a id="18771" class="Symbol">)</a>
</pre>-->
<pre class="Agda"><a id="Int-elim-by-sign"></a><a id="18790" href="Data.Int.html#18790" data-type="(P : Int → Type) →
((x : Nat) → P (diff x 0)) →
((x : Nat) → P (diff 0 x)) → P (diff 0 0) → (x : Int) → P x" class="Function">Int-elim-by-sign</a>
  <a id="18809" class="Symbol">:</a> <a id="18811" class="Symbol">(</a><a id="18812" href="Data.Int.html#18812" class="Bound">P</a> <a id="18814" class="Symbol">:</a> <a id="18816" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a> <a id="18820" class="Symbol">→</a> <a id="18822" href="1Lab.Type.html#391" class="Primitive">Type</a><a id="18826" class="Symbol">)</a>
  <a id="18830" class="Symbol">→</a> <a id="18832" class="Symbol">(</a><a id="18833" href="Data.Int.html#18833" class="Bound">pos</a> <a id="18837" class="Symbol">:</a> <a id="18839" class="Symbol">∀</a> <a id="18841" href="Data.Int.html#18841" class="Bound">x</a> <a id="18843" class="Symbol">→</a> <a id="18845" href="Data.Int.html#18812" class="Bound">P</a> <a id="18847" class="Symbol">(</a><a id="18848" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="18853" href="Data.Int.html#18841" class="Bound">x</a> <a id="18855" class="Number">0</a><a id="18856" class="Symbol">))</a>
  <a id="18861" class="Symbol">→</a> <a id="18863" class="Symbol">(</a><a id="18864" href="Data.Int.html#18864" class="Bound">neg</a> <a id="18868" class="Symbol">:</a> <a id="18870" class="Symbol">∀</a> <a id="18872" href="Data.Int.html#18872" class="Bound">x</a> <a id="18874" class="Symbol">→</a> <a id="18876" href="Data.Int.html#18812" class="Bound">P</a> <a id="18878" class="Symbol">(</a><a id="18879" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="18884" class="Number">0</a> <a id="18886" href="Data.Int.html#18872" class="Bound">x</a><a id="18887" class="Symbol">))</a>
  <a id="18892" class="Symbol">→</a> <a id="18894" href="Data.Int.html#18812" class="Bound">P</a> <a id="18896" class="Symbol">(</a><a id="18897" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="18902" class="Number">0</a> <a id="18904" class="Number">0</a><a id="18905" class="Symbol">)</a>
  <a id="18909" class="Symbol">→</a> <a id="18911" class="Symbol">∀</a> <a id="18913" href="Data.Int.html#18913" class="Bound">x</a> <a id="18915" class="Symbol">→</a> <a id="18917" href="Data.Int.html#18812" class="Bound">P</a> <a id="18919" href="Data.Int.html#18913" class="Bound">x</a>
<a id="18921" href="Data.Int.html#18790" data-type="(P : Int → Type) →
((x : Nat) → P (diff x 0)) →
((x : Nat) → P (diff 0 x)) → P (diff 0 0) → (x : Int) → P x" class="Function">Int-elim-by-sign</a> <a id="18938" href="Data.Int.html#18938" class="Bound">P</a> <a id="18940" href="Data.Int.html#18940" class="Bound">pos</a> <a id="18944" href="Data.Int.html#18944" class="Bound">neg</a> <a id="18948" href="Data.Int.html#18948" class="Bound">zer</a> <a id="18952" href="Data.Int.html#18952" class="Bound">x</a> <a id="18954" class="Keyword">with</a> <a id="18959" href="1Lab.Path.html#20337" data-type="(x : A) → Singleton x" class="Function">inspect</a> <a id="18967" class="Symbol">(</a><a id="18968" href="Data.Int.html#8375" data-type="(n : Int) → Canonical n" class="Function">canonicalise</a> <a id="18981" href="Data.Int.html#18952" class="Bound">x</a><a id="18982" class="Symbol">)</a>
<a id="18984" class="Symbol">...</a> <a id="18988" class="Symbol">|</a> <a id="18990" class="Symbol">(</a><a id="18991" href="Agda.Builtin.Nat.html#195" data-type="Nat" class="InductiveConstructor">zero</a>  <a id="18997" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="18999" href="Agda.Builtin.Nat.html#195" data-type="Nat" class="InductiveConstructor">zero</a>  <a id="19005" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="19007" href="Data.Int.html#19007" class="Bound">p</a><a id="19008" class="Symbol">)</a> <a id="19010" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="19012" href="Data.Int.html#19012" class="Bound">q</a> <a id="19014" class="Symbol">=</a> <a id="19016" href="1Lab.Path.html#15309" data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" class="Function">subst</a> <a id="19022" class="Bound">P</a> <a id="19024" href="Data.Int.html#19007" class="Bound">p</a> <a id="19026" class="Bound">zer</a>
<a id="19030" class="Symbol">...</a> <a id="19034" class="Symbol">|</a> <a id="19036" class="Symbol">(</a><a id="19037" href="Agda.Builtin.Nat.html#195" data-type="Nat" class="InductiveConstructor">zero</a>  <a id="19043" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="19045" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="19049" href="Data.Int.html#19049" class="Bound">b</a> <a id="19051" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="19053" href="Data.Int.html#19053" class="Bound">p</a><a id="19054" class="Symbol">)</a> <a id="19056" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="19058" href="Data.Int.html#19058" class="Bound">q</a> <a id="19060" class="Symbol">=</a> <a id="19062" href="1Lab.Path.html#15309" data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" class="Function">subst</a> <a id="19068" class="Bound">P</a> <a id="19070" href="Data.Int.html#19053" class="Bound">p</a> <a id="19072" class="Symbol">(</a><a id="19073" class="Bound">neg</a> <a id="19077" class="Symbol">(</a><a id="19078" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="19082" href="Data.Int.html#19049" class="Bound">b</a><a id="19083" class="Symbol">))</a>
<a id="19086" class="Symbol">...</a> <a id="19090" class="Symbol">|</a> <a id="19092" class="Symbol">(</a><a id="19093" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="19097" href="Data.Int.html#19097" class="Bound">a</a> <a id="19099" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="19101" href="Agda.Builtin.Nat.html#195" data-type="Nat" class="InductiveConstructor">zero</a>  <a id="19107" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="19109" href="Data.Int.html#19109" class="Bound">p</a><a id="19110" class="Symbol">)</a> <a id="19112" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="19114" href="Data.Int.html#19114" class="Bound">q</a> <a id="19116" class="Symbol">=</a> <a id="19118" href="1Lab.Path.html#15309" data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" class="Function">subst</a> <a id="19124" class="Bound">P</a> <a id="19126" href="Data.Int.html#19109" class="Bound">p</a> <a id="19128" class="Symbol">(</a><a id="19129" class="Bound">pos</a> <a id="19133" class="Symbol">(</a><a id="19134" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="19138" href="Data.Int.html#19097" class="Bound">a</a><a id="19139" class="Symbol">))</a>
<a id="19142" class="Symbol">...</a> <a id="19146" class="Symbol">|</a> <a id="19148" class="Symbol">(</a><a id="19149" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="19153" href="Data.Int.html#19153" class="Bound">a</a> <a id="19155" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="19157" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="19161" href="Data.Int.html#19161" class="Bound">b</a> <a id="19163" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="19165" href="Data.Int.html#19165" class="Bound">p</a><a id="19166" class="Symbol">)</a> <a id="19168" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="19170" href="Data.Int.html#19170" class="Bound">q</a> <a id="19172" class="Symbol">=</a>
  <a id="19176" href="1Lab.Type.html#1352" data-type="⊥ → A" class="Function">absurd</a> <a id="19183" class="Symbol">(</a><a id="19184" href="Data.Int.html#18029" data-type="(x : Int) →
canonicalise x .fst ≡ suc k → canonicalise x .snd .fst ≡ suc n → ⊥" class="Function">canonicalise-not-both-suc</a> <a id="19210" class="Bound">x</a> <a id="19212" class="Symbol">(</a><a id="19213" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="19216" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="19220" href="Data.Int.html#19170" class="Bound">q</a><a id="19221" class="Symbol">)</a> <a id="19223" class="Symbol">(</a><a id="19224" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="19227" class="Symbol">(</a><a id="19228" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="19232" href="1Lab.Type.html#2227" data-type="((y : B₁ x) → C x y) → (f : (x : A) → B₁ x) (x : A) → C x (f x)" class="Function Operator">∘</a> <a id="19234" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a><a id="19237" class="Symbol">)</a> <a id="19239" href="Data.Int.html#19170" class="Bound">q</a><a id="19240" class="Symbol">))</a>
</pre>
<p>This procedure is useful, for instance, for computing absolute
values:</p>
<pre class="Agda"><a id="abs"></a><a id="19328" href="Data.Int.html#19328" data-type="Int → Nat" class="Function">abs</a> <a id="19332" class="Symbol">:</a> <a id="19334" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a> <a id="19338" class="Symbol">→</a> <a id="19340" href="Agda.Builtin.Nat.html#177" data-type="Type" class="Datatype">Nat</a>
<a id="19344" href="Data.Int.html#19328" data-type="Int → Nat" class="Function">abs</a> <a id="19348" class="Symbol">=</a> <a id="19350" href="Data.Int.html#18790" data-type="(P : Int → Type) →
((x : Nat) → P (diff x 0)) →
((x : Nat) → P (diff 0 x)) → P (diff 0 0) → (x : Int) → P x" class="Function">Int-elim-by-sign</a> <a id="19367" class="Symbol">_</a> <a id="19369" class="Symbol">(λ</a> <a id="19372" href="Data.Int.html#19372" class="Bound">x</a> <a id="19374" class="Symbol">→</a> <a id="19376" href="Data.Int.html#19372" class="Bound">x</a><a id="19377" class="Symbol">)</a> <a id="19379" class="Symbol">(λ</a> <a id="19382" href="Data.Int.html#19382" class="Bound">x</a> <a id="19384" class="Symbol">→</a> <a id="19386" href="Data.Int.html#19382" class="Bound">x</a><a id="19387" class="Symbol">)</a> <a id="19389" href="Agda.Builtin.Nat.html#195" data-type="Nat" class="InductiveConstructor">zero</a>

<a id="19395" href="Data.Int.html#19395" class="Function">_</a> <a id="19397" class="Symbol">:</a> <a id="19399" href="Data.Int.html#19328" data-type="Int → Nat" class="Function">abs</a> <a id="19403" class="Number">-10</a> <a id="19407" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="19409" class="Number">10</a>
<a id="19412" class="Symbol">_</a> <a id="19414" class="Symbol">=</a> <a id="19416" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
</pre>
<h1 id="algebra"><a href="#algebra" class="header-link">Algebra<span class="header-link-emoji">🔗</span></a></h1>
<p>With these recursion and elimination helpers, it becomes routine to
lift the algebraic operations from naturals to integers:</p>
<h2 id="successors"><a href="#successors" class="header-link">Successors<span class="header-link-emoji">🔗</span></a></h2>
<p>The simplest “algebraic operation” on an integer is taking its
successor. In fact, the integers are characterised by being the free
type with an equivalence - that equivalence being “successor”.</p>
<pre class="Agda"><a id="sucℤ"></a><a id="19782" href="Data.Int.html#19782" data-type="Int → Int" class="Function">sucℤ</a> <a id="19787" class="Symbol">:</a> <a id="19789" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a> <a id="19793" class="Symbol">→</a> <a id="19795" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a>
<a id="19799" href="Data.Int.html#19782" data-type="Int → Int" class="Function">sucℤ</a> <a id="19804" class="Symbol">(</a><a id="19805" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="19810" href="Data.Int.html#19810" class="Bound">x</a> <a id="19812" href="Data.Int.html#19812" class="Bound">y</a><a id="19813" class="Symbol">)</a>   <a id="19817" class="Symbol">=</a> <a id="19819" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="19824" class="Symbol">(</a><a id="19825" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="19829" href="Data.Int.html#19810" class="Bound">x</a><a id="19830" class="Symbol">)</a> <a id="19832" href="Data.Int.html#19812" class="Bound">y</a>
<a id="19834" href="Data.Int.html#19782" data-type="Int → Int" class="Function">sucℤ</a> <a id="19839" class="Symbol">(</a><a id="19840" href="Data.Int.html#689" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="19845" href="Data.Int.html#19845" class="Bound">m</a> <a id="19847" href="Data.Int.html#19847" class="Bound">n</a> <a id="19849" href="Data.Int.html#19849" class="Bound">i</a><a id="19850" class="Symbol">)</a> <a id="19852" class="Symbol">=</a> <a id="19854" href="Data.Int.html#689" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="19859" class="Symbol">(</a><a id="19860" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="19864" href="Data.Int.html#19845" class="Bound">m</a><a id="19865" class="Symbol">)</a> <a id="19867" href="Data.Int.html#19847" class="Bound">n</a> <a id="19869" href="Data.Int.html#19849" class="Bound">i</a>

<a id="predℤ"></a><a id="19872" href="Data.Int.html#19872" data-type="Int → Int" class="Function">predℤ</a> <a id="19878" class="Symbol">:</a> <a id="19880" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a> <a id="19884" class="Symbol">→</a> <a id="19886" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a>
<a id="19890" href="Data.Int.html#19872" data-type="Int → Int" class="Function">predℤ</a> <a id="19896" class="Symbol">(</a><a id="19897" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="19902" href="Data.Int.html#19902" class="Bound">x</a> <a id="19904" href="Data.Int.html#19904" class="Bound">y</a><a id="19905" class="Symbol">)</a>   <a id="19909" class="Symbol">=</a> <a id="19911" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="19916" href="Data.Int.html#19902" class="Bound">x</a> <a id="19918" class="Symbol">(</a><a id="19919" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="19923" href="Data.Int.html#19904" class="Bound">y</a><a id="19924" class="Symbol">)</a>
<a id="19926" href="Data.Int.html#19872" data-type="Int → Int" class="Function">predℤ</a> <a id="19932" class="Symbol">(</a><a id="19933" href="Data.Int.html#689" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="19938" href="Data.Int.html#19938" class="Bound">m</a> <a id="19940" href="Data.Int.html#19940" class="Bound">n</a> <a id="19942" href="Data.Int.html#19942" class="Bound">i</a><a id="19943" class="Symbol">)</a> <a id="19945" class="Symbol">=</a> <a id="19947" href="Data.Int.html#689" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="19952" href="Data.Int.html#19938" class="Bound">m</a> <a id="19954" class="Symbol">(</a><a id="19955" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="19959" href="Data.Int.html#19940" class="Bound">n</a><a id="19960" class="Symbol">)</a> <a id="19962" href="Data.Int.html#19942" class="Bound">i</a>
</pre>
<p>The successor of
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a, b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>
is
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1 + a, b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>.</span>
Similarly, the predecessor of
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a, b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>
is
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mn>1</mn><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a, 1 + b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>.</span>
By the generating equality
<span class="Agda"><a href="Data.Int.html#689" class="InductiveConstructor">quot</a></span>,
we have that predecessor and successor are inverses, since applying both
(in either order) takes
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a, b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>
to
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>a</mi><mo separator="true">,</mo><mn>1</mn><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1 + a, 1 + b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>.</span></p>
<pre class="Agda"><a id="pred-sucℤ"></a><a id="20246" href="Data.Int.html#20246" data-type="(x : Int) → predℤ (sucℤ x) ≡ x" class="Function">pred-sucℤ</a> <a id="20256" class="Symbol">:</a> <a id="20258" class="Symbol">(</a><a id="20259" href="Data.Int.html#20259" class="Bound">x</a> <a id="20261" class="Symbol">:</a> <a id="20263" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a><a id="20266" class="Symbol">)</a> <a id="20268" class="Symbol">→</a> <a id="20270" href="Data.Int.html#19872" data-type="Int → Int" class="Function">predℤ</a> <a id="20276" class="Symbol">(</a><a id="20277" href="Data.Int.html#19782" data-type="Int → Int" class="Function">sucℤ</a> <a id="20282" href="Data.Int.html#20259" class="Bound">x</a><a id="20283" class="Symbol">)</a> <a id="20285" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="20287" href="Data.Int.html#20259" class="Bound">x</a>
<a id="20289" href="Data.Int.html#20246" data-type="(x : Int) → predℤ (sucℤ x) ≡ x" class="Function">pred-sucℤ</a> <a id="20299" class="Symbol">(</a><a id="20300" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="20305" href="Data.Int.html#20305" class="Bound">x</a> <a id="20307" href="Data.Int.html#20307" class="Bound">y</a><a id="20308" class="Symbol">)</a>     <a id="20314" class="Symbol">=</a> <a id="20316" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="20320" class="Symbol">(</a><a id="20321" href="Data.Int.html#689" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="20326" href="Data.Int.html#20305" class="Bound">x</a> <a id="20328" href="Data.Int.html#20307" class="Bound">y</a><a id="20329" class="Symbol">)</a>
<a id="20331" href="Data.Int.html#20246" data-type="(x : Int) → predℤ (sucℤ x) ≡ x" class="Function">pred-sucℤ</a> <a id="20341" class="Symbol">(</a><a id="20342" href="Data.Int.html#689" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="20347" href="Data.Int.html#20347" class="Bound">m</a> <a id="20349" href="Data.Int.html#20349" class="Bound">n</a> <a id="20351" href="Data.Int.html#20351" class="Bound">i</a><a id="20352" class="Symbol">)</a> <a id="20354" href="Data.Int.html#20354" class="Bound">j</a> <a id="20356" class="Symbol">=</a> <a id="20358" href="Data.Int.html#3762" data-type="(a b : Nat) →
Square (quot a b) (quot a b) (quot (suc a) (suc b))
(quot (suc a) (suc b))" class="Function">quot-diamond</a> <a id="20371" href="Data.Int.html#20347" class="Bound">m</a> <a id="20373" href="Data.Int.html#20349" class="Bound">n</a> <a id="20375" href="Data.Int.html#20351" class="Bound">i</a> <a id="20377" class="Symbol">(</a><a id="20378" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="20380" href="Data.Int.html#20354" class="Bound">j</a><a id="20381" class="Symbol">)</a>

<a id="suc-predℤ"></a><a id="20384" href="Data.Int.html#20384" data-type="(x : Int) → sucℤ (predℤ x) ≡ x" class="Function">suc-predℤ</a> <a id="20394" class="Symbol">:</a> <a id="20396" class="Symbol">(</a><a id="20397" href="Data.Int.html#20397" class="Bound">x</a> <a id="20399" class="Symbol">:</a> <a id="20401" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a><a id="20404" class="Symbol">)</a> <a id="20406" class="Symbol">→</a> <a id="20408" href="Data.Int.html#19782" data-type="Int → Int" class="Function">sucℤ</a> <a id="20413" class="Symbol">(</a><a id="20414" href="Data.Int.html#19872" data-type="Int → Int" class="Function">predℤ</a> <a id="20420" href="Data.Int.html#20397" class="Bound">x</a><a id="20421" class="Symbol">)</a> <a id="20423" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="20425" href="Data.Int.html#20397" class="Bound">x</a>
<a id="20427" href="Data.Int.html#20384" data-type="(x : Int) → sucℤ (predℤ x) ≡ x" class="Function">suc-predℤ</a> <a id="20437" class="Symbol">(</a><a id="20438" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="20443" href="Data.Int.html#20443" class="Bound">x</a> <a id="20445" href="Data.Int.html#20445" class="Bound">y</a><a id="20446" class="Symbol">)</a>     <a id="20452" class="Symbol">=</a> <a id="20454" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="20458" class="Symbol">(</a><a id="20459" href="Data.Int.html#689" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="20464" href="Data.Int.html#20443" class="Bound">x</a> <a id="20466" href="Data.Int.html#20445" class="Bound">y</a><a id="20467" class="Symbol">)</a>
<a id="20469" href="Data.Int.html#20384" data-type="(x : Int) → sucℤ (predℤ x) ≡ x" class="Function">suc-predℤ</a> <a id="20479" class="Symbol">(</a><a id="20480" href="Data.Int.html#689" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="20485" href="Data.Int.html#20485" class="Bound">m</a> <a id="20487" href="Data.Int.html#20487" class="Bound">n</a> <a id="20489" href="Data.Int.html#20489" class="Bound">i</a><a id="20490" class="Symbol">)</a> <a id="20492" href="Data.Int.html#20492" class="Bound">j</a> <a id="20494" class="Symbol">=</a> <a id="20496" href="Data.Int.html#3762" data-type="(a b : Nat) →
Square (quot a b) (quot a b) (quot (suc a) (suc b))
(quot (suc a) (suc b))" class="Function">quot-diamond</a> <a id="20509" href="Data.Int.html#20485" class="Bound">m</a> <a id="20511" href="Data.Int.html#20487" class="Bound">n</a> <a id="20513" href="Data.Int.html#20489" class="Bound">i</a> <a id="20515" class="Symbol">(</a><a id="20516" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="20518" href="Data.Int.html#20492" class="Bound">j</a><a id="20519" class="Symbol">)</a>

<a id="sucℤ-is-equiv"></a><a id="20522" href="Data.Int.html#20522" data-type="is-equiv sucℤ" class="Function">sucℤ-is-equiv</a> <a id="20536" class="Symbol">:</a> <a id="20538" href="1Lab.Equiv.html#2286" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-equiv</a> <a id="20547" href="Data.Int.html#19782" data-type="Int → Int" class="Function">sucℤ</a>
<a id="20552" href="Data.Int.html#20522" data-type="is-equiv sucℤ" class="Function">sucℤ-is-equiv</a> <a id="20566" class="Symbol">=</a> <a id="20568" href="1Lab.Equiv.html#20157" data-type="(i : is-iso f) → is-equiv f" class="Function">is-iso→is-equiv</a> <a id="20584" class="Symbol">(</a><a id="20585" href="1Lab.Equiv.html#6116" data-type="(inv₁ : B₁ → A) (rinv₁ : is-right-inverse inv₁ f)
(linv₁ : is-left-inverse inv₁ f) →
is-iso f" class="InductiveConstructor">iso</a> <a id="20589" href="Data.Int.html#19872" data-type="Int → Int" class="Function">predℤ</a> <a id="20595" href="Data.Int.html#20384" data-type="(x : Int) → sucℤ (predℤ x) ≡ x" class="Function">suc-predℤ</a> <a id="20605" href="Data.Int.html#20246" data-type="(x : Int) → predℤ (sucℤ x) ≡ x" class="Function">pred-sucℤ</a><a id="20614" class="Symbol">)</a>

<a id="predℤ-is-equiv"></a><a id="20617" href="Data.Int.html#20617" data-type="is-equiv predℤ" class="Function">predℤ-is-equiv</a> <a id="20632" class="Symbol">:</a> <a id="20634" href="1Lab.Equiv.html#2286" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-equiv</a> <a id="20643" href="Data.Int.html#19872" data-type="Int → Int" class="Function">predℤ</a>
<a id="20649" href="Data.Int.html#20617" data-type="is-equiv predℤ" class="Function">predℤ-is-equiv</a> <a id="20664" class="Symbol">=</a> <a id="20666" href="1Lab.Equiv.html#20157" data-type="(i : is-iso f) → is-equiv f" class="Function">is-iso→is-equiv</a> <a id="20682" class="Symbol">(</a><a id="20683" href="1Lab.Equiv.html#6116" data-type="(inv₁ : B₁ → A) (rinv₁ : is-right-inverse inv₁ f)
(linv₁ : is-left-inverse inv₁ f) →
is-iso f" class="InductiveConstructor">iso</a> <a id="20687" href="Data.Int.html#19782" data-type="Int → Int" class="Function">sucℤ</a> <a id="20692" href="Data.Int.html#20246" data-type="(x : Int) → predℤ (sucℤ x) ≡ x" class="Function">pred-sucℤ</a> <a id="20702" href="Data.Int.html#20384" data-type="(x : Int) → sucℤ (predℤ x) ≡ x" class="Function">suc-predℤ</a><a id="20711" class="Symbol">)</a>
</pre>
<h2 id="addition"><a href="#addition" class="header-link">Addition<span class="header-link-emoji">🔗</span></a></h2>
<pre class="Agda"><a id="_+ℤ_"></a><a id="20739" href="Data.Int.html#20739" data-type="Int → Int → Int" class="Function Operator">_+ℤ_</a> <a id="20744" class="Symbol">:</a> <a id="20746" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a> <a id="20750" class="Symbol">→</a> <a id="20752" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a> <a id="20756" class="Symbol">→</a> <a id="20758" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a>
<a id="20762" href="Data.Int.html#20739" data-type="Int → Int → Int" class="Function Operator">_+ℤ_</a> <a id="20767" class="Symbol">=</a>
  <a id="20771" href="Data.Int.html#15682" data-type="⦃ iss-b : H-Level B₁ 2 ⦄ (f : Nat × Nat → Nat × Nat → B₁) →
((a b x y : Nat) → f (a , b) (x , y) ≡ f (suc a , suc b) (x , y)) →
((a b x y : Nat) → f (a , b) (x , y) ≡ f (a , b) (suc x , suc y)) →
Int → Int → B₁" class="Function">Int-rec₂-set</a>
    <a id="20788" class="Symbol">(λ</a> <a id="20791" class="Symbol">{</a> <a id="20793" class="Symbol">(</a><a id="20794" href="Data.Int.html#20794" class="Bound">a</a> <a id="20796" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="20798" href="Data.Int.html#20798" class="Bound">b</a><a id="20799" class="Symbol">)</a> <a id="20801" class="Symbol">(</a><a id="20802" href="Data.Int.html#20802" class="Bound">c</a> <a id="20804" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="20806" href="Data.Int.html#20806" class="Bound">d</a><a id="20807" class="Symbol">)</a> <a id="20809" class="Symbol">→</a> <a id="20811" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="20816" class="Symbol">(</a><a id="20817" href="Data.Int.html#20794" class="Bound">a</a> <a id="20819" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="20821" href="Data.Int.html#20802" class="Bound">c</a><a id="20822" class="Symbol">)</a> <a id="20824" class="Symbol">(</a><a id="20825" href="Data.Int.html#20798" class="Bound">b</a> <a id="20827" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="20829" href="Data.Int.html#20806" class="Bound">d</a><a id="20830" class="Symbol">)})</a>
    <a id="20838" class="Symbol">(λ</a> <a id="20841" href="Data.Int.html#20841" class="Bound">a</a> <a id="20843" href="Data.Int.html#20843" class="Bound">b</a> <a id="20845" href="Data.Int.html#20845" class="Bound">x</a> <a id="20847" href="Data.Int.html#20847" class="Bound">y</a> <a id="20849" class="Symbol">→</a> <a id="20851" href="Data.Int.html#689" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="20856" class="Symbol">_</a> <a id="20858" class="Symbol">_)</a>
    <a id="20865" class="Symbol">(λ</a> <a id="20868" href="Data.Int.html#20868" class="Bound">a</a> <a id="20870" href="Data.Int.html#20870" class="Bound">b</a> <a id="20872" href="Data.Int.html#20872" class="Bound">x</a> <a id="20874" href="Data.Int.html#20874" class="Bound">y</a> <a id="20876" class="Symbol">→</a> <a id="20878" href="Data.Int.html#689" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="20883" class="Symbol">_</a> <a id="20885" class="Symbol">_</a> <a id="20887" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="20889" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="20893" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="20898" class="Symbol">(</a><a id="20899" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="20903" class="Symbol">(</a><a id="20904" href="Data.Nat.Properties.html#871" data-type="(x y : Nat) → x + suc y ≡ suc (x + y)" class="Function">+-sucr</a> <a id="20911" class="Symbol">_</a> <a id="20913" class="Symbol">_))</a> <a id="20917" class="Symbol">(</a><a id="20918" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="20922" class="Symbol">(</a><a id="20923" href="Data.Nat.Properties.html#871" data-type="(x y : Nat) → x + suc y ≡ suc (x + y)" class="Function">+-sucr</a> <a id="20930" class="Symbol">_</a> <a id="20932" class="Symbol">_)))</a>
</pre>
<p>Since addition of integers is (essentially!) addition of pairs of
naturals, the algebraic properties of
<span class="Agda"><a href="Agda.Builtin.Nat.html#310" class="Primitive Operator">+</a></span>
on the natural numbers automatically lift to properties about
<span class="Agda"><a href="Data.Int.html#20739" class="Function Operator">_+ℤ_</a></span>,
using the recursion helpers for props
(<span class="Agda"><a href="Data.Int.html#16411" class="Function">Int-elim-prop</a></span>)
and the fact that <code class="sourceCode agda" data-ident="Int-is-set">equality of integers is a proposition</code>.</p>
<pre class="Agda"><a id="+ℤ-associative"></a><a id="21289" href="Data.Int.html#21289" data-type="(x y z : Int) → ((x +ℤ y) +ℤ z) ≡ (x +ℤ (y +ℤ z))" class="Function">+ℤ-associative</a> <a id="21304" class="Symbol">:</a> <a id="21306" class="Symbol">(</a><a id="21307" href="Data.Int.html#21307" class="Bound">x</a> <a id="21309" href="Data.Int.html#21309" class="Bound">y</a> <a id="21311" href="Data.Int.html#21311" class="Bound">z</a> <a id="21313" class="Symbol">:</a> <a id="21315" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a><a id="21318" class="Symbol">)</a> <a id="21320" class="Symbol">→</a> <a id="21322" class="Symbol">(</a><a id="21323" href="Data.Int.html#21307" class="Bound">x</a> <a id="21325" href="Data.Int.html#20739" data-type="Int → Int → Int" class="Function Operator">+ℤ</a> <a id="21328" href="Data.Int.html#21309" class="Bound">y</a><a id="21329" class="Symbol">)</a> <a id="21331" href="Data.Int.html#20739" data-type="Int → Int → Int" class="Function Operator">+ℤ</a> <a id="21334" href="Data.Int.html#21311" class="Bound">z</a> <a id="21336" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="21338" href="Data.Int.html#21307" class="Bound">x</a> <a id="21340" href="Data.Int.html#20739" data-type="Int → Int → Int" class="Function Operator">+ℤ</a> <a id="21343" class="Symbol">(</a><a id="21344" href="Data.Int.html#21309" class="Bound">y</a> <a id="21346" href="Data.Int.html#20739" data-type="Int → Int → Int" class="Function Operator">+ℤ</a> <a id="21349" href="Data.Int.html#21311" class="Bound">z</a><a id="21350" class="Symbol">)</a>
<a id="+ℤ-zerol"></a><a id="21352" href="Data.Int.html#21352" data-type="(x : Int) → (0 +ℤ x) ≡ x" class="Function">+ℤ-zerol</a>       <a id="21367" class="Symbol">:</a> <a id="21369" class="Symbol">(</a><a id="21370" href="Data.Int.html#21370" class="Bound">x</a> <a id="21372" class="Symbol">:</a> <a id="21374" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a><a id="21377" class="Symbol">)</a>     <a id="21383" class="Symbol">→</a> <a id="21385" class="Number">0</a> <a id="21387" href="Data.Int.html#20739" data-type="Int → Int → Int" class="Function Operator">+ℤ</a> <a id="21390" href="Data.Int.html#21370" class="Bound">x</a> <a id="21392" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="21394" href="Data.Int.html#21370" class="Bound">x</a>
<a id="+ℤ-zeror"></a><a id="21396" href="Data.Int.html#21396" data-type="(x : Int) → (x +ℤ 0) ≡ x" class="Function">+ℤ-zeror</a>       <a id="21411" class="Symbol">:</a> <a id="21413" class="Symbol">(</a><a id="21414" href="Data.Int.html#21414" class="Bound">x</a> <a id="21416" class="Symbol">:</a> <a id="21418" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a><a id="21421" class="Symbol">)</a>     <a id="21427" class="Symbol">→</a> <a id="21429" href="Data.Int.html#21414" class="Bound">x</a> <a id="21431" href="Data.Int.html#20739" data-type="Int → Int → Int" class="Function Operator">+ℤ</a> <a id="21434" class="Number">0</a> <a id="21436" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="21438" href="Data.Int.html#21414" class="Bound">x</a>
<a id="+ℤ-commutative"></a><a id="21440" href="Data.Int.html#21440" data-type="(x y : Int) → (x +ℤ y) ≡ (y +ℤ x)" class="Function">+ℤ-commutative</a> <a id="21455" class="Symbol">:</a> <a id="21457" class="Symbol">(</a><a id="21458" href="Data.Int.html#21458" class="Bound">x</a> <a id="21460" href="Data.Int.html#21460" class="Bound">y</a> <a id="21462" class="Symbol">:</a> <a id="21464" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a><a id="21467" class="Symbol">)</a>   <a id="21471" class="Symbol">→</a> <a id="21473" href="Data.Int.html#21458" class="Bound">x</a> <a id="21475" href="Data.Int.html#20739" data-type="Int → Int → Int" class="Function Operator">+ℤ</a> <a id="21478" href="Data.Int.html#21460" class="Bound">y</a> <a id="21480" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="21482" href="Data.Int.html#21460" class="Bound">y</a> <a id="21484" href="Data.Int.html#20739" data-type="Int → Int → Int" class="Function Operator">+ℤ</a> <a id="21487" href="Data.Int.html#21458" class="Bound">x</a>
</pre>
<details>
<summary>
See the proofs here
</summary>
<pre class="Agda"><a id="21552" href="Data.Int.html#21289" data-type="(x y z : Int) → ((x +ℤ y) +ℤ z) ≡ (x +ℤ (y +ℤ z))" class="Function">+ℤ-associative</a> <a id="21567" class="Symbol">=</a>
  <a id="21571" href="Data.Int.html#17179" data-type="((x y z : Int) → is-prop (P x y z)) →
((a b c d e f : Nat) → P (diff a b) (diff c d) (diff e f)) →
(x y z : Int) → P x y z" class="Function">Int-elim₃-prop</a>
    <a id="21590" class="Symbol">(λ</a> <a id="21593" href="Data.Int.html#21593" class="Bound">x</a> <a id="21595" href="Data.Int.html#21595" class="Bound">y</a> <a id="21597" href="Data.Int.html#21597" class="Bound">z</a> <a id="21599" class="Symbol">→</a> <a id="21601" href="1Lab.HLevel.Retracts.html#8061" data-type="(n : Nat) ⦃ x : H-Level T n ⦄ → is-hlevel T n" class="Function">hlevel</a> <a id="21608" class="Number">1</a><a id="21609" class="Symbol">)</a>
    <a id="21615" class="Symbol">(λ</a> <a id="21618" href="Data.Int.html#21618" class="Bound">a</a> <a id="21620" href="Data.Int.html#21620" class="Bound">b</a> <a id="21622" href="Data.Int.html#21622" class="Bound">c</a> <a id="21624" href="Data.Int.html#21624" class="Bound">d</a> <a id="21626" href="Data.Int.html#21626" class="Bound">e</a> <a id="21628" href="Data.Int.html#21628" class="Bound">f</a> <a id="21630" class="Symbol">→</a> <a id="21632" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="21636" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="21641" class="Symbol">(</a><a id="21642" href="Data.Nat.Properties.html#553" data-type="(x y z : Nat) → x + y + z ≡ x + (y + z)" class="Function">+-associative</a> <a id="21656" href="Data.Int.html#21618" class="Bound">a</a> <a id="21658" href="Data.Int.html#21622" class="Bound">c</a> <a id="21660" href="Data.Int.html#21626" class="Bound">e</a><a id="21661" class="Symbol">)</a> <a id="21663" class="Symbol">(</a><a id="21664" href="Data.Nat.Properties.html#553" data-type="(x y z : Nat) → x + y + z ≡ x + (y + z)" class="Function">+-associative</a> <a id="21678" href="Data.Int.html#21620" class="Bound">b</a> <a id="21680" href="Data.Int.html#21624" class="Bound">d</a> <a id="21682" href="Data.Int.html#21628" class="Bound">f</a><a id="21683" class="Symbol">))</a>
<a id="21686" href="Data.Int.html#21352" data-type="(x : Int) → (0 +ℤ x) ≡ x" class="Function">+ℤ-zerol</a> <a id="21695" class="Symbol">=</a> <a id="21697" href="Data.Int.html#16411" data-type="((x : Int) → is-prop (P x)) →
((a b : Nat) → P (diff a b)) → (x : Int) → P x" class="Function">Int-elim-prop</a> <a id="21711" class="Symbol">(λ</a> <a id="21714" href="Data.Int.html#21714" class="Bound">x</a> <a id="21716" class="Symbol">→</a> <a id="21718" href="1Lab.HLevel.Retracts.html#8061" data-type="(n : Nat) ⦃ x : H-Level T n ⦄ → is-hlevel T n" class="Function">hlevel</a> <a id="21725" class="Number">1</a><a id="21726" class="Symbol">)</a> <a id="21728" class="Symbol">(λ</a> <a id="21731" href="Data.Int.html#21731" class="Bound">a</a> <a id="21733" href="Data.Int.html#21733" class="Bound">b</a> <a id="21735" class="Symbol">→</a> <a id="21737" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a><a id="21741" class="Symbol">)</a>
<a id="21743" href="Data.Int.html#21396" data-type="(x : Int) → (x +ℤ 0) ≡ x" class="Function">+ℤ-zeror</a> <a id="21752" class="Symbol">=</a>
  <a id="21756" href="Data.Int.html#16411" data-type="((x : Int) → is-prop (P x)) →
((a b : Nat) → P (diff a b)) → (x : Int) → P x" class="Function">Int-elim-prop</a> <a id="21770" class="Symbol">(λ</a> <a id="21773" href="Data.Int.html#21773" class="Bound">x</a> <a id="21775" class="Symbol">→</a> <a id="21777" href="1Lab.HLevel.Retracts.html#8061" data-type="(n : Nat) ⦃ x : H-Level T n ⦄ → is-hlevel T n" class="Function">hlevel</a> <a id="21784" class="Number">1</a><a id="21785" class="Symbol">)</a> <a id="21787" class="Symbol">(λ</a> <a id="21790" href="Data.Int.html#21790" class="Bound">a</a> <a id="21792" href="Data.Int.html#21792" class="Bound">b</a> <a id="21794" class="Symbol">→</a> <a id="21796" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="21800" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="21805" class="Symbol">(</a><a id="21806" href="Data.Nat.Properties.html#746" data-type="(x : Nat) → x + 0 ≡ x" class="Function">+-zeror</a> <a id="21814" href="Data.Int.html#21790" class="Bound">a</a><a id="21815" class="Symbol">)</a> <a id="21817" class="Symbol">(</a><a id="21818" href="Data.Nat.Properties.html#746" data-type="(x : Nat) → x + 0 ≡ x" class="Function">+-zeror</a> <a id="21826" href="Data.Int.html#21792" class="Bound">b</a><a id="21827" class="Symbol">))</a>
<a id="21830" href="Data.Int.html#21440" data-type="(x y : Int) → (x +ℤ y) ≡ (y +ℤ x)" class="Function">+ℤ-commutative</a> <a id="21845" class="Symbol">=</a>
  <a id="21849" href="Data.Int.html#16829" data-type="((x y : Int) → is-prop (P x y)) →
((a b x y : Nat) → P (diff a b) (diff x y)) → (x y : Int) → P x y" class="Function">Int-elim₂-prop</a> <a id="21864" class="Symbol">(λ</a> <a id="21867" href="Data.Int.html#21867" class="Bound">x</a> <a id="21869" href="Data.Int.html#21869" class="Bound">y</a> <a id="21871" class="Symbol">→</a> <a id="21873" href="1Lab.HLevel.Retracts.html#8061" data-type="(n : Nat) ⦃ x : H-Level T n ⦄ → is-hlevel T n" class="Function">hlevel</a> <a id="21880" class="Number">1</a><a id="21881" class="Symbol">)</a>
    <a id="21887" class="Symbol">(λ</a> <a id="21890" href="Data.Int.html#21890" class="Bound">a</a> <a id="21892" href="Data.Int.html#21892" class="Bound">b</a> <a id="21894" href="Data.Int.html#21894" class="Bound">c</a> <a id="21896" href="Data.Int.html#21896" class="Bound">d</a> <a id="21898" class="Symbol">→</a> <a id="21900" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="21904" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="21909" class="Symbol">(</a><a id="21910" href="Data.Nat.Properties.html#979" data-type="(x y : Nat) → x + y ≡ y + x" class="Function">+-commutative</a> <a id="21924" href="Data.Int.html#21890" class="Bound">a</a> <a id="21926" href="Data.Int.html#21894" class="Bound">c</a><a id="21927" class="Symbol">)</a> <a id="21929" class="Symbol">(</a><a id="21930" href="Data.Nat.Properties.html#979" data-type="(x y : Nat) → x + y ≡ y + x" class="Function">+-commutative</a> <a id="21944" href="Data.Int.html#21892" class="Bound">b</a> <a id="21946" href="Data.Int.html#21896" class="Bound">d</a><a id="21947" class="Symbol">))</a>
</pre>
</details>
<h2 id="inverses"><a href="#inverses" class="header-link">Inverses<span class="header-link-emoji">🔗</span></a></h2>
<p>Every integer
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>
has an additive inverse, denoted
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">-x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord mathnormal">x</span></span></span></span>,</span>
which is obtained by swapping the components of the pair. Since the
definition of
<span class="Agda"><a href="Data.Int.html#22223" class="Function">negate</a></span>
is very simple, it can be written conveniently without using
<span class="Agda"><a href="Data.Int.html#13370" class="Function">Int-rec</a></span>:</p>
<pre class="Agda"><a id="negate"></a><a id="22223" href="Data.Int.html#22223" data-type="Int → Int" class="Function">negate</a> <a id="22230" class="Symbol">:</a> <a id="22232" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a> <a id="22236" class="Symbol">→</a> <a id="22238" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a>
<a id="22242" href="Data.Int.html#22223" data-type="Int → Int" class="Function">negate</a> <a id="22249" class="Symbol">(</a><a id="22250" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="22255" href="Data.Int.html#22255" class="Bound">x</a> <a id="22257" href="Data.Int.html#22257" class="Bound">y</a><a id="22258" class="Symbol">)</a> <a id="22260" class="Symbol">=</a> <a id="22262" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="22267" href="Data.Int.html#22257" class="Bound">y</a> <a id="22269" href="Data.Int.html#22255" class="Bound">x</a>
<a id="22271" href="Data.Int.html#22223" data-type="Int → Int" class="Function">negate</a> <a id="22278" class="Symbol">(</a><a id="22279" href="Data.Int.html#689" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="22284" href="Data.Int.html#22284" class="Bound">m</a> <a id="22286" href="Data.Int.html#22286" class="Bound">n</a> <a id="22288" href="Data.Int.html#22288" class="Bound">i</a><a id="22289" class="Symbol">)</a> <a id="22291" class="Symbol">=</a> <a id="22293" href="Data.Int.html#689" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="22298" href="Data.Int.html#22286" class="Bound">n</a> <a id="22300" href="Data.Int.html#22284" class="Bound">m</a> <a id="22302" href="Data.Int.html#22288" class="Bound">i</a>
</pre>
<p>The proof that
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">-x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord mathnormal">x</span></span></span></span>
is an additive inverse to
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>
follows, essentially, from commutativity of addition on natural numbers,
and the fact that
<span class="Agda"><a href="Data.Int.html#1367" class="Function">all zeroes are identified</a></span>.</p>
<pre class="Agda"><a id="+ℤ-inverser"></a><a id="22508" href="Data.Int.html#22508" data-type="(x : Int) → (x +ℤ negate x) ≡ 0" class="Function">+ℤ-inverser</a> <a id="22520" class="Symbol">:</a> <a id="22522" class="Symbol">(</a><a id="22523" href="Data.Int.html#22523" class="Bound">x</a> <a id="22525" class="Symbol">:</a> <a id="22527" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a><a id="22530" class="Symbol">)</a> <a id="22532" class="Symbol">→</a> <a id="22534" href="Data.Int.html#22523" class="Bound">x</a> <a id="22536" href="Data.Int.html#20739" data-type="Int → Int → Int" class="Function Operator">+ℤ</a> <a id="22539" href="Data.Int.html#22223" data-type="Int → Int" class="Function">negate</a> <a id="22546" href="Data.Int.html#22523" class="Bound">x</a> <a id="22548" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="22550" class="Number">0</a>
<a id="22552" href="Data.Int.html#22508" data-type="(x : Int) → (x +ℤ negate x) ≡ 0" class="Function">+ℤ-inverser</a> <a id="22564" class="Symbol">=</a>
  <a id="22568" href="Data.Int.html#16411" data-type="((x : Int) → is-prop (P x)) →
((a b : Nat) → P (diff a b)) → (x : Int) → P x" class="Function">Int-elim-prop</a> <a id="22582" class="Symbol">(λ</a> <a id="22585" href="Data.Int.html#22585" class="Bound">_</a> <a id="22587" class="Symbol">→</a> <a id="22589" href="1Lab.HLevel.Retracts.html#8061" data-type="(n : Nat) ⦃ x : H-Level T n ⦄ → is-hlevel T n" class="Function">hlevel</a> <a id="22596" class="Number">1</a><a id="22597" class="Symbol">)</a> <a id="22599" class="Symbol">λ</a> <a id="22601" class="Keyword">where</a>
    <a id="22611" href="Data.Int.html#22611" class="Bound">a</a> <a id="22613" href="Data.Int.html#22613" class="Bound">b</a> <a id="22615" class="Symbol">→</a> <a id="22617" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="22622" class="Symbol">(</a><a id="22623" href="Data.Int.html#22611" class="Bound">a</a> <a id="22625" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="22627" href="Data.Int.html#22613" class="Bound">b</a><a id="22628" class="Symbol">)</a> <a id="22630" class="Symbol">(</a><a id="22631" href="Data.Int.html#22613" class="Bound">b</a> <a id="22633" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="22635" href="Data.Int.html#22611" class="Bound">a</a><a id="22636" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function"><a id="22638" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="22641" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="22645" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="22650" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="22655" class="Symbol">(</a><a id="22656" href="Data.Nat.Properties.html#979" data-type="(x y : Nat) → x + y ≡ y + x" class="Function">+-commutative</a> <a id="22670" href="Data.Int.html#22613" class="Bound">b</a> <a id="22672" href="Data.Int.html#22611" class="Bound">a</a><a id="22673" class="Symbol">)</a> <a id="22675" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
          <a id="22687" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="22692" class="Symbol">(</a><a id="22693" href="Data.Int.html#22611" class="Bound">a</a> <a id="22695" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="22697" href="Data.Int.html#22613" class="Bound">b</a><a id="22698" class="Symbol">)</a> <a id="22700" class="Symbol">(</a><a id="22701" href="Data.Int.html#22611" class="Bound">a</a> <a id="22703" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="22705" href="Data.Int.html#22613" class="Bound">b</a><a id="22706" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function"><a id="22708" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="22711" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="22715" class="Symbol">(</a><a id="22716" href="Data.Int.html#1367" data-type="(n : Nat) → diff 0 0 ≡ diff n n" class="Function">zeroes</a> <a id="22723" class="Symbol">(</a><a id="22724" href="Data.Int.html#22611" class="Bound">a</a> <a id="22726" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="22728" href="Data.Int.html#22613" class="Bound">b</a><a id="22729" class="Symbol">))</a> <a id="22732" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
          <a id="22744" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="22749" class="Number">0</a> <a id="22751" class="Number">0</a>             <a id="22765" href="1Lab.Path.html#46945" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>

<a id="+ℤ-inversel"></a><a id="22768" href="Data.Int.html#22768" data-type="(x : Int) → (negate x +ℤ x) ≡ 0" class="Function">+ℤ-inversel</a> <a id="22780" class="Symbol">:</a> <a id="22782" class="Symbol">(</a><a id="22783" href="Data.Int.html#22783" class="Bound">x</a> <a id="22785" class="Symbol">:</a> <a id="22787" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a><a id="22790" class="Symbol">)</a> <a id="22792" class="Symbol">→</a> <a id="22794" href="Data.Int.html#22223" data-type="Int → Int" class="Function">negate</a> <a id="22801" href="Data.Int.html#22783" class="Bound">x</a> <a id="22803" href="Data.Int.html#20739" data-type="Int → Int → Int" class="Function Operator">+ℤ</a> <a id="22806" href="Data.Int.html#22783" class="Bound">x</a> <a id="22808" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="22810" class="Number">0</a>
<a id="22812" href="Data.Int.html#22768" data-type="(x : Int) → (negate x +ℤ x) ≡ 0" class="Function">+ℤ-inversel</a> <a id="22824" class="Symbol">=</a>
  <a id="22828" href="Data.Int.html#16411" data-type="((x : Int) → is-prop (P x)) →
((a b : Nat) → P (diff a b)) → (x : Int) → P x" class="Function">Int-elim-prop</a> <a id="22842" class="Symbol">(λ</a> <a id="22845" href="Data.Int.html#22845" class="Bound">_</a> <a id="22847" class="Symbol">→</a> <a id="22849" href="1Lab.HLevel.Retracts.html#8061" data-type="(n : Nat) ⦃ x : H-Level T n ⦄ → is-hlevel T n" class="Function">hlevel</a> <a id="22856" class="Number">1</a><a id="22857" class="Symbol">)</a> <a id="22859" class="Symbol">λ</a> <a id="22861" class="Keyword">where</a>
    <a id="22871" href="Data.Int.html#22871" class="Bound">a</a> <a id="22873" href="Data.Int.html#22873" class="Bound">b</a> <a id="22875" class="Symbol">→</a> <a id="22877" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="22882" class="Symbol">(</a><a id="22883" href="Data.Int.html#22873" class="Bound">b</a> <a id="22885" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="22887" href="Data.Int.html#22871" class="Bound">a</a><a id="22888" class="Symbol">)</a> <a id="22890" class="Symbol">(</a><a id="22891" href="Data.Int.html#22871" class="Bound">a</a> <a id="22893" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="22895" href="Data.Int.html#22873" class="Bound">b</a><a id="22896" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function"><a id="22898" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="22901" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="22905" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="22910" class="Symbol">(</a><a id="22911" href="Data.Nat.Properties.html#979" data-type="(x y : Nat) → x + y ≡ y + x" class="Function">+-commutative</a> <a id="22925" href="Data.Int.html#22873" class="Bound">b</a> <a id="22927" href="Data.Int.html#22871" class="Bound">a</a><a id="22928" class="Symbol">)</a> <a id="22930" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="22935" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
          <a id="22947" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="22952" class="Symbol">(</a><a id="22953" href="Data.Int.html#22871" class="Bound">a</a> <a id="22955" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="22957" href="Data.Int.html#22873" class="Bound">b</a><a id="22958" class="Symbol">)</a> <a id="22960" class="Symbol">(</a><a id="22961" href="Data.Int.html#22871" class="Bound">a</a> <a id="22963" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="22965" href="Data.Int.html#22873" class="Bound">b</a><a id="22966" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function"><a id="22968" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="22971" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="22975" class="Symbol">(</a><a id="22976" href="Data.Int.html#1367" data-type="(n : Nat) → diff 0 0 ≡ diff n n" class="Function">zeroes</a> <a id="22983" class="Symbol">(</a><a id="22984" href="Data.Int.html#22871" class="Bound">a</a> <a id="22986" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="22988" href="Data.Int.html#22873" class="Bound">b</a><a id="22989" class="Symbol">))</a> <a id="22992" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
          <a id="23004" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="23009" class="Number">0</a> <a id="23011" class="Number">0</a>             <a id="23025" href="1Lab.Path.html#46945" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
</pre>
<p>Since
<span class="Agda"><a href="Data.Int.html#22223" class="Function">negate</a></span>
is precisely what’s missing for
<span class="Agda"><a href="Agda.Builtin.Nat.html#177" class="Datatype">Nat</a></span>
to be a group, we <em>can</em> turn <a href="Algebra.Group.html#the-integers">the integers</a> into a group.
Subtraction is defined as addition with the inverse, rather than
directly on
<span class="Agda"><a href="Data.Int.html#662" class="InductiveConstructor">diff</a></span>:</p>
<pre class="Agda"><a id="_-ℤ_"></a><a id="23307" href="Data.Int.html#23307" data-type="Int → Int → Int" class="Function Operator">_-ℤ_</a> <a id="23312" class="Symbol">:</a> <a id="23314" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a> <a id="23318" class="Symbol">→</a> <a id="23320" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a> <a id="23324" class="Symbol">→</a> <a id="23326" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a>
<a id="23330" href="Data.Int.html#23330" class="Bound">x</a> <a id="23332" href="Data.Int.html#23307" data-type="Int → Int → Int" class="Function Operator">-ℤ</a> <a id="23335" href="Data.Int.html#23335" class="Bound">y</a> <a id="23337" class="Symbol">=</a> <a id="23339" href="Data.Int.html#23330" class="Bound">x</a> <a id="23341" href="Data.Int.html#20739" data-type="Int → Int → Int" class="Function Operator">+ℤ</a> <a id="23344" href="Data.Int.html#22223" data-type="Int → Int" class="Function">negate</a> <a id="23351" href="Data.Int.html#23335" class="Bound">y</a>
</pre>
<h2 id="multiplication"><a href="#multiplication" class="header-link">Multiplication<span class="header-link-emoji">🔗</span></a></h2>
<p>We now prove that the integers are a <em>ring</em>, i.e. that there
is a multiplication operation
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∗</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x*y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4653em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>
with 1 as a left/right identity, which is associative, and additionally
distributes over addition on both the left and the right. It’s also
commutative — so
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\bb{Z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">Z</span></span></span></span>
is a <em>commutative</em> ring.</p>
<p>The definition of multiplication is slightly tricky: We use the
binomial theorem. Pretend that
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">xy</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>
is really
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>−</mo><mi>b</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>c</mi><mo>−</mo><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a-b)(c-d)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mclose">)</span></span></span></span>,</span>
and expand that to
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mi>c</mi><mo>+</mo><mi>b</mi><mi>d</mi><mo stretchy="false">)</mo><mo>−</mo><mo stretchy="false">(</mo><mi>a</mi><mi>d</mi><mo>+</mo><mi>b</mi><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(ac+bd) - (ad+bc)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">c</span><span class="mclose">)</span></span></span></span>:</span>
that’s our product. It remains to show that this respects the defining
equation
<span class="Agda"><a href="Data.Int.html#689" class="InductiveConstructor">quot</a></span>,
which involves some nasty equations (you can see them in the types of
<span class="Agda"><a href="Data.Int.html#24359" class="Function">l₁</a></span>
and
<span class="Agda"><a href="Data.Int.html#24505" class="Function">l₂</a></span>
below) — but this can be done with <a href="Data.Nat.Solver.html">the
semiring solver</a>.</p>
<pre class="Agda"><a id="_*ℤ_"></a><a id="24140" href="Data.Int.html#24140" data-type="Int → Int → Int" class="Function Operator">_*ℤ_</a> <a id="24145" class="Symbol">:</a> <a id="24147" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a> <a id="24151" class="Symbol">→</a> <a id="24153" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a> <a id="24157" class="Symbol">→</a> <a id="24159" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a>
<a id="24163" href="Data.Int.html#24140" data-type="Int → Int → Int" class="Function Operator">_*ℤ_</a> <a id="24168" class="Symbol">=</a> <a id="24170" href="Data.Int.html#15682" data-type="⦃ iss-b : H-Level B₁ 2 ⦄ (f : Nat × Nat → Nat × Nat → B₁) →
((a b x y : Nat) → f (a , b) (x , y) ≡ f (suc a , suc b) (x , y)) →
((a b x y : Nat) → f (a , b) (x , y) ≡ f (a , b) (suc x , suc y)) →
Int → Int → B₁" class="Function">Int-rec₂-set</a>
  <a id="24185" class="Symbol">(λ</a> <a id="24188" class="Symbol">{</a> <a id="24190" class="Symbol">(</a><a id="24191" href="Data.Int.html#24191" class="Bound">a</a> <a id="24193" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="24195" href="Data.Int.html#24195" class="Bound">b</a><a id="24196" class="Symbol">)</a> <a id="24198" class="Symbol">(</a><a id="24199" href="Data.Int.html#24199" class="Bound">c</a> <a id="24201" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="24203" href="Data.Int.html#24203" class="Bound">d</a><a id="24204" class="Symbol">)</a> <a id="24206" class="Symbol">→</a> <a id="24208" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="24213" class="Symbol">(</a><a id="24214" href="Data.Int.html#24191" class="Bound">a</a> <a id="24216" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="24218" href="Data.Int.html#24199" class="Bound">c</a> <a id="24220" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="24222" href="Data.Int.html#24195" class="Bound">b</a> <a id="24224" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="24226" href="Data.Int.html#24203" class="Bound">d</a><a id="24227" class="Symbol">)</a> <a id="24229" class="Symbol">(</a><a id="24230" href="Data.Int.html#24191" class="Bound">a</a> <a id="24232" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="24234" href="Data.Int.html#24203" class="Bound">d</a> <a id="24236" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="24238" href="Data.Int.html#24195" class="Bound">b</a> <a id="24240" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="24242" href="Data.Int.html#24199" class="Bound">c</a><a id="24243" class="Symbol">)</a> <a id="24245" class="Symbol">})</a>
  <a id="24250" class="Symbol">(λ</a> <a id="24253" href="Data.Int.html#24253" class="Bound">a</a> <a id="24255" href="Data.Int.html#24255" class="Bound">b</a> <a id="24257" href="Data.Int.html#24257" class="Bound">x</a> <a id="24259" href="Data.Int.html#24259" class="Bound">y</a> <a id="24261" class="Symbol">→</a> <a id="24263" href="Data.Int.html#2994" data-type="a + d ≡ b + c → diff a b ≡ diff c d" class="Function">same-difference</a> <a id="24279" class="Symbol">(</a><a id="24280" href="Data.Int.html#24359" data-type="(a b x y : Nat) →
a * x + b * y + (suc a * y + suc b * x) ≡
a * y + b * x + (suc a * x + suc b * y)" class="Function">l₁</a> <a id="24283" href="Data.Int.html#24253" class="Bound">a</a> <a id="24285" href="Data.Int.html#24255" class="Bound">b</a> <a id="24287" href="Data.Int.html#24257" class="Bound">x</a> <a id="24289" href="Data.Int.html#24259" class="Bound">y</a><a id="24290" class="Symbol">))</a>
  <a id="24295" class="Symbol">(λ</a> <a id="24298" href="Data.Int.html#24298" class="Bound">a</a> <a id="24300" href="Data.Int.html#24300" class="Bound">b</a> <a id="24302" href="Data.Int.html#24302" class="Bound">x</a> <a id="24304" href="Data.Int.html#24304" class="Bound">y</a> <a id="24306" class="Symbol">→</a> <a id="24308" href="Data.Int.html#2994" data-type="a + d ≡ b + c → diff a b ≡ diff c d" class="Function">same-difference</a> <a id="24324" class="Symbol">(</a><a id="24325" href="Data.Int.html#24505" data-type="(a b x y : Nat) →
a * x + b * y + (a * suc y + b * suc x) ≡
a * y + b * x + (a * suc x + b * suc y)" class="Function">l₂</a> <a id="24328" href="Data.Int.html#24298" class="Bound">a</a> <a id="24330" href="Data.Int.html#24300" class="Bound">b</a> <a id="24332" href="Data.Int.html#24302" class="Bound">x</a> <a id="24334" href="Data.Int.html#24304" class="Bound">y</a><a id="24335" class="Symbol">))</a>
  <a id="24340" class="Keyword">where</a> <a id="24346" class="Keyword">abstract</a>
    <a id="24359" href="Data.Int.html#24359" data-type="(a b x y : Nat) →
a * x + b * y + (suc a * y + suc b * x) ≡
a * y + b * x + (suc a * x + suc b * y)" class="Function">l₁</a>
      <a id="24368" class="Symbol">:</a> <a id="24370" class="Symbol">∀</a> <a id="24372" href="Data.Int.html#24372" class="Bound">a</a> <a id="24374" href="Data.Int.html#24374" class="Bound">b</a> <a id="24376" href="Data.Int.html#24376" class="Bound">x</a> <a id="24378" href="Data.Int.html#24378" class="Bound">y</a>
      <a id="24386" class="Symbol">→</a> <a id="24388" href="Data.Int.html#24372" class="Bound">a</a> <a id="24390" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="24392" href="Data.Int.html#24376" class="Bound">x</a> <a id="24394" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="24396" href="Data.Int.html#24374" class="Bound">b</a> <a id="24398" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="24400" href="Data.Int.html#24378" class="Bound">y</a> <a id="24402" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="24404" class="Symbol">(</a><a id="24405" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="24409" href="Data.Int.html#24372" class="Bound">a</a> <a id="24411" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="24413" href="Data.Int.html#24378" class="Bound">y</a> <a id="24415" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="24417" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="24421" href="Data.Int.html#24374" class="Bound">b</a> <a id="24423" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="24425" href="Data.Int.html#24376" class="Bound">x</a><a id="24426" class="Symbol">)</a>
      <a id="24434" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="24436" href="Data.Int.html#24372" class="Bound">a</a> <a id="24438" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="24440" href="Data.Int.html#24378" class="Bound">y</a> <a id="24442" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="24444" href="Data.Int.html#24374" class="Bound">b</a> <a id="24446" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="24448" href="Data.Int.html#24376" class="Bound">x</a> <a id="24450" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="24452" class="Symbol">(</a><a id="24453" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="24457" href="Data.Int.html#24372" class="Bound">a</a> <a id="24459" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="24461" href="Data.Int.html#24376" class="Bound">x</a> <a id="24463" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="24465" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="24469" href="Data.Int.html#24374" class="Bound">b</a> <a id="24471" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="24473" href="Data.Int.html#24378" class="Bound">y</a><a id="24474" class="Symbol">)</a>
    <a id="24480" href="Data.Int.html#24359" data-type="(a b x y : Nat) →
a * x + b * y + (suc a * y + suc b * x) ≡
a * y + b * x + (suc a * x + suc b * y)" class="Function">l₁</a> <a id="24483" href="Data.Int.html#24483" class="Bound">a</a> <a id="24485" href="Data.Int.html#24485" class="Bound">b</a> <a id="24487" href="Data.Int.html#24487" class="Bound">x</a> <a id="24489" href="Data.Int.html#24489" class="Bound">y</a> <a id="24491" class="Symbol">=</a> <a id="24493" href="Data.Nat.Solver.html#23207" data-type="Term → TC ⊤" class="Macro">solve!</a>

    <a id="24505" href="Data.Int.html#24505" data-type="(a b x y : Nat) →
a * x + b * y + (a * suc y + b * suc x) ≡
a * y + b * x + (a * suc x + b * suc y)" class="Function">l₂</a>
      <a id="24514" class="Symbol">:</a> <a id="24516" class="Symbol">∀</a> <a id="24518" href="Data.Int.html#24518" class="Bound">a</a> <a id="24520" href="Data.Int.html#24520" class="Bound">b</a> <a id="24522" href="Data.Int.html#24522" class="Bound">x</a> <a id="24524" href="Data.Int.html#24524" class="Bound">y</a>
      <a id="24532" class="Symbol">→</a> <a id="24534" href="Data.Int.html#24518" class="Bound">a</a> <a id="24536" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="24538" href="Data.Int.html#24522" class="Bound">x</a> <a id="24540" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="24542" href="Data.Int.html#24520" class="Bound">b</a> <a id="24544" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="24546" href="Data.Int.html#24524" class="Bound">y</a> <a id="24548" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="24550" class="Symbol">(</a><a id="24551" href="Data.Int.html#24518" class="Bound">a</a> <a id="24553" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="24555" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="24559" href="Data.Int.html#24524" class="Bound">y</a> <a id="24561" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="24563" href="Data.Int.html#24520" class="Bound">b</a> <a id="24565" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="24567" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="24571" href="Data.Int.html#24522" class="Bound">x</a><a id="24572" class="Symbol">)</a>
      <a id="24580" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="24582" href="Data.Int.html#24518" class="Bound">a</a> <a id="24584" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="24586" href="Data.Int.html#24524" class="Bound">y</a> <a id="24588" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="24590" href="Data.Int.html#24520" class="Bound">b</a> <a id="24592" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="24594" href="Data.Int.html#24522" class="Bound">x</a> <a id="24596" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="24598" class="Symbol">(</a><a id="24599" href="Data.Int.html#24518" class="Bound">a</a> <a id="24601" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="24603" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="24607" href="Data.Int.html#24522" class="Bound">x</a> <a id="24609" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="24611" href="Data.Int.html#24520" class="Bound">b</a> <a id="24613" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="24615" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="24619" href="Data.Int.html#24524" class="Bound">y</a><a id="24620" class="Symbol">)</a>
    <a id="24626" href="Data.Int.html#24505" data-type="(a b x y : Nat) →
a * x + b * y + (a * suc y + b * suc x) ≡
a * y + b * x + (a * suc x + b * suc y)" class="Function">l₂</a> <a id="24629" href="Data.Int.html#24629" class="Bound">a</a> <a id="24631" href="Data.Int.html#24631" class="Bound">b</a> <a id="24633" href="Data.Int.html#24633" class="Bound">x</a> <a id="24635" href="Data.Int.html#24635" class="Bound">y</a> <a id="24637" class="Symbol">=</a> <a id="24639" href="Data.Nat.Solver.html#23207" data-type="Term → TC ⊤" class="Macro">solve!</a>
</pre>
<p>We omit the proofs of the arithmetic identities below since they are
essentially induction + calling the semiring solver.</p>
<pre class="Agda"><a id="24782" class="Keyword">abstract</a>
  <a id="*ℤ-associative"></a><a id="24793" href="Data.Int.html#24793" data-type="(x y z : Int) → ((x *ℤ y) *ℤ z) ≡ (x *ℤ (y *ℤ z))" class="Function">*ℤ-associative</a> <a id="24808" class="Symbol">:</a> <a id="24810" class="Symbol">∀</a> <a id="24812" href="Data.Int.html#24812" class="Bound">x</a> <a id="24814" href="Data.Int.html#24814" class="Bound">y</a> <a id="24816" href="Data.Int.html#24816" class="Bound">z</a> <a id="24818" class="Symbol">→</a> <a id="24820" class="Symbol">(</a><a id="24821" href="Data.Int.html#24812" class="Bound">x</a> <a id="24823" href="Data.Int.html#24140" data-type="Int → Int → Int" class="Function Operator">*ℤ</a> <a id="24826" href="Data.Int.html#24814" class="Bound">y</a><a id="24827" class="Symbol">)</a> <a id="24829" href="Data.Int.html#24140" data-type="Int → Int → Int" class="Function Operator">*ℤ</a> <a id="24832" href="Data.Int.html#24816" class="Bound">z</a> <a id="24834" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="24836" href="Data.Int.html#24812" class="Bound">x</a> <a id="24838" href="Data.Int.html#24140" data-type="Int → Int → Int" class="Function Operator">*ℤ</a> <a id="24841" class="Symbol">(</a><a id="24842" href="Data.Int.html#24814" class="Bound">y</a> <a id="24844" href="Data.Int.html#24140" data-type="Int → Int → Int" class="Function Operator">*ℤ</a> <a id="24847" href="Data.Int.html#24816" class="Bound">z</a><a id="24848" class="Symbol">)</a>
  <a id="*ℤ-commutative"></a><a id="24852" href="Data.Int.html#24852" data-type="(x y : Int) → (x *ℤ y) ≡ (y *ℤ x)" class="Function">*ℤ-commutative</a> <a id="24867" class="Symbol">:</a> <a id="24869" class="Symbol">∀</a> <a id="24871" href="Data.Int.html#24871" class="Bound">x</a> <a id="24873" href="Data.Int.html#24873" class="Bound">y</a> <a id="24875" class="Symbol">→</a> <a id="24877" href="Data.Int.html#24871" class="Bound">x</a> <a id="24879" href="Data.Int.html#24140" data-type="Int → Int → Int" class="Function Operator">*ℤ</a> <a id="24882" href="Data.Int.html#24873" class="Bound">y</a> <a id="24884" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="24886" href="Data.Int.html#24873" class="Bound">y</a> <a id="24888" href="Data.Int.html#24140" data-type="Int → Int → Int" class="Function Operator">*ℤ</a> <a id="24891" href="Data.Int.html#24871" class="Bound">x</a>
  <a id="*ℤ-idl"></a><a id="24895" href="Data.Int.html#24895" data-type="(x : Int) → (1 *ℤ x) ≡ x" class="Function">*ℤ-idl</a> <a id="24902" class="Symbol">:</a> <a id="24904" class="Symbol">∀</a> <a id="24906" href="Data.Int.html#24906" class="Bound">x</a> <a id="24908" class="Symbol">→</a> <a id="24910" class="Number">1</a> <a id="24912" href="Data.Int.html#24140" data-type="Int → Int → Int" class="Function Operator">*ℤ</a> <a id="24915" href="Data.Int.html#24906" class="Bound">x</a> <a id="24917" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="24919" href="Data.Int.html#24906" class="Bound">x</a>
  <a id="*ℤ-idr"></a><a id="24923" href="Data.Int.html#24923" data-type="(x : Int) → (x *ℤ 1) ≡ x" class="Function">*ℤ-idr</a> <a id="24930" class="Symbol">:</a> <a id="24932" class="Symbol">∀</a> <a id="24934" href="Data.Int.html#24934" class="Bound">x</a> <a id="24936" class="Symbol">→</a> <a id="24938" href="Data.Int.html#24934" class="Bound">x</a> <a id="24940" href="Data.Int.html#24140" data-type="Int → Int → Int" class="Function Operator">*ℤ</a> <a id="24943" class="Number">1</a> <a id="24945" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="24947" href="Data.Int.html#24934" class="Bound">x</a>
  <a id="*ℤ-distrib-+ℤ-l"></a><a id="24951" href="Data.Int.html#24951" data-type="(x y z : Int) → (x *ℤ (y +ℤ z)) ≡ ((x *ℤ y) +ℤ (x *ℤ z))" class="Function">*ℤ-distrib-+ℤ-l</a> <a id="24967" class="Symbol">:</a> <a id="24969" class="Symbol">∀</a> <a id="24971" href="Data.Int.html#24971" class="Bound">x</a> <a id="24973" href="Data.Int.html#24973" class="Bound">y</a> <a id="24975" href="Data.Int.html#24975" class="Bound">z</a> <a id="24977" class="Symbol">→</a> <a id="24979" href="Data.Int.html#24971" class="Bound">x</a> <a id="24981" href="Data.Int.html#24140" data-type="Int → Int → Int" class="Function Operator">*ℤ</a> <a id="24984" class="Symbol">(</a><a id="24985" href="Data.Int.html#24973" class="Bound">y</a> <a id="24987" href="Data.Int.html#20739" data-type="Int → Int → Int" class="Function Operator">+ℤ</a> <a id="24990" href="Data.Int.html#24975" class="Bound">z</a><a id="24991" class="Symbol">)</a> <a id="24993" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="24995" class="Symbol">(</a><a id="24996" href="Data.Int.html#24971" class="Bound">x</a> <a id="24998" href="Data.Int.html#24140" data-type="Int → Int → Int" class="Function Operator">*ℤ</a> <a id="25001" href="Data.Int.html#24973" class="Bound">y</a><a id="25002" class="Symbol">)</a> <a id="25004" href="Data.Int.html#20739" data-type="Int → Int → Int" class="Function Operator">+ℤ</a> <a id="25007" class="Symbol">(</a><a id="25008" href="Data.Int.html#24971" class="Bound">x</a> <a id="25010" href="Data.Int.html#24140" data-type="Int → Int → Int" class="Function Operator">*ℤ</a> <a id="25013" href="Data.Int.html#24975" class="Bound">z</a><a id="25014" class="Symbol">)</a>
  <a id="*ℤ-distrib-+ℤ-r"></a><a id="25018" href="Data.Int.html#25018" data-type="(x y z : Int) → ((y +ℤ z) *ℤ x) ≡ ((y *ℤ x) +ℤ (z *ℤ x))" class="Function">*ℤ-distrib-+ℤ-r</a> <a id="25034" class="Symbol">:</a> <a id="25036" class="Symbol">∀</a> <a id="25038" href="Data.Int.html#25038" class="Bound">x</a> <a id="25040" href="Data.Int.html#25040" class="Bound">y</a> <a id="25042" href="Data.Int.html#25042" class="Bound">z</a> <a id="25044" class="Symbol">→</a> <a id="25046" class="Symbol">(</a><a id="25047" href="Data.Int.html#25040" class="Bound">y</a> <a id="25049" href="Data.Int.html#20739" data-type="Int → Int → Int" class="Function Operator">+ℤ</a> <a id="25052" href="Data.Int.html#25042" class="Bound">z</a><a id="25053" class="Symbol">)</a> <a id="25055" href="Data.Int.html#24140" data-type="Int → Int → Int" class="Function Operator">*ℤ</a> <a id="25058" href="Data.Int.html#25038" class="Bound">x</a> <a id="25060" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="25062" class="Symbol">(</a><a id="25063" href="Data.Int.html#25040" class="Bound">y</a> <a id="25065" href="Data.Int.html#24140" data-type="Int → Int → Int" class="Function Operator">*ℤ</a> <a id="25068" href="Data.Int.html#25038" class="Bound">x</a><a id="25069" class="Symbol">)</a> <a id="25071" href="Data.Int.html#20739" data-type="Int → Int → Int" class="Function Operator">+ℤ</a> <a id="25074" class="Symbol">(</a><a id="25075" href="Data.Int.html#25042" class="Bound">z</a> <a id="25077" href="Data.Int.html#24140" data-type="Int → Int → Int" class="Function Operator">*ℤ</a> <a id="25080" href="Data.Int.html#25038" class="Bound">x</a><a id="25081" class="Symbol">)</a>
</pre>
<!--
<pre class="Agda">  <a id="25103" href="Data.Int.html#24793" data-type="(x y z : Int) → ((x *ℤ y) *ℤ z) ≡ (x *ℤ (y *ℤ z))" class="Function">*ℤ-associative</a> <a id="25118" class="Symbol">=</a>
    <a id="25124" href="Data.Int.html#17179" data-type="((x y z : Int) → is-prop (P x y z)) →
((a b c d e f : Nat) → P (diff a b) (diff c d) (diff e f)) →
(x y z : Int) → P x y z" class="Function">Int-elim₃-prop</a> <a id="25139" class="Symbol">(λ</a> <a id="25142" href="Data.Int.html#25142" class="Bound">_</a> <a id="25144" href="Data.Int.html#25144" class="Bound">_</a> <a id="25146" href="Data.Int.html#25146" class="Bound">_</a> <a id="25148" class="Symbol">→</a> <a id="25150" href="1Lab.HLevel.Retracts.html#8061" data-type="(n : Nat) ⦃ x : H-Level T n ⦄ → is-hlevel T n" class="Function">hlevel</a> <a id="25157" class="Number">1</a><a id="25158" class="Symbol">)</a>
      <a id="25166" class="Symbol">λ</a> <a id="25168" href="Data.Int.html#25168" class="Bound">a</a> <a id="25170" href="Data.Int.html#25170" class="Bound">b</a> <a id="25172" href="Data.Int.html#25172" class="Bound">c</a> <a id="25174" href="Data.Int.html#25174" class="Bound">d</a> <a id="25176" href="Data.Int.html#25176" class="Bound">e</a> <a id="25178" href="Data.Int.html#25178" class="Bound">f</a> <a id="25180" class="Symbol">→</a> <a id="25182" href="Data.Int.html#2994" data-type="a + d ≡ b + c → diff a b ≡ diff c d" class="Function">same-difference</a> <a id="25198" class="Symbol">(</a><a id="25199" href="Data.Int.html#25243" data-type="(a b c d e f : Nat) →
(a * c + b * d) * e + (a * d + b * c) * f +
(a * (c * f + d * e) + b * (c * e + d * f))
≡
(a * c + b * d) * f + (a * d + b * c) * e +
(a * (c * e + d * f) + b * (c * f + d * e))" class="Function">lemma</a> <a id="25205" href="Data.Int.html#25168" class="Bound">a</a> <a id="25207" href="Data.Int.html#25170" class="Bound">b</a> <a id="25209" href="Data.Int.html#25172" class="Bound">c</a> <a id="25211" href="Data.Int.html#25174" class="Bound">d</a> <a id="25213" href="Data.Int.html#25176" class="Bound">e</a> <a id="25215" href="Data.Int.html#25178" class="Bound">f</a><a id="25216" class="Symbol">)</a>
    <a id="25222" class="Keyword">where</a> <a id="25228" class="Keyword">abstract</a>
      <a id="25243" href="Data.Int.html#25243" data-type="(a b c d e f : Nat) →
(a * c + b * d) * e + (a * d + b * c) * f +
(a * (c * f + d * e) + b * (c * e + d * f))
≡
(a * c + b * d) * f + (a * d + b * c) * e +
(a * (c * e + d * f) + b * (c * f + d * e))" class="Function">lemma</a>
        <a id="25257" class="Symbol">:</a> <a id="25259" class="Symbol">∀</a> <a id="25261" href="Data.Int.html#25261" class="Bound">a</a> <a id="25263" href="Data.Int.html#25263" class="Bound">b</a> <a id="25265" href="Data.Int.html#25265" class="Bound">c</a> <a id="25267" href="Data.Int.html#25267" class="Bound">d</a> <a id="25269" href="Data.Int.html#25269" class="Bound">e</a> <a id="25271" href="Data.Int.html#25271" class="Bound">f</a>
        <a id="25281" class="Symbol">→</a> <a id="25283" class="Symbol">(</a><a id="25284" href="Data.Int.html#25261" class="Bound">a</a> <a id="25286" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="25288" href="Data.Int.html#25265" class="Bound">c</a> <a id="25290" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="25292" href="Data.Int.html#25263" class="Bound">b</a> <a id="25294" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="25296" href="Data.Int.html#25267" class="Bound">d</a><a id="25297" class="Symbol">)</a> <a id="25299" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="25301" href="Data.Int.html#25269" class="Bound">e</a> <a id="25303" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="25305" class="Symbol">(</a><a id="25306" href="Data.Int.html#25261" class="Bound">a</a> <a id="25308" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="25310" href="Data.Int.html#25267" class="Bound">d</a> <a id="25312" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="25314" href="Data.Int.html#25263" class="Bound">b</a> <a id="25316" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="25318" href="Data.Int.html#25265" class="Bound">c</a><a id="25319" class="Symbol">)</a> <a id="25321" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="25323" href="Data.Int.html#25271" class="Bound">f</a> <a id="25325" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="25327" class="Symbol">(</a><a id="25328" href="Data.Int.html#25261" class="Bound">a</a> <a id="25330" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="25332" class="Symbol">(</a><a id="25333" href="Data.Int.html#25265" class="Bound">c</a> <a id="25335" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="25337" href="Data.Int.html#25271" class="Bound">f</a> <a id="25339" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="25341" href="Data.Int.html#25267" class="Bound">d</a> <a id="25343" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="25345" href="Data.Int.html#25269" class="Bound">e</a><a id="25346" class="Symbol">)</a> <a id="25348" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="25350" href="Data.Int.html#25263" class="Bound">b</a> <a id="25352" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="25354" class="Symbol">(</a><a id="25355" href="Data.Int.html#25265" class="Bound">c</a> <a id="25357" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="25359" href="Data.Int.html#25269" class="Bound">e</a> <a id="25361" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="25363" href="Data.Int.html#25267" class="Bound">d</a> <a id="25365" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="25367" href="Data.Int.html#25271" class="Bound">f</a><a id="25368" class="Symbol">))</a>
        <a id="25379" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="25381" class="Symbol">(</a><a id="25382" href="Data.Int.html#25261" class="Bound">a</a> <a id="25384" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="25386" href="Data.Int.html#25265" class="Bound">c</a> <a id="25388" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="25390" href="Data.Int.html#25263" class="Bound">b</a> <a id="25392" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="25394" href="Data.Int.html#25267" class="Bound">d</a><a id="25395" class="Symbol">)</a> <a id="25397" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="25399" href="Data.Int.html#25271" class="Bound">f</a> <a id="25401" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="25403" class="Symbol">(</a><a id="25404" href="Data.Int.html#25261" class="Bound">a</a> <a id="25406" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="25408" href="Data.Int.html#25267" class="Bound">d</a> <a id="25410" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="25412" href="Data.Int.html#25263" class="Bound">b</a> <a id="25414" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="25416" href="Data.Int.html#25265" class="Bound">c</a><a id="25417" class="Symbol">)</a> <a id="25419" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="25421" href="Data.Int.html#25269" class="Bound">e</a> <a id="25423" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="25425" class="Symbol">(</a><a id="25426" href="Data.Int.html#25261" class="Bound">a</a> <a id="25428" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="25430" class="Symbol">(</a><a id="25431" href="Data.Int.html#25265" class="Bound">c</a> <a id="25433" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="25435" href="Data.Int.html#25269" class="Bound">e</a> <a id="25437" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="25439" href="Data.Int.html#25267" class="Bound">d</a> <a id="25441" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="25443" href="Data.Int.html#25271" class="Bound">f</a><a id="25444" class="Symbol">)</a> <a id="25446" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="25448" href="Data.Int.html#25263" class="Bound">b</a> <a id="25450" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="25452" class="Symbol">(</a><a id="25453" href="Data.Int.html#25265" class="Bound">c</a> <a id="25455" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="25457" href="Data.Int.html#25271" class="Bound">f</a> <a id="25459" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="25461" href="Data.Int.html#25267" class="Bound">d</a> <a id="25463" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="25465" href="Data.Int.html#25269" class="Bound">e</a><a id="25466" class="Symbol">))</a>
      <a id="25475" href="Data.Int.html#25243" data-type="(a b c d e f : Nat) →
(a * c + b * d) * e + (a * d + b * c) * f +
(a * (c * f + d * e) + b * (c * e + d * f))
≡
(a * c + b * d) * f + (a * d + b * c) * e +
(a * (c * e + d * f) + b * (c * f + d * e))" class="Function">lemma</a> <a id="25481" href="Data.Int.html#25481" class="Bound">a</a> <a id="25483" href="Data.Int.html#25483" class="Bound">b</a> <a id="25485" href="Data.Int.html#25485" class="Bound">c</a> <a id="25487" href="Data.Int.html#25487" class="Bound">d</a> <a id="25489" href="Data.Int.html#25489" class="Bound">e</a> <a id="25491" href="Data.Int.html#25491" class="Bound">f</a> <a id="25493" class="Symbol">=</a> <a id="25495" href="Data.Nat.Solver.html#23207" data-type="Term → TC ⊤" class="Macro">solve!</a>

  <a id="25505" href="Data.Int.html#24852" data-type="(x y : Int) → (x *ℤ y) ≡ (y *ℤ x)" class="Function">*ℤ-commutative</a> <a id="25520" class="Symbol">=</a>
    <a id="25526" href="Data.Int.html#16829" data-type="((x y : Int) → is-prop (P x y)) →
((a b x y : Nat) → P (diff a b) (diff x y)) → (x y : Int) → P x y" class="Function">Int-elim₂-prop</a> <a id="25541" class="Symbol">(λ</a> <a id="25544" href="Data.Int.html#25544" class="Bound">_</a> <a id="25546" href="Data.Int.html#25546" class="Bound">_</a> <a id="25548" class="Symbol">→</a> <a id="25550" href="1Lab.HLevel.Retracts.html#8061" data-type="(n : Nat) ⦃ x : H-Level T n ⦄ → is-hlevel T n" class="Function">hlevel</a> <a id="25557" class="Number">1</a><a id="25558" class="Symbol">)</a> <a id="25560" class="Symbol">λ</a> <a id="25562" href="Data.Int.html#25562" class="Bound">a</a> <a id="25564" href="Data.Int.html#25564" class="Bound">b</a> <a id="25566" href="Data.Int.html#25566" class="Bound">x</a> <a id="25568" href="Data.Int.html#25568" class="Bound">y</a> <a id="25570" class="Symbol">→</a> <a id="25572" href="Data.Int.html#2994" data-type="a + d ≡ b + c → diff a b ≡ diff c d" class="Function">same-difference</a> <a id="25588" class="Symbol">(</a><a id="25589" href="Data.Int.html#25629" data-type="(a b x y : Nat) →
a * x + b * y + (x * b + y * a) ≡ a * y + b * x + (x * a + y * b)" class="Function">lemma</a> <a id="25595" href="Data.Int.html#25562" class="Bound">a</a> <a id="25597" href="Data.Int.html#25564" class="Bound">b</a> <a id="25599" href="Data.Int.html#25566" class="Bound">x</a> <a id="25601" href="Data.Int.html#25568" class="Bound">y</a><a id="25602" class="Symbol">)</a>
    <a id="25608" class="Keyword">where</a> <a id="25614" class="Keyword">abstract</a>
      <a id="25629" href="Data.Int.html#25629" data-type="(a b x y : Nat) →
a * x + b * y + (x * b + y * a) ≡ a * y + b * x + (x * a + y * b)" class="Function">lemma</a> <a id="25635" class="Symbol">:</a> <a id="25637" class="Symbol">∀</a> <a id="25639" href="Data.Int.html#25639" class="Bound">a</a> <a id="25641" href="Data.Int.html#25641" class="Bound">b</a> <a id="25643" href="Data.Int.html#25643" class="Bound">x</a> <a id="25645" href="Data.Int.html#25645" class="Bound">y</a> <a id="25647" class="Symbol">→</a> <a id="25649" href="Data.Int.html#25639" class="Bound">a</a> <a id="25651" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="25653" href="Data.Int.html#25643" class="Bound">x</a> <a id="25655" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="25657" href="Data.Int.html#25641" class="Bound">b</a> <a id="25659" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="25661" href="Data.Int.html#25645" class="Bound">y</a> <a id="25663" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="25665" class="Symbol">(</a><a id="25666" href="Data.Int.html#25643" class="Bound">x</a> <a id="25668" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="25670" href="Data.Int.html#25641" class="Bound">b</a> <a id="25672" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="25674" href="Data.Int.html#25645" class="Bound">y</a> <a id="25676" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="25678" href="Data.Int.html#25639" class="Bound">a</a><a id="25679" class="Symbol">)</a> <a id="25681" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="25683" href="Data.Int.html#25639" class="Bound">a</a> <a id="25685" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="25687" href="Data.Int.html#25645" class="Bound">y</a> <a id="25689" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="25691" href="Data.Int.html#25641" class="Bound">b</a> <a id="25693" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="25695" href="Data.Int.html#25643" class="Bound">x</a> <a id="25697" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="25699" class="Symbol">(</a><a id="25700" href="Data.Int.html#25643" class="Bound">x</a> <a id="25702" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="25704" href="Data.Int.html#25639" class="Bound">a</a> <a id="25706" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="25708" href="Data.Int.html#25645" class="Bound">y</a> <a id="25710" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="25712" href="Data.Int.html#25641" class="Bound">b</a><a id="25713" class="Symbol">)</a>
      <a id="25721" href="Data.Int.html#25629" data-type="(a b x y : Nat) →
a * x + b * y + (x * b + y * a) ≡ a * y + b * x + (x * a + y * b)" class="Function">lemma</a> <a id="25727" href="Data.Int.html#25727" class="Bound">a</a> <a id="25729" href="Data.Int.html#25729" class="Bound">b</a> <a id="25731" href="Data.Int.html#25731" class="Bound">x</a> <a id="25733" href="Data.Int.html#25733" class="Bound">y</a> <a id="25735" class="Symbol">=</a> <a id="25737" href="Data.Nat.Solver.html#23207" data-type="Term → TC ⊤" class="Macro">solve!</a>

  <a id="25747" href="Data.Int.html#24895" data-type="(x : Int) → (1 *ℤ x) ≡ x" class="Function">*ℤ-idl</a> <a id="25754" class="Symbol">=</a> <a id="25756" href="Data.Int.html#16411" data-type="((x : Int) → is-prop (P x)) →
((a b : Nat) → P (diff a b)) → (x : Int) → P x" class="Function">Int-elim-prop</a> <a id="25770" class="Symbol">(λ</a> <a id="25773" href="Data.Int.html#25773" class="Bound">_</a> <a id="25775" class="Symbol">→</a> <a id="25777" href="1Lab.HLevel.Retracts.html#8061" data-type="(n : Nat) ⦃ x : H-Level T n ⦄ → is-hlevel T n" class="Function">hlevel</a> <a id="25784" class="Number">1</a><a id="25785" class="Symbol">)</a> <a id="25787" class="Symbol">(λ</a> <a id="25790" href="Data.Int.html#25790" class="Bound">a</a> <a id="25792" href="Data.Int.html#25792" class="Bound">b</a> <a id="25794" class="Symbol">→</a> <a id="25796" href="Data.Int.html#2994" data-type="a + d ≡ b + c → diff a b ≡ diff c d" class="Function">same-difference</a> <a id="25812" class="Symbol">(</a><a id="25813" href="Data.Int.html#25850" data-type="(a b : Nat) → a + 0 + 0 + b ≡ b + 0 + 0 + a" class="Function">lemma</a> <a id="25819" href="Data.Int.html#25790" class="Bound">a</a> <a id="25821" href="Data.Int.html#25792" class="Bound">b</a><a id="25822" class="Symbol">))</a>
    <a id="25829" class="Keyword">where</a> <a id="25835" class="Keyword">abstract</a>
      <a id="25850" href="Data.Int.html#25850" data-type="(a b : Nat) → a + 0 + 0 + b ≡ b + 0 + 0 + a" class="Function">lemma</a> <a id="25856" class="Symbol">:</a> <a id="25858" class="Symbol">∀</a> <a id="25860" href="Data.Int.html#25860" class="Bound">a</a> <a id="25862" href="Data.Int.html#25862" class="Bound">b</a> <a id="25864" class="Symbol">→</a> <a id="25866" class="Symbol">(</a><a id="25867" href="Data.Int.html#25860" class="Bound">a</a> <a id="25869" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="25871" class="Number">0</a> <a id="25873" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="25875" class="Number">0</a> <a id="25877" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="25879" href="Data.Int.html#25862" class="Bound">b</a><a id="25880" class="Symbol">)</a> <a id="25882" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="25884" class="Symbol">(</a><a id="25885" href="Data.Int.html#25862" class="Bound">b</a> <a id="25887" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="25889" class="Number">0</a> <a id="25891" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="25893" class="Number">0</a> <a id="25895" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="25897" href="Data.Int.html#25860" class="Bound">a</a><a id="25898" class="Symbol">)</a>
      <a id="25906" href="Data.Int.html#25850" data-type="(a b : Nat) → a + 0 + 0 + b ≡ b + 0 + 0 + a" class="Function">lemma</a> <a id="25912" href="Data.Int.html#25912" class="Bound">a</a> <a id="25914" href="Data.Int.html#25914" class="Bound">b</a> <a id="25916" class="Symbol">=</a> <a id="25918" href="Data.Nat.Solver.html#23207" data-type="Term → TC ⊤" class="Macro">solve!</a>

  <a id="25928" href="Data.Int.html#24923" data-type="(x : Int) → (x *ℤ 1) ≡ x" class="Function">*ℤ-idr</a> <a id="25935" class="Symbol">=</a> <a id="25937" href="Data.Int.html#16411" data-type="((x : Int) → is-prop (P x)) →
((a b : Nat) → P (diff a b)) → (x : Int) → P x" class="Function">Int-elim-prop</a> <a id="25951" class="Symbol">(λ</a> <a id="25954" href="Data.Int.html#25954" class="Bound">_</a> <a id="25956" class="Symbol">→</a> <a id="25958" href="1Lab.HLevel.Retracts.html#8061" data-type="(n : Nat) ⦃ x : H-Level T n ⦄ → is-hlevel T n" class="Function">hlevel</a> <a id="25965" class="Number">1</a><a id="25966" class="Symbol">)</a> <a id="25968" class="Symbol">(λ</a> <a id="25971" href="Data.Int.html#25971" class="Bound">a</a> <a id="25973" href="Data.Int.html#25973" class="Bound">b</a> <a id="25975" class="Symbol">→</a> <a id="25977" href="Data.Int.html#2994" data-type="a + d ≡ b + c → diff a b ≡ diff c d" class="Function">same-difference</a> <a id="25993" class="Symbol">(</a><a id="25994" href="Data.Int.html#26031" data-type="(a b : Nat) → a * 1 + b * 0 + b ≡ a * 0 + b * 1 + a" class="Function">lemma</a> <a id="26000" href="Data.Int.html#25971" class="Bound">a</a> <a id="26002" href="Data.Int.html#25973" class="Bound">b</a><a id="26003" class="Symbol">))</a>
    <a id="26010" class="Keyword">where</a> <a id="26016" class="Keyword">abstract</a>
      <a id="26031" href="Data.Int.html#26031" data-type="(a b : Nat) → a * 1 + b * 0 + b ≡ a * 0 + b * 1 + a" class="Function">lemma</a> <a id="26037" class="Symbol">:</a> <a id="26039" class="Symbol">∀</a> <a id="26041" href="Data.Int.html#26041" class="Bound">a</a> <a id="26043" href="Data.Int.html#26043" class="Bound">b</a> <a id="26045" class="Symbol">→</a> <a id="26047" href="Data.Int.html#26041" class="Bound">a</a> <a id="26049" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="26051" class="Number">1</a> <a id="26053" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="26055" href="Data.Int.html#26043" class="Bound">b</a> <a id="26057" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="26059" class="Number">0</a> <a id="26061" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="26063" href="Data.Int.html#26043" class="Bound">b</a> <a id="26065" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="26067" href="Data.Int.html#26041" class="Bound">a</a> <a id="26069" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="26071" class="Number">0</a> <a id="26073" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="26075" href="Data.Int.html#26043" class="Bound">b</a> <a id="26077" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="26079" class="Number">1</a> <a id="26081" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="26083" href="Data.Int.html#26041" class="Bound">a</a>
      <a id="26091" href="Data.Int.html#26031" data-type="(a b : Nat) → a * 1 + b * 0 + b ≡ a * 0 + b * 1 + a" class="Function">lemma</a> <a id="26097" href="Data.Int.html#26097" class="Bound">a</a> <a id="26099" href="Data.Int.html#26099" class="Bound">b</a> <a id="26101" class="Symbol">=</a> <a id="26103" href="Data.Nat.Solver.html#23207" data-type="Term → TC ⊤" class="Macro">solve!</a>

  <a id="26113" href="Data.Int.html#24951" data-type="(x y z : Int) → (x *ℤ (y +ℤ z)) ≡ ((x *ℤ y) +ℤ (x *ℤ z))" class="Function">*ℤ-distrib-+ℤ-l</a> <a id="26129" class="Symbol">=</a> <a id="26131" href="Data.Int.html#17179" data-type="((x y z : Int) → is-prop (P x y z)) →
((a b c d e f : Nat) → P (diff a b) (diff c d) (diff e f)) →
(x y z : Int) → P x y z" class="Function">Int-elim₃-prop</a> <a id="26146" class="Symbol">(λ</a> <a id="26149" href="Data.Int.html#26149" class="Bound">_</a> <a id="26151" href="Data.Int.html#26151" class="Bound">_</a> <a id="26153" href="Data.Int.html#26153" class="Bound">_</a> <a id="26155" class="Symbol">→</a> <a id="26157" href="1Lab.HLevel.Retracts.html#8061" data-type="(n : Nat) ⦃ x : H-Level T n ⦄ → is-hlevel T n" class="Function">hlevel</a> <a id="26164" class="Number">1</a><a id="26165" class="Symbol">)</a>
    <a id="26171" class="Symbol">λ</a> <a id="26173" href="Data.Int.html#26173" class="Bound">a</a> <a id="26175" href="Data.Int.html#26175" class="Bound">b</a> <a id="26177" href="Data.Int.html#26177" class="Bound">c</a> <a id="26179" href="Data.Int.html#26179" class="Bound">d</a> <a id="26181" href="Data.Int.html#26181" class="Bound">e</a> <a id="26183" href="Data.Int.html#26183" class="Bound">f</a> <a id="26185" class="Symbol">→</a> <a id="26187" href="Data.Int.html#2994" data-type="a + d ≡ b + c → diff a b ≡ diff c d" class="Function">same-difference</a> <a id="26203" class="Symbol">(</a><a id="26204" href="Data.Int.html#26248" data-type="(a b c d e f : Nat) →
a * (c + e) + b * (d + f) + (a * d + b * c + (a * f + b * e)) ≡
a * (d + f) + b * (c + e) + (a * c + b * d + (a * e + b * f))" class="Function">lemma</a> <a id="26210" href="Data.Int.html#26173" class="Bound">a</a> <a id="26212" href="Data.Int.html#26175" class="Bound">b</a> <a id="26214" href="Data.Int.html#26177" class="Bound">c</a> <a id="26216" href="Data.Int.html#26179" class="Bound">d</a> <a id="26218" href="Data.Int.html#26181" class="Bound">e</a> <a id="26220" href="Data.Int.html#26183" class="Bound">f</a><a id="26221" class="Symbol">)</a>
    <a id="26227" class="Keyword">where</a> <a id="26233" class="Keyword">abstract</a>
      <a id="26248" href="Data.Int.html#26248" data-type="(a b c d e f : Nat) →
a * (c + e) + b * (d + f) + (a * d + b * c + (a * f + b * e)) ≡
a * (d + f) + b * (c + e) + (a * c + b * d + (a * e + b * f))" class="Function">lemma</a> <a id="26254" class="Symbol">:</a> <a id="26256" class="Symbol">∀</a> <a id="26258" href="Data.Int.html#26258" class="Bound">a</a> <a id="26260" href="Data.Int.html#26260" class="Bound">b</a> <a id="26262" href="Data.Int.html#26262" class="Bound">c</a> <a id="26264" href="Data.Int.html#26264" class="Bound">d</a> <a id="26266" href="Data.Int.html#26266" class="Bound">e</a> <a id="26268" href="Data.Int.html#26268" class="Bound">f</a> <a id="26270" class="Symbol">→</a> <a id="26272" href="Data.Int.html#26258" class="Bound">a</a> <a id="26274" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="26276" class="Symbol">(</a><a id="26277" href="Data.Int.html#26262" class="Bound">c</a> <a id="26279" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="26281" href="Data.Int.html#26266" class="Bound">e</a><a id="26282" class="Symbol">)</a> <a id="26284" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="26286" href="Data.Int.html#26260" class="Bound">b</a> <a id="26288" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="26290" class="Symbol">(</a><a id="26291" href="Data.Int.html#26264" class="Bound">d</a> <a id="26293" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="26295" href="Data.Int.html#26268" class="Bound">f</a><a id="26296" class="Symbol">)</a> <a id="26298" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="26300" class="Symbol">(</a><a id="26301" href="Data.Int.html#26258" class="Bound">a</a> <a id="26303" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="26305" href="Data.Int.html#26264" class="Bound">d</a> <a id="26307" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="26309" href="Data.Int.html#26260" class="Bound">b</a> <a id="26311" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="26313" href="Data.Int.html#26262" class="Bound">c</a> <a id="26315" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="26317" class="Symbol">(</a><a id="26318" href="Data.Int.html#26258" class="Bound">a</a> <a id="26320" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="26322" href="Data.Int.html#26268" class="Bound">f</a> <a id="26324" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="26326" href="Data.Int.html#26260" class="Bound">b</a> <a id="26328" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="26330" href="Data.Int.html#26266" class="Bound">e</a><a id="26331" class="Symbol">))</a> <a id="26334" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="26336" href="Data.Int.html#26258" class="Bound">a</a> <a id="26338" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="26340" class="Symbol">(</a><a id="26341" href="Data.Int.html#26264" class="Bound">d</a> <a id="26343" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="26345" href="Data.Int.html#26268" class="Bound">f</a><a id="26346" class="Symbol">)</a> <a id="26348" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="26350" href="Data.Int.html#26260" class="Bound">b</a> <a id="26352" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="26354" class="Symbol">(</a><a id="26355" href="Data.Int.html#26262" class="Bound">c</a> <a id="26357" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="26359" href="Data.Int.html#26266" class="Bound">e</a><a id="26360" class="Symbol">)</a> <a id="26362" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="26364" class="Symbol">(</a><a id="26365" href="Data.Int.html#26258" class="Bound">a</a> <a id="26367" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="26369" href="Data.Int.html#26262" class="Bound">c</a> <a id="26371" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="26373" href="Data.Int.html#26260" class="Bound">b</a> <a id="26375" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="26377" href="Data.Int.html#26264" class="Bound">d</a> <a id="26379" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="26381" class="Symbol">(</a><a id="26382" href="Data.Int.html#26258" class="Bound">a</a> <a id="26384" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="26386" href="Data.Int.html#26266" class="Bound">e</a> <a id="26388" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="26390" href="Data.Int.html#26260" class="Bound">b</a> <a id="26392" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="26394" href="Data.Int.html#26268" class="Bound">f</a><a id="26395" class="Symbol">))</a>
      <a id="26404" href="Data.Int.html#26248" data-type="(a b c d e f : Nat) →
a * (c + e) + b * (d + f) + (a * d + b * c + (a * f + b * e)) ≡
a * (d + f) + b * (c + e) + (a * c + b * d + (a * e + b * f))" class="Function">lemma</a> <a id="26410" href="Data.Int.html#26410" class="Bound">a</a> <a id="26412" href="Data.Int.html#26412" class="Bound">b</a> <a id="26414" href="Data.Int.html#26414" class="Bound">c</a> <a id="26416" href="Data.Int.html#26416" class="Bound">d</a> <a id="26418" href="Data.Int.html#26418" class="Bound">e</a> <a id="26420" href="Data.Int.html#26420" class="Bound">f</a> <a id="26422" class="Symbol">=</a> <a id="26424" href="Data.Nat.Solver.html#23207" data-type="Term → TC ⊤" class="Macro">solve!</a>

  <a id="26434" href="Data.Int.html#25018" data-type="(x y z : Int) → ((y +ℤ z) *ℤ x) ≡ ((y *ℤ x) +ℤ (z *ℤ x))" class="Function">*ℤ-distrib-+ℤ-r</a> <a id="26450" class="Symbol">=</a> <a id="26452" href="Data.Int.html#17179" data-type="((x y z : Int) → is-prop (P x y z)) →
((a b c d e f : Nat) → P (diff a b) (diff c d) (diff e f)) →
(x y z : Int) → P x y z" class="Function">Int-elim₃-prop</a> <a id="26467" class="Symbol">(λ</a> <a id="26470" href="Data.Int.html#26470" class="Bound">_</a> <a id="26472" href="Data.Int.html#26472" class="Bound">_</a> <a id="26474" href="Data.Int.html#26474" class="Bound">_</a> <a id="26476" class="Symbol">→</a> <a id="26478" href="1Lab.HLevel.Retracts.html#8061" data-type="(n : Nat) ⦃ x : H-Level T n ⦄ → is-hlevel T n" class="Function">hlevel</a> <a id="26485" class="Number">1</a><a id="26486" class="Symbol">)</a>
    <a id="26492" class="Symbol">λ</a> <a id="26494" href="Data.Int.html#26494" class="Bound">a</a> <a id="26496" href="Data.Int.html#26496" class="Bound">b</a> <a id="26498" href="Data.Int.html#26498" class="Bound">c</a> <a id="26500" href="Data.Int.html#26500" class="Bound">d</a> <a id="26502" href="Data.Int.html#26502" class="Bound">e</a> <a id="26504" href="Data.Int.html#26504" class="Bound">f</a> <a id="26506" class="Symbol">→</a> <a id="26508" href="Data.Int.html#2994" data-type="a + d ≡ b + c → diff a b ≡ diff c d" class="Function">same-difference</a> <a id="26524" class="Symbol">(</a><a id="26525" href="Data.Int.html#26560" data-type="(a b c d e f : Nat) →
(c + e) * a + (d + f) * b + (c * b + d * a + (e * b + f * a)) ≡
(c + e) * b + (d + f) * a + (c * a + d * b + (e * a + f * b))" class="Function">lemma</a> <a id="26531" href="Data.Int.html#26494" class="Bound">a</a> <a id="26533" href="Data.Int.html#26496" class="Bound">b</a> <a id="26535" href="Data.Int.html#26498" class="Bound">c</a> <a id="26537" href="Data.Int.html#26500" class="Bound">d</a> <a id="26539" href="Data.Int.html#26502" class="Bound">e</a> <a id="26541" href="Data.Int.html#26504" class="Bound">f</a><a id="26542" class="Symbol">)</a>
    <a id="26548" class="Keyword">where</a>
      <a id="26560" href="Data.Int.html#26560" data-type="(a b c d e f : Nat) →
(c + e) * a + (d + f) * b + (c * b + d * a + (e * b + f * a)) ≡
(c + e) * b + (d + f) * a + (c * a + d * b + (e * a + f * b))" class="Function">lemma</a> <a id="26566" class="Symbol">:</a> <a id="26568" class="Symbol">∀</a> <a id="26570" href="Data.Int.html#26570" class="Bound">a</a> <a id="26572" href="Data.Int.html#26572" class="Bound">b</a> <a id="26574" href="Data.Int.html#26574" class="Bound">c</a> <a id="26576" href="Data.Int.html#26576" class="Bound">d</a> <a id="26578" href="Data.Int.html#26578" class="Bound">e</a> <a id="26580" href="Data.Int.html#26580" class="Bound">f</a> <a id="26582" class="Symbol">→</a> <a id="26584" class="Symbol">(</a><a id="26585" href="Data.Int.html#26574" class="Bound">c</a> <a id="26587" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="26589" href="Data.Int.html#26578" class="Bound">e</a><a id="26590" class="Symbol">)</a> <a id="26592" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="26594" href="Data.Int.html#26570" class="Bound">a</a> <a id="26596" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="26598" class="Symbol">(</a><a id="26599" href="Data.Int.html#26576" class="Bound">d</a> <a id="26601" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="26603" href="Data.Int.html#26580" class="Bound">f</a><a id="26604" class="Symbol">)</a> <a id="26606" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="26608" href="Data.Int.html#26572" class="Bound">b</a> <a id="26610" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="26612" class="Symbol">(</a><a id="26613" href="Data.Int.html#26574" class="Bound">c</a> <a id="26615" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="26617" href="Data.Int.html#26572" class="Bound">b</a> <a id="26619" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="26621" href="Data.Int.html#26576" class="Bound">d</a> <a id="26623" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="26625" href="Data.Int.html#26570" class="Bound">a</a> <a id="26627" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="26629" class="Symbol">(</a><a id="26630" href="Data.Int.html#26578" class="Bound">e</a> <a id="26632" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="26634" href="Data.Int.html#26572" class="Bound">b</a> <a id="26636" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="26638" href="Data.Int.html#26580" class="Bound">f</a> <a id="26640" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="26642" href="Data.Int.html#26570" class="Bound">a</a><a id="26643" class="Symbol">))</a> <a id="26646" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="26648" class="Symbol">(</a><a id="26649" href="Data.Int.html#26574" class="Bound">c</a> <a id="26651" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="26653" href="Data.Int.html#26578" class="Bound">e</a><a id="26654" class="Symbol">)</a> <a id="26656" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="26658" href="Data.Int.html#26572" class="Bound">b</a> <a id="26660" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="26662" class="Symbol">(</a><a id="26663" href="Data.Int.html#26576" class="Bound">d</a> <a id="26665" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="26667" href="Data.Int.html#26580" class="Bound">f</a><a id="26668" class="Symbol">)</a> <a id="26670" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="26672" href="Data.Int.html#26570" class="Bound">a</a> <a id="26674" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="26676" class="Symbol">(</a><a id="26677" href="Data.Int.html#26574" class="Bound">c</a> <a id="26679" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="26681" href="Data.Int.html#26570" class="Bound">a</a> <a id="26683" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="26685" href="Data.Int.html#26576" class="Bound">d</a> <a id="26687" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="26689" href="Data.Int.html#26572" class="Bound">b</a> <a id="26691" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="26693" class="Symbol">(</a><a id="26694" href="Data.Int.html#26578" class="Bound">e</a> <a id="26696" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="26698" href="Data.Int.html#26570" class="Bound">a</a> <a id="26700" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="26702" href="Data.Int.html#26580" class="Bound">f</a> <a id="26704" href="Agda.Builtin.Nat.html#513" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="26706" href="Data.Int.html#26572" class="Bound">b</a><a id="26707" class="Symbol">))</a>
      <a id="26716" href="Data.Int.html#26560" data-type="(a b c d e f : Nat) →
(c + e) * a + (d + f) * b + (c * b + d * a + (e * b + f * a)) ≡
(c + e) * b + (d + f) * a + (c * a + d * b + (e * a + f * b))" class="Function">lemma</a> <a id="26722" href="Data.Int.html#26722" class="Bound">a</a> <a id="26724" href="Data.Int.html#26724" class="Bound">b</a> <a id="26726" href="Data.Int.html#26726" class="Bound">c</a> <a id="26728" href="Data.Int.html#26728" class="Bound">d</a> <a id="26730" href="Data.Int.html#26730" class="Bound">e</a> <a id="26732" href="Data.Int.html#26732" class="Bound">f</a> <a id="26734" class="Symbol">=</a> <a id="26736" href="Data.Nat.Solver.html#23207" data-type="Term → TC ⊤" class="Macro">solve!</a>

<a id="canonicalise-injective"></a><a id="26744" href="Data.Int.html#26744" data-type="(x y : Int) →
canonicalise x .fst ≡ canonicalise y .fst →
canonicalise x .snd .fst ≡ canonicalise y .snd .fst → x ≡ y" class="Function">canonicalise-injective</a>
  <a id="26769" class="Symbol">:</a> <a id="26771" class="Symbol">∀</a> <a id="26773" href="Data.Int.html#26773" class="Bound">x</a> <a id="26775" href="Data.Int.html#26775" class="Bound">y</a>
  <a id="26779" class="Symbol">→</a> <a id="26781" href="Data.Int.html#8375" data-type="(n : Int) → Canonical n" class="Function">canonicalise</a> <a id="26794" href="Data.Int.html#26773" class="Bound">x</a> <a id="26796" class="Symbol">.</a><a id="26797" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a>      <a id="26806" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="26808" href="Data.Int.html#8375" data-type="(n : Int) → Canonical n" class="Function">canonicalise</a> <a id="26821" href="Data.Int.html#26775" class="Bound">y</a> <a id="26823" class="Symbol">.</a><a id="26824" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a>
  <a id="26830" class="Symbol">→</a> <a id="26832" href="Data.Int.html#8375" data-type="(n : Int) → Canonical n" class="Function">canonicalise</a> <a id="26845" href="Data.Int.html#26773" class="Bound">x</a> <a id="26847" class="Symbol">.</a><a id="26848" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="26852" class="Symbol">.</a><a id="26853" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="26857" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="26859" href="Data.Int.html#8375" data-type="(n : Int) → Canonical n" class="Function">canonicalise</a> <a id="26872" href="Data.Int.html#26775" class="Bound">y</a> <a id="26874" class="Symbol">.</a><a id="26875" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="26879" class="Symbol">.</a><a id="26880" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a>
  <a id="26886" class="Symbol">→</a> <a id="26888" href="Data.Int.html#26773" class="Bound">x</a> <a id="26890" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="26892" href="Data.Int.html#26775" class="Bound">y</a>
<a id="26894" href="Data.Int.html#26744" data-type="(x y : Int) →
canonicalise x .fst ≡ canonicalise y .fst →
canonicalise x .snd .fst ≡ canonicalise y .snd .fst → x ≡ y" class="Function">canonicalise-injective</a> <a id="26917" class="Symbol">=</a> <a id="26919" href="Data.Int.html#16829" data-type="((x y : Int) → is-prop (P x y)) →
((a b x y : Nat) → P (diff a b) (diff x y)) → (x y : Int) → P x y" class="Function">Int-elim₂-prop</a> <a id="26934" class="Symbol">(λ</a> <a id="26937" href="Data.Int.html#26937" class="Bound">_</a> <a id="26939" href="Data.Int.html#26939" class="Bound">_</a> <a id="26941" class="Symbol">→</a> <a id="26943" href="1Lab.HLevel.Retracts.html#8061" data-type="(n : Nat) ⦃ x : H-Level T n ⦄ → is-hlevel T n" class="Function">hlevel</a> <a id="26950" class="Number">1</a><a id="26951" class="Symbol">)</a> <a id="26953" class="Symbol">λ</a> <a id="26955" href="Data.Int.html#26955" class="Bound">a</a> <a id="26957" href="Data.Int.html#26957" class="Bound">b</a> <a id="26959" href="Data.Int.html#26959" class="Bound">x</a> <a id="26961" href="Data.Int.html#26961" class="Bound">y</a> <a id="26963" href="Data.Int.html#26963" class="Bound">p</a> <a id="26965" href="Data.Int.html#26965" class="Bound">q</a> <a id="26967" class="Symbol">→</a>
     <a id="26974" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="26978" class="Symbol">(</a><a id="26979" href="Data.Int.html#8375" data-type="(n : Int) → Canonical n" class="Function">canonicalise</a> <a id="26992" class="Symbol">(</a><a id="26993" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="26998" href="Data.Int.html#26955" class="Bound">a</a> <a id="27000" href="Data.Int.html#26957" class="Bound">b</a><a id="27001" class="Symbol">)</a> <a id="27003" class="Symbol">.</a><a id="27004" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="27008" class="Symbol">.</a><a id="27009" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a><a id="27012" class="Symbol">)</a>
  <a id="27016" href="1Lab.Path.html#38293" data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" class="Function Operator">··</a> <a id="27019" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="27023" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="27028" href="Data.Int.html#26963" class="Bound">p</a> <a id="27030" href="Data.Int.html#26965" class="Bound">q</a>
  <a id="27034" href="1Lab.Path.html#38293" data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" class="Function Operator">··</a> <a id="27037" href="Data.Int.html#8375" data-type="(n : Int) → Canonical n" class="Function">canonicalise</a> <a id="27050" class="Symbol">(</a><a id="27051" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="27056" href="Data.Int.html#26959" class="Bound">x</a> <a id="27058" href="Data.Int.html#26961" class="Bound">y</a><a id="27059" class="Symbol">)</a> <a id="27061" class="Symbol">.</a><a id="27062" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="27066" class="Symbol">.</a><a id="27067" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a>

<a id="Discrete-Int"></a><a id="27072" href="Data.Int.html#27072" data-type="Discrete Int" class="Function">Discrete-Int</a> <a id="27085" class="Symbol">:</a> <a id="27087" href="1Lab.Type.Dec.html#585" data-type="Type ℓ → Type ℓ" class="Function">Discrete</a> <a id="27096" href="Data.Int.html#643" data-type="Type" class="Datatype">Int</a>
<a id="27100" href="Data.Int.html#27072" data-type="Discrete Int" class="Function">Discrete-Int</a> <a id="27113" class="Symbol">=</a> <a id="27115" href="Data.Int.html#16829" data-type="((x y : Int) → is-prop (P x y)) →
((a b x y : Nat) → P (diff a b) (diff x y)) → (x y : Int) → P x y" class="Function">Int-elim₂-prop</a> <a id="27130" class="Symbol">(λ</a> <a id="27133" href="Data.Int.html#27133" class="Bound">_</a> <a id="27135" href="Data.Int.html#27135" class="Bound">_</a> <a id="27137" class="Symbol">→</a> <a id="27139" href="1Lab.HLevel.Retracts.html#8061" data-type="(n : Nat) ⦃ x : H-Level T n ⦄ → is-hlevel T n" class="Function">hlevel</a> <a id="27146" class="Number">1</a><a id="27147" class="Symbol">)</a> <a id="27149" class="Symbol">λ</a> <a id="27151" href="Data.Int.html#27151" class="Bound">a</a> <a id="27153" href="Data.Int.html#27153" class="Bound">b</a> <a id="27155" href="Data.Int.html#27155" class="Bound">x</a> <a id="27157" href="Data.Int.html#27157" class="Bound">y</a> <a id="27159" class="Symbol">→</a>
  <a id="27163" href="1Lab.Type.Dec.html#332" data-type="(P : Dec A → Type ℓ&#39;) →
((y : A) → P (yes y)) →
((y : A → ⊥) → P (no y)) → (x : Dec A) → P x" class="Function">case</a> <a id="27168" class="Symbol">(λ</a> <a id="27171" href="Data.Int.html#27171" class="Bound">_</a> <a id="27173" class="Symbol">→</a> <a id="27175" href="1Lab.Type.Dec.html#254" data-type="Type ℓ → Type ℓ" class="Datatype">Dec</a> <a id="27179" class="Symbol">(</a><a id="27180" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="27185" href="Data.Int.html#27151" class="Bound">a</a> <a id="27187" href="Data.Int.html#27153" class="Bound">b</a> <a id="27189" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="27191" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="27196" href="Data.Int.html#27155" class="Bound">x</a> <a id="27198" href="Data.Int.html#27157" class="Bound">y</a><a id="27199" class="Symbol">))</a>
    <a id="27206" class="Symbol">(</a><a id="27207" href="1Lab.Type.Dec.html#292" data-type="A → Dec A" class="InductiveConstructor">yes</a> <a id="27211" href="1Lab.Type.html#2227" data-type="((y : B₁ x) → C x y) → (f : (x : A) → B₁ x) (x : A) → C x (f x)" class="Function Operator">∘</a> <a id="27213" href="Data.Int.html#2994" data-type="a + d ≡ b + c → diff a b ≡ diff c d" class="Function">same-difference</a><a id="27228" class="Symbol">)</a>
    <a id="27234" class="Symbol">(λ</a> <a id="27237" href="Data.Int.html#27237" class="Bound">¬sd</a> <a id="27241" class="Symbol">→</a> <a id="27243" href="1Lab.Type.Dec.html#310" data-type="(A → ⊥) → Dec A" class="InductiveConstructor">no</a> <a id="27246" class="Symbol">λ</a> <a id="27248" href="Data.Int.html#27248" class="Bound">sd</a> <a id="27251" class="Symbol">→</a> <a id="27253" href="Data.Int.html#27237" class="Bound">¬sd</a> <a id="27257" class="Symbol">(</a><a id="27258" href="Data.Int.html#6453" data-type="(a b : Nat) (x : Int) → diff a b ≡ x → Code a b x" class="Function">ℤ-Path.encode</a> <a id="27272" href="Data.Int.html#27151" class="Bound">a</a> <a id="27274" href="Data.Int.html#27153" class="Bound">b</a> <a id="27276" class="Symbol">(</a><a id="27277" href="Data.Int.html#662" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="27282" href="Data.Int.html#27155" class="Bound">x</a> <a id="27284" href="Data.Int.html#27157" class="Bound">y</a><a id="27285" class="Symbol">)</a> <a id="27287" href="Data.Int.html#27248" class="Bound">sd</a><a id="27289" class="Symbol">))</a>
    <a id="27296" class="Symbol">(</a><a id="27297" href="Data.Nat.Base.html#2008" data-type="Discrete Nat" class="Function">Discrete-Nat</a> <a id="27310" class="Symbol">(</a><a id="27311" href="Data.Int.html#27151" class="Bound">a</a> <a id="27313" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="27315" href="Data.Int.html#27157" class="Bound">y</a><a id="27316" class="Symbol">)</a> <a id="27318" class="Symbol">(</a><a id="27319" href="Data.Int.html#27153" class="Bound">b</a> <a id="27321" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="27323" href="Data.Int.html#27155" class="Bound">x</a><a id="27324" class="Symbol">))</a>
</pre>-->
<section class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>In the diagram, we write
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">S</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">\id{S}x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathrm">S</span><span class="mord mathnormal">x</span></span></span></span>
for <code>suc x</code>.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>keeping in mind that the image of
<span class="Agda"><a href="Data.Int.html#8375" class="Function">canonicalise</a></span>
is restricted to pairs of the form
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo>+</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0,1+x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>,</span>
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>x</mi><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1+x,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span>,</span>
or
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
  </article>
</div>
</main>
</body>
</html>
