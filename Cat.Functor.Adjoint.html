<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="keywords" content="Agda,categories,topos" />

  <title>Cat.Functor.Adjoint - 1Lab</title>

  <link rel="stylesheet" href="/css/default.css" />
  <link rel="stylesheet" href="/css/katex.min.css" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Cat.Functor.Adjoint - 1Lab" />
  <meta name="twitter:image" content="https://1lab.dev/static/cube-128x.png" />

  <meta name="og:title" content="Cat.Functor.Adjoint - 1Lab" />
  <meta name="og:image" content="https://1lab.dev/static/cube-128x.png" />
  <meta name="og:site-name" content="1Lab" />
  <meta name="og:type" content="website" />

    <meta name="og:description" content="&lt;p&gt;We present two definitions of adjoint functors, one which is computationally convenient (units and counits), and one which is conceptually clean (adjoints as “optimal solutions” — initial objects in certain comma categories).&lt;/p&gt;" />
  <meta name="twitter:description" content="&lt;p&gt;We present two definitions of adjoint functors, one which is computationally convenient (units and counits), and one which is conceptually clean (adjoints as “optimal solutions” — initial objects in certain comma categories).&lt;/p&gt;" />
  <meta name="description" content="&lt;p&gt;We present two definitions of adjoint functors, one which is computationally convenient (units and counits), and one which is conceptually clean (adjoints as “optimal solutions” — initial objects in certain comma categories).&lt;/p&gt;" />
  
  <script defer src="/main.js"></script>

  <noscript>
    <style>
      body span.reasoning-step .as-written {
        display: inline;
      }

      body span.reasoning-step .alternate {
        display: none;
      }
    </style>
  </noscript>

  <!-- Google font embeds -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;0,800;1,400;1,500;1,600;1,700;1,800&amp;family=Inria+Sans:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&amp;display=swap" rel="stylesheet">
</head>

<body class="text-page">
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <!-- Table of contents (only if the page has a table of contents) -->
    <aside id="toc">
    <div id="toc-container" style="min-width: 10em; font-size: 15pt;">
      <!-- Title for the page -->
      <h3 class="Agda" style="margin-top: 0; margin-bottom: 0; white-space: pre;">
                <a class="Module">Cat.Functor.Adjoint</a>
              </h3>

      <!-- Cube logo -->
      <a id="logo" href="/">
        <img alt="1Lab" src="/static/cube-72x.png" style="display: block; margin-bottom: 1em; margin: auto;" width="32px" height="32px" />
      </a>

      <!-- Actual table of contents (separated from the rest by
      horizontal rules) -->
      <hr />
      <ul>
      <li><a href="#adjoint-functors"><a href="#adjoint-functors" class="header-link">Adjoint functors<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#universal-morphisms"><a href="#universal-morphisms" class="header-link">Universal morphisms<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#defining-the-l"><a href="#defining-the-l" class="header-link">Defining the L<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#building-the-adjunction"><a href="#building-the-adjunction" class="header-link">Building the adjunction<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#from-an-adjunction"><a href="#from-an-adjunction" class="header-link">From an adjunction<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      <li><a href="#adjuncts"><a href="#adjuncts" class="header-link">Adjuncts<span class="header-link-emoji">🔗</span></a></a></li>
      </ul>
      <hr />

      <!-- Sidebar controls -->
      <div style="display: flex; gap: 0.25em; flex-flow: row wrap;">
        <!-- Sidebar equations control -->
        <span class="equations" style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-eqns" type="checkbox" class="equations" id="sidebar-eqns">
          <label for="sidebar-eqns">Equations</label>
        </span>

        <!-- Sidebar fonts control -->
        <span style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-font" type="checkbox" id="toggle-fonts">
          <label for="toggle-fonts">Serif Font</label>
        </span>

        <!-- Sidebar footnotes control -->
        <span class="inline-footnotes" style="display: none; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-fns" type="checkbox" class="inline-footnotes" id="sidebar-fns">
          <label for="sidebar-fns">Inline Footnotes</label>
        </span>
      </div>

      <hr />

      <!-- Navbar navigation (lol) -->
      <div id="return" style="white-space: nowrap;">
        <div class="search-form search-form-proxy" role="form">
          <input id="search-box-proxy" type_="text" placeholder="Search..." autocomplete="off" tabindex="0"></input>
        </div>

              <a href="/">back to index</a> <br />
              <a href="all-pages.html">view all pages</a> <br />
        <a href="https://github.com/plt-amy/cubical-1lab/blob/0ba437bf9e3c9711e0722440ea037ab88a75ce36/src/Cat/Functor/Adjoint.lagda.md">link to source</a> <br />
                <hr /> <div class="author-list">Written by Amélia Liao and Reed Mullanix</div> <br />
              </div>
    </div>
  </aside>
  
  <article>
    <!-- Article navigation (narrow screens only) -->
    <div class="narrow-only" id="article-nav">
      <!-- Index return anchor (only if the page is not the index) -->
            <div id="return">
        <a href="/">back to index</a>
      </div>
      
      <!-- Navbar equations control -->
      <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-eqns" type="checkbox" class="equations" id="navbar-eqns">
        <label for="navbar-eqns">Equations</label>
      </span>

      <!-- Navbar footnotes control -->
      <span class="inline-footnotes" style="display: none; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-fns" type="checkbox" class="inline-footnotes" id="navbar-fns">
        <label for="navbar-fns">Inline Footnotes</label>
      </span>
    </div>

<pre class="Agda"><a id="268" class="Keyword">open</a> <a id="273" class="Keyword">import</a> <a id="280" href="Cat.Diagram.Initial.html" class="Module">Cat.Diagram.Initial</a>
<a id="300" class="Keyword">open</a> <a id="305" class="Keyword">import</a> <a id="312" href="Cat.Instances.Comma.html" class="Module">Cat.Instances.Comma</a>
<a id="332" class="Keyword">open</a> <a id="337" class="Keyword">import</a> <a id="344" href="Cat.Prelude.html" class="Module">Cat.Prelude</a>

<a id="357" class="Keyword">import</a> <a id="364" href="Cat.Functor.Reasoning.html" class="Module">Cat.Functor.Reasoning</a> <a id="386" class="Symbol">as</a> <a id="389" class="Module">Func</a>
<a id="394" class="Keyword">import</a> <a id="401" href="Cat.Reasoning.html" class="Module">Cat.Reasoning</a>

<a id="416" class="Keyword">module</a> <a id="423" href="Cat.Functor.Adjoint.html" class="Module">Cat.Functor.Adjoint</a> <a id="443" class="Keyword">where</a>
</pre>
<!--
<pre class="Agda"><a id="467" class="Keyword">private</a> <a id="475" class="Keyword">variable</a>
  <a id="486" href="Cat.Functor.Adjoint.html#486" class="Generalizable">o</a> <a id="488" href="Cat.Functor.Adjoint.html#488" class="Generalizable">h</a> <a id="490" class="Symbol">:</a> <a id="492" href="Agda.Primitive.html#597" data-type="Type" class="Postulate">Level</a>
  <a id="500" href="Cat.Functor.Adjoint.html#500" class="Generalizable">C</a> <a id="502" href="Cat.Functor.Adjoint.html#502" class="Generalizable">D</a> <a id="504" class="Symbol">:</a> <a id="506" href="Cat.Base.html#704" data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" class="Record">Precategory</a> <a id="518" href="Cat.Functor.Adjoint.html#486" class="Generalizable">o</a> <a id="520" href="Cat.Functor.Adjoint.html#488" class="Generalizable">h</a>

<a id="523" class="Keyword">open</a> <a id="528" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Module">Functor</a> <a id="536" class="Keyword">hiding</a> <a id="543" class="Symbol">(</a><a id="544" href="Cat.Base.html#8972" data-type="(r : Functor C D) → Functor (C ^op) (D ^op)" class="Function">op</a><a id="546" class="Symbol">)</a>

<a id="adj-level"></a><a id="549" href="Cat.Functor.Adjoint.html#549" data-type="Precategory o₁ h₁ → Precategory o₂ h₂ → Level" class="Function">adj-level</a> <a id="559" class="Symbol">:</a> <a id="561" class="Symbol">∀</a> <a id="563" class="Symbol">{</a><a id="564" href="Cat.Functor.Adjoint.html#564" class="Bound">o₁</a> <a id="567" href="Cat.Functor.Adjoint.html#567" class="Bound">h₁</a> <a id="570" href="Cat.Functor.Adjoint.html#570" class="Bound">o₂</a> <a id="573" href="Cat.Functor.Adjoint.html#573" class="Bound">h₂</a><a id="575" class="Symbol">}</a> <a id="577" class="Symbol">(</a><a id="578" href="Cat.Functor.Adjoint.html#578" class="Bound">C</a> <a id="580" class="Symbol">:</a> <a id="582" href="Cat.Base.html#704" data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" class="Record">Precategory</a> <a id="594" href="Cat.Functor.Adjoint.html#564" class="Bound">o₁</a> <a id="597" href="Cat.Functor.Adjoint.html#567" class="Bound">h₁</a><a id="599" class="Symbol">)</a> <a id="601" class="Symbol">(</a><a id="602" href="Cat.Functor.Adjoint.html#602" class="Bound">D</a> <a id="604" class="Symbol">:</a> <a id="606" href="Cat.Base.html#704" data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" class="Record">Precategory</a> <a id="618" href="Cat.Functor.Adjoint.html#570" class="Bound">o₂</a> <a id="621" href="Cat.Functor.Adjoint.html#573" class="Bound">h₂</a><a id="623" class="Symbol">)</a>
          <a id="635" class="Symbol">→</a> <a id="637" href="Agda.Primitive.html#597" data-type="Type" class="Postulate">Level</a>
<a id="643" href="Cat.Functor.Adjoint.html#549" data-type="Precategory o₁ h₁ → Precategory o₂ h₂ → Level" class="Function">adj-level</a> <a id="653" class="Symbol">{</a><a id="654" class="Argument">o₁</a> <a id="657" class="Symbol">=</a> <a id="659" href="Cat.Functor.Adjoint.html#659" class="Bound">o₁</a><a id="661" class="Symbol">}</a> <a id="663" class="Symbol">{</a><a id="664" href="Cat.Functor.Adjoint.html#664" class="Bound">h₁</a><a id="666" class="Symbol">}</a> <a id="668" class="Symbol">{</a><a id="669" href="Cat.Functor.Adjoint.html#669" class="Bound">o₂</a><a id="671" class="Symbol">}</a> <a id="673" class="Symbol">{</a><a id="674" href="Cat.Functor.Adjoint.html#674" class="Bound">h₂</a><a id="676" class="Symbol">}</a> <a id="678" class="Symbol">_</a> <a id="680" class="Symbol">_</a> <a id="682" class="Symbol">=</a> <a id="684" href="Cat.Functor.Adjoint.html#659" class="Bound">o₁</a> <a id="687" href="Agda.Primitive.html#810" data-type="Level → Level → Level" class="Primitive Operator">⊔</a> <a id="689" href="Cat.Functor.Adjoint.html#669" class="Bound">o₂</a> <a id="692" href="Agda.Primitive.html#810" data-type="Level → Level → Level" class="Primitive Operator">⊔</a> <a id="694" href="Cat.Functor.Adjoint.html#664" class="Bound">h₁</a> <a id="697" href="Agda.Primitive.html#810" data-type="Level → Level → Level" class="Primitive Operator">⊔</a> <a id="699" href="Cat.Functor.Adjoint.html#674" class="Bound">h₂</a>
</pre>-->
<h1 id="adjoint-functors"><a href="#adjoint-functors" class="header-link">Adjoint functors<span class="header-link-emoji">🔗</span></a></h1>
<p>Category theory is, in general, the study of how things can be related. For instance, structures at the level of sets (e.g. the collection of natural numbers) are often interestingly related by propositions (i.e. the proposition <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≤</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \le y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>).</span> Structures at the level of groupoids (e.g. the collection of all sets) are interestingly related by sets (i.e. the set of maps <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>→</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \to y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>).</span> Going further, we have structures at the level of 2-groupoids, which could be given an interesting <em>category</em> of relations, etc.</p>
<p>A particularly important relationship is, of course, “sameness.” Going up the ladder of category number, we have equality at the (-1)-level, isomorphism at the 0-level, and what’s generally referred to as “equivalence” at higher levels. It’s often interesting to weaken these relations, by making some components directed: This starts at the level of categories, where “directing” an equivalence gives us the concept of <strong>adjunction</strong>.</p>
<p>An <em>equivalence of categories</em> between <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">\ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">\ca{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span> is given by a pair of functors <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>:</mo><mi mathvariant="script">C</mi><mo>⇆</mo><mi mathvariant="script">D</mi><mo>:</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">L : \ca{C} \leftrightarrows \ca{D} : R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8641em;vertical-align:-0.1808em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel amsrm">⇆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>,</span> equipped with natural <em>isomorphisms</em> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>η</mi><mo>:</mo><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">d</mi></mrow><mo>≅</mo><mo stretchy="false">(</mo><mi>R</mi><mo>∘</mo><mi>L</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\eta : \id{Id} \cong (R \circ L)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">η</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">Id</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mclose">)</span></span></span></span> (the “unit”) and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ε</mi><mo>:</mo><mo stretchy="false">(</mo><mi>L</mi><mo>∘</mo><mi>R</mi><mo stretchy="false">)</mo><mo>≅</mo><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">d</mi></mrow></mrow><annotation encoding="application/x-tex">\eps : (L \circ R) \cong \id{Id}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ε</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">Id</span></span></span></span></span> (the “counit”). We still want the correspondence to be bidirectional, so we can’t change the types of <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>,</span> <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span>;</span> What we <em>can</em> do is weaken the natural isomorphisms to natural <em>transformations</em>. The data of an <strong>adjunction</strong> starts as such:</p>
<pre class="Agda"><a id="2185" class="Keyword">record</a> <a id="_⊣_"></a><a id="2192" href="Cat.Functor.Adjoint.html#2192" data-type="(L : Functor C D) (R₁ : Functor D C) → Type (C.o ⊔ C.h ⊔ D.o ⊔ D.h)" class="Record Operator">_⊣_</a> <a id="2196" class="Symbol">(</a><a id="2197" href="Cat.Functor.Adjoint.html#2197" class="Bound">L</a> <a id="2199" class="Symbol">:</a> <a id="2201" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="2209" href="Cat.Functor.Adjoint.html#500" class="Generalizable">C</a> <a id="2211" href="Cat.Functor.Adjoint.html#502" class="Generalizable">D</a><a id="2212" class="Symbol">)</a> <a id="2214" class="Symbol">(</a><a id="2215" href="Cat.Functor.Adjoint.html#2215" class="Bound">R</a> <a id="2217" class="Symbol">:</a> <a id="2219" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="2227" href="Cat.Functor.Adjoint.html#502" class="Generalizable">D</a> <a id="2229" href="Cat.Functor.Adjoint.html#500" class="Generalizable">C</a><a id="2230" class="Symbol">)</a> <a id="2232" class="Symbol">:</a> <a id="2234" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="2239" class="Symbol">(</a><a id="2240" href="Cat.Functor.Adjoint.html#549" data-type="Precategory o₁ h₁ → Precategory o₂ h₂ → Level" class="Function">adj-level</a> <a id="2250" href="Cat.Functor.Adjoint.html#2209" class="Bound">C</a> <a id="2252" href="Cat.Functor.Adjoint.html#2211" class="Bound">D</a><a id="2253" class="Symbol">)</a> <a id="2255" class="Keyword">where</a>
  <a id="2263" class="Keyword">private</a>
    <a id="2275" class="Keyword">module</a> <a id="_⊣_.C"></a><a id="2282" href="Cat.Functor.Adjoint.html#2282" class="Module">C</a> <a id="2284" class="Symbol">=</a> <a id="2286" href="Cat.Base.html#704" data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" class="Module">Precategory</a> <a id="2298" href="Cat.Functor.Adjoint.html#2209" class="Bound">C</a>
    <a id="2304" class="Keyword">module</a> <a id="_⊣_.D"></a><a id="2311" href="Cat.Functor.Adjoint.html#2311" class="Module">D</a> <a id="2313" class="Symbol">=</a> <a id="2315" href="Cat.Base.html#704" data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" class="Module">Precategory</a> <a id="2327" href="Cat.Functor.Adjoint.html#2211" class="Bound">D</a>

  <a id="2332" class="Keyword">field</a>
    <a id="_⊣_.unit"></a><a id="2342" href="Cat.Functor.Adjoint.html#2342" data-type="L ⊣ R₁ → Id =&gt; R₁ F∘ L" class="Field">unit</a>   <a id="2349" class="Symbol">:</a> <a id="2351" href="Cat.Base.html#11722" data-type="Functor C C" class="Function">Id</a> <a id="2354" href="Cat.Base.html#12241" data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" class="Record Operator">=&gt;</a> <a id="2357" class="Symbol">(</a><a id="2358" href="Cat.Functor.Adjoint.html#2215" class="Bound">R</a> <a id="2360" href="Cat.Base.html#9697" data-type="Functor D E → Functor C D → Functor C E" class="Function Operator">F∘</a> <a id="2363" href="Cat.Functor.Adjoint.html#2197" class="Bound">L</a><a id="2364" class="Symbol">)</a>
    <a id="_⊣_.counit"></a><a id="2370" href="Cat.Functor.Adjoint.html#2370" data-type="L ⊣ R₁ → L F∘ R₁ =&gt; Id" class="Field">counit</a> <a id="2377" class="Symbol">:</a> <a id="2379" class="Symbol">(</a><a id="2380" href="Cat.Functor.Adjoint.html#2197" class="Bound">L</a> <a id="2382" href="Cat.Base.html#9697" data-type="Functor D E → Functor C D → Functor C E" class="Function Operator">F∘</a> <a id="2385" href="Cat.Functor.Adjoint.html#2215" class="Bound">R</a><a id="2386" class="Symbol">)</a> <a id="2388" href="Cat.Base.html#12241" data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" class="Record Operator">=&gt;</a> <a id="2391" href="Cat.Base.html#11722" data-type="Functor C C" class="Function">Id</a>

  <a id="2397" class="Keyword">module</a> <a id="_⊣_.unit"></a><a id="2404" href="Cat.Functor.Adjoint.html#2404" class="Module">unit</a> <a id="2409" class="Symbol">=</a> <a id="2411" href="Cat.Base.html#12241" data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" class="Module Operator">_=&gt;_</a> <a id="2416" href="Cat.Functor.Adjoint.html#2342" data-type="L ⊣ R₁ → Id =&gt; R₁ F∘ L" class="Field">unit</a>
  <a id="2423" class="Keyword">module</a> <a id="_⊣_.counit"></a><a id="2430" href="Cat.Functor.Adjoint.html#2430" class="Module">counit</a> <a id="2437" class="Symbol">=</a> <a id="2439" href="Cat.Base.html#12241" data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" class="Module Operator">_=&gt;_</a> <a id="2444" href="Cat.Functor.Adjoint.html#2370" data-type="L ⊣ R₁ → L F∘ R₁ =&gt; Id" class="Field">counit</a> <a id="2451" class="Keyword">renaming</a> <a id="2460" class="Symbol">(</a><a id="2461" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="2463" class="Symbol">to</a> <a id="2466" class="Field">ε</a><a id="2467" class="Symbol">)</a>
</pre>
<p>Unfortunately, the data that we have here is not particularly coherent. The <span class="Agda"><a href="Cat.Functor.Adjoint.html#2342" class="Field">unit</a></span> and <span class="Agda"><a href="Cat.Functor.Adjoint.html#2370" class="Field">counit</a></span> let us introduce <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>∘</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">R\circ L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span> and eliminate <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>∘</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">L\circ R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> in a composition, which gives us two ways of mapping <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>⇒</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">L \To L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span>.</span> One is the identity, and the other is going through the unit: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>⇒</mo><mi>L</mi><mo>∘</mo><mi>R</mi><mo>∘</mo><mi>L</mi><mo>⇒</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">L \To L\circ R\circ L \To L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span> (the situation with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> is symmetric). We must impose further equations on the natural transformations to make sure these match:</p>
<pre class="Agda">  <a id="2933" class="Keyword">field</a>
    <a id="_⊣_.zig"></a><a id="2943" href="Cat.Functor.Adjoint.html#2943" data-type="(r : L ⊣ R₁) →
D ._∘_ (η (r .counit) (F₀ L A)) (F₁ L (r .unit .η A)) ≡ D .id" class="Field">zig</a> <a id="2947" class="Symbol">:</a> <a id="2949" class="Symbol">∀</a> <a id="2951" class="Symbol">{</a><a id="2952" href="Cat.Functor.Adjoint.html#2952" class="Bound">A</a><a id="2953" class="Symbol">}</a> <a id="2955" class="Symbol">→</a> <a id="2957" href="Cat.Functor.Adjoint.html#2466" class="Function">counit.ε</a> <a id="2966" class="Symbol">(</a><a id="2967" href="Cat.Base.html#7996" data-type="Functor C D → C .Ob → Ob D" class="Field">F₀</a> <a id="2970" href="Cat.Functor.Adjoint.html#2197" class="Bound">L</a> <a id="2972" href="Cat.Functor.Adjoint.html#2952" class="Bound">A</a><a id="2973" class="Symbol">)</a> <a id="2975" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="2979" href="Cat.Base.html#8017" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="2982" href="Cat.Functor.Adjoint.html#2197" class="Bound">L</a> <a id="2984" class="Symbol">(</a><a id="2985" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Function">unit.η</a> <a id="2992" href="Cat.Functor.Adjoint.html#2952" class="Bound">A</a><a id="2993" class="Symbol">)</a> <a id="2995" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="2997" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">D.id</a>
    <a id="_⊣_.zag"></a><a id="3006" href="Cat.Functor.Adjoint.html#3006" data-type="(r : L ⊣ R₁) →
C ._∘_ (F₁ R₁ (η (r .counit) B₁)) (r .unit .η (F₀ R₁ B₁)) ≡ C .id" class="Field">zag</a> <a id="3010" class="Symbol">:</a> <a id="3012" class="Symbol">∀</a> <a id="3014" class="Symbol">{</a><a id="3015" href="Cat.Functor.Adjoint.html#3015" class="Bound">B</a><a id="3016" class="Symbol">}</a> <a id="3018" class="Symbol">→</a> <a id="3020" href="Cat.Base.html#8017" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="3023" href="Cat.Functor.Adjoint.html#2215" class="Bound">R</a> <a id="3025" class="Symbol">(</a><a id="3026" href="Cat.Functor.Adjoint.html#2466" class="Function">counit.ε</a> <a id="3035" href="Cat.Functor.Adjoint.html#3015" class="Bound">B</a><a id="3036" class="Symbol">)</a> <a id="3038" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="3042" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Function">unit.η</a> <a id="3049" class="Symbol">(</a><a id="3050" href="Cat.Base.html#7996" data-type="Functor C D → C .Ob → Ob D" class="Field">F₀</a> <a id="3053" href="Cat.Functor.Adjoint.html#2215" class="Bound">R</a> <a id="3055" href="Cat.Functor.Adjoint.html#3015" class="Bound">B</a><a id="3056" class="Symbol">)</a> <a id="3058" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="3060" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">C.id</a>

<a id="3066" class="Keyword">infixr</a> <a id="3073" class="Number">15</a> <a id="3076" href="Cat.Functor.Adjoint.html#2192" data-type="(L : Functor C D) (R₁ : Functor D C) → Type (C.o ⊔ C.h ⊔ D.o ⊔ D.h)" class="Record Operator">_⊣_</a>
</pre>
<p>These are called “triangle identities” because of the shape they have as commutative diagrams:</p>
<div class="mathpar">
<div class="diagram-container">
<img src="light-736f61228a1ec522ec947b5c2df33b28d5800b19.svg" title="commutative diagram" class="diagram diagram-light quiver" />
<img src="dark-736f61228a1ec522ec947b5c2df33b28d5800b19.svg" title="commutative diagram" class="diagram diagram-dark quiver" />
</div>
<div class="diagram-container">
<img src="light-88202b89d1455fa535f2b6e8e82bb43f2c2d6e04.svg" title="commutative diagram" class="diagram diagram-light quiver" />
<img src="dark-88202b89d1455fa535f2b6e8e82bb43f2c2d6e04.svg" title="commutative diagram" class="diagram diagram-dark quiver" />
</div>
</div>
<h1 id="universal-morphisms"><a href="#universal-morphisms" class="header-link">Universal morphisms<span class="header-link-emoji">🔗</span></a></h1>
<!--
<pre class="Agda"><a id="3596" class="Keyword">module</a> <a id="3603" href="Cat.Functor.Adjoint.html#3603" class="Module">_</a>
  <a id="3607" class="Symbol">{</a><a id="3608" href="Cat.Functor.Adjoint.html#3608" class="Bound">o</a> <a id="3610" href="Cat.Functor.Adjoint.html#3610" class="Bound">h</a> <a id="3612" href="Cat.Functor.Adjoint.html#3612" class="Bound">o&#39;</a> <a id="3615" href="Cat.Functor.Adjoint.html#3615" class="Bound">h&#39;</a><a id="3617" class="Symbol">}</a>
  <a id="3621" class="Symbol">{</a><a id="3622" href="Cat.Functor.Adjoint.html#3622" class="Bound">C</a> <a id="3624" class="Symbol">:</a> <a id="3626" href="Cat.Base.html#704" data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" class="Record">Precategory</a> <a id="3638" href="Cat.Functor.Adjoint.html#3608" class="Bound">o</a> <a id="3640" href="Cat.Functor.Adjoint.html#3610" class="Bound">h</a><a id="3641" class="Symbol">}</a>
  <a id="3645" class="Symbol">{</a><a id="3646" href="Cat.Functor.Adjoint.html#3646" class="Bound">D</a> <a id="3648" class="Symbol">:</a> <a id="3650" href="Cat.Base.html#704" data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" class="Record">Precategory</a> <a id="3662" href="Cat.Functor.Adjoint.html#3612" class="Bound">o&#39;</a> <a id="3665" href="Cat.Functor.Adjoint.html#3615" class="Bound">h&#39;</a><a id="3667" class="Symbol">}</a>
  <a id="3671" class="Keyword">where</a>

  <a id="3680" class="Keyword">private</a>
    <a id="3692" class="Keyword">module</a> <a id="3699" href="Cat.Functor.Adjoint.html#3699" class="Module">C</a> <a id="3701" class="Symbol">=</a> <a id="3703" href="Cat.Base.html#704" data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" class="Module">Precategory</a> <a id="3715" href="Cat.Functor.Adjoint.html#3622" class="Bound">C</a>
    <a id="3721" class="Keyword">module</a> <a id="3728" href="Cat.Functor.Adjoint.html#3728" class="Module">D</a> <a id="3730" class="Symbol">=</a> <a id="3732" href="Cat.Base.html#704" data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" class="Module">Precategory</a> <a id="3744" href="Cat.Functor.Adjoint.html#3646" class="Bound">D</a>
</pre>-->
<p>Another perspective on adjoint functors is given by finding “most efficient solutions” to the “problem” posed by a functor. For instance, the (<a href="Cat.Functor.Base.html#ff-functors">ff</a>) inclusion of <a href="Cat.Thin.html#prosets">prosets</a> into <a href="Cat.Instances.StrictCat.html#strict-precategories">strict precategories</a> poses the problem of turning a precategory into a proset. While this can’t be done in a 1:1 way (precategories are strictly more general than prosets), we <em>can</em> still ponder whether there is some “most efficient” way to turn a category into a proset.</p>
<p>While we can’t directly consider maps from precategories to proset, we <em>can</em> consider maps from precategories to the inclusion of a proset; Let us write <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">\ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span> for a generic precategory, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">P</mi></mrow><annotation encoding="application/x-tex">\ca{P}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.08222em;">P</span></span></span></span> for a generic proset, and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo stretchy="false">(</mo><mi mathvariant="script">P</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">U(\ca{P})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mopen">(</span><span class="mord mathcal" style="margin-right:0.08222em;">P</span><span class="mclose">)</span></span></span></span> for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">P</mi></mrow><annotation encoding="application/x-tex">\ca{P}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.08222em;">P</span></span></span></span> considered as a precategory. Any functor <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi><mo>→</mo><mi>U</mi><mo stretchy="false">(</mo><mi mathvariant="script">P</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\ca{C} \to U(\ca{P})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mopen">(</span><span class="mord mathcal" style="margin-right:0.08222em;">P</span><span class="mclose">)</span></span></span></span> can be seen as “a way to turn <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">\ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span> into a proset,” but not all of these can be the “most efficient” way. In fact, there is a vast sea of uninteresting ways to turn a precategory into a proset: turn them all into the <a href="Cat.Diagram.Terminal.html">terminal</a> proset!</p>
<p>A “most efficient” solution, then, would be one through which all others factor. A “universal” way of turning a strict precategory into a proset: A <strong>universal morphism</strong> from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">\ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span> to <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span>.</span> The way we think about universal morphisms (reusing the same variables) is as <a href="Cat.Diagram.Initial.html">initial objects</a> in the <a href="Cat.Instances.Comma.html">comma category</a> <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi><mo>↙</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">\ca{C} \swarrow U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↙</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span>,</span> where that category is conceptualised as being “the category of maps from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">\ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span> to <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span>.</span>”</p>
<pre class="Agda">  <a id="5472" href="Cat.Functor.Adjoint.html#5472" data-type="C .Ob → Functor D C → Type (h ⊔ o&#39; ⊔ h&#39;)" class="Function">Universal-morphism</a> <a id="5491" class="Symbol">:</a> <a id="5493" href="Cat.Base.html#1419" data-type="Precategory o h → Type o" class="Function">C.Ob</a> <a id="5498" class="Symbol">→</a> <a id="5500" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="5508" href="Cat.Functor.Adjoint.html#3646" class="Bound">D</a> <a id="5510" href="Cat.Functor.Adjoint.html#3622" class="Bound">C</a> <a id="5512" class="Symbol">→</a> <a id="5514" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="5519" class="Symbol">_</a>
  <a id="5523" href="Cat.Functor.Adjoint.html#5472" data-type="C .Ob → Functor D C → Type (h ⊔ o&#39; ⊔ h&#39;)" class="Function">Universal-morphism</a> <a id="5542" href="Cat.Functor.Adjoint.html#5542" class="Bound">X</a> <a id="5544" href="Cat.Functor.Adjoint.html#5544" class="Bound">R</a> <a id="5546" class="Symbol">=</a> <a id="5548" href="Cat.Diagram.Initial.html#401" data-type="(C : Precategory o h) → Type (o ⊔ h)" class="Record">Initial</a> <a id="5556" class="Symbol">(</a><a id="5557" href="Cat.Functor.Adjoint.html#5542" class="Bound">X</a> <a id="5559" href="Cat.Instances.Comma.html#5800" data-type="A .Ob →
Functor B₁ A → Precategory (ah ⊔ bo ⊔ lzero) (ah ⊔ bh ⊔ lzero)" class="Function Operator">↙</a> <a id="5561" href="Cat.Functor.Adjoint.html#5544" class="Bound">R</a><a id="5562" class="Symbol">)</a>
</pre>
<p>Abstracting away, suppose that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>:</mo><mi>D</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">R : D \to C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> has universal morphisms for every object of <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>.</span> To show the correspondence between these two ideas of adjunction, we show that this assignment extends to a functor <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>:</mo><mi>C</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">L : C \to D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>,</span> with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>⊣</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">L \dashv R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊣</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> as defined above.</p>
<!--
<pre class="Agda"><a id="5844" class="Keyword">module</a> <a id="5851" href="Cat.Functor.Adjoint.html#5851" class="Module">_</a>
  <a id="5855" class="Symbol">{</a><a id="5856" href="Cat.Functor.Adjoint.html#5856" class="Bound">o</a> <a id="5858" href="Cat.Functor.Adjoint.html#5858" class="Bound">h</a> <a id="5860" href="Cat.Functor.Adjoint.html#5860" class="Bound">o&#39;</a> <a id="5863" href="Cat.Functor.Adjoint.html#5863" class="Bound">h&#39;</a><a id="5865" class="Symbol">}</a>
  <a id="5869" class="Symbol">{</a><a id="5870" href="Cat.Functor.Adjoint.html#5870" class="Bound">C</a> <a id="5872" class="Symbol">:</a> <a id="5874" href="Cat.Base.html#704" data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" class="Record">Precategory</a> <a id="5886" href="Cat.Functor.Adjoint.html#5856" class="Bound">o</a> <a id="5888" href="Cat.Functor.Adjoint.html#5858" class="Bound">h</a><a id="5889" class="Symbol">}</a>
  <a id="5893" class="Symbol">{</a><a id="5894" href="Cat.Functor.Adjoint.html#5894" class="Bound">D</a> <a id="5896" class="Symbol">:</a> <a id="5898" href="Cat.Base.html#704" data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" class="Record">Precategory</a> <a id="5910" href="Cat.Functor.Adjoint.html#5860" class="Bound">o&#39;</a> <a id="5913" href="Cat.Functor.Adjoint.html#5863" class="Bound">h&#39;</a><a id="5915" class="Symbol">}</a>
  <a id="5919" class="Symbol">(</a><a id="5920" href="Cat.Functor.Adjoint.html#5920" class="Bound">R</a> <a id="5922" class="Symbol">:</a> <a id="5924" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="5932" href="Cat.Functor.Adjoint.html#5894" class="Bound">D</a> <a id="5934" href="Cat.Functor.Adjoint.html#5870" class="Bound">C</a><a id="5935" class="Symbol">)</a>
  <a id="5939" class="Symbol">(</a><a id="5940" href="Cat.Functor.Adjoint.html#5940" class="Bound">universal-map-for</a> <a id="5958" class="Symbol">:</a> <a id="5960" class="Symbol">∀</a> <a id="5962" href="Cat.Functor.Adjoint.html#5962" class="Bound">c</a> <a id="5964" class="Symbol">→</a> <a id="5966" href="Cat.Functor.Adjoint.html#5472" data-type="C .Ob → Functor D C → Type (h ⊔ o&#39; ⊔ h&#39;)" class="Function">Universal-morphism</a> <a id="5985" href="Cat.Functor.Adjoint.html#5962" class="Bound">c</a> <a id="5987" href="Cat.Functor.Adjoint.html#5920" class="Bound">R</a><a id="5988" class="Symbol">)</a>
  <a id="5992" class="Keyword">where</a>

  <a id="6001" class="Keyword">open</a> <a id="6006" href="Cat.Diagram.Initial.html#401" data-type="(C : Precategory o h) → Type (o ⊔ h)" class="Module">Initial</a>
  <a id="6016" class="Keyword">open</a> <a id="6021" href="Cat.Instances.Comma.html#2452" data-type="(F : Functor A C) (G : Functor B₁ C) (a b : ↓Obj F G) →
Type (ah ⊔ bh ⊔ h)" class="Module">↓Hom</a> <a id="6026" class="Keyword">using</a> <a id="6032" class="Symbol">(</a><a id="6033" href="Cat.Instances.Comma.html#2621" data-type="↓Hom F G a b → Hom B₁ (a .y) (y b)" class="Field">β</a><a id="6034" class="Symbol">)</a>
  <a id="6038" class="Keyword">open</a> <a id="6043" href="Cat.Instances.Comma.html#1730" data-type="(F : Functor A C) (G : Functor B₁ C) → Type (ao ⊔ bo ⊔ h)" class="Module">↓Obj</a> <a id="6048" class="Keyword">using</a> <a id="6054" class="Symbol">(</a><a id="6055" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">map</a><a id="6058" class="Symbol">)</a>

  <a id="6063" class="Keyword">open</a> <a id="6068" href="Cat.Base.html#704" data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" class="Module">Precategory</a>

  <a id="6083" class="Keyword">private</a>
    <a id="6095" class="Keyword">import</a> <a id="6102" href="Cat.Reasoning.html" class="Module">Cat.Reasoning</a> <a id="6116" href="Cat.Functor.Adjoint.html#5870" class="Bound">C</a> as <a id="6121" href="Cat.Functor.Adjoint.html#6121" class="Module">C</a>
    <a id="6127" class="Keyword">import</a> <a id="6134" href="Cat.Reasoning.html" class="Module">Cat.Reasoning</a> <a id="6148" href="Cat.Functor.Adjoint.html#5894" class="Bound">D</a> as <a id="6153" href="Cat.Functor.Adjoint.html#6153" class="Module">D</a>
    <a id="6159" class="Keyword">module</a> <a id="6166" href="Cat.Functor.Adjoint.html#6166" class="Module">R</a> <a id="6168" class="Symbol">=</a> <a id="6170" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Module">Functor</a> <a id="6178" href="Cat.Functor.Adjoint.html#5920" class="Bound">R</a>
</pre>-->
<h2 id="defining-the-l"><a href="#defining-the-l" class="header-link">Defining the L<span class="header-link-emoji">🔗</span></a></h2>
<p>We first show that the assignment of universal morphisms restricts to a functorial assignment <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>:</mo><mi>C</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">L : C \to D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>.</span> Recall that an object in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>↙</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">X \swarrow R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↙</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> is given by a codomain <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> and a map <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>R</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X \to R(y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>.</span> We define <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>0</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L_0(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span> to be the codomain of the universal morphism:</p>
<pre class="Agda">  <a id="6484" href="Cat.Functor.Adjoint.html#6484" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Ob → D .Ob" class="Function">L₀</a> <a id="6487" class="Symbol">:</a> <a id="6489" href="Cat.Base.html#1419" data-type="Precategory o h → Type o" class="Function">C.Ob</a> <a id="6494" class="Symbol">→</a> <a id="6496" href="Cat.Base.html#1419" data-type="Precategory o h → Type o" class="Function">D.Ob</a>
  <a id="6503" href="Cat.Functor.Adjoint.html#6484" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Ob → D .Ob" class="Function">L₀</a> <a id="6506" href="Cat.Functor.Adjoint.html#6506" class="Bound">x</a> <a id="6508" class="Symbol">=</a> <a id="6510" href="Cat.Functor.Adjoint.html#5940" class="Bound">universal-map-for</a> <a id="6528" href="Cat.Functor.Adjoint.html#6506" class="Bound">x</a> <a id="6530" class="Symbol">.</a><a id="6531" href="Cat.Diagram.Initial.html#442" data-type="Initial C → Ob C" class="Field">bot</a> <a id="6535" class="Symbol">.</a><a id="6536" href="Cat.Instances.Comma.html#1816" data-type="↓Obj F G → Ob B₁" class="Field">↓Obj.y</a>

  <a id="6546" href="Cat.Functor.Adjoint.html#6546" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(c : C .Ob) →
C .Hom c (₀ R₁ (L₀ R₁ universal-map-for c))" class="Function">L₀′</a> <a id="6550" class="Symbol">:</a> <a id="6552" class="Symbol">(</a><a id="6553" href="Cat.Functor.Adjoint.html#6553" class="Bound">c</a> <a id="6555" class="Symbol">:</a> <a id="6557" href="Cat.Base.html#1419" data-type="Precategory o h → Type o" class="Function">C.Ob</a><a id="6561" class="Symbol">)</a> <a id="6563" class="Symbol">→</a> <a id="6565" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">C.Hom</a> <a id="6571" href="Cat.Functor.Adjoint.html#6553" class="Bound">c</a> <a id="6573" class="Symbol">(</a><a id="6574" href="Cat.Base.html#8727" data-type="(r : Functor C D) → C .Ob → D .Ob" class="Function">R.₀</a> <a id="6578" class="Symbol">(</a><a id="6579" href="Cat.Functor.Adjoint.html#6484" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Ob → D .Ob" class="Function">L₀</a> <a id="6582" href="Cat.Functor.Adjoint.html#6553" class="Bound">c</a><a id="6583" class="Symbol">))</a>
  <a id="6588" href="Cat.Functor.Adjoint.html#6546" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(c : C .Ob) →
C .Hom c (₀ R₁ (L₀ R₁ universal-map-for c))" class="Function">L₀′</a> <a id="6592" href="Cat.Functor.Adjoint.html#6592" class="Bound">x</a> <a id="6594" class="Symbol">=</a> <a id="6596" href="Cat.Functor.Adjoint.html#5940" class="Bound">universal-map-for</a> <a id="6614" href="Cat.Functor.Adjoint.html#6592" class="Bound">x</a> <a id="6616" class="Symbol">.</a><a id="6617" href="Cat.Diagram.Initial.html#442" data-type="Initial C → Ob C" class="Field">bot</a> <a id="6621" class="Symbol">.</a><a id="6622" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">map</a>
</pre>
<p>Given an arrow <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>→</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \to b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> in <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">\ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span>,</span> we can send it to a uniquely-determined <em>object</em> in <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>↙</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">a \swarrow R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↙</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>:</span> We take the universal arrow assigned to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> (an object of <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>↙</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">b \swarrow R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↙</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>),</span> and precompose with <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span>.</span> This object will then serve as the domain of the morphism part of <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span>,</span> which is given by the unique assignment arrows out of the initial object in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>↙</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">a \swarrow R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↙</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> (see <span class="Agda"><a href="Cat.Functor.Adjoint.html#7160" class="Function">lift↓</a></span> below).</p>
<pre class="Agda">  <a id="7038" class="Keyword">private</a>
    <a id="7050" href="Cat.Functor.Adjoint.html#7050" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Hom a b → (a ↙ R₁) .Ob" class="Function">to-ob</a> <a id="7056" class="Symbol">:</a> <a id="7058" class="Symbol">∀</a> <a id="7060" class="Symbol">{</a><a id="7061" href="Cat.Functor.Adjoint.html#7061" class="Bound">a</a> <a id="7063" href="Cat.Functor.Adjoint.html#7063" class="Bound">b</a><a id="7064" class="Symbol">}</a> <a id="7066" class="Symbol">→</a> <a id="7068" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">C.Hom</a> <a id="7074" href="Cat.Functor.Adjoint.html#7061" class="Bound">a</a> <a id="7076" href="Cat.Functor.Adjoint.html#7063" class="Bound">b</a> <a id="7078" class="Symbol">→</a> <a id="7080" class="Symbol">(</a><a id="7081" href="Cat.Functor.Adjoint.html#7061" class="Bound">a</a> <a id="7083" href="Cat.Instances.Comma.html#5800" data-type="A .Ob →
Functor B₁ A → Precategory (ah ⊔ bo ⊔ lzero) (ah ⊔ bh ⊔ lzero)" class="Function Operator">↙</a> <a id="7085" href="Cat.Functor.Adjoint.html#5920" class="Bound">R</a><a id="7086" class="Symbol">)</a> <a id="7088" class="Symbol">.</a><a id="7089" href="Cat.Base.html#1419" data-type="Precategory o h → Type o" class="Field">Precategory.Ob</a>
    <a id="7108" href="Cat.Functor.Adjoint.html#7050" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Hom a b → (a ↙ R₁) .Ob" class="Function">to-ob</a> <a id="7114" class="Symbol">{</a><a id="7115" href="Cat.Functor.Adjoint.html#7115" class="Bound">a</a><a id="7116" class="Symbol">}</a> <a id="7118" class="Symbol">{</a><a id="7119" href="Cat.Functor.Adjoint.html#7119" class="Bound">b</a><a id="7120" class="Symbol">}</a> <a id="7122" href="Cat.Functor.Adjoint.html#7122" class="Bound">h</a> <a id="7124" class="Symbol">=</a> <a id="7126" class="Keyword">record</a> <a id="7133" class="Symbol">{</a> <a id="7135" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">map</a> <a id="7139" class="Symbol">=</a> <a id="7141" href="Cat.Functor.Adjoint.html#6546" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(c : C .Ob) →
C .Hom c (₀ R₁ (L₀ R₁ universal-map-for c))" class="Function">L₀′</a> <a id="7145" href="Cat.Functor.Adjoint.html#7119" class="Bound">b</a> <a id="7147" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="7151" href="Cat.Functor.Adjoint.html#7122" class="Bound">h</a> <a id="7153" class="Symbol">}</a>

    <a id="7160" href="Cat.Functor.Adjoint.html#7160" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(g : C .Hom x y) →
Hom (x ↙ R₁) (universal-map-for x .bot)
(to-ob R₁ universal-map-for g)" class="Function">lift↓</a> <a id="7166" class="Symbol">:</a> <a id="7168" class="Symbol">∀</a> <a id="7170" class="Symbol">{</a><a id="7171" href="Cat.Functor.Adjoint.html#7171" class="Bound">x</a> <a id="7173" href="Cat.Functor.Adjoint.html#7173" class="Bound">y</a><a id="7174" class="Symbol">}</a> <a id="7176" class="Symbol">(</a><a id="7177" href="Cat.Functor.Adjoint.html#7177" class="Bound">g</a> <a id="7179" class="Symbol">:</a> <a id="7181" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">C.Hom</a> <a id="7187" href="Cat.Functor.Adjoint.html#7171" class="Bound">x</a> <a id="7189" href="Cat.Functor.Adjoint.html#7173" class="Bound">y</a><a id="7190" class="Symbol">)</a>
          <a id="7202" class="Symbol">→</a> <a id="7204" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Field">Precategory.Hom</a> <a id="7220" class="Symbol">(</a><a id="7221" href="Cat.Functor.Adjoint.html#7171" class="Bound">x</a> <a id="7223" href="Cat.Instances.Comma.html#5800" data-type="A .Ob →
Functor B₁ A → Precategory (ah ⊔ bo ⊔ lzero) (ah ⊔ bh ⊔ lzero)" class="Function Operator">↙</a> <a id="7225" href="Cat.Functor.Adjoint.html#5920" class="Bound">R</a><a id="7226" class="Symbol">)</a> <a id="7228" class="Symbol">(</a><a id="7229" href="Cat.Functor.Adjoint.html#5940" class="Bound">universal-map-for</a> <a id="7247" href="Cat.Functor.Adjoint.html#7171" class="Bound">x</a> <a id="7249" class="Symbol">.</a><a id="7250" href="Cat.Diagram.Initial.html#442" data-type="Initial C → Ob C" class="Field">bot</a><a id="7253" class="Symbol">)</a> <a id="7255" class="Symbol">(</a><a id="7256" href="Cat.Functor.Adjoint.html#7050" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Hom a b → (a ↙ R₁) .Ob" class="Function">to-ob</a> <a id="7262" href="Cat.Functor.Adjoint.html#7177" class="Bound">g</a><a id="7263" class="Symbol">)</a>
    <a id="7269" href="Cat.Functor.Adjoint.html#7160" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(g : C .Hom x y) →
Hom (x ↙ R₁) (universal-map-for x .bot)
(to-ob R₁ universal-map-for g)" class="Function">lift↓</a> <a id="7275" class="Symbol">{</a><a id="7276" href="Cat.Functor.Adjoint.html#7276" class="Bound">x</a><a id="7277" class="Symbol">}</a> <a id="7279" class="Symbol">{</a><a id="7280" href="Cat.Functor.Adjoint.html#7280" class="Bound">y</a><a id="7281" class="Symbol">}</a> <a id="7283" href="Cat.Functor.Adjoint.html#7283" class="Bound">g</a> <a id="7285" class="Symbol">=</a> <a id="7287" href="Cat.Diagram.Initial.html#600" data-type="(r : Initial C) → Hom C (bot r) x" class="Function">¡</a> <a id="7289" class="Symbol">(</a><a id="7290" href="Cat.Functor.Adjoint.html#5940" class="Bound">universal-map-for</a> <a id="7308" href="Cat.Functor.Adjoint.html#7276" class="Bound">x</a><a id="7309" class="Symbol">)</a> <a id="7311" class="Symbol">{</a><a id="7312" href="Cat.Functor.Adjoint.html#7050" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Hom a b → (a ↙ R₁) .Ob" class="Function">to-ob</a> <a id="7318" href="Cat.Functor.Adjoint.html#7283" class="Bound">g</a><a id="7319" class="Symbol">}</a>

  <a id="7324" href="Cat.Functor.Adjoint.html#7324" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Hom a b →
D .Hom (L₀ R₁ universal-map-for a) (L₀ R₁ universal-map-for b)" class="Function">L₁</a> <a id="7327" class="Symbol">:</a> <a id="7329" class="Symbol">∀</a> <a id="7331" class="Symbol">{</a><a id="7332" href="Cat.Functor.Adjoint.html#7332" class="Bound">a</a> <a id="7334" href="Cat.Functor.Adjoint.html#7334" class="Bound">b</a><a id="7335" class="Symbol">}</a> <a id="7337" class="Symbol">→</a> <a id="7339" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">C.Hom</a> <a id="7345" href="Cat.Functor.Adjoint.html#7332" class="Bound">a</a> <a id="7347" href="Cat.Functor.Adjoint.html#7334" class="Bound">b</a> <a id="7349" class="Symbol">→</a> <a id="7351" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">D.Hom</a> <a id="7357" class="Symbol">(</a><a id="7358" href="Cat.Functor.Adjoint.html#6484" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Ob → D .Ob" class="Function">L₀</a> <a id="7361" href="Cat.Functor.Adjoint.html#7332" class="Bound">a</a><a id="7362" class="Symbol">)</a> <a id="7364" class="Symbol">(</a><a id="7365" href="Cat.Functor.Adjoint.html#6484" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Ob → D .Ob" class="Function">L₀</a> <a id="7368" href="Cat.Functor.Adjoint.html#7334" class="Bound">b</a><a id="7369" class="Symbol">)</a>
  <a id="7373" href="Cat.Functor.Adjoint.html#7324" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Hom a b →
D .Hom (L₀ R₁ universal-map-for a) (L₀ R₁ universal-map-for b)" class="Function">L₁</a> <a id="7376" class="Symbol">{</a><a id="7377" href="Cat.Functor.Adjoint.html#7377" class="Bound">a</a><a id="7378" class="Symbol">}</a> <a id="7380" class="Symbol">{</a><a id="7381" href="Cat.Functor.Adjoint.html#7381" class="Bound">b</a><a id="7382" class="Symbol">}</a> <a id="7384" href="Cat.Functor.Adjoint.html#7384" class="Bound">x</a> <a id="7386" class="Symbol">=</a> <a id="7388" href="Cat.Functor.Adjoint.html#7160" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(g : C .Hom x y) →
Hom (x ↙ R₁) (universal-map-for x .bot)
(to-ob R₁ universal-map-for g)" class="Function">lift↓</a> <a id="7394" href="Cat.Functor.Adjoint.html#7384" class="Bound">x</a> <a id="7396" class="Symbol">.</a><a id="7397" href="Cat.Instances.Comma.html#2621" data-type="↓Hom F G a b → Hom B₁ (a .y) (y b)" class="Field">β</a>
</pre>
<details>
<summary>
It now suffices to show the functor identities hold for <span class="Agda"><a href="Cat.Functor.Adjoint.html#7324" class="Function">L₁</a></span>. They follow essentially from the uniqueness of maps out of an initial object.
</summary>
<pre class="Agda">  <a id="7593" class="Keyword">private</a> <a id="7601" class="Keyword">abstract</a>
    <a id="7614" href="Cat.Functor.Adjoint.html#7614" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
L₁ R₁ universal-map-for (C .id) ≡ D .id" class="Function">L-id</a> <a id="7619" class="Symbol">:</a> <a id="7621" class="Symbol">∀</a> <a id="7623" class="Symbol">{</a><a id="7624" href="Cat.Functor.Adjoint.html#7624" class="Bound">a</a><a id="7625" class="Symbol">}</a> <a id="7627" class="Symbol">→</a> <a id="7629" href="Cat.Functor.Adjoint.html#7324" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Hom a b →
D .Hom (L₀ R₁ universal-map-for a) (L₀ R₁ universal-map-for b)" class="Function">L₁</a> <a id="7632" class="Symbol">(</a><a id="7633" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">C.id</a> <a id="7638" class="Symbol">{</a><a id="7639" href="Cat.Functor.Adjoint.html#7624" class="Bound">a</a><a id="7640" class="Symbol">})</a> <a id="7643" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="7645" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">D.id</a> <a id="7650" class="Symbol">{</a><a id="7651" href="Cat.Functor.Adjoint.html#6484" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Ob → D .Ob" class="Function">L₀</a> <a id="7654" href="Cat.Functor.Adjoint.html#7624" class="Bound">a</a><a id="7655" class="Symbol">}</a>
    <a id="7661" href="Cat.Functor.Adjoint.html#7614" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
L₁ R₁ universal-map-for (C .id) ≡ D .id" class="Function">L-id</a> <a id="7666" class="Symbol">{</a><a id="7667" href="Cat.Functor.Adjoint.html#7667" class="Bound">a</a><a id="7668" class="Symbol">}</a> <a id="7670" class="Symbol">=</a> <a id="7672" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="7675" href="Cat.Instances.Comma.html#2621" data-type="↓Hom F G a b → Hom B₁ (a .y) (y b)" class="Field">β</a> <a id="7677" class="Symbol">(</a><a id="7678" href="Cat.Diagram.Initial.html#646" data-type="(r : Initial C) (h : Hom C (bot r) x) → ¡ r ≡ h" class="Function">¡-unique</a> <a id="7687" class="Symbol">(</a><a id="7688" href="Cat.Functor.Adjoint.html#5940" class="Bound">universal-map-for</a> <a id="7706" href="Cat.Functor.Adjoint.html#7667" class="Bound">a</a><a id="7707" class="Symbol">)</a>
                      <a id="7731" class="Symbol">(</a><a id="7732" class="Keyword">record</a> <a id="7739" class="Symbol">{</a> <a id="7741" href="Cat.Instances.Comma.html#2646" data-type="(r : ↓Hom F G a b) →
C ._∘_ (map b) (F₁ F (r .α)) ≡ C ._∘_ (F₁ G (r .β)) (a .map)" class="Field">sq</a> <a id="7744" class="Symbol">=</a> <a id="7746" href="Cat.Reasoning.html#1108" data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → (C ∘ f) a ≡ f" class="Function">C.elimr</a> <a id="7754" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
                                  <a id="7793" href="1Lab.Path.html#38305" data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" class="Function Operator">··</a> <a id="7796" href="Cat.Reasoning.html#1108" data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → (C ∘ f) a ≡ f" class="Function">C.elimr</a> <a id="7804" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
                                  <a id="7843" href="1Lab.Path.html#38305" data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" class="Function Operator">··</a> <a id="7846" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="7850" class="Symbol">(</a><a id="7851" href="Cat.Reasoning.html#1009" data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → (C ∘ a) f ≡ f" class="Function">C.eliml</a> <a id="7859" href="Cat.Base.html#8343" data-type="(r : Functor C D) → r .F₁ (C .id) ≡ id D" class="Function">R.F-id</a><a id="7865" class="Symbol">)</a> <a id="7867" class="Symbol">}))</a>

    <a id="7876" href="Cat.Functor.Adjoint.html#7876" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(f : C .Hom y z) (g : C .Hom x y) →
C ._∘_
(₁ R₁
 (D ._∘_ (L₁ R₁ universal-map-for f) (L₁ R₁ universal-map-for g)))
(L₀′ R₁ universal-map-for x)
≡ C ._∘_ (to-ob R₁ universal-map-for (C ._∘_ f g) .map) (C .id)" class="Function">lemma</a> <a id="7882" class="Symbol">:</a> <a id="7884" class="Symbol">∀</a> <a id="7886" class="Symbol">{</a><a id="7887" href="Cat.Functor.Adjoint.html#7887" class="Bound">x</a> <a id="7889" href="Cat.Functor.Adjoint.html#7889" class="Bound">y</a> <a id="7891" href="Cat.Functor.Adjoint.html#7891" class="Bound">z</a><a id="7892" class="Symbol">}</a> <a id="7894" class="Symbol">(</a><a id="7895" href="Cat.Functor.Adjoint.html#7895" class="Bound">f</a> <a id="7897" class="Symbol">:</a> <a id="7899" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">C.Hom</a> <a id="7905" href="Cat.Functor.Adjoint.html#7889" class="Bound">y</a> <a id="7907" href="Cat.Functor.Adjoint.html#7891" class="Bound">z</a><a id="7908" class="Symbol">)</a> <a id="7910" class="Symbol">(</a><a id="7911" href="Cat.Functor.Adjoint.html#7911" class="Bound">g</a> <a id="7913" class="Symbol">:</a> <a id="7915" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">C.Hom</a> <a id="7921" href="Cat.Functor.Adjoint.html#7887" class="Bound">x</a> <a id="7923" href="Cat.Functor.Adjoint.html#7889" class="Bound">y</a><a id="7924" class="Symbol">)</a>
          <a id="7936" class="Symbol">→</a> <a id="7938" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">R.₁</a> <a id="7942" class="Symbol">(</a><a id="7943" href="Cat.Functor.Adjoint.html#7324" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Hom a b →
D .Hom (L₀ R₁ universal-map-for a) (L₀ R₁ universal-map-for b)" class="Function">L₁</a> <a id="7946" href="Cat.Functor.Adjoint.html#7895" class="Bound">f</a> <a id="7948" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="7952" href="Cat.Functor.Adjoint.html#7324" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Hom a b →
D .Hom (L₀ R₁ universal-map-for a) (L₀ R₁ universal-map-for b)" class="Function">L₁</a> <a id="7955" href="Cat.Functor.Adjoint.html#7911" class="Bound">g</a><a id="7956" class="Symbol">)</a> <a id="7958" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="7962" class="Symbol">(</a><a id="7963" href="Cat.Functor.Adjoint.html#6546" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(c : C .Ob) →
C .Hom c (₀ R₁ (L₀ R₁ universal-map-for c))" class="Function">L₀′</a> <a id="7967" href="Cat.Functor.Adjoint.html#7887" class="Bound">x</a><a id="7968" class="Symbol">)</a>
          <a id="7980" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="7982" href="Cat.Functor.Adjoint.html#7050" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Hom a b → (a ↙ R₁) .Ob" class="Function">to-ob</a> <a id="7988" class="Symbol">(</a><a id="7989" href="Cat.Functor.Adjoint.html#7895" class="Bound">f</a> <a id="7991" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="7995" href="Cat.Functor.Adjoint.html#7911" class="Bound">g</a><a id="7996" class="Symbol">)</a> <a id="7998" class="Symbol">.</a><a id="7999" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">map</a> <a id="8003" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="8007" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">C.id</a>
    <a id="8016" href="Cat.Functor.Adjoint.html#7876" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(f : C .Hom y z) (g : C .Hom x y) →
C ._∘_
(₁ R₁
 (D ._∘_ (L₁ R₁ universal-map-for f) (L₁ R₁ universal-map-for g)))
(L₀′ R₁ universal-map-for x)
≡ C ._∘_ (to-ob R₁ universal-map-for (C ._∘_ f g) .map) (C .id)" class="Function">lemma</a> <a id="8022" class="Symbol">{</a><a id="8023" href="Cat.Functor.Adjoint.html#8023" class="Bound">x</a><a id="8024" class="Symbol">}</a> <a id="8026" class="Symbol">{</a><a id="8027" href="Cat.Functor.Adjoint.html#8027" class="Bound">y</a><a id="8028" class="Symbol">}</a> <a id="8030" class="Symbol">{</a><a id="8031" href="Cat.Functor.Adjoint.html#8031" class="Bound">z</a><a id="8032" class="Symbol">}</a> <a id="8034" href="Cat.Functor.Adjoint.html#8034" class="Bound">f</a> <a id="8036" href="Cat.Functor.Adjoint.html#8036" class="Bound">g</a> <a id="8038" class="Symbol">=</a>
      <a id="8046" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">R.₁</a> <a id="8050" class="Symbol">(</a><a id="8051" href="Cat.Functor.Adjoint.html#7160" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(g : C .Hom x y) →
Hom (x ↙ R₁) (universal-map-for x .bot)
(to-ob R₁ universal-map-for g)" class="Function">lift↓</a> <a id="8057" href="Cat.Functor.Adjoint.html#8034" class="Bound">f</a> <a id="8059" class="Symbol">.</a><a id="8060" href="Cat.Instances.Comma.html#2621" data-type="↓Hom F G a b → Hom B₁ (a .y) (y b)" class="Field">β</a> <a id="8062" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8066" href="Cat.Functor.Adjoint.html#7160" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(g : C .Hom x y) →
Hom (x ↙ R₁) (universal-map-for x .bot)
(to-ob R₁ universal-map-for g)" class="Function">lift↓</a> <a id="8072" href="Cat.Functor.Adjoint.html#8036" class="Bound">g</a> <a id="8074" class="Symbol">.</a><a id="8075" href="Cat.Instances.Comma.html#2621" data-type="↓Hom F G a b → Hom B₁ (a .y) (y b)" class="Field">β</a><a id="8076" class="Symbol">)</a> <a id="8078" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="8082" class="Symbol">(</a><a id="8083" href="Cat.Functor.Adjoint.html#6546" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(c : C .Ob) →
C .Hom c (₀ R₁ (L₀ R₁ universal-map-for c))" class="Function">L₀′</a> <a id="8087" href="Cat.Functor.Adjoint.html#8023" class="Bound">x</a><a id="8088" class="Symbol">)</a>       <span class="reasoning-step"><span class="as-written Function"><a id="8096" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="8099" href="Cat.Reasoning.html#1844" data-type="(C : Precategory o ℓ) (c≡ab : c ≡ (C ∘ a) b) →
(C ∘ c) f ≡ (C ∘ a) ((C ∘ b) f)" class="Function">C.pushl</a> <a id="8107" class="Symbol">(</a><a id="8108" href="Cat.Base.html#8383" data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" class="Function">R.F-∘</a> <a id="8114" class="Symbol">_</a> <a id="8116" class="Symbol">_)</a> <a id="8119" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="8127" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">R.₁</a> <a id="8131" class="Symbol">(</a><a id="8132" href="Cat.Functor.Adjoint.html#7160" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(g : C .Hom x y) →
Hom (x ↙ R₁) (universal-map-for x .bot)
(to-ob R₁ universal-map-for g)" class="Function">lift↓</a> <a id="8138" href="Cat.Functor.Adjoint.html#8034" class="Bound">f</a> <a id="8140" class="Symbol">.</a><a id="8141" href="Cat.Instances.Comma.html#2621" data-type="↓Hom F G a b → Hom B₁ (a .y) (y b)" class="Field">β</a><a id="8142" class="Symbol">)</a> <a id="8144" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="8148" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">R.₁</a> <a id="8152" class="Symbol">(</a><a id="8153" href="Cat.Functor.Adjoint.html#7160" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(g : C .Hom x y) →
Hom (x ↙ R₁) (universal-map-for x .bot)
(to-ob R₁ universal-map-for g)" class="Function">lift↓</a> <a id="8159" href="Cat.Functor.Adjoint.html#8036" class="Bound">g</a> <a id="8161" class="Symbol">.</a><a id="8162" href="Cat.Instances.Comma.html#2621" data-type="↓Hom F G a b → Hom B₁ (a .y) (y b)" class="Field">β</a><a id="8163" class="Symbol">)</a> <a id="8165" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="8169" class="Symbol">(</a><a id="8170" href="Cat.Functor.Adjoint.html#6546" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(c : C .Ob) →
C .Hom c (₀ R₁ (L₀ R₁ universal-map-for c))" class="Function">L₀′</a> <a id="8174" href="Cat.Functor.Adjoint.html#8023" class="Bound">x</a><a id="8175" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function"><a id="8177" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="8180" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="8183" class="Symbol">(</a><a id="8184" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">R.₁</a> <a id="8188" class="Symbol">(</a><a id="8189" href="Cat.Functor.Adjoint.html#7160" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(g : C .Hom x y) →
Hom (x ↙ R₁) (universal-map-for x .bot)
(to-ob R₁ universal-map-for g)" class="Function">lift↓</a> <a id="8195" href="Cat.Functor.Adjoint.html#8034" class="Bound">f</a> <a id="8197" class="Symbol">.</a><a id="8198" href="Cat.Instances.Comma.html#2621" data-type="↓Hom F G a b → Hom B₁ (a .y) (y b)" class="Field">β</a><a id="8199" class="Symbol">)</a> <a id="8201" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘_</a><a id="8205" class="Symbol">)</a> <a id="8207" class="Symbol">(</a><a id="8208" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="8212" class="Symbol">(</a><a id="8213" href="Cat.Functor.Adjoint.html#7160" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(g : C .Hom x y) →
Hom (x ↙ R₁) (universal-map-for x .bot)
(to-ob R₁ universal-map-for g)" class="Function">lift↓</a> <a id="8219" href="Cat.Functor.Adjoint.html#8036" class="Bound">g</a> <a id="8221" class="Symbol">.</a><a id="8222" href="Cat.Instances.Comma.html#2646" data-type="(r : ↓Hom F G a b) →
C ._∘_ (map b) (F₁ F (r .α)) ≡ C ._∘_ (F₁ G (r .β)) (a .map)" class="Field">↓Hom.sq</a><a id="8229" class="Symbol">)</a> <a id="8231" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="8233" href="Cat.Base.html#3437" data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ f (r .id) ≡ f" class="Function">C.idr</a> <a id="8239" class="Symbol">_)</a> <a id="8242" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="8250" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">R.₁</a> <a id="8254" class="Symbol">(</a><a id="8255" href="Cat.Functor.Adjoint.html#7160" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(g : C .Hom x y) →
Hom (x ↙ R₁) (universal-map-for x .bot)
(to-ob R₁ universal-map-for g)" class="Function">lift↓</a> <a id="8261" href="Cat.Functor.Adjoint.html#8034" class="Bound">f</a> <a id="8263" class="Symbol">.</a><a id="8264" href="Cat.Instances.Comma.html#2621" data-type="↓Hom F G a b → Hom B₁ (a .y) (y b)" class="Field">β</a><a id="8265" class="Symbol">)</a> <a id="8267" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="8271" href="Cat.Functor.Adjoint.html#6546" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(c : C .Ob) →
C .Hom c (₀ R₁ (L₀ R₁ universal-map-for c))" class="Function">L₀′</a> <a id="8275" href="Cat.Functor.Adjoint.html#8027" class="Bound">y</a> <a id="8277" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="8281" href="Cat.Functor.Adjoint.html#8036" class="Bound">g</a>                  <span class="reasoning-step"><span class="as-written Function"><a id="8300" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="8303" href="Cat.Reasoning.html#2007" data-type="(C : Precategory o ℓ) (p : (C ∘ f) h ≡ (C ∘ g) i) →
(C ∘ f) ((C ∘ h) b) ≡ (C ∘ g) ((C ∘ i) b)" class="Function">C.extendl</a> <a id="8313" class="Symbol">(</a><a id="8314" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="8318" class="Symbol">(</a><a id="8319" href="Cat.Functor.Adjoint.html#7160" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(g : C .Hom x y) →
Hom (x ↙ R₁) (universal-map-for x .bot)
(to-ob R₁ universal-map-for g)" class="Function">lift↓</a> <a id="8325" href="Cat.Functor.Adjoint.html#8034" class="Bound">f</a> <a id="8327" class="Symbol">.</a><a id="8328" href="Cat.Instances.Comma.html#2646" data-type="(r : ↓Hom F G a b) →
C ._∘_ (map b) (F₁ F (r .α)) ≡ C ._∘_ (F₁ G (r .β)) (a .map)" class="Field">↓Hom.sq</a><a id="8335" class="Symbol">)</a> <a id="8337" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="8339" href="Cat.Base.html#3437" data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ f (r .id) ≡ f" class="Function">C.idr</a> <a id="8345" class="Symbol">_)</a> <a id="8348" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="8356" href="Cat.Functor.Adjoint.html#6546" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(c : C .Ob) →
C .Hom c (₀ R₁ (L₀ R₁ universal-map-for c))" class="Function">L₀′</a> <a id="8360" href="Cat.Functor.Adjoint.html#8031" class="Bound">z</a> <a id="8362" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="8366" href="Cat.Functor.Adjoint.html#8034" class="Bound">f</a> <a id="8368" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="8372" href="Cat.Functor.Adjoint.html#8036" class="Bound">g</a>                                 <span class="reasoning-step"><span class="as-written Function Operator"><a id="8406" href="1Lab.Path.html#46783" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">≡˘⟨</a> <a id="8410" href="Cat.Base.html#3437" data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ f (r .id) ≡ f" class="Function">C.idr</a> <a id="8416" class="Symbol">_</a> <a id="8418" href="1Lab.Path.html#46783" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡˘</span></span>
      <a id="8426" href="Cat.Functor.Adjoint.html#7050" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Hom a b → (a ↙ R₁) .Ob" class="Function">to-ob</a> <a id="8432" class="Symbol">(</a><a id="8433" href="Cat.Functor.Adjoint.html#8034" class="Bound">f</a> <a id="8435" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="8439" href="Cat.Functor.Adjoint.html#8036" class="Bound">g</a><a id="8440" class="Symbol">)</a> <a id="8442" class="Symbol">.</a><a id="8443" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">map</a> <a id="8447" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="8451" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">C.id</a>                     <a id="8476" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>

    <a id="8483" href="Cat.Functor.Adjoint.html#8483" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(f : C .Hom y z) (g : C .Hom x y) →
L₁ R₁ universal-map-for (C ._∘_ f g) ≡
D ._∘_ (L₁ R₁ universal-map-for f) (L₁ R₁ universal-map-for g)" class="Function">L-∘</a> <a id="8487" class="Symbol">:</a> <a id="8489" class="Symbol">∀</a> <a id="8491" class="Symbol">{</a><a id="8492" href="Cat.Functor.Adjoint.html#8492" class="Bound">x</a> <a id="8494" href="Cat.Functor.Adjoint.html#8494" class="Bound">y</a> <a id="8496" href="Cat.Functor.Adjoint.html#8496" class="Bound">z</a><a id="8497" class="Symbol">}</a> <a id="8499" class="Symbol">(</a><a id="8500" href="Cat.Functor.Adjoint.html#8500" class="Bound">f</a> <a id="8502" class="Symbol">:</a> <a id="8504" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">C.Hom</a> <a id="8510" href="Cat.Functor.Adjoint.html#8494" class="Bound">y</a> <a id="8512" href="Cat.Functor.Adjoint.html#8496" class="Bound">z</a><a id="8513" class="Symbol">)</a> <a id="8515" class="Symbol">(</a><a id="8516" href="Cat.Functor.Adjoint.html#8516" class="Bound">g</a> <a id="8518" class="Symbol">:</a> <a id="8520" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">C.Hom</a> <a id="8526" href="Cat.Functor.Adjoint.html#8492" class="Bound">x</a> <a id="8528" href="Cat.Functor.Adjoint.html#8494" class="Bound">y</a><a id="8529" class="Symbol">)</a>
        <a id="8539" class="Symbol">→</a> <a id="8541" href="Cat.Functor.Adjoint.html#7324" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Hom a b →
D .Hom (L₀ R₁ universal-map-for a) (L₀ R₁ universal-map-for b)" class="Function">L₁</a> <a id="8544" class="Symbol">(</a><a id="8545" href="Cat.Functor.Adjoint.html#8500" class="Bound">f</a> <a id="8547" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="8551" href="Cat.Functor.Adjoint.html#8516" class="Bound">g</a><a id="8552" class="Symbol">)</a> <a id="8554" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="8556" href="Cat.Functor.Adjoint.html#7324" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Hom a b →
D .Hom (L₀ R₁ universal-map-for a) (L₀ R₁ universal-map-for b)" class="Function">L₁</a> <a id="8559" href="Cat.Functor.Adjoint.html#8500" class="Bound">f</a> <a id="8561" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8565" href="Cat.Functor.Adjoint.html#7324" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Hom a b →
D .Hom (L₀ R₁ universal-map-for a) (L₀ R₁ universal-map-for b)" class="Function">L₁</a> <a id="8568" href="Cat.Functor.Adjoint.html#8516" class="Bound">g</a>
    <a id="8574" href="Cat.Functor.Adjoint.html#8483" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(f : C .Hom y z) (g : C .Hom x y) →
L₁ R₁ universal-map-for (C ._∘_ f g) ≡
D ._∘_ (L₁ R₁ universal-map-for f) (L₁ R₁ universal-map-for g)" class="Function">L-∘</a> <a id="8578" href="Cat.Functor.Adjoint.html#8578" class="Bound">f</a> <a id="8580" href="Cat.Functor.Adjoint.html#8580" class="Bound">g</a> <a id="8582" class="Symbol">=</a> <a id="8584" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="8587" href="Cat.Instances.Comma.html#2621" data-type="↓Hom F G a b → Hom B₁ (a .y) (y b)" class="Field">β</a> <a id="8589" class="Symbol">(</a><a id="8590" href="Cat.Diagram.Initial.html#646" data-type="(r : Initial C) (h : Hom C (bot r) x) → ¡ r ≡ h" class="Function">¡-unique</a> <a id="8599" class="Symbol">(</a><a id="8600" href="Cat.Functor.Adjoint.html#5940" class="Bound">universal-map-for</a> <a id="8618" class="Symbol">_)</a> <a id="8621" class="Symbol">(</a><a id="8622" class="Keyword">record</a> <a id="8629" class="Symbol">{</a> <a id="8631" href="Cat.Instances.Comma.html#2646" data-type="(r : ↓Hom F G a b) →
C ._∘_ (map b) (F₁ F (r .α)) ≡ C ._∘_ (F₁ G (r .β)) (a .map)" class="Field">sq</a> <a id="8634" class="Symbol">=</a> <a id="8636" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="8640" class="Symbol">(</a><a id="8641" href="Cat.Functor.Adjoint.html#7876" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(f : C .Hom y z) (g : C .Hom x y) →
C ._∘_
(₁ R₁
 (D ._∘_ (L₁ R₁ universal-map-for f) (L₁ R₁ universal-map-for g)))
(L₀′ R₁ universal-map-for x)
≡ C ._∘_ (to-ob R₁ universal-map-for (C ._∘_ f g) .map) (C .id)" class="Function">lemma</a> <a id="8647" href="Cat.Functor.Adjoint.html#8578" class="Bound">f</a> <a id="8649" href="Cat.Functor.Adjoint.html#8580" class="Bound">g</a><a id="8650" class="Symbol">)</a> <a id="8652" class="Symbol">}))</a>
</pre>
</details>
<p>That out of the way, we have our <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span> functor. We now have to show that it defines a left adjoint to the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> we started with.</p>
<pre class="Agda">  <a id="8808" href="Cat.Functor.Adjoint.html#8808" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
Functor C D" class="Function">universal-maps→L</a> <a id="8825" class="Symbol">:</a> <a id="8827" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="8835" href="Cat.Functor.Adjoint.html#5870" class="Bound">C</a> <a id="8837" href="Cat.Functor.Adjoint.html#5894" class="Bound">D</a>
  <a id="8841" href="Cat.Functor.Adjoint.html#8808" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
Functor C D" class="Function">universal-maps→L</a> <a id="8858" class="Symbol">.</a><a id="8859" href="Cat.Base.html#7996" data-type="Functor C D → C .Ob → Ob D" class="Field">F₀</a> <a id="8862" class="Symbol">=</a> <a id="8864" href="Cat.Functor.Adjoint.html#6484" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Ob → D .Ob" class="Function">L₀</a>
  <a id="8869" href="Cat.Functor.Adjoint.html#8808" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
Functor C D" class="Function">universal-maps→L</a> <a id="8886" class="Symbol">.</a><a id="8887" href="Cat.Base.html#8017" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="8890" class="Symbol">=</a> <a id="8892" href="Cat.Functor.Adjoint.html#7324" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Hom a b →
D .Hom (L₀ R₁ universal-map-for a) (L₀ R₁ universal-map-for b)" class="Function">L₁</a>
  <a id="8897" href="Cat.Functor.Adjoint.html#8808" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
Functor C D" class="Function">universal-maps→L</a> <a id="8914" class="Symbol">.</a><a id="8915" href="Cat.Base.html#8343" data-type="(r : Functor C D) → r .F₁ (C .id) ≡ id D" class="Field">F-id</a> <a id="8920" class="Symbol">=</a> <a id="8922" href="Cat.Functor.Adjoint.html#7614" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
L₁ R₁ universal-map-for (C .id) ≡ D .id" class="Function">L-id</a>
  <a id="8929" href="Cat.Functor.Adjoint.html#8808" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
Functor C D" class="Function">universal-maps→L</a> <a id="8946" class="Symbol">.</a><a id="8947" href="Cat.Base.html#8383" data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" class="Field">F-∘</a> <a id="8951" class="Symbol">=</a> <a id="8953" href="Cat.Functor.Adjoint.html#8483" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(f : C .Hom y z) (g : C .Hom x y) →
L₁ R₁ universal-map-for (C ._∘_ f g) ≡
D ._∘_ (L₁ R₁ universal-map-for f) (L₁ R₁ universal-map-for g)" class="Function">L-∘</a>
</pre>
<!--
<pre class="Agda">  <a id="8977" class="Keyword">open</a> <a id="8982" href="Cat.Functor.Adjoint.html#2192" data-type="(L : Functor C D) (R₁ : Functor D C) → Type (C.o ⊔ C.h ⊔ D.o ⊔ D.h)" class="Module Operator">_⊣_</a>
  <a id="8988" class="Keyword">open</a> <a id="8993" href="Cat.Base.html#12241" data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" class="Module Operator">_=&gt;_</a>
</pre>-->
<h2 id="building-the-adjunction"><a href="#building-the-adjunction" class="header-link">Building the adjunction<span class="header-link-emoji">🔗</span></a></h2>
<p>We now prove that <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>⊣</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">L \dashv R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊣</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>,</span> which, recall, means giving natural transformations <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>η</mi><mo>:</mo><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">d</mi></mrow><mo>⇒</mo><mo stretchy="false">(</mo><mi>R</mi><mi>F</mi><mo>∘</mo><mi>L</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\eta : \id{Id} \To (R F\circ L)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">η</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">Id</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">RF</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mclose">)</span></span></span></span> (the <em>adjunction unit</em>) and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ε</mi><mo>:</mo><mo stretchy="false">(</mo><mi>L</mi><mo>∘</mo><mi>R</mi><mo stretchy="false">)</mo><mo>⇒</mo><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">d</mi></mrow></mrow><annotation encoding="application/x-tex">\eps : (L \circ R) \To \id{Id}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ε</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">Id</span></span></span></span></span> (the <em>adjunction counit</em>). We begin with the counit, since that’s more involved.</p>
<p>The construction begins by defining a function <span class="Agda"><a href="Cat.Functor.Adjoint.html#9558" class="Function">mapd</a></span> which sends each object of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">\ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span> to the initial object in <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>↙</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">x \swarrow R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↙</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>.</span> Note that this is the same as <span class="Agda"><a href="Cat.Functor.Adjoint.html#6484" class="Function">L₀</a></span>, but returning the entire object rather than a part of it.</p>
<pre class="Agda">  <a id="9546" class="Keyword">private</a>
    <a id="9558" href="Cat.Functor.Adjoint.html#9558" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(x : C .Ob) →
Ob (x ↙ R₁)" class="Function">mapd</a> <a id="9563" class="Symbol">:</a> <a id="9565" class="Symbol">∀</a> <a id="9567" class="Symbol">(</a><a id="9568" href="Cat.Functor.Adjoint.html#9568" class="Bound">x</a> <a id="9570" class="Symbol">:</a> <a id="9572" href="Cat.Base.html#1419" data-type="Precategory o h → Type o" class="Function">C.Ob</a><a id="9576" class="Symbol">)</a> <a id="9578" class="Symbol">→</a> <a id="9580" href="Cat.Base.html#1419" data-type="Precategory o h → Type o" class="Field">Ob</a> <a id="9583" class="Symbol">(</a><a id="9584" href="Cat.Functor.Adjoint.html#9568" class="Bound">x</a> <a id="9586" href="Cat.Instances.Comma.html#5800" data-type="A .Ob →
Functor B₁ A → Precategory (ah ⊔ bo ⊔ lzero) (ah ⊔ bh ⊔ lzero)" class="Function Operator">↙</a> <a id="9588" href="Cat.Functor.Adjoint.html#5920" class="Bound">R</a><a id="9589" class="Symbol">)</a>
    <a id="9595" href="Cat.Functor.Adjoint.html#9558" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(x : C .Ob) →
Ob (x ↙ R₁)" class="Function">mapd</a> <a id="9600" href="Cat.Functor.Adjoint.html#9600" class="Bound">x</a> <a id="9602" class="Symbol">=</a> <a id="9604" href="Cat.Functor.Adjoint.html#5940" class="Bound">universal-map-for</a> <a id="9622" href="Cat.Functor.Adjoint.html#9600" class="Bound">x</a> <a id="9624" class="Symbol">.</a><a id="9625" href="Cat.Diagram.Initial.html#442" data-type="Initial C → Ob C" class="Field">bot</a>
</pre>
<p>Now for an object <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>:</mo><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">x : \ca{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span>,</span> we have <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>:</mo><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">R(x) : \ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span>,</span> so by the assumption that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> has a collection of universal objects, the comma category <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>↙</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">R(x) \swarrow R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↙</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> has an initial object; Let us write that object as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>L</mi><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">!</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(L(R(x)), !)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">))</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mclose">!)</span></span></span></span> — recall that here, <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">!</mo><mo>:</mo><mi>R</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>→</mo><mi>R</mi><mi>L</mi><mi>R</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">! : R(x) \to RLR(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>.</span></p>
<p>This means, in particular, that for any other object <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>y</mi><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(y, f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span> (with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>∈</mo><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">y \in \ca{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>R</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>→</mo><mi>R</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f : R(x) \to R(y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> in <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">\ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span>),</span> there is a unique map <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">d</mi></mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>→</mo><mo stretchy="false">(</mo><mi>y</mi><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\id{mapd}(x) \to (y, f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">mapd</span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span>,</span> which breaks down as a map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi><mo>:</mo><mi>L</mi><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>→</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">\beta : L(R(x)) \to y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> such that the square below commutes.</p>
<div class="diagram-container">
<img src="light-4c81dcc8079c0e802c9a787115956570c20814bc.svg" title="commutative diagram" class="diagram diagram-light quiver" />
<img src="dark-4c81dcc8079c0e802c9a787115956570c20814bc.svg" title="commutative diagram" class="diagram diagram-dark quiver" />
</div>
<pre class="Agda">    <a id="10372" href="Cat.Functor.Adjoint.html#10372" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(x : D .Ob) →
Hom (₀ R₁ x ↙ R₁) (mapd R₁ universal-map-for (₀ R₁ x))
(record { map = C .id })" class="Function">ε</a> <a id="10374" class="Symbol">:</a> <a id="10376" class="Symbol">∀</a> <a id="10378" class="Symbol">(</a><a id="10379" href="Cat.Functor.Adjoint.html#10379" class="Bound">x</a> <a id="10381" class="Symbol">:</a> <a id="10383" href="Cat.Base.html#1419" data-type="Precategory o h → Type o" class="Function">D.Ob</a><a id="10387" class="Symbol">)</a> <a id="10389" class="Symbol">→</a> <a id="10391" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Field">Hom</a> <a id="10395" class="Symbol">(</a><a id="10396" href="Cat.Base.html#8727" data-type="(r : Functor C D) → C .Ob → D .Ob" class="Function">R.₀</a> <a id="10400" href="Cat.Functor.Adjoint.html#10379" class="Bound">x</a> <a id="10402" href="Cat.Instances.Comma.html#5800" data-type="A .Ob →
Functor B₁ A → Precategory (ah ⊔ bo ⊔ lzero) (ah ⊔ bh ⊔ lzero)" class="Function Operator">↙</a> <a id="10404" href="Cat.Functor.Adjoint.html#5920" class="Bound">R</a><a id="10405" class="Symbol">)</a> <a id="10407" class="Symbol">(</a><a id="10408" href="Cat.Functor.Adjoint.html#9558" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(x : C .Ob) →
Ob (x ↙ R₁)" class="Function">mapd</a> <a id="10413" class="Symbol">(</a><a id="10414" href="Cat.Base.html#8727" data-type="(r : Functor C D) → C .Ob → D .Ob" class="Function">R.₀</a> <a id="10418" href="Cat.Functor.Adjoint.html#10379" class="Bound">x</a><a id="10419" class="Symbol">))</a> <a id="10422" class="Symbol">_</a>
    <a id="10428" href="Cat.Functor.Adjoint.html#10372" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(x : D .Ob) →
Hom (₀ R₁ x ↙ R₁) (mapd R₁ universal-map-for (₀ R₁ x))
(record { map = C .id })" class="Function">ε</a> <a id="10430" href="Cat.Functor.Adjoint.html#10430" class="Bound">x</a> <a id="10432" class="Symbol">=</a> <a id="10434" href="Cat.Diagram.Initial.html#600" data-type="(r : Initial C) → Hom C (bot r) x" class="Function">Initial.¡</a> <a id="10444" class="Symbol">(</a><a id="10445" href="Cat.Functor.Adjoint.html#5940" class="Bound">universal-map-for</a> <a id="10463" class="Symbol">(</a><a id="10464" href="Cat.Base.html#8727" data-type="(r : Functor C D) → C .Ob → D .Ob" class="Function">R.₀</a> <a id="10468" href="Cat.Functor.Adjoint.html#10430" class="Bound">x</a><a id="10469" class="Symbol">))</a> <a id="10472" class="Symbol">{</a><a id="10473" class="Argument">x</a> <a id="10475" class="Symbol">=</a> <a id="10477" class="Keyword">record</a> <a id="10484" class="Symbol">{</a> <a id="10486" href="Cat.Instances.Comma.html#1816" data-type="↓Obj F G → Ob B₁" class="Field">y</a> <a id="10488" class="Symbol">=</a> <a id="10490" href="Cat.Functor.Adjoint.html#10430" class="Bound">x</a> <a id="10492" class="Symbol">;</a> <a id="10494" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">map</a> <a id="10498" class="Symbol">=</a> <a id="10500" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">C.id</a> <a id="10505" class="Symbol">}}</a>
</pre>
<p>The magic trick is that, if we pick <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi></mrow><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x, \id{id})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathrm">id</span></span><span class="mclose">)</span></span></span></span> as the object of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>↙</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">R(x)\swarrow R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↙</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> to map into, then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span> in the diagram above must be <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>R</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>→</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">LR(x) \to x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>!</span> We choose this map as our adjunction counit. A tedious calculation shows that this assignment is natural, essentially because <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span> is unique.</p>
<pre class="Agda">  <a id="10824" href="Cat.Functor.Adjoint.html#10824" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
universal-maps→L R₁ universal-map-for ⊣ R₁" class="Function">universal-maps→L⊣R</a> <a id="10843" class="Symbol">:</a> <a id="10845" href="Cat.Functor.Adjoint.html#8808" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
Functor C D" class="Function">universal-maps→L</a> <a id="10862" href="Cat.Functor.Adjoint.html#2192" data-type="(L : Functor C D) (R₁ : Functor D C) → Type (C.o ⊔ C.h ⊔ D.o ⊔ D.h)" class="Record Operator">⊣</a> <a id="10864" href="Cat.Functor.Adjoint.html#5920" class="Bound">R</a>
  <a id="10868" href="Cat.Functor.Adjoint.html#10824" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
universal-maps→L R₁ universal-map-for ⊣ R₁" class="Function">universal-maps→L⊣R</a> <a id="10887" class="Symbol">.</a><a id="10888" href="Cat.Functor.Adjoint.html#2370" data-type="L ⊣ R₁ → L F∘ R₁ =&gt; Id" class="Field">counit</a> <a id="10895" class="Symbol">.</a><a id="10896" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="10898" href="Cat.Functor.Adjoint.html#10898" class="Bound">x</a> <a id="10900" class="Symbol">=</a> <a id="10902" href="Cat.Functor.Adjoint.html#10372" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(x : D .Ob) →
Hom (₀ R₁ x ↙ R₁) (mapd R₁ universal-map-for (₀ R₁ x))
(record { map = C .id })" class="Function">ε</a> <a id="10904" href="Cat.Functor.Adjoint.html#10898" class="Bound">x</a> <a id="10906" class="Symbol">.</a><a id="10907" href="Cat.Instances.Comma.html#2621" data-type="↓Hom F G a b → Hom B₁ (a .y) (y b)" class="Field">↓Hom.β</a>
  <a id="10916" href="Cat.Functor.Adjoint.html#10824" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
universal-maps→L R₁ universal-map-for ⊣ R₁" class="Function">universal-maps→L⊣R</a> <a id="10935" class="Symbol">.</a><a id="10936" href="Cat.Functor.Adjoint.html#2370" data-type="L ⊣ R₁ → L F∘ R₁ =&gt; Id" class="Field">counit</a> <a id="10943" class="Symbol">.</a><a id="10944" href="Cat.Base.html#13369" data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" class="Field">is-natural</a> <a id="10955" href="Cat.Functor.Adjoint.html#10955" class="Bound">x</a> <a id="10957" href="Cat.Functor.Adjoint.html#10957" class="Bound">y</a> <a id="10959" href="Cat.Functor.Adjoint.html#10959" class="Bound">f</a> <a id="10961" class="Symbol">=</a>
    <a id="10967" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="10970" href="Cat.Instances.Comma.html#2621" data-type="↓Hom F G a b → Hom B₁ (a .y) (y b)" class="Field">↓Hom.β</a> <a id="10977" class="Symbol">(</a>
      <a id="10985" href="Cat.Diagram.Initial.html#717" data-type="(r : Initial C) (f g : Hom C (bot r) x) → f ≡ g" class="Function">¡-unique₂</a> <a id="10995" class="Symbol">(</a><a id="10996" href="Cat.Functor.Adjoint.html#5940" class="Bound">universal-map-for</a> <a id="11014" class="Symbol">(</a><a id="11015" href="Cat.Base.html#8727" data-type="(r : Functor C D) → C .Ob → D .Ob" class="Function">R.₀</a> <a id="11019" href="Cat.Functor.Adjoint.html#10955" class="Bound">x</a><a id="11020" class="Symbol">))</a> <a id="11023" class="Symbol">{</a><a id="11024" class="Keyword">record</a> <a id="11031" class="Symbol">{</a> <a id="11033" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">map</a> <a id="11037" class="Symbol">=</a> <a id="11039" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">R.₁</a> <a id="11043" href="Cat.Functor.Adjoint.html#10959" class="Bound">f</a> <a id="11045" class="Symbol">}}</a>
      <a id="11054" class="Symbol">(</a><a id="11055" class="Keyword">record</a> <a id="11062" class="Symbol">{</a> <a id="11064" href="Cat.Instances.Comma.html#2646" data-type="(r : ↓Hom F G a b) →
C ._∘_ (map b) (F₁ F (r .α)) ≡ C ._∘_ (F₁ G (r .β)) (a .map)" class="Field">sq</a> <a id="11067" class="Symbol">=</a>
        <a id="11077" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">R.₁</a> <a id="11081" href="Cat.Functor.Adjoint.html#10959" class="Bound">f</a> <a id="11083" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="11087" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">C.id</a>                                          <span class="reasoning-step"><span class="as-written Function"><a id="11133" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="11136" href="Cat.Base.html#3437" data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ f (r .id) ≡ f" class="Function">C.idr</a> <a id="11142" class="Symbol">_</a> <a id="11144" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
        <a id="11154" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">R.₁</a> <a id="11158" href="Cat.Functor.Adjoint.html#10959" class="Bound">f</a>                                                   <span class="reasoning-step"><span class="as-written Function Operator"><a id="11210" href="1Lab.Path.html#46783" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">≡˘⟨</a> <a id="11214" href="Cat.Reasoning.html#2621" data-type="(C : Precategory o ℓ) (inv₁ : (C ∘ h) i ≡ id C) →
(C ∘ h) ((C ∘ i) f) ≡ f" class="Function">C.cancell</a> <a id="11224" class="Symbol">(</a><a id="11225" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="11229" class="Symbol">(</a><a id="11230" href="Cat.Functor.Adjoint.html#10372" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(x : D .Ob) →
Hom (₀ R₁ x ↙ R₁) (mapd R₁ universal-map-for (₀ R₁ x))
(record { map = C .id })" class="Function">ε</a> <a id="11232" href="Cat.Functor.Adjoint.html#10957" class="Bound">y</a> <a id="11234" class="Symbol">.</a><a id="11235" href="Cat.Instances.Comma.html#2646" data-type="(r : ↓Hom F G a b) →
C ._∘_ (map b) (F₁ F (r .α)) ≡ C ._∘_ (F₁ G (r .β)) (a .map)" class="Field">↓Hom.sq</a><a id="11242" class="Symbol">)</a> <a id="11244" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="11246" href="Cat.Base.html#3437" data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ f (r .id) ≡ f" class="Function">C.idr</a> <a id="11252" class="Symbol">_)</a> <a id="11255" href="1Lab.Path.html#46783" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡˘</span></span>
        <a id="11265" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">R.₁</a> <a id="11269" class="Symbol">(</a><a id="11270" href="Cat.Functor.Adjoint.html#10372" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(x : D .Ob) →
Hom (₀ R₁ x ↙ R₁) (mapd R₁ universal-map-for (₀ R₁ x))
(record { map = C .id })" class="Function">ε</a> <a id="11272" href="Cat.Functor.Adjoint.html#10957" class="Bound">y</a> <a id="11274" class="Symbol">.</a><a id="11275" href="Cat.Instances.Comma.html#2621" data-type="↓Hom F G a b → Hom B₁ (a .y) (y b)" class="Field">β</a><a id="11276" class="Symbol">)</a> <a id="11278" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="11282" class="Symbol">_</a> <a id="11284" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="11288" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">R.₁</a> <a id="11292" href="Cat.Functor.Adjoint.html#10959" class="Bound">f</a>                            <span class="reasoning-step"><span class="as-written Function Operator"><a id="11321" href="1Lab.Path.html#46783" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">≡˘⟨</a> <a id="11325" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="11329" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C._∘_</a> <a id="11335" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="11340" class="Symbol">(</a><a id="11341" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="11345" class="Symbol">(</a><a id="11346" href="Cat.Functor.Adjoint.html#7160" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(g : C .Hom x y) →
Hom (x ↙ R₁) (universal-map-for x .bot)
(to-ob R₁ universal-map-for g)" class="Function">lift↓</a> <a id="11352" class="Symbol">(</a><a id="11353" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">R.₁</a> <a id="11357" href="Cat.Functor.Adjoint.html#10959" class="Bound">f</a><a id="11358" class="Symbol">)</a> <a id="11360" class="Symbol">.</a><a id="11361" href="Cat.Instances.Comma.html#2646" data-type="(r : ↓Hom F G a b) →
C ._∘_ (map b) (F₁ F (r .α)) ≡ C ._∘_ (F₁ G (r .β)) (a .map)" class="Field">↓Hom.sq</a><a id="11368" class="Symbol">)</a> <a id="11370" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="11372" href="Cat.Base.html#3437" data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ f (r .id) ≡ f" class="Function">C.idr</a> <a id="11378" class="Symbol">_)</a> <a id="11381" href="1Lab.Path.html#46783" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡˘</span></span>
        <a id="11391" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">R.₁</a> <a id="11395" class="Symbol">(</a><a id="11396" href="Cat.Functor.Adjoint.html#10372" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(x : D .Ob) →
Hom (₀ R₁ x ↙ R₁) (mapd R₁ universal-map-for (₀ R₁ x))
(record { map = C .id })" class="Function">ε</a> <a id="11398" href="Cat.Functor.Adjoint.html#10957" class="Bound">y</a> <a id="11400" class="Symbol">.</a><a id="11401" href="Cat.Instances.Comma.html#2621" data-type="↓Hom F G a b → Hom B₁ (a .y) (y b)" class="Field">β</a><a id="11402" class="Symbol">)</a> <a id="11404" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="11408" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">R.₁</a> <a id="11412" class="Symbol">(</a><a id="11413" href="Cat.Functor.Adjoint.html#7324" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Hom a b →
D .Hom (L₀ R₁ universal-map-for a) (L₀ R₁ universal-map-for b)" class="Function">L₁</a> <a id="11416" class="Symbol">(</a><a id="11417" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">R.₁</a> <a id="11421" href="Cat.Functor.Adjoint.html#10959" class="Bound">f</a><a id="11422" class="Symbol">))</a> <a id="11425" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="11429" href="Cat.Functor.Adjoint.html#9558" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(x : C .Ob) →
Ob (x ↙ R₁)" class="Function">mapd</a> <a id="11434" class="Symbol">(</a><a id="11435" href="Cat.Base.html#8727" data-type="(r : Functor C D) → C .Ob → D .Ob" class="Function">R.₀</a> <a id="11439" href="Cat.Functor.Adjoint.html#10955" class="Bound">x</a><a id="11440" class="Symbol">)</a> <a id="11442" class="Symbol">.</a><a id="11443" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">map</a> <span class="reasoning-step"><span class="as-written Function"><a id="11447" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="11450" href="Cat.Reasoning.html#1548" data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ a) ((C ∘ b) f) ≡ (C ∘ c) f" class="Function">C.pulll</a> <a id="11458" class="Symbol">(</a><a id="11459" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="11463" class="Symbol">(</a><a id="11464" href="Cat.Base.html#8383" data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" class="Function">R.F-∘</a> <a id="11470" class="Symbol">_</a> <a id="11472" class="Symbol">_))</a> <a id="11476" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
        <a id="11486" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">R.₁</a> <a id="11490" class="Symbol">(</a><a id="11491" href="Cat.Functor.Adjoint.html#10372" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(x : D .Ob) →
Hom (₀ R₁ x ↙ R₁) (mapd R₁ universal-map-for (₀ R₁ x))
(record { map = C .id })" class="Function">ε</a> <a id="11493" href="Cat.Functor.Adjoint.html#10957" class="Bound">y</a> <a id="11495" class="Symbol">.</a><a id="11496" href="Cat.Instances.Comma.html#2621" data-type="↓Hom F G a b → Hom B₁ (a .y) (y b)" class="Field">β</a> <a id="11498" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="11502" href="Cat.Functor.Adjoint.html#7324" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Hom a b →
D .Hom (L₀ R₁ universal-map-for a) (L₀ R₁ universal-map-for b)" class="Function">L₁</a> <a id="11505" class="Symbol">(</a><a id="11506" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">R.₁</a> <a id="11510" href="Cat.Functor.Adjoint.html#10959" class="Bound">f</a><a id="11511" class="Symbol">))</a> <a id="11514" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="11518" href="Cat.Functor.Adjoint.html#9558" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(x : C .Ob) →
Ob (x ↙ R₁)" class="Function">mapd</a> <a id="11523" class="Symbol">(</a><a id="11524" href="Cat.Base.html#8727" data-type="(r : Functor C D) → C .Ob → D .Ob" class="Function">R.₀</a> <a id="11528" href="Cat.Functor.Adjoint.html#10955" class="Bound">x</a><a id="11529" class="Symbol">)</a> <a id="11531" class="Symbol">.</a><a id="11532" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">map</a>       <a id="11542" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a> <a id="11544" class="Symbol">})</a>
      <a id="11553" class="Symbol">(</a><a id="11554" class="Keyword">record</a> <a id="11561" class="Symbol">{</a> <a id="11563" href="Cat.Instances.Comma.html#2646" data-type="(r : ↓Hom F G a b) →
C ._∘_ (map b) (F₁ F (r .α)) ≡ C ._∘_ (F₁ G (r .β)) (a .map)" class="Field">sq</a> <a id="11566" class="Symbol">=</a>
        <a id="11576" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">R.₁</a> <a id="11580" href="Cat.Functor.Adjoint.html#10959" class="Bound">f</a> <a id="11582" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="11586" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">C.id</a>                               <span class="reasoning-step"><span class="as-written Function Operator"><a id="11621" href="1Lab.Path.html#46783" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">≡˘⟨</a> <a id="11625" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="11628" class="Symbol">(</a><a id="11629" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">R.₁</a> <a id="11633" href="Cat.Functor.Adjoint.html#10959" class="Bound">f</a> <a id="11635" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘_</a><a id="11639" class="Symbol">)</a> <a id="11641" class="Symbol">(</a><a id="11642" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="11646" class="Symbol">(</a><a id="11647" href="Cat.Functor.Adjoint.html#10372" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(x : D .Ob) →
Hom (₀ R₁ x ↙ R₁) (mapd R₁ universal-map-for (₀ R₁ x))
(record { map = C .id })" class="Function">ε</a> <a id="11649" href="Cat.Functor.Adjoint.html#10955" class="Bound">x</a> <a id="11651" class="Symbol">.</a><a id="11652" href="Cat.Instances.Comma.html#2646" data-type="(r : ↓Hom F G a b) →
C ._∘_ (map b) (F₁ F (r .α)) ≡ C ._∘_ (F₁ G (r .β)) (a .map)" class="Field">↓Hom.sq</a><a id="11659" class="Symbol">)</a> <a id="11661" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="11663" href="Cat.Base.html#3437" data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ f (r .id) ≡ f" class="Function">C.idr</a> <a id="11669" class="Symbol">_)</a> <a id="11672" href="1Lab.Path.html#46783" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡˘</span></span>
        <a id="11682" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">R.₁</a> <a id="11686" href="Cat.Functor.Adjoint.html#10959" class="Bound">f</a> <a id="11688" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="11692" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">R.₁</a> <a id="11696" class="Symbol">(</a><a id="11697" href="Cat.Functor.Adjoint.html#10372" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(x : D .Ob) →
Hom (₀ R₁ x ↙ R₁) (mapd R₁ universal-map-for (₀ R₁ x))
(record { map = C .id })" class="Function">ε</a> <a id="11699" href="Cat.Functor.Adjoint.html#10955" class="Bound">x</a> <a id="11701" class="Symbol">.</a><a id="11702" href="Cat.Instances.Comma.html#2621" data-type="↓Hom F G a b → Hom B₁ (a .y) (y b)" class="Field">β</a><a id="11703" class="Symbol">)</a> <a id="11705" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="11709" href="Cat.Functor.Adjoint.html#9558" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(x : C .Ob) →
Ob (x ↙ R₁)" class="Function">mapd</a> <a id="11714" class="Symbol">(</a><a id="11715" href="Cat.Base.html#8727" data-type="(r : Functor C D) → C .Ob → D .Ob" class="Function">R.₀</a> <a id="11719" href="Cat.Functor.Adjoint.html#10955" class="Bound">x</a><a id="11720" class="Symbol">)</a> <a id="11722" class="Symbol">.</a><a id="11723" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">map</a> <span class="reasoning-step"><span class="as-written Function"><a id="11727" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="11730" href="Cat.Reasoning.html#1548" data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ a) ((C ∘ b) f) ≡ (C ∘ c) f" class="Function">C.pulll</a> <a id="11738" class="Symbol">(</a><a id="11739" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="11743" class="Symbol">(</a><a id="11744" href="Cat.Base.html#8383" data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" class="Function">R.F-∘</a> <a id="11750" class="Symbol">_</a> <a id="11752" class="Symbol">_))</a> <a id="11756" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
        <a id="11766" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">R.₁</a> <a id="11770" class="Symbol">(</a><a id="11771" href="Cat.Functor.Adjoint.html#10959" class="Bound">f</a> <a id="11773" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="11777" href="Cat.Functor.Adjoint.html#10372" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(x : D .Ob) →
Hom (₀ R₁ x ↙ R₁) (mapd R₁ universal-map-for (₀ R₁ x))
(record { map = C .id })" class="Function">ε</a> <a id="11779" href="Cat.Functor.Adjoint.html#10955" class="Bound">x</a> <a id="11781" class="Symbol">.</a><a id="11782" href="Cat.Instances.Comma.html#2621" data-type="↓Hom F G a b → Hom B₁ (a .y) (y b)" class="Field">β</a><a id="11783" class="Symbol">)</a> <a id="11785" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="11789" href="Cat.Functor.Adjoint.html#9558" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(x : C .Ob) →
Ob (x ↙ R₁)" class="Function">mapd</a> <a id="11794" class="Symbol">(</a><a id="11795" href="Cat.Base.html#8727" data-type="(r : Functor C D) → C .Ob → D .Ob" class="Function">R.₀</a> <a id="11799" href="Cat.Functor.Adjoint.html#10955" class="Bound">x</a><a id="11800" class="Symbol">)</a> <a id="11802" class="Symbol">.</a><a id="11803" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">map</a>     <a id="11811" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a> <a id="11813" class="Symbol">}))</a>
</pre>
<p>For the adjunction unit, the situation is a lot easier. Recall that we <em>defined</em> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span> on objects (<span class="Agda"><a href="Cat.Functor.Adjoint.html#6484" class="Function">L₀</a></span>) to be the codomain part of the initial object of <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>↙</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">x \swarrow R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↙</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>;</span> The <em>map</em> part of that object then gives us a natural family of morphisms <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>→</mo><mi>R</mi><mo stretchy="false">(</mo><mi>L</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x \to R(L(x))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">))</span></span></span></span>.</span> By definition. It’s so “by definition” that Agda can figure out the components by itself:</p>
<pre class="Agda">  <a id="12192" href="Cat.Functor.Adjoint.html#10824" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
universal-maps→L R₁ universal-map-for ⊣ R₁" class="Function">universal-maps→L⊣R</a> <a id="12211" class="Symbol">.</a><a id="12212" href="Cat.Functor.Adjoint.html#2342" data-type="L ⊣ R₁ → Id =&gt; R₁ F∘ L" class="Field">unit</a> <a id="12217" class="Symbol">.</a><a id="12218" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="12220" href="Cat.Functor.Adjoint.html#12220" class="Bound">x</a>              <a id="12235" class="Symbol">=</a> <a id="12237" class="Symbol">_</a>
  <a id="12241" href="Cat.Functor.Adjoint.html#10824" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
universal-maps→L R₁ universal-map-for ⊣ R₁" class="Function">universal-maps→L⊣R</a> <a id="12260" class="Symbol">.</a><a id="12261" href="Cat.Functor.Adjoint.html#2342" data-type="L ⊣ R₁ → Id =&gt; R₁ F∘ L" class="Field">unit</a> <a id="12266" class="Symbol">.</a><a id="12267" href="Cat.Base.html#13369" data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" class="Field">is-natural</a> <a id="12278" href="Cat.Functor.Adjoint.html#12278" class="Bound">x</a> <a id="12280" href="Cat.Functor.Adjoint.html#12280" class="Bound">y</a> <a id="12282" href="Cat.Functor.Adjoint.html#12282" class="Bound">f</a> <a id="12284" class="Symbol">=</a> <a id="12286" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="12290" class="Symbol">(</a><a id="12291" href="Cat.Base.html#3437" data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ f (r .id) ≡ f" class="Function">C.idr</a> <a id="12297" class="Symbol">_)</a> <a id="12300" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="12302" href="Cat.Functor.Adjoint.html#7160" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(g : C .Hom x y) →
Hom (x ↙ R₁) (universal-map-for x .bot)
(to-ob R₁ universal-map-for g)" class="Function">lift↓</a> <a id="12308" href="Cat.Functor.Adjoint.html#12282" class="Bound">f</a> <a id="12310" class="Symbol">.</a><a id="12311" href="Cat.Instances.Comma.html#2646" data-type="(r : ↓Hom F G a b) →
C ._∘_ (map b) (F₁ F (r .α)) ≡ C ._∘_ (F₁ G (r .β)) (a .map)" class="Field">↓Hom.sq</a>
</pre>
<p>If you think back to the adjunction counit, you’ll recall that it satisfied a triangle that looks like the one below, and that the top map (the map component of the initial object) is what we defined the adjunction unit to be, so.. It’s <span class="Agda"><a href="Cat.Functor.Adjoint.html#3006" class="Field">zag</a></span>.</p>
<div class="diagram-container">
<img src="light-0e53c89adfa4db9618e8ed9736d967d35e311a89.svg" title="commutative diagram" class="diagram diagram-light quiver" />
<img src="dark-0e53c89adfa4db9618e8ed9736d967d35e311a89.svg" title="commutative diagram" class="diagram diagram-dark quiver" />
</div>
<pre class="Agda">  <a id="12791" href="Cat.Functor.Adjoint.html#10824" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
universal-maps→L R₁ universal-map-for ⊣ R₁" class="Function">universal-maps→L⊣R</a> <a id="12810" class="Symbol">.</a><a id="12811" href="Cat.Functor.Adjoint.html#3006" data-type="(r : L ⊣ R₁) →
C ._∘_ (F₁ R₁ (η (r .counit) B₁)) (r .unit .η (F₀ R₁ B₁)) ≡ C .id" class="Field">zag</a> <a id="12815" class="Symbol">{</a><a id="12816" href="Cat.Functor.Adjoint.html#12816" class="Bound">x</a><a id="12817" class="Symbol">}</a> <a id="12819" class="Symbol">=</a> <a id="12821" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="12825" class="Symbol">(</a><a id="12826" href="Cat.Functor.Adjoint.html#10372" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(x : D .Ob) →
Hom (₀ R₁ x ↙ R₁) (mapd R₁ universal-map-for (₀ R₁ x))
(record { map = C .id })" class="Function">ε</a> <a id="12828" href="Cat.Functor.Adjoint.html#12816" class="Bound">x</a> <a id="12830" class="Symbol">.</a><a id="12831" href="Cat.Instances.Comma.html#2646" data-type="(r : ↓Hom F G a b) →
C ._∘_ (map b) (F₁ F (r .α)) ≡ C ._∘_ (F₁ G (r .β)) (a .map)" class="Field">↓Hom.sq</a><a id="12838" class="Symbol">)</a> <a id="12840" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="12842" href="Cat.Base.html#3437" data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ f (r .id) ≡ f" class="Function">C.idr</a> <a id="12848" class="Symbol">_</a>
</pre>
<p>The other triangle identity is slightly more annoying, but it works just as well. It follows from the uniqueness of maps out of the initial object:</p>
<pre class="Agda">  <a id="13014" href="Cat.Functor.Adjoint.html#10824" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
universal-maps→L R₁ universal-map-for ⊣ R₁" class="Function">universal-maps→L⊣R</a> <a id="13033" class="Symbol">.</a><a id="13034" href="Cat.Functor.Adjoint.html#2943" data-type="(r : L ⊣ R₁) →
D ._∘_ (η (r .counit) (F₀ L A)) (F₁ L (r .unit .η A)) ≡ D .id" class="Field">zig</a> <a id="13038" class="Symbol">{</a><a id="13039" href="Cat.Functor.Adjoint.html#13039" class="Bound">x</a><a id="13040" class="Symbol">}</a> <a id="13042" class="Symbol">=</a>
    <a id="13048" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="13051" href="Cat.Instances.Comma.html#2621" data-type="↓Hom F G a b → Hom B₁ (a .y) (y b)" class="Field">↓Hom.β</a> <a id="13058" class="Symbol">(</a>
      <a id="13066" href="Cat.Diagram.Initial.html#717" data-type="(r : Initial C) (f g : Hom C (bot r) x) → f ≡ g" class="Function">¡-unique₂</a> <a id="13076" class="Symbol">(</a><a id="13077" href="Cat.Functor.Adjoint.html#5940" class="Bound">universal-map-for</a> <a id="13095" href="Cat.Functor.Adjoint.html#13039" class="Bound">x</a><a id="13096" class="Symbol">)</a> <a id="13098" class="Symbol">{</a><a id="13099" class="Keyword">record</a> <a id="13106" class="Symbol">{</a> <a id="13108" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">map</a> <a id="13112" class="Symbol">=</a> <a id="13114" href="Cat.Functor.Adjoint.html#13583" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Hom x (₀ R₁ (L₀ R₁ universal-map-for x))" class="Function">α</a> <a id="13116" class="Symbol">}}</a>
        <a id="13127" class="Symbol">(</a><a id="13128" class="Keyword">record</a> <a id="13135" class="Symbol">{</a> <a id="13137" href="Cat.Instances.Comma.html#2646" data-type="(r : ↓Hom F G a b) →
C ._∘_ (map b) (F₁ F (r .α)) ≡ C ._∘_ (F₁ G (r .β)) (a .map)" class="Field">sq</a> <a id="13140" class="Symbol">=</a>
          <a id="13152" href="Cat.Functor.Adjoint.html#13583" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Hom x (₀ R₁ (L₀ R₁ universal-map-for x))" class="Function">α</a> <a id="13154" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="13158" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">C.id</a>                     <span class="reasoning-step"><span class="as-written Function"><a id="13183" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="13186" href="Cat.Base.html#3437" data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ f (r .id) ≡ f" class="Function">C.idr</a> <a id="13192" class="Symbol">_</a> <a id="13194" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
          <a id="13206" href="Cat.Functor.Adjoint.html#13583" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Hom x (₀ R₁ (L₀ R₁ universal-map-for x))" class="Function">α</a>                              <span class="reasoning-step"><span class="as-written Function Operator"><a id="13237" href="1Lab.Path.html#46783" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">≡˘⟨</a> <a id="13241" href="Cat.Reasoning.html#2621" data-type="(C : Precategory o ℓ) (inv₁ : (C ∘ h) i ≡ id C) →
(C ∘ h) ((C ∘ i) f) ≡ f" class="Function">C.cancell</a> <a id="13251" class="Symbol">(</a><a id="13252" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="13256" class="Symbol">(</a><a id="13257" href="Cat.Functor.Adjoint.html#10372" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(x : D .Ob) →
Hom (₀ R₁ x ↙ R₁) (mapd R₁ universal-map-for (₀ R₁ x))
(record { map = C .id })" class="Function">ε</a> <a id="13259" class="Symbol">(</a><a id="13260" href="Cat.Functor.Adjoint.html#6484" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Ob → D .Ob" class="Function">L₀</a> <a id="13263" href="Cat.Functor.Adjoint.html#13039" class="Bound">x</a><a id="13264" class="Symbol">)</a> <a id="13266" class="Symbol">.</a><a id="13267" href="Cat.Instances.Comma.html#2646" data-type="(r : ↓Hom F G a b) →
C ._∘_ (map b) (F₁ F (r .α)) ≡ C ._∘_ (F₁ G (r .β)) (a .map)" class="Field">↓Hom.sq</a><a id="13274" class="Symbol">)</a> <a id="13276" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="13278" href="Cat.Base.html#3437" data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ f (r .id) ≡ f" class="Function">C.idr</a> <a id="13284" class="Symbol">_)</a> <a id="13287" href="1Lab.Path.html#46783" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡˘</span></span>
          <a id="13299" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">R.₁</a> <a id="13303" class="Symbol">_</a> <a id="13305" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="13309" class="Symbol">_</a> <a id="13311" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="13315" href="Cat.Functor.Adjoint.html#13583" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Hom x (₀ R₁ (L₀ R₁ universal-map-for x))" class="Function">α</a>              <span class="reasoning-step"><span class="as-written Function Operator"><a id="13330" href="1Lab.Path.html#46783" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">≡˘⟨</a> <a id="13334" href="Cat.Reasoning.html#1678" data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ (C ∘ f) a) b ≡ (C ∘ f) c" class="Function">C.pullr</a> <a id="13342" class="Symbol">(</a><a id="13343" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="13347" class="Symbol">(</a><a id="13348" href="Cat.Functor.Adjoint.html#7160" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(g : C .Hom x y) →
Hom (x ↙ R₁) (universal-map-for x .bot)
(to-ob R₁ universal-map-for g)" class="Function">lift↓</a> <a id="13354" href="Cat.Functor.Adjoint.html#13583" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Hom x (₀ R₁ (L₀ R₁ universal-map-for x))" class="Function">α</a> <a id="13356" class="Symbol">.</a><a id="13357" href="Cat.Instances.Comma.html#2646" data-type="(r : ↓Hom F G a b) →
C ._∘_ (map b) (F₁ F (r .α)) ≡ C ._∘_ (F₁ G (r .β)) (a .map)" class="Field">↓Hom.sq</a><a id="13364" class="Symbol">)</a> <a id="13366" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="13368" href="Cat.Base.html#3437" data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ f (r .id) ≡ f" class="Function">C.idr</a> <a id="13374" class="Symbol">_)</a> <a id="13377" href="1Lab.Path.html#46783" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡˘</span></span>
          <a id="13389" class="Symbol">(</a><a id="13390" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">R.₁</a> <a id="13394" class="Symbol">_</a> <a id="13396" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="13400" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">R.₁</a> <a id="13404" class="Symbol">(</a><a id="13405" href="Cat.Base.html#8017" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="13408" href="Cat.Functor.Adjoint.html#13603" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
Functor C D" class="Function">L</a> <a id="13410" href="Cat.Functor.Adjoint.html#13583" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Hom x (₀ R₁ (L₀ R₁ universal-map-for x))" class="Function">α</a><a id="13411" class="Symbol">))</a> <a id="13414" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="13418" href="Cat.Functor.Adjoint.html#13583" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Hom x (₀ R₁ (L₀ R₁ universal-map-for x))" class="Function">α</a> <span class="reasoning-step"><span class="as-written Function Operator"><a id="13420" href="1Lab.Path.html#46783" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">≡˘⟨</a> <a id="13424" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="13427" class="Symbol">(</a><a id="13428" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C._∘</a> <a id="13433" href="Cat.Functor.Adjoint.html#13583" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Hom x (₀ R₁ (L₀ R₁ universal-map-for x))" class="Function">α</a><a id="13434" class="Symbol">)</a> <a id="13436" class="Symbol">(</a><a id="13437" href="Cat.Base.html#8383" data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" class="Function">R.F-∘</a> <a id="13443" class="Symbol">_</a> <a id="13445" class="Symbol">_)</a> <a id="13448" href="1Lab.Path.html#46783" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡˘</span></span>
          <a id="13460" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">R.₁</a> <a id="13464" class="Symbol">(_</a> <a id="13467" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="13471" href="Cat.Base.html#8017" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="13474" href="Cat.Functor.Adjoint.html#13603" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
Functor C D" class="Function">L</a> <a id="13476" href="Cat.Functor.Adjoint.html#13583" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Hom x (₀ R₁ (L₀ R₁ universal-map-for x))" class="Function">α</a><a id="13477" class="Symbol">)</a> <a id="13479" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="13483" href="Cat.Functor.Adjoint.html#13583" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Hom x (₀ R₁ (L₀ R₁ universal-map-for x))" class="Function">α</a>       <a id="13491" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
        <a id="13501" class="Symbol">})</a>
        <a id="13512" class="Symbol">(</a><a id="13513" class="Keyword">record</a> <a id="13520" class="Symbol">{</a> <a id="13522" href="Cat.Instances.Comma.html#2646" data-type="(r : ↓Hom F G a b) →
C ._∘_ (map b) (F₁ F (r .α)) ≡ C ._∘_ (F₁ G (r .β)) (a .map)" class="Field">sq</a> <a id="13525" class="Symbol">=</a> <a id="13527" href="Cat.Reasoning.html#789" data-type="(C : Precategory o ℓ) → (C ∘ f) (id C) ≡ (C ∘ id C) f" class="Function">C.id-comm</a> <a id="13537" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="13539" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="13542" class="Symbol">(</a><a id="13543" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C._∘</a> <a id="13548" class="Symbol">_)</a> <a id="13551" class="Symbol">(</a><a id="13552" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="13556" href="Cat.Base.html#8343" data-type="(r : Functor C D) → r .F₁ (C .id) ≡ id D" class="Function">R.F-id</a><a id="13562" class="Symbol">)</a> <a id="13564" class="Symbol">})</a>
    <a id="13571" class="Symbol">)</a>
    <a id="13577" class="Keyword">where</a> <a id="13583" href="Cat.Functor.Adjoint.html#13583" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Hom x (₀ R₁ (L₀ R₁ universal-map-for x))" class="Function">α</a> <a id="13585" class="Symbol">=</a> <a id="13587" href="Cat.Functor.Adjoint.html#6546" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(c : C .Ob) →
C .Hom c (₀ R₁ (L₀ R₁ universal-map-for c))" class="Function">L₀′</a> <a id="13591" href="Cat.Functor.Adjoint.html#13039" class="Bound">x</a>
          <a id="13603" href="Cat.Functor.Adjoint.html#13603" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
Functor C D" class="Function">L</a> <a id="13605" class="Symbol">=</a> <a id="13607" href="Cat.Functor.Adjoint.html#8808" data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
Functor C D" class="Function">universal-maps→L</a>
</pre>
<h2 id="from-an-adjunction"><a href="#from-an-adjunction" class="header-link">From an adjunction<span class="header-link-emoji">🔗</span></a></h2>
<p>To finish the correspondence, we show that any (left) adjoint functor <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>⊣</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">L \dashv R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊣</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> defines a system of universal arrows <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mo>↙</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">- \swarrow R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↙</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>;</span> This means that, not only does a “universal way of solving <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>” <em>give</em> a left adjoint to <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>,</span> it <em>is</em> a left adjoint to <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>.</span></p>
<!--
<pre class="Agda"><a id="13927" class="Keyword">module</a> <a id="13934" href="Cat.Functor.Adjoint.html#13934" class="Module">_</a>
  <a id="13938" class="Symbol">{</a><a id="13939" href="Cat.Functor.Adjoint.html#13939" class="Bound">L</a> <a id="13941" class="Symbol">:</a> <a id="13943" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="13951" href="Cat.Functor.Adjoint.html#500" class="Generalizable">C</a> <a id="13953" href="Cat.Functor.Adjoint.html#502" class="Generalizable">D</a><a id="13954" class="Symbol">}</a> <a id="13956" class="Symbol">{</a><a id="13957" href="Cat.Functor.Adjoint.html#13957" class="Bound">R</a> <a id="13959" class="Symbol">:</a> <a id="13961" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="13969" href="Cat.Functor.Adjoint.html#502" class="Generalizable">D</a> <a id="13971" href="Cat.Functor.Adjoint.html#500" class="Generalizable">C</a><a id="13972" class="Symbol">}</a>
  <a id="13976" class="Symbol">(</a><a id="13977" href="Cat.Functor.Adjoint.html#13977" class="Bound">adj</a> <a id="13981" class="Symbol">:</a> <a id="13983" href="Cat.Functor.Adjoint.html#13939" class="Bound">L</a> <a id="13985" href="Cat.Functor.Adjoint.html#2192" data-type="(L : Functor C D) (R₁ : Functor D C) → Type (C.o ⊔ C.h ⊔ D.o ⊔ D.h)" class="Record Operator">⊣</a> <a id="13987" href="Cat.Functor.Adjoint.html#13957" class="Bound">R</a><a id="13988" class="Symbol">)</a>
  <a id="13992" class="Keyword">where</a>

  <a id="14001" class="Keyword">private</a>
    <a id="14013" class="Keyword">import</a> <a id="14020" href="Cat.Functor.Reasoning.html" class="Module">Cat.Functor.Reasoning</a> <a id="14042" href="Cat.Functor.Adjoint.html#13939" class="Bound">L</a> as <a id="14047" href="Cat.Functor.Adjoint.html#14047" class="Module">L</a>
    <a id="14053" class="Keyword">import</a> <a id="14060" href="Cat.Functor.Reasoning.html" class="Module">Cat.Functor.Reasoning</a> <a id="14082" href="Cat.Functor.Adjoint.html#13957" class="Bound">R</a> as <a id="14087" href="Cat.Functor.Adjoint.html#14087" class="Module">R</a>
    <a id="14093" class="Keyword">import</a> <a id="14100" href="Cat.Reasoning.html" class="Module">Cat.Reasoning</a> <a id="14114" href="Cat.Functor.Adjoint.html#13951" class="Bound">C</a> as <a id="14119" href="Cat.Functor.Adjoint.html#14119" class="Module">C</a>
    <a id="14125" class="Keyword">import</a> <a id="14132" href="Cat.Reasoning.html" class="Module">Cat.Reasoning</a> <a id="14146" href="Cat.Functor.Adjoint.html#13953" class="Bound">D</a> as <a id="14151" href="Cat.Functor.Adjoint.html#14151" class="Module">D</a>
    <a id="14157" class="Keyword">module</a> <a id="14164" href="Cat.Functor.Adjoint.html#14164" class="Module">adj</a> <a id="14168" class="Symbol">=</a> <a id="14170" href="Cat.Functor.Adjoint.html#2192" data-type="(L : Functor C D) (R₁ : Functor D C) → Type (C.o ⊔ C.h ⊔ D.o ⊔ D.h)" class="Module Operator">_⊣_</a> <a id="14174" href="Cat.Functor.Adjoint.html#13977" class="Bound">adj</a>
</pre>-->
<p>So, given an object <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">x \in \ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span>,</span> we must find an object <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> and a universal map <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>→</mo><mi>R</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x \to R(y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>.</span> Recall that, in the previous section, we constructed the left adjoint <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span>’s</span> action on objects by using our system of universal arrows; Symetrically, in this section, we take the codomain to be <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mi>L</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y = L(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>.</span> We must then find an arrow <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>→</mo><mi>R</mi><mi>L</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">x \to RLx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">Lx</span></span></span></span>,</span> but this is exactly the adjunction unit <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>η</mi></mrow><annotation encoding="application/x-tex">\eta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">η</span></span></span></span>!</span></p>
<pre class="Agda">  <a id="14588" href="Cat.Functor.Adjoint.html#14588" data-type="L ⊣ R₁ → (x : C .Ob) → Ob (x ↙ R₁)" class="Function">L⊣R→map-to-R</a> <a id="14601" class="Symbol">:</a> <a id="14603" class="Symbol">∀</a> <a id="14605" href="Cat.Functor.Adjoint.html#14605" class="Bound">x</a> <a id="14607" class="Symbol">→</a> <a id="14609" href="Cat.Base.html#1419" data-type="Precategory o h → Type o" class="Field">Precategory.Ob</a> <a id="14624" class="Symbol">(</a><a id="14625" href="Cat.Functor.Adjoint.html#14605" class="Bound">x</a> <a id="14627" href="Cat.Instances.Comma.html#5800" data-type="A .Ob →
Functor B₁ A → Precategory (ah ⊔ bo ⊔ lzero) (ah ⊔ bh ⊔ lzero)" class="Function Operator">↙</a> <a id="14629" href="Cat.Functor.Adjoint.html#13957" class="Bound">R</a><a id="14630" class="Symbol">)</a>
  <a id="14634" href="Cat.Functor.Adjoint.html#14588" data-type="L ⊣ R₁ → (x : C .Ob) → Ob (x ↙ R₁)" class="Function">L⊣R→map-to-R</a> <a id="14647" href="Cat.Functor.Adjoint.html#14647" class="Bound">x</a> <a id="14649" class="Symbol">.</a><a id="14650" href="Cat.Instances.Comma.html#1799" data-type="↓Obj F G → Ob A" class="Field">↓Obj.x</a> <a id="14657" class="Symbol">=</a> <a id="14659" href="Agda.Builtin.Unit.html#201" data-type="⊤" class="InductiveConstructor">tt</a>
  <a id="14664" href="Cat.Functor.Adjoint.html#14588" data-type="L ⊣ R₁ → (x : C .Ob) → Ob (x ↙ R₁)" class="Function">L⊣R→map-to-R</a> <a id="14677" href="Cat.Functor.Adjoint.html#14677" class="Bound">x</a> <a id="14679" class="Symbol">.</a><a id="14680" href="Cat.Instances.Comma.html#1816" data-type="↓Obj F G → Ob B₁" class="Field">↓Obj.y</a> <a id="14687" class="Symbol">=</a> <a id="14689" href="Cat.Base.html#8727" data-type="(r : Functor C D) → C .Ob → D .Ob" class="Function">L.₀</a> <a id="14693" href="Cat.Functor.Adjoint.html#14677" class="Bound">x</a>
  <a id="14697" href="Cat.Functor.Adjoint.html#14588" data-type="L ⊣ R₁ → (x : C .Ob) → Ob (x ↙ R₁)" class="Function">L⊣R→map-to-R</a> <a id="14710" href="Cat.Functor.Adjoint.html#14710" class="Bound">x</a> <a id="14712" class="Symbol">.</a><a id="14713" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">↓Obj.map</a> <a id="14722" class="Symbol">=</a> <a id="14724" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Function">adj.unit.η</a> <a id="14735" class="Symbol">_</a>
</pre>
<p>We must now show that the unit <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>η</mi></mrow><annotation encoding="application/x-tex">\eta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">η</span></span></span></span> is universal among the pairs <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>y</mi><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(y, f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span>,</span> with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> a map <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>→</mo><mi>R</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x \to R(y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>.</span> Recall that for our object <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>L</mi><mi>x</mi><mo separator="true">,</mo><mi>η</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(Lx, \eta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">Lx</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">η</span><span class="mclose">)</span></span></span></span> to be <a href="Cat.Diagram.Initial.html">initial</a>, we must find an arrow <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>y</mi><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">)</mo><mo>→</mo><mo stretchy="false">(</mo><mi>L</mi><mi>x</mi><mo separator="true">,</mo><mi>η</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(y, f) \to (Lx, \eta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">Lx</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">η</span><span class="mclose">)</span></span></span></span>,</span> and prove that this is the only possible such arrow; And that morphisms in the comma category <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>↙</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">x \swarrow R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↙</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> break down as maps <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>:</mo><mi>L</mi><mi>x</mi><mo>→</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">g : Lx \to y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">Lx</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> such that the triangle below commutes:</p>
<div class="diagram-container">
<img src="light-5ef1b7a59df5769dd462ea34de9bd9a740145cfc.svg" title="commutative diagram" class="diagram diagram-light quiver" />
<img src="dark-5ef1b7a59df5769dd462ea34de9bd9a740145cfc.svg" title="commutative diagram" class="diagram diagram-dark quiver" />
</div>
<p>We can actually read off the map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span> pretty directly from the diagram: It must be a map <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>x</mi><mo>→</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">Lx \to y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">Lx</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>,</span> but we’ve been given a map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>R</mi><mi>x</mi><mo>→</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">LRx \to x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> (the adjunction counit) and a map <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>→</mo><mi>R</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">x \to Ry</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>;</span> We may then take our <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span> to be the composite</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>L</mi><mi>x</mi><mo>→</mo><mi>L</mi><mi>R</mi><mi>y</mi><mo>→</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">
Lx \to LRy \to y
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">Lx</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span></span></p>
<pre class="Agda">  <a id="15615" href="Cat.Functor.Adjoint.html#15615" data-type="(adj : L ⊣ R₁) (x : C .Ob) →
is-initial (x ↙ R₁) (L⊣R→map-to-R adj x)" class="Function">L⊣R→map-to-R-is-initial</a>
    <a id="15643" class="Symbol">:</a> <a id="15645" class="Symbol">∀</a> <a id="15647" href="Cat.Functor.Adjoint.html#15647" class="Bound">x</a> <a id="15649" class="Symbol">→</a> <a id="15651" href="Cat.Diagram.Initial.html#326" data-type="(C : Precategory o h) → Ob C → Type (o ⊔ h)" class="Function">is-initial</a> <a id="15662" class="Symbol">(</a><a id="15663" href="Cat.Functor.Adjoint.html#15647" class="Bound">x</a> <a id="15665" href="Cat.Instances.Comma.html#5800" data-type="A .Ob →
Functor B₁ A → Precategory (ah ⊔ bo ⊔ lzero) (ah ⊔ bh ⊔ lzero)" class="Function Operator">↙</a> <a id="15667" href="Cat.Functor.Adjoint.html#13957" class="Bound">R</a><a id="15668" class="Symbol">)</a> <a id="15670" class="Symbol">(</a><a id="15671" href="Cat.Functor.Adjoint.html#14588" data-type="L ⊣ R₁ → (x : C .Ob) → Ob (x ↙ R₁)" class="Function">L⊣R→map-to-R</a> <a id="15684" href="Cat.Functor.Adjoint.html#15647" class="Bound">x</a><a id="15685" class="Symbol">)</a>
  <a id="15689" href="Cat.Functor.Adjoint.html#15615" data-type="(adj : L ⊣ R₁) (x : C .Ob) →
is-initial (x ↙ R₁) (L⊣R→map-to-R adj x)" class="Function">L⊣R→map-to-R-is-initial</a> <a id="15713" href="Cat.Functor.Adjoint.html#15713" class="Bound">x</a> <a id="15715" href="Cat.Functor.Adjoint.html#15715" class="Bound">other-map</a> <a id="15725" class="Symbol">.</a><a id="15726" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a> <a id="15733" class="Symbol">.</a><a id="15734" href="Cat.Instances.Comma.html#2595" data-type="↓Hom F G a b → Hom A (a .x) (x b)" class="Field">↓Hom.α</a> <a id="15741" class="Symbol">=</a> <a id="15743" href="Agda.Builtin.Unit.html#201" data-type="⊤" class="InductiveConstructor">tt</a>
  <a id="15748" href="Cat.Functor.Adjoint.html#15615" data-type="(adj : L ⊣ R₁) (x : C .Ob) →
is-initial (x ↙ R₁) (L⊣R→map-to-R adj x)" class="Function">L⊣R→map-to-R-is-initial</a> <a id="15772" href="Cat.Functor.Adjoint.html#15772" class="Bound">x</a> <a id="15774" href="Cat.Functor.Adjoint.html#15774" class="Bound">other-map</a> <a id="15784" class="Symbol">.</a><a id="15785" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a> <a id="15792" class="Symbol">.</a><a id="15793" href="Cat.Instances.Comma.html#2621" data-type="↓Hom F G a b → Hom B₁ (a .y) (y b)" class="Field">↓Hom.β</a> <a id="15800" class="Symbol">=</a>
    <a id="15806" href="Cat.Functor.Adjoint.html#2466" class="Function">adj.counit.ε</a> <a id="15819" class="Symbol">_</a> <a id="15821" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="15825" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">L.₁</a> <a id="15829" class="Symbol">(</a><a id="15830" href="Cat.Functor.Adjoint.html#15774" class="Bound">other-map</a> <a id="15840" class="Symbol">.</a><a id="15841" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">↓Obj.map</a><a id="15849" class="Symbol">)</a>
  <a id="15853" href="Cat.Functor.Adjoint.html#15615" data-type="(adj : L ⊣ R₁) (x : C .Ob) →
is-initial (x ↙ R₁) (L⊣R→map-to-R adj x)" class="Function">L⊣R→map-to-R-is-initial</a> <a id="15877" href="Cat.Functor.Adjoint.html#15877" class="Bound">x</a> <a id="15879" href="Cat.Functor.Adjoint.html#15879" class="Bound">other-map</a> <a id="15889" class="Symbol">.</a><a id="15890" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a> <a id="15897" class="Symbol">.</a><a id="15898" href="Cat.Instances.Comma.html#2646" data-type="(r : ↓Hom F G a b) →
C ._∘_ (map b) (F₁ F (r .α)) ≡ C ._∘_ (F₁ G (r .β)) (a .map)" class="Field">↓Hom.sq</a> <a id="15906" class="Symbol">=</a>
    <a id="15912" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="15916" class="Symbol">(</a>
      <a id="15924" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">R.₁</a> <a id="15928" class="Symbol">(</a><a id="15929" href="Cat.Functor.Adjoint.html#2466" class="Function">adj.counit.ε</a> <a id="15942" class="Symbol">_</a> <a id="15944" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="15948" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">L.₁</a> <a id="15952" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">om.map</a><a id="15958" class="Symbol">)</a> <a id="15960" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="15964" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Function">adj.unit.η</a> <a id="15975" class="Symbol">_</a>       <span class="reasoning-step"><span class="as-written Function"><a id="15983" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="15986" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="15990" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C._∘_</a> <a id="15996" class="Symbol">(</a><a id="15997" href="Cat.Base.html#8383" data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" class="Function">R.F-∘</a> <a id="16003" class="Symbol">_</a> <a id="16005" class="Symbol">_)</a> <a id="16008" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="16013" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="16015" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="16019" class="Symbol">(</a><a id="16020" href="Cat.Base.html#3857" data-type="(r : Precategory o h) (f : r .Hom y z) (g : r .Hom x y)
(h : r .Hom w x) →
r ._∘_ f (r ._∘_ g h) ≡ r ._∘_ (r ._∘_ f g) h" class="Function">C.assoc</a> <a id="16028" class="Symbol">_</a> <a id="16030" class="Symbol">_</a> <a id="16032" class="Symbol">_)</a> <a id="16035" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="16043" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">R.₁</a> <a id="16047" class="Symbol">(</a><a id="16048" href="Cat.Functor.Adjoint.html#2466" class="Function">adj.counit.ε</a> <a id="16061" class="Symbol">_)</a> <a id="16064" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="16068" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">R.₁</a> <a id="16072" class="Symbol">(</a><a id="16073" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">L.₁</a> <a id="16077" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">om.map</a><a id="16083" class="Symbol">)</a> <a id="16085" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="16089" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Function">adj.unit.η</a> <a id="16100" class="Symbol">_</a> <span class="reasoning-step"><span class="as-written Function Operator"><a id="16102" href="1Lab.Path.html#46783" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">≡˘⟨</a> <a id="16106" href="Cat.Reasoning.html#4627" data-type="(C : Precategory o ℓ) → g ≡ h → (C ∘ f) g ≡ (C ∘ f) h" class="Function Operator">C.refl⟩∘⟨</a> <a id="16116" href="Cat.Base.html#13369" data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" class="Function">adj.unit.is-natural</a> <a id="16136" class="Symbol">_</a> <a id="16138" class="Symbol">_</a> <a id="16140" class="Symbol">_</a> <a id="16142" href="1Lab.Path.html#46783" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡˘</span></span>
      <a id="16150" class="Symbol">(</a><a id="16151" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">R.₁</a> <a id="16155" class="Symbol">(</a><a id="16156" href="Cat.Functor.Adjoint.html#2466" class="Function">adj.counit.ε</a> <a id="16169" class="Symbol">_)</a> <a id="16172" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="16176" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Function">adj.unit.η</a> <a id="16187" class="Symbol">_</a> <a id="16189" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="16193" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">om.map</a><a id="16199" class="Symbol">)</a>         <span class="reasoning-step"><span class="as-written Function"><a id="16209" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="16212" href="Cat.Reasoning.html#2621" data-type="(C : Precategory o ℓ) (inv₁ : (C ∘ h) i ≡ id C) →
(C ∘ h) ((C ∘ i) f) ≡ f" class="Function">C.cancell</a> <a id="16222" href="Cat.Functor.Adjoint.html#3006" data-type="(r : L ⊣ R₁) →
C ._∘_ (F₁ R₁ (η (r .counit) B₁)) (r .unit .η (F₀ R₁ B₁)) ≡ C .id" class="Field">adj.zag</a> <a id="16230" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="16238" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">om.map</a>                                                     <span class="reasoning-step"><span class="as-written Function"><a id="16297" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="16300" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="16304" class="Symbol">(</a><a id="16305" href="Cat.Base.html#3437" data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ f (r .id) ≡ f" class="Function">C.idr</a> <a id="16311" class="Symbol">_)</a> <a id="16314" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="16322" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">om.map</a> <a id="16329" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="16333" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">C.id</a>                                            <a id="16381" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
    <a id="16387" class="Symbol">)</a>
    <a id="16393" class="Keyword">where</a> <a id="16399" class="Keyword">module</a> <a id="16406" href="Cat.Functor.Adjoint.html#16406" class="Module">om</a> <a id="16409" class="Symbol">=</a> <a id="16411" href="Cat.Instances.Comma.html#1730" data-type="(F : Functor A C) (G : Functor B₁ C) → Type (ao ⊔ bo ⊔ h)" class="Module">↓Obj</a> <a id="16416" href="Cat.Functor.Adjoint.html#15879" class="Bound">other-map</a>
</pre>
<p>Checking that the triangle above commutes is a routine application of naturality and the triangle identities; The same is true for proving that the map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span> above is unique.</p>
<pre class="Agda">  <a id="16615" href="Cat.Functor.Adjoint.html#15615" data-type="(adj : L ⊣ R₁) (x : C .Ob) →
is-initial (x ↙ R₁) (L⊣R→map-to-R adj x)" class="Function">L⊣R→map-to-R-is-initial</a> <a id="16639" href="Cat.Functor.Adjoint.html#16639" class="Bound">x</a> <a id="16641" href="Cat.Functor.Adjoint.html#16641" class="Bound">other-map</a> <a id="16651" class="Symbol">.</a><a id="16652" href="1Lab.HLevel.html#1416" data-type="(r : is-contr A) (x : A) → r .centre ≡ x" class="Field">paths</a> <a id="16658" href="Cat.Functor.Adjoint.html#16658" class="Bound">y</a> <a id="16660" class="Symbol">=</a>
    <a id="16666" href="Cat.Instances.Comma.html#3372" data-type="(F : Functor A C) (G : Functor B₁ C) →
f .α ≡ g .α → f .β ≡ g .β → f ≡ g" class="Function">↓Hom-path</a> <a id="16676" class="Symbol">_</a> <a id="16678" class="Symbol">_</a> <a id="16680" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="16685" class="Symbol">(</a>
      <a id="16693" href="Cat.Functor.Adjoint.html#2466" class="Function">adj.counit.ε</a> <a id="16706" class="Symbol">_</a> <a id="16708" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="16712" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">L.₁</a> <a id="16716" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Function">om.map</a>                            <span class="reasoning-step"><span class="as-written Function"><a id="16750" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="16753" href="Cat.Reasoning.html#4627" data-type="(C : Precategory o ℓ) → g ≡ h → (C ∘ f) g ≡ (C ∘ f) h" class="Function Operator">D.refl⟩∘⟨</a> <a id="16763" href="Cat.Functor.Reasoning.html#1463" data-type="(F : Functor 𝒞 𝒟) (c≡ab : c ≡ (F ∘ a) b) →
F₁ F c ≡ (F ∘ F₁ F a) (F₁ F b)" class="Function">L.expand</a> <a id="16772" class="Symbol">(</a><a id="16773" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="16777" class="Symbol">(</a><a id="16778" href="Cat.Base.html#3437" data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ f (r .id) ≡ f" class="Function">C.idr</a> <a id="16784" class="Symbol">_)</a> <a id="16787" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="16789" href="Cat.Functor.Adjoint.html#16658" class="Bound">y</a> <a id="16791" class="Symbol">.</a><a id="16792" href="Cat.Instances.Comma.html#2646" data-type="(r : ↓Hom F G a b) →
C ._∘_ (map b) (F₁ F (r .α)) ≡ C ._∘_ (F₁ G (r .β)) (a .map)" class="Field">↓Hom.sq</a><a id="16799" class="Symbol">)</a> <a id="16801" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="16809" href="Cat.Functor.Adjoint.html#2466" class="Function">adj.counit.ε</a> <a id="16822" class="Symbol">_</a> <a id="16824" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="16828" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">L.₁</a> <a id="16832" class="Symbol">(</a><a id="16833" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">R.₁</a> <a id="16837" href="Cat.Instances.Comma.html#2621" data-type="↓Hom F G a b → Hom B₁ (a .y) (y b)" class="Field">y.β</a><a id="16840" class="Symbol">)</a> <a id="16842" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="16846" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">L.₁</a> <a id="16850" class="Symbol">(</a><a id="16851" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Function">adj.unit.η</a> <a id="16862" class="Symbol">_)</a>  <span class="reasoning-step"><span class="as-written Function"><a id="16866" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="16869" href="Cat.Reasoning.html#1548" data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ a) ((C ∘ b) f) ≡ (C ∘ c) f" class="Function">D.pulll</a> <a id="16877" class="Symbol">(</a><a id="16878" href="Cat.Base.html#13369" data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" class="Function">adj.counit.is-natural</a> <a id="16900" class="Symbol">_</a> <a id="16902" class="Symbol">_</a> <a id="16904" class="Symbol">_)</a> <a id="16907" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span> <a id="16909" class="Comment">-- nvmd</a>
      <a id="16923" class="Symbol">(</a><a id="16924" href="Cat.Instances.Comma.html#2621" data-type="↓Hom F G a b → Hom B₁ (a .y) (y b)" class="Field">y.β</a> <a id="16928" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="16932" href="Cat.Functor.Adjoint.html#2466" class="Function">adj.counit.ε</a> <a id="16945" class="Symbol">_)</a> <a id="16948" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="16952" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">L.₁</a> <a id="16956" class="Symbol">(</a><a id="16957" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Function">adj.unit.η</a> <a id="16968" class="Symbol">_)</a>          <span class="reasoning-step"><span class="as-written Function"><a id="16980" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="16983" href="Cat.Reasoning.html#2731" data-type="(C : Precategory o ℓ) (inv₁ : (C ∘ h) i ≡ id C) →
(C ∘ (C ∘ f) h) i ≡ f" class="Function">D.cancelr</a> <a id="16993" href="Cat.Functor.Adjoint.html#2943" data-type="(r : L ⊣ R₁) →
D ._∘_ (η (r .counit) (F₀ L A)) (F₁ L (r .unit .η A)) ≡ D .id" class="Field">adj.zig</a> <a id="17001" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="17009" href="Cat.Instances.Comma.html#2621" data-type="↓Hom F G a b → Hom B₁ (a .y) (y b)" class="Field">y.β</a>                                                      <a id="17066" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
    <a id="17072" class="Symbol">)</a>
    <a id="17078" class="Keyword">where</a>
      <a id="17090" class="Keyword">module</a> <a id="17097" href="Cat.Functor.Adjoint.html#17097" class="Module">om</a> <a id="17100" class="Symbol">=</a> <a id="17102" href="Cat.Instances.Comma.html#1730" data-type="(F : Functor A C) (G : Functor B₁ C) → Type (ao ⊔ bo ⊔ h)" class="Module">↓Obj</a> <a id="17107" href="Cat.Functor.Adjoint.html#16641" class="Bound">other-map</a>
      <a id="17123" class="Keyword">module</a> <a id="17130" href="Cat.Functor.Adjoint.html#17130" class="Module">y</a> <a id="17132" class="Symbol">=</a> <a id="17134" href="Cat.Instances.Comma.html#2452" data-type="(F : Functor A C) (G : Functor B₁ C) (a b : ↓Obj F G) →
Type (ah ⊔ bh ⊔ h)" class="Module">↓Hom</a> <a id="17139" href="Cat.Functor.Adjoint.html#16658" class="Bound">y</a>
</pre>
<p>Hence, we can safely say that having a functor <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span> and an adjunction <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>⊣</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">L \dashv R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊣</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> is the same thing as having a functor <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> and a system of universal arrows into <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>:</span></p>
<pre class="Agda">  <a id="17320" href="Cat.Functor.Adjoint.html#17320" data-type="L ⊣ R₁ → (x : C .Ob) → Universal-morphism x R₁" class="Function">L⊣R→universal-maps</a> <a id="17339" class="Symbol">:</a> <a id="17341" class="Symbol">∀</a> <a id="17343" href="Cat.Functor.Adjoint.html#17343" class="Bound">x</a> <a id="17345" class="Symbol">→</a> <a id="17347" href="Cat.Functor.Adjoint.html#5472" data-type="C .Ob → Functor D C → Type (h ⊔ o&#39; ⊔ h&#39;)" class="Function">Universal-morphism</a> <a id="17366" href="Cat.Functor.Adjoint.html#17343" class="Bound">x</a> <a id="17368" href="Cat.Functor.Adjoint.html#13957" class="Bound">R</a>
  <a id="17372" href="Cat.Functor.Adjoint.html#17320" data-type="L ⊣ R₁ → (x : C .Ob) → Universal-morphism x R₁" class="Function">L⊣R→universal-maps</a> <a id="17391" href="Cat.Functor.Adjoint.html#17391" class="Bound">x</a> <a id="17393" class="Symbol">.</a><a id="17394" href="Cat.Diagram.Initial.html#442" data-type="Initial C → Ob C" class="Field">Initial.bot</a> <a id="17406" class="Symbol">=</a> <a id="17408" href="Cat.Functor.Adjoint.html#14588" data-type="L ⊣ R₁ → (x : C .Ob) → Ob (x ↙ R₁)" class="Function">L⊣R→map-to-R</a> <a id="17421" href="Cat.Functor.Adjoint.html#17391" class="Bound">x</a>
  <a id="17425" href="Cat.Functor.Adjoint.html#17320" data-type="L ⊣ R₁ → (x : C .Ob) → Universal-morphism x R₁" class="Function">L⊣R→universal-maps</a> <a id="17444" href="Cat.Functor.Adjoint.html#17444" class="Bound">x</a> <a id="17446" class="Symbol">.</a><a id="17447" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Field">Initial.has⊥</a> <a id="17460" class="Symbol">=</a> <a id="17462" href="Cat.Functor.Adjoint.html#15615" data-type="(adj : L ⊣ R₁) (x : C .Ob) →
is-initial (x ↙ R₁) (L⊣R→map-to-R adj x)" class="Function">L⊣R→map-to-R-is-initial</a> <a id="17486" href="Cat.Functor.Adjoint.html#17444" class="Bound">x</a>
</pre>
<!-- TODO [Amy 2022-03-02]
prove that we recover L by going L⊣R → universal maps → L⊣R. this is
straightforward but I'm tired
-->
<h1 id="adjuncts"><a href="#adjuncts" class="header-link">Adjuncts<span class="header-link-emoji">🔗</span></a></h1>
<p>Another view on adjunctions, one which is productive when thinking about adjoint <em>endo</em>functors <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>⊣</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">L \dashv R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊣</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>,</span> is the concept of <em>adjuncts</em>. Any pair of natural transformations <em>typed like</em> a unit and counit allow you to pass between the Hom-sets <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>L</mi><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\hom(La,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">hom</span><span class="mopen">(</span><span class="mord mathnormal">L</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span> and <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>R</mi><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\hom(a,Rb)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">hom</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>,</span> by composing the functorial action of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span> (resp <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>)</span> with the natural transformations:</p>
<!--
<pre class="Agda"><a id="18014" class="Keyword">module</a> <a id="18021" href="Cat.Functor.Adjoint.html#18021" class="Module">_</a> <a id="18023" class="Symbol">{</a><a id="18024" href="Cat.Functor.Adjoint.html#18024" class="Bound">L</a> <a id="18026" class="Symbol">:</a> <a id="18028" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="18036" href="Cat.Functor.Adjoint.html#500" class="Generalizable">C</a> <a id="18038" href="Cat.Functor.Adjoint.html#502" class="Generalizable">D</a><a id="18039" class="Symbol">}</a> <a id="18041" class="Symbol">{</a><a id="18042" href="Cat.Functor.Adjoint.html#18042" class="Bound">R</a> <a id="18044" class="Symbol">:</a> <a id="18046" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="18054" href="Cat.Functor.Adjoint.html#502" class="Generalizable">D</a> <a id="18056" href="Cat.Functor.Adjoint.html#500" class="Generalizable">C</a><a id="18057" class="Symbol">}</a> <a id="18059" class="Symbol">(</a><a id="18060" href="Cat.Functor.Adjoint.html#18060" class="Bound">adj</a> <a id="18064" class="Symbol">:</a> <a id="18066" href="Cat.Functor.Adjoint.html#18024" class="Bound">L</a> <a id="18068" href="Cat.Functor.Adjoint.html#2192" data-type="(L : Functor C D) (R₁ : Functor D C) → Type (C.o ⊔ C.h ⊔ D.o ⊔ D.h)" class="Record Operator">⊣</a> <a id="18070" href="Cat.Functor.Adjoint.html#18042" class="Bound">R</a><a id="18071" class="Symbol">)</a> <a id="18073" class="Keyword">where</a>
  <a id="18081" class="Keyword">private</a>
    <a id="18093" class="Keyword">module</a> <a id="18100" href="Cat.Functor.Adjoint.html#18100" class="Module">L</a> <a id="18102" class="Symbol">=</a> <a id="18104" href="Cat.Functor.Reasoning.html" class="Module">Func</a> <a id="18109" href="Cat.Functor.Adjoint.html#18024" class="Bound">L</a>
    <a id="18115" class="Keyword">module</a> <a id="18122" href="Cat.Functor.Adjoint.html#18122" class="Module">R</a> <a id="18124" class="Symbol">=</a> <a id="18126" href="Cat.Functor.Reasoning.html" class="Module">Func</a> <a id="18131" href="Cat.Functor.Adjoint.html#18042" class="Bound">R</a>
    <a id="18137" class="Keyword">module</a> <a id="18144" href="Cat.Functor.Adjoint.html#18144" class="Module">C</a> <a id="18146" class="Symbol">=</a> <a id="18148" href="Cat.Reasoning.html" class="Module">Cat.Reasoning</a> <a id="18162" href="Cat.Functor.Adjoint.html#18036" class="Bound">C</a>
    <a id="18168" class="Keyword">module</a> <a id="18175" href="Cat.Functor.Adjoint.html#18175" class="Module">D</a> <a id="18177" class="Symbol">=</a> <a id="18179" href="Cat.Reasoning.html" class="Module">Cat.Reasoning</a> <a id="18193" href="Cat.Functor.Adjoint.html#18038" class="Bound">D</a>
    <a id="18199" class="Keyword">module</a> <a id="18206" href="Cat.Functor.Adjoint.html#18206" class="Module">adj</a> <a id="18210" class="Symbol">=</a> <a id="18212" href="Cat.Functor.Adjoint.html#2192" data-type="(L : Functor C D) (R₁ : Functor D C) → Type (C.o ⊔ C.h ⊔ D.o ⊔ D.h)" class="Module Operator">_⊣_</a> <a id="18216" href="Cat.Functor.Adjoint.html#18060" class="Bound">adj</a>
</pre>-->
<pre class="Agda">  <a id="18239" href="Cat.Functor.Adjoint.html#18239" data-type="(adj : L ⊣ R₁) → D .Hom (₀ L a) b → C .Hom a (₀ R₁ b)" class="Function">L-adjunct</a> <a id="18249" class="Symbol">:</a> <a id="18251" class="Symbol">∀</a> <a id="18253" class="Symbol">{</a><a id="18254" href="Cat.Functor.Adjoint.html#18254" class="Bound">a</a> <a id="18256" href="Cat.Functor.Adjoint.html#18256" class="Bound">b</a><a id="18257" class="Symbol">}</a> <a id="18259" class="Symbol">→</a> <a id="18261" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">D.Hom</a> <a id="18267" class="Symbol">(</a><a id="18268" href="Cat.Base.html#8727" data-type="(r : Functor C D) → C .Ob → D .Ob" class="Function">L.₀</a> <a id="18272" href="Cat.Functor.Adjoint.html#18254" class="Bound">a</a><a id="18273" class="Symbol">)</a> <a id="18275" href="Cat.Functor.Adjoint.html#18256" class="Bound">b</a> <a id="18277" class="Symbol">→</a> <a id="18279" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">C.Hom</a> <a id="18285" href="Cat.Functor.Adjoint.html#18254" class="Bound">a</a> <a id="18287" class="Symbol">(</a><a id="18288" href="Cat.Base.html#8727" data-type="(r : Functor C D) → C .Ob → D .Ob" class="Function">R.₀</a> <a id="18292" href="Cat.Functor.Adjoint.html#18256" class="Bound">b</a><a id="18293" class="Symbol">)</a>
  <a id="18297" href="Cat.Functor.Adjoint.html#18239" data-type="(adj : L ⊣ R₁) → D .Hom (₀ L a) b → C .Hom a (₀ R₁ b)" class="Function">L-adjunct</a> <a id="18307" href="Cat.Functor.Adjoint.html#18307" class="Bound">f</a> <a id="18309" class="Symbol">=</a> <a id="18311" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">R.₁</a> <a id="18315" href="Cat.Functor.Adjoint.html#18307" class="Bound">f</a> <a id="18317" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="18321" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Function">adj.unit.η</a> <a id="18332" class="Symbol">_</a>

  <a id="18337" href="Cat.Functor.Adjoint.html#18337" data-type="(adj : L ⊣ R₁) → C .Hom a (₀ R₁ b) → D .Hom (₀ L a) b" class="Function">R-adjunct</a> <a id="18347" class="Symbol">:</a> <a id="18349" class="Symbol">∀</a> <a id="18351" class="Symbol">{</a><a id="18352" href="Cat.Functor.Adjoint.html#18352" class="Bound">a</a> <a id="18354" href="Cat.Functor.Adjoint.html#18354" class="Bound">b</a><a id="18355" class="Symbol">}</a> <a id="18357" class="Symbol">→</a> <a id="18359" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">C.Hom</a> <a id="18365" href="Cat.Functor.Adjoint.html#18352" class="Bound">a</a> <a id="18367" class="Symbol">(</a><a id="18368" href="Cat.Base.html#8727" data-type="(r : Functor C D) → C .Ob → D .Ob" class="Function">R.₀</a> <a id="18372" href="Cat.Functor.Adjoint.html#18354" class="Bound">b</a><a id="18373" class="Symbol">)</a> <a id="18375" class="Symbol">→</a> <a id="18377" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">D.Hom</a> <a id="18383" class="Symbol">(</a><a id="18384" href="Cat.Base.html#8727" data-type="(r : Functor C D) → C .Ob → D .Ob" class="Function">L.₀</a> <a id="18388" href="Cat.Functor.Adjoint.html#18352" class="Bound">a</a><a id="18389" class="Symbol">)</a> <a id="18391" href="Cat.Functor.Adjoint.html#18354" class="Bound">b</a>
  <a id="18395" href="Cat.Functor.Adjoint.html#18337" data-type="(adj : L ⊣ R₁) → C .Hom a (₀ R₁ b) → D .Hom (₀ L a) b" class="Function">R-adjunct</a> <a id="18405" href="Cat.Functor.Adjoint.html#18405" class="Bound">f</a> <a id="18407" class="Symbol">=</a> <a id="18409" href="Cat.Functor.Adjoint.html#2466" class="Function">adj.counit.ε</a> <a id="18422" class="Symbol">_</a> <a id="18424" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="18428" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">L.₁</a> <a id="18432" href="Cat.Functor.Adjoint.html#18405" class="Bound">f</a>
</pre>
<p>The important part that the actual data of an adjunction gets you is these functions are inverse <em>equivalences</em> between the hom-sets <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>L</mi><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>≅</mo><mi>hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>R</mi><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\hom(La,b) \cong \hom(a,Rb)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">hom</span><span class="mopen">(</span><span class="mord mathnormal">L</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">hom</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>.</span></p>
<pre class="Agda">  <a id="18614" href="Cat.Functor.Adjoint.html#18614" data-type="(adj : L ⊣ R₁) → is-right-inverse (R-adjunct adj) (L-adjunct adj)" class="Function">L-R-adjunct</a> <a id="18626" class="Symbol">:</a> <a id="18628" class="Symbol">∀</a> <a id="18630" class="Symbol">{</a><a id="18631" href="Cat.Functor.Adjoint.html#18631" class="Bound">a</a> <a id="18633" href="Cat.Functor.Adjoint.html#18633" class="Bound">b</a><a id="18634" class="Symbol">}</a> <a id="18636" class="Symbol">→</a> <a id="18638" href="1Lab.Equiv.html#5739" data-type="(B₁ → A) → (A → B₁) → Type B.ℓ₁" class="Function">is-right-inverse</a> <a id="18655" class="Symbol">(</a><a id="18656" href="Cat.Functor.Adjoint.html#18337" data-type="(adj : L ⊣ R₁) → C .Hom a (₀ R₁ b) → D .Hom (₀ L a) b" class="Function">R-adjunct</a> <a id="18666" class="Symbol">{</a><a id="18667" href="Cat.Functor.Adjoint.html#18631" class="Bound">a</a><a id="18668" class="Symbol">}</a> <a id="18670" class="Symbol">{</a><a id="18671" href="Cat.Functor.Adjoint.html#18633" class="Bound">b</a><a id="18672" class="Symbol">})</a> <a id="18675" href="Cat.Functor.Adjoint.html#18239" data-type="(adj : L ⊣ R₁) → D .Hom (₀ L a) b → C .Hom a (₀ R₁ b)" class="Function">L-adjunct</a>
  <a id="18687" href="Cat.Functor.Adjoint.html#18614" data-type="(adj : L ⊣ R₁) → is-right-inverse (R-adjunct adj) (L-adjunct adj)" class="Function">L-R-adjunct</a> <a id="18699" href="Cat.Functor.Adjoint.html#18699" class="Bound">f</a> <a id="18701" class="Symbol">=</a>
    <a id="18707" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">R.₁</a> <a id="18711" class="Symbol">(</a><a id="18712" href="Cat.Functor.Adjoint.html#2466" class="Function">adj.counit.ε</a> <a id="18725" class="Symbol">_</a> <a id="18727" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="18731" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">L.₁</a> <a id="18735" href="Cat.Functor.Adjoint.html#18699" class="Bound">f</a><a id="18736" class="Symbol">)</a> <a id="18738" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="18742" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Function">adj.unit.η</a> <a id="18753" class="Symbol">_</a>        <span class="reasoning-step"><span class="as-written Function"><a id="18762" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="18765" href="Cat.Functor.Reasoning.html#1533" data-type="(F : Functor 𝒞 𝒟) (c≡ab : c ≡ (F ∘ a) b) →
(F ∘ F₁ F c) f ≡ (F ∘ F₁ F a) ((F ∘ F₁ F b) f)" class="Function">R.pushl</a> <a id="18773" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="18778" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="18784" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">R.₁</a> <a id="18788" class="Symbol">(</a><a id="18789" href="Cat.Functor.Adjoint.html#2466" class="Function">adj.counit.ε</a> <a id="18802" class="Symbol">_)</a> <a id="18805" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="18809" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">R.₁</a> <a id="18813" class="Symbol">(</a><a id="18814" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">L.₁</a> <a id="18818" href="Cat.Functor.Adjoint.html#18699" class="Bound">f</a><a id="18819" class="Symbol">)</a> <a id="18821" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="18825" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Function">adj.unit.η</a> <a id="18836" class="Symbol">_</a>  <span class="reasoning-step"><span class="as-written Function Operator"><a id="18839" href="1Lab.Path.html#46783" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">≡˘⟨</a> <a id="18843" href="Cat.Reasoning.html#4627" data-type="(C : Precategory o ℓ) → g ≡ h → (C ∘ f) g ≡ (C ∘ f) h" class="Function Operator">C.refl⟩∘⟨</a> <a id="18853" href="Cat.Base.html#13369" data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" class="Function">adj.unit.is-natural</a> <a id="18873" class="Symbol">_</a> <a id="18875" class="Symbol">_</a> <a id="18877" class="Symbol">_</a> <a id="18879" href="1Lab.Path.html#46783" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡˘</span></span>
    <a id="18885" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">R.₁</a> <a id="18889" class="Symbol">(</a><a id="18890" href="Cat.Functor.Adjoint.html#2466" class="Function">adj.counit.ε</a> <a id="18903" class="Symbol">_)</a> <a id="18906" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="18910" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Function">adj.unit.η</a> <a id="18921" class="Symbol">_</a> <a id="18923" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="18927" href="Cat.Functor.Adjoint.html#18699" class="Bound">f</a>            <span class="reasoning-step"><span class="as-written Function"><a id="18940" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="18943" href="Cat.Reasoning.html#2621" data-type="(C : Precategory o ℓ) (inv₁ : (C ∘ h) i ≡ id C) →
(C ∘ h) ((C ∘ i) f) ≡ f" class="Function">C.cancell</a> <a id="18953" href="Cat.Functor.Adjoint.html#3006" data-type="(r : L ⊣ R₁) →
C ._∘_ (F₁ R₁ (η (r .counit) B₁)) (r .unit .η (F₀ R₁ B₁)) ≡ C .id" class="Field">adj.zag</a> <a id="18961" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="18967" href="Cat.Functor.Adjoint.html#18699" class="Bound">f</a>                                                      <a id="19022" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>

  <a id="19027" href="Cat.Functor.Adjoint.html#19027" data-type="(adj : L ⊣ R₁) → is-left-inverse (R-adjunct adj) (L-adjunct adj)" class="Function">R-L-adjunct</a> <a id="19039" class="Symbol">:</a> <a id="19041" class="Symbol">∀</a> <a id="19043" class="Symbol">{</a><a id="19044" href="Cat.Functor.Adjoint.html#19044" class="Bound">a</a> <a id="19046" href="Cat.Functor.Adjoint.html#19046" class="Bound">b</a><a id="19047" class="Symbol">}</a> <a id="19049" class="Symbol">→</a> <a id="19051" href="1Lab.Equiv.html#5649" data-type="(B₁ → A) → (A → B₁) → Type A.ℓ₁" class="Function">is-left-inverse</a> <a id="19067" class="Symbol">(</a><a id="19068" href="Cat.Functor.Adjoint.html#18337" data-type="(adj : L ⊣ R₁) → C .Hom a (₀ R₁ b) → D .Hom (₀ L a) b" class="Function">R-adjunct</a> <a id="19078" class="Symbol">{</a><a id="19079" href="Cat.Functor.Adjoint.html#19044" class="Bound">a</a><a id="19080" class="Symbol">}</a> <a id="19082" class="Symbol">{</a><a id="19083" href="Cat.Functor.Adjoint.html#19046" class="Bound">b</a><a id="19084" class="Symbol">})</a> <a id="19087" href="Cat.Functor.Adjoint.html#18239" data-type="(adj : L ⊣ R₁) → D .Hom (₀ L a) b → C .Hom a (₀ R₁ b)" class="Function">L-adjunct</a>
  <a id="19099" href="Cat.Functor.Adjoint.html#19027" data-type="(adj : L ⊣ R₁) → is-left-inverse (R-adjunct adj) (L-adjunct adj)" class="Function">R-L-adjunct</a> <a id="19111" href="Cat.Functor.Adjoint.html#19111" class="Bound">f</a> <a id="19113" class="Symbol">=</a>
    <a id="19119" href="Cat.Functor.Adjoint.html#2466" class="Function">adj.counit.ε</a> <a id="19132" class="Symbol">_</a> <a id="19134" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="19138" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">L.₁</a> <a id="19142" class="Symbol">(</a><a id="19143" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">R.₁</a> <a id="19147" href="Cat.Functor.Adjoint.html#19111" class="Bound">f</a> <a id="19149" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="19153" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Function">adj.unit.η</a> <a id="19164" class="Symbol">_)</a>       <span class="reasoning-step"><span class="as-written Function"><a id="19173" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="19176" href="Cat.Reasoning.html#4627" data-type="(C : Precategory o ℓ) → g ≡ h → (C ∘ f) g ≡ (C ∘ f) h" class="Function Operator">D.refl⟩∘⟨</a> <a id="19186" href="Cat.Base.html#8383" data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" class="Function">L.F-∘</a> <a id="19192" class="Symbol">_</a> <a id="19194" class="Symbol">_</a> <a id="19196" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="19202" href="Cat.Functor.Adjoint.html#2466" class="Function">adj.counit.ε</a> <a id="19215" class="Symbol">_</a> <a id="19217" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="19221" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">L.₁</a> <a id="19225" class="Symbol">(</a><a id="19226" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">R.₁</a> <a id="19230" href="Cat.Functor.Adjoint.html#19111" class="Bound">f</a><a id="19231" class="Symbol">)</a> <a id="19233" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="19237" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">L.₁</a> <a id="19241" class="Symbol">(</a><a id="19242" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Function">adj.unit.η</a> <a id="19253" class="Symbol">_)</a> <span class="reasoning-step"><span class="as-written Function"><a id="19256" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="19259" href="Cat.Reasoning.html#2007" data-type="(C : Precategory o ℓ) (p : (C ∘ f) h ≡ (C ∘ g) i) →
(C ∘ f) ((C ∘ h) b) ≡ (C ∘ g) ((C ∘ i) b)" class="Function">D.extendl</a> <a id="19269" class="Symbol">(</a><a id="19270" href="Cat.Base.html#13369" data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" class="Function">adj.counit.is-natural</a> <a id="19292" class="Symbol">_</a> <a id="19294" class="Symbol">_</a> <a id="19296" class="Symbol">_)</a> <a id="19299" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="19305" href="Cat.Functor.Adjoint.html#19111" class="Bound">f</a> <a id="19307" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="19311" href="Cat.Functor.Adjoint.html#2466" class="Function">adj.counit.ε</a> <a id="19324" class="Symbol">_</a> <a id="19326" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="19330" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">L.₁</a> <a id="19334" class="Symbol">(</a><a id="19335" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Function">adj.unit.η</a> <a id="19346" class="Symbol">_)</a>           <span class="reasoning-step"><span class="as-written Function"><a id="19359" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="19362" href="Cat.Reasoning.html#1108" data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → (C ∘ f) a ≡ f" class="Function">D.elimr</a> <a id="19370" href="Cat.Functor.Adjoint.html#2943" data-type="(r : L ⊣ R₁) →
D ._∘_ (η (r .counit) (F₀ L A)) (F₁ L (r .unit .η A)) ≡ D .id" class="Field">adj.zig</a> <a id="19378" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="19384" href="Cat.Functor.Adjoint.html#19111" class="Bound">f</a>                                                     <a id="19438" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>

  <a id="19443" href="Cat.Functor.Adjoint.html#19443" data-type="(adj : L ⊣ R₁) → is-equiv (L-adjunct adj)" class="Function">L-adjunct-is-equiv</a> <a id="19462" class="Symbol">:</a> <a id="19464" class="Symbol">∀</a> <a id="19466" class="Symbol">{</a><a id="19467" href="Cat.Functor.Adjoint.html#19467" class="Bound">a</a> <a id="19469" href="Cat.Functor.Adjoint.html#19469" class="Bound">b</a><a id="19470" class="Symbol">}</a> <a id="19472" class="Symbol">→</a> <a id="19474" href="1Lab.Equiv.html#2286" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-equiv</a> <a id="19483" class="Symbol">(</a><a id="19484" href="Cat.Functor.Adjoint.html#18239" data-type="(adj : L ⊣ R₁) → D .Hom (₀ L a) b → C .Hom a (₀ R₁ b)" class="Function">L-adjunct</a> <a id="19494" class="Symbol">{</a><a id="19495" href="Cat.Functor.Adjoint.html#19467" class="Bound">a</a><a id="19496" class="Symbol">}</a> <a id="19498" class="Symbol">{</a><a id="19499" href="Cat.Functor.Adjoint.html#19469" class="Bound">b</a><a id="19500" class="Symbol">})</a>
  <a id="19505" href="Cat.Functor.Adjoint.html#19443" data-type="(adj : L ⊣ R₁) → is-equiv (L-adjunct adj)" class="Function">L-adjunct-is-equiv</a> <a id="19524" class="Symbol">=</a> <a id="19526" href="1Lab.Equiv.html#19815" data-type="(i : is-iso f) → is-equiv f" class="Function">is-iso→is-equiv</a>
    <a id="19546" class="Symbol">(</a><a id="19547" href="1Lab.Equiv.html#6116" data-type="(inv₁ : B₁ → A) (rinv₁ : is-right-inverse inv₁ f)
(linv₁ : is-left-inverse inv₁ f) →
is-iso f" class="InductiveConstructor">iso</a> <a id="19551" href="Cat.Functor.Adjoint.html#18337" data-type="(adj : L ⊣ R₁) → C .Hom a (₀ R₁ b) → D .Hom (₀ L a) b" class="Function">R-adjunct</a> <a id="19561" href="Cat.Functor.Adjoint.html#18614" data-type="(adj : L ⊣ R₁) → is-right-inverse (R-adjunct adj) (L-adjunct adj)" class="Function">L-R-adjunct</a> <a id="19573" href="Cat.Functor.Adjoint.html#19027" data-type="(adj : L ⊣ R₁) → is-left-inverse (R-adjunct adj) (L-adjunct adj)" class="Function">R-L-adjunct</a><a id="19584" class="Symbol">)</a>

  <a id="19589" href="Cat.Functor.Adjoint.html#19589" data-type="(adj : L ⊣ R₁) → is-equiv (R-adjunct adj)" class="Function">R-adjunct-is-equiv</a> <a id="19608" class="Symbol">:</a> <a id="19610" class="Symbol">∀</a> <a id="19612" class="Symbol">{</a><a id="19613" href="Cat.Functor.Adjoint.html#19613" class="Bound">a</a> <a id="19615" href="Cat.Functor.Adjoint.html#19615" class="Bound">b</a><a id="19616" class="Symbol">}</a> <a id="19618" class="Symbol">→</a> <a id="19620" href="1Lab.Equiv.html#2286" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-equiv</a> <a id="19629" class="Symbol">(</a><a id="19630" href="Cat.Functor.Adjoint.html#18337" data-type="(adj : L ⊣ R₁) → C .Hom a (₀ R₁ b) → D .Hom (₀ L a) b" class="Function">R-adjunct</a> <a id="19640" class="Symbol">{</a><a id="19641" href="Cat.Functor.Adjoint.html#19613" class="Bound">a</a><a id="19642" class="Symbol">}</a> <a id="19644" class="Symbol">{</a><a id="19645" href="Cat.Functor.Adjoint.html#19615" class="Bound">b</a><a id="19646" class="Symbol">})</a>
  <a id="19651" href="Cat.Functor.Adjoint.html#19589" data-type="(adj : L ⊣ R₁) → is-equiv (R-adjunct adj)" class="Function">R-adjunct-is-equiv</a> <a id="19670" class="Symbol">=</a> <a id="19672" href="1Lab.Equiv.html#19815" data-type="(i : is-iso f) → is-equiv f" class="Function">is-iso→is-equiv</a>
    <a id="19692" class="Symbol">(</a><a id="19693" href="1Lab.Equiv.html#6116" data-type="(inv₁ : B₁ → A) (rinv₁ : is-right-inverse inv₁ f)
(linv₁ : is-left-inverse inv₁ f) →
is-iso f" class="InductiveConstructor">iso</a> <a id="19697" href="Cat.Functor.Adjoint.html#18239" data-type="(adj : L ⊣ R₁) → D .Hom (₀ L a) b → C .Hom a (₀ R₁ b)" class="Function">L-adjunct</a> <a id="19707" href="Cat.Functor.Adjoint.html#19027" data-type="(adj : L ⊣ R₁) → is-left-inverse (R-adjunct adj) (L-adjunct adj)" class="Function">R-L-adjunct</a> <a id="19719" href="Cat.Functor.Adjoint.html#18614" data-type="(adj : L ⊣ R₁) → is-right-inverse (R-adjunct adj) (L-adjunct adj)" class="Function">L-R-adjunct</a><a id="19730" class="Symbol">)</a>
</pre>
<!--
<pre class="Agda"><a id="19750" class="Keyword">module</a> <a id="19757" href="Cat.Functor.Adjoint.html#19757" class="Module">_</a> <a id="19759" class="Symbol">{</a><a id="19760" href="Cat.Functor.Adjoint.html#19760" class="Bound">L</a> <a id="19762" class="Symbol">:</a> <a id="19764" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="19772" href="Cat.Functor.Adjoint.html#500" class="Generalizable">C</a> <a id="19774" href="Cat.Functor.Adjoint.html#502" class="Generalizable">D</a><a id="19775" class="Symbol">}</a> <a id="19777" class="Symbol">{</a><a id="19778" href="Cat.Functor.Adjoint.html#19778" class="Bound">R</a> <a id="19780" class="Symbol">:</a> <a id="19782" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="19790" href="Cat.Functor.Adjoint.html#502" class="Generalizable">D</a> <a id="19792" href="Cat.Functor.Adjoint.html#500" class="Generalizable">C</a><a id="19793" class="Symbol">}</a> <a id="19795" class="Symbol">(</a><a id="19796" href="Cat.Functor.Adjoint.html#19796" class="Bound">adj</a> <a id="19800" class="Symbol">:</a> <a id="19802" href="Cat.Functor.Adjoint.html#19760" class="Bound">L</a> <a id="19804" href="Cat.Functor.Adjoint.html#2192" data-type="(L : Functor C D) (R₁ : Functor D C) → Type (C.o ⊔ C.h ⊔ D.o ⊔ D.h)" class="Record Operator">⊣</a> <a id="19806" href="Cat.Functor.Adjoint.html#19778" class="Bound">R</a><a id="19807" class="Symbol">)</a> <a id="19809" class="Keyword">where</a>
  <a id="19817" class="Keyword">private</a>
    <a id="19829" class="Keyword">module</a> <a id="19836" href="Cat.Functor.Adjoint.html#19836" class="Module">L</a> <a id="19838" class="Symbol">=</a> <a id="19840" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Module">Functor</a> <a id="19848" href="Cat.Functor.Adjoint.html#19760" class="Bound">L</a>
    <a id="19854" class="Keyword">module</a> <a id="19861" href="Cat.Functor.Adjoint.html#19861" class="Module">R</a> <a id="19863" class="Symbol">=</a> <a id="19865" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Module">Functor</a> <a id="19873" href="Cat.Functor.Adjoint.html#19778" class="Bound">R</a>
    <a id="19879" class="Keyword">module</a> <a id="19886" href="Cat.Functor.Adjoint.html#19886" class="Module">C</a> <a id="19888" class="Symbol">=</a> <a id="19890" href="Cat.Reasoning.html" class="Module">Cat.Reasoning</a> <a id="19904" href="Cat.Functor.Adjoint.html#19772" class="Bound">C</a>
    <a id="19910" class="Keyword">module</a> <a id="19917" href="Cat.Functor.Adjoint.html#19917" class="Module">D</a> <a id="19919" class="Symbol">=</a> <a id="19921" href="Cat.Reasoning.html" class="Module">Cat.Reasoning</a> <a id="19935" href="Cat.Functor.Adjoint.html#19774" class="Bound">D</a>
    <a id="19941" class="Keyword">module</a> <a id="19948" href="Cat.Functor.Adjoint.html#19948" class="Module">adj</a> <a id="19952" class="Symbol">=</a> <a id="19954" href="Cat.Functor.Adjoint.html#2192" data-type="(L : Functor C D) (R₁ : Functor D C) → Type (C.o ⊔ C.h ⊔ D.o ⊔ D.h)" class="Module Operator">_⊣_</a> <a id="19958" href="Cat.Functor.Adjoint.html#19796" class="Bound">adj</a>

  <a id="19965" class="Keyword">open</a> <a id="19970" href="Cat.Functor.Adjoint.html#2192" data-type="(L : Functor C D) (R₁ : Functor D C) → Type (C.o ⊔ C.h ⊔ D.o ⊔ D.h)" class="Module Operator">_⊣_</a>
  <a id="19976" class="Keyword">open</a> <a id="19981" href="Cat.Base.html#12241" data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" class="Module Operator">_=&gt;_</a>

  <a id="19989" href="Cat.Functor.Adjoint.html#19989" data-type="(adj : L ⊣ R₁) → op R₁ ⊣ op L" class="Function">opposite-adjunction</a> <a id="20009" class="Symbol">:</a> <a id="20011" href="Cat.Base.html#8972" data-type="(r : Functor C D) → Functor (C ^op) (D ^op)" class="Function">R.op</a> <a id="20016" href="Cat.Functor.Adjoint.html#2192" data-type="(L : Functor C D) (R₁ : Functor D C) → Type (C.o ⊔ C.h ⊔ D.o ⊔ D.h)" class="Record Operator">⊣</a> <a id="20018" href="Cat.Base.html#8972" data-type="(r : Functor C D) → Functor (C ^op) (D ^op)" class="Function">L.op</a>
  <a id="20025" href="Cat.Functor.Adjoint.html#19989" data-type="(adj : L ⊣ R₁) → op R₁ ⊣ op L" class="Function">opposite-adjunction</a> <a id="20045" class="Symbol">.</a><a id="20046" href="Cat.Functor.Adjoint.html#2342" data-type="L ⊣ R₁ → Id =&gt; R₁ F∘ L" class="Field">unit</a> <a id="20051" class="Symbol">.</a><a id="20052" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="20054" class="Symbol">_</a> <a id="20056" class="Symbol">=</a> <a id="20058" href="Cat.Functor.Adjoint.html#2466" class="Function">adj.counit.ε</a> <a id="20071" class="Symbol">_</a>
  <a id="20075" href="Cat.Functor.Adjoint.html#19989" data-type="(adj : L ⊣ R₁) → op R₁ ⊣ op L" class="Function">opposite-adjunction</a> <a id="20095" class="Symbol">.</a><a id="20096" href="Cat.Functor.Adjoint.html#2342" data-type="L ⊣ R₁ → Id =&gt; R₁ F∘ L" class="Field">unit</a> <a id="20101" class="Symbol">.</a><a id="20102" href="Cat.Base.html#13369" data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" class="Field">is-natural</a> <a id="20113" href="Cat.Functor.Adjoint.html#20113" class="Bound">x</a> <a id="20115" href="Cat.Functor.Adjoint.html#20115" class="Bound">y</a> <a id="20117" href="Cat.Functor.Adjoint.html#20117" class="Bound">f</a> <a id="20119" class="Symbol">=</a> <a id="20121" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="20125" class="Symbol">(</a><a id="20126" href="Cat.Base.html#13369" data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" class="Function">adj.counit.is-natural</a> <a id="20148" class="Symbol">_</a> <a id="20150" class="Symbol">_</a> <a id="20152" class="Symbol">_)</a>
  <a id="20157" href="Cat.Functor.Adjoint.html#19989" data-type="(adj : L ⊣ R₁) → op R₁ ⊣ op L" class="Function">opposite-adjunction</a> <a id="20177" class="Symbol">.</a><a id="20178" href="Cat.Functor.Adjoint.html#2370" data-type="L ⊣ R₁ → L F∘ R₁ =&gt; Id" class="Field">counit</a> <a id="20185" class="Symbol">.</a><a id="20186" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="20188" class="Symbol">_</a> <a id="20190" class="Symbol">=</a> <a id="20192" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Function">adj.unit.η</a> <a id="20203" class="Symbol">_</a>
  <a id="20207" href="Cat.Functor.Adjoint.html#19989" data-type="(adj : L ⊣ R₁) → op R₁ ⊣ op L" class="Function">opposite-adjunction</a> <a id="20227" class="Symbol">.</a><a id="20228" href="Cat.Functor.Adjoint.html#2370" data-type="L ⊣ R₁ → L F∘ R₁ =&gt; Id" class="Field">counit</a> <a id="20235" class="Symbol">.</a><a id="20236" href="Cat.Base.html#13369" data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" class="Field">is-natural</a> <a id="20247" href="Cat.Functor.Adjoint.html#20247" class="Bound">x</a> <a id="20249" href="Cat.Functor.Adjoint.html#20249" class="Bound">y</a> <a id="20251" href="Cat.Functor.Adjoint.html#20251" class="Bound">f</a> <a id="20253" class="Symbol">=</a> <a id="20255" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="20259" class="Symbol">(</a><a id="20260" href="Cat.Base.html#13369" data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" class="Function">adj.unit.is-natural</a> <a id="20280" class="Symbol">_</a> <a id="20282" class="Symbol">_</a> <a id="20284" class="Symbol">_)</a>
  <a id="20289" href="Cat.Functor.Adjoint.html#19989" data-type="(adj : L ⊣ R₁) → op R₁ ⊣ op L" class="Function">opposite-adjunction</a> <a id="20309" class="Symbol">.</a><a id="20310" href="Cat.Functor.Adjoint.html#2943" data-type="(r : L ⊣ R₁) →
D ._∘_ (η (r .counit) (F₀ L A)) (F₁ L (r .unit .η A)) ≡ D .id" class="Field">zig</a> <a id="20314" class="Symbol">=</a> <a id="20316" href="Cat.Functor.Adjoint.html#3006" data-type="(r : L ⊣ R₁) →
C ._∘_ (F₁ R₁ (η (r .counit) B₁)) (r .unit .η (F₀ R₁ B₁)) ≡ C .id" class="Field">adj.zag</a>
  <a id="20326" href="Cat.Functor.Adjoint.html#19989" data-type="(adj : L ⊣ R₁) → op R₁ ⊣ op L" class="Function">opposite-adjunction</a> <a id="20346" class="Symbol">.</a><a id="20347" href="Cat.Functor.Adjoint.html#3006" data-type="(r : L ⊣ R₁) →
C ._∘_ (F₁ R₁ (η (r .counit) B₁)) (r .unit .η (F₀ R₁ B₁)) ≡ C .id" class="Field">zag</a> <a id="20351" class="Symbol">=</a> <a id="20353" href="Cat.Functor.Adjoint.html#2943" data-type="(r : L ⊣ R₁) →
D ._∘_ (η (r .counit) (F₀ L A)) (F₁ L (r .unit .η A)) ≡ D .id" class="Field">adj.zig</a>
</pre>-->
  </article>
</div>
</main>
</body>
</html>
