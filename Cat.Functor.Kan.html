<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="keywords" content="Agda,categories,topos" />

  <title>Cat.Functor.Kan - 1Lab</title>

  <link rel="stylesheet" href="/css/default.css" />
  <link rel="stylesheet" href="/css/katex.min.css" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Cat.Functor.Kan - 1Lab" />
  <meta name="twitter:image" content="https://1lab.dev/static/cube-128x.png" />

  <meta name="og:title" content="Cat.Functor.Kan - 1Lab" />
  <meta name="og:image" content="https://1lab.dev/static/cube-128x.png" />
  <meta name="og:site-name" content="1Lab" />
  <meta name="og:type" content="website" />

    <meta name="og:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="twitter:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  
  <script defer src="/main.js"></script>

  <noscript>
    <style>
      body span.reasoning-step .as-written {
        display: inline;
      }

      body span.reasoning-step .alternate {
        display: none;
      }
    </style>
  </noscript>

  <!-- Google font embeds -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;0,800;1,400;1,500;1,600;1,700;1,800&amp;family=Inria+Sans:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&amp;display=swap" rel="stylesheet">
</head>

<body class="text-page">
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <!-- Table of contents (only if the page has a table of contents) -->
    <aside id="toc">
    <div id="toc-container" style="min-width: 10em; font-size: 15pt;">
      <!-- Title for the page -->
      <h3 class="Agda" style="margin-top: 0; margin-bottom: 0; white-space: pre;">
                <a class="Module">Cat.Functor.Kan</a>
              </h3>

      <!-- Cube logo -->
      <a id="logo" href="/">
        <img alt="1Lab" src="/static/cube-72x.png" style="display: block; margin-bottom: 1em; margin: auto;" width="32px" height="32px" />
      </a>

      <!-- Actual table of contents (separated from the rest by
      horizontal rules) -->
      <hr />
      <ul>
      <li><a href="#kan-extensions"><a href="#kan-extensions" class="header-link">Kan
      extensions<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#ubiquity"><a href="#ubiquity" class="header-link">Ubiquity<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      <li><a href="#a-formula"><a href="#a-formula" class="header-link">A
      formula<span class="header-link-emoji">🔗</span></a></a></li>
      </ul>
      <hr />

      <!-- Sidebar controls -->
      <div style="display: flex; gap: 0.25em; flex-flow: row wrap;">
        <!-- Sidebar equations control -->
        <span class="equations" style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-eqns" type="checkbox" class="equations" id="sidebar-eqns">
          <label for="sidebar-eqns">Equations</label>
        </span>

        <!-- Sidebar fonts control -->
        <span style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-font" type="checkbox" id="toggle-fonts">
          <label for="toggle-fonts">Serif Font</label>
        </span>

        <!-- Sidebar footnotes control -->
        <span class="inline-footnotes" style="display: none; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-fns" type="checkbox" class="inline-footnotes" id="sidebar-fns">
          <label for="sidebar-fns">Inline Footnotes</label>
        </span>
      </div>

      <hr />

      <!-- Navbar navigation (lol) -->
      <div id="return" style="white-space: nowrap;">
        <div class="search-form search-form-proxy" role="form">
          <input id="search-box-proxy" type_="text" placeholder="Search..." autocomplete="off" tabindex="0"></input>
        </div>

              <a href="/">back to index</a> <br />
              <a href="all-pages.html">view all pages</a> <br />
        <a href="https://github.com/plt-amy/cubical-1lab/blob/2062bad7140078f9f32ed0b855d1bcbd0e3244f1/src/Cat/Functor/Kan.lagda.md">link to source</a> <br />
                <hr /> <div class="author-list">Written by Amélia Liao and Naïm Favier</div> <br />
              </div>
    </div>
  </aside>
  
  <article>
    <!-- Article navigation (narrow screens only) -->
    <div class="narrow-only" id="article-nav">
      <!-- Index return anchor (only if the page is not the index) -->
            <div id="return">
        <a href="/">back to index</a>
      </div>
      
      <!-- Navbar equations control -->
      <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-eqns" type="checkbox" class="equations" id="navbar-eqns">
        <label for="navbar-eqns">Equations</label>
      </span>

      <!-- Navbar footnotes control -->
      <span class="inline-footnotes" style="display: none; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-fns" type="checkbox" class="inline-footnotes" id="navbar-fns">
        <label for="navbar-fns">Inline Footnotes</label>
      </span>
    </div>

<pre class="Agda"><a id="9" class="Keyword">open</a> <a id="14" class="Keyword">import</a> <a id="21" href="Cat.Instances.Shape.Terminal.html" class="Module">Cat.Instances.Shape.Terminal</a>
<a id="50" class="Keyword">open</a> <a id="55" class="Keyword">import</a> <a id="62" href="Cat.Diagram.Colimit.Base.html" class="Module">Cat.Diagram.Colimit.Base</a>
<a id="87" class="Keyword">open</a> <a id="92" class="Keyword">import</a> <a id="99" href="Cat.Instances.Functor.html" class="Module">Cat.Instances.Functor</a>
<a id="121" class="Keyword">open</a> <a id="126" class="Keyword">import</a> <a id="133" href="Cat.Diagram.Initial.html" class="Module">Cat.Diagram.Initial</a>
<a id="153" class="Keyword">open</a> <a id="158" class="Keyword">import</a> <a id="165" href="Cat.Functor.Adjoint.html" class="Module">Cat.Functor.Adjoint</a>
<a id="185" class="Keyword">open</a> <a id="190" class="Keyword">import</a> <a id="197" href="Cat.Instances.Comma.html" class="Module">Cat.Instances.Comma</a>
<a id="217" class="Keyword">open</a> <a id="222" class="Keyword">import</a> <a id="229" href="Cat.Functor.Base.html" class="Module">Cat.Functor.Base</a>
<a id="246" class="Keyword">open</a> <a id="251" class="Keyword">import</a> <a id="258" href="Cat.Prelude.html" class="Module">Cat.Prelude</a>

<a id="271" class="Keyword">import</a> <a id="278" href="Cat.Functor.Reasoning.html" class="Module">Cat.Functor.Reasoning</a> <a id="300" class="Symbol">as</a> <a id="303" class="Module">Func</a>
<a id="308" class="Keyword">import</a> <a id="315" href="Cat.Reasoning.html" class="Module">Cat.Reasoning</a> <a id="329" class="Symbol">as</a> <a id="332" class="Module">Cat</a>

<a id="337" class="Keyword">module</a> <a id="344" href="Cat.Functor.Kan.html" class="Module">Cat.Functor.Kan</a> <a id="360" class="Keyword">where</a>
</pre>
<!--
<pre class="Agda"><a id="384" class="Keyword">private</a>
  <a id="394" class="Keyword">variable</a>
    <a id="407" href="Cat.Functor.Kan.html#407" class="Generalizable">o</a> <a id="409" href="Cat.Functor.Kan.html#409" class="Generalizable">ℓ</a> <a id="411" class="Symbol">:</a> <a id="413" href="Agda.Primitive.html#582" data-type="Type" class="Postulate">Level</a>
    <a id="423" href="Cat.Functor.Kan.html#423" class="Generalizable">C</a> <a id="425" href="Cat.Functor.Kan.html#425" class="Generalizable">C′</a> <a id="428" href="Cat.Functor.Kan.html#428" class="Generalizable">D</a> <a id="430" class="Symbol">:</a> <a id="432" href="Cat.Base.html#704" data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" class="Record">Precategory</a> <a id="444" href="Cat.Functor.Kan.html#407" class="Generalizable">o</a> <a id="446" href="Cat.Functor.Kan.html#409" class="Generalizable">ℓ</a>
  <a id="kan-lvl"></a><a id="450" href="Cat.Functor.Kan.html#450" class="Function">kan-lvl</a> <a id="458" class="Symbol">:</a> <a id="460" class="Symbol">∀</a> <a id="462" class="Symbol">{</a><a id="463" href="Cat.Functor.Kan.html#463" class="Bound">o</a> <a id="465" href="Cat.Functor.Kan.html#465" class="Bound">ℓ</a> <a id="467" href="Cat.Functor.Kan.html#467" class="Bound">o′</a> <a id="470" href="Cat.Functor.Kan.html#470" class="Bound">ℓ′</a> <a id="473" href="Cat.Functor.Kan.html#473" class="Bound">o′′</a> <a id="477" href="Cat.Functor.Kan.html#477" class="Bound">ℓ′′</a><a id="480" class="Symbol">}</a> <a id="482" class="Symbol">{</a><a id="483" href="Cat.Functor.Kan.html#483" class="Bound">C</a> <a id="485" class="Symbol">:</a> <a id="487" href="Cat.Base.html#704" data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" class="Record">Precategory</a> <a id="499" href="Cat.Functor.Kan.html#463" class="Bound">o</a> <a id="501" href="Cat.Functor.Kan.html#465" class="Bound">ℓ</a><a id="502" class="Symbol">}</a> <a id="504" class="Symbol">{</a><a id="505" href="Cat.Functor.Kan.html#505" class="Bound">C′</a> <a id="508" class="Symbol">:</a> <a id="510" href="Cat.Base.html#704" data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" class="Record">Precategory</a> <a id="522" href="Cat.Functor.Kan.html#467" class="Bound">o′</a> <a id="525" href="Cat.Functor.Kan.html#470" class="Bound">ℓ′</a><a id="527" class="Symbol">}</a> <a id="529" class="Symbol">{</a><a id="530" href="Cat.Functor.Kan.html#530" class="Bound">D</a> <a id="532" class="Symbol">:</a> <a id="534" href="Cat.Base.html#704" data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" class="Record">Precategory</a> <a id="546" href="Cat.Functor.Kan.html#473" class="Bound">o′′</a> <a id="550" href="Cat.Functor.Kan.html#477" class="Bound">ℓ′′</a><a id="553" class="Symbol">}</a>
          <a id="565" class="Symbol">→</a> <a id="567" href="Cat.Base.html#7198" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="575" href="Cat.Functor.Kan.html#483" class="Bound">C</a> <a id="577" href="Cat.Functor.Kan.html#530" class="Bound">D</a> <a id="579" class="Symbol">→</a> <a id="581" href="Cat.Base.html#7198" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="589" href="Cat.Functor.Kan.html#483" class="Bound">C</a> <a id="591" href="Cat.Functor.Kan.html#505" class="Bound">C′</a> <a id="594" class="Symbol">→</a> <a id="596" href="Agda.Primitive.html#582" data-type="Type" class="Postulate">Level</a>
  <a id="604" href="Cat.Functor.Kan.html#450" class="Function">kan-lvl</a> <a id="612" class="Symbol">{</a><a id="613" href="Cat.Functor.Kan.html#613" class="Bound">a</a><a id="614" class="Symbol">}</a> <a id="616" class="Symbol">{</a><a id="617" href="Cat.Functor.Kan.html#617" class="Bound">b</a><a id="618" class="Symbol">}</a> <a id="620" class="Symbol">{</a><a id="621" href="Cat.Functor.Kan.html#621" class="Bound">c</a><a id="622" class="Symbol">}</a> <a id="624" class="Symbol">{</a><a id="625" href="Cat.Functor.Kan.html#625" class="Bound">d</a><a id="626" class="Symbol">}</a> <a id="628" class="Symbol">{</a><a id="629" href="Cat.Functor.Kan.html#629" class="Bound">e</a><a id="630" class="Symbol">}</a> <a id="632" class="Symbol">{</a><a id="633" href="Cat.Functor.Kan.html#633" class="Bound">f</a><a id="634" class="Symbol">}</a> <a id="636" class="Symbol">_</a> <a id="638" class="Symbol">_</a> <a id="640" class="Symbol">=</a> <a id="642" href="Cat.Functor.Kan.html#613" class="Bound">a</a> <a id="644" href="Agda.Primitive.html#795" data-type="Level → Level → Level" class="Primitive Operator">⊔</a> <a id="646" href="Cat.Functor.Kan.html#617" class="Bound">b</a> <a id="648" href="Agda.Primitive.html#795" data-type="Level → Level → Level" class="Primitive Operator">⊔</a> <a id="650" href="Cat.Functor.Kan.html#621" class="Bound">c</a> <a id="652" href="Agda.Primitive.html#795" data-type="Level → Level → Level" class="Primitive Operator">⊔</a> <a id="654" href="Cat.Functor.Kan.html#625" class="Bound">d</a> <a id="656" href="Agda.Primitive.html#795" data-type="Level → Level → Level" class="Primitive Operator">⊔</a> <a id="658" href="Cat.Functor.Kan.html#629" class="Bound">e</a> <a id="660" href="Agda.Primitive.html#795" data-type="Level → Level → Level" class="Primitive Operator">⊔</a> <a id="662" href="Cat.Functor.Kan.html#633" class="Bound">f</a>
</pre>-->
<h1 id="kan-extensions"><a href="#kan-extensions" class="header-link">Kan
extensions<span class="header-link-emoji">🔗</span></a></h1>
<p>Suppose we have a functor
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>:</mo><mi mathvariant="script">C</mi><mo>→</mo><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">F : \ca{C} \to \ca{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span>,</span>
and a functor
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>:</mo><mi mathvariant="script">C</mi><mo>→</mo><msup><mi mathvariant="script">C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">p : \ca{C} \to \ca{C}&#39;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>
— perhaps to be thought of as a <a href="Cat.Functor.FullSubcategory.html">full subcategory</a> inclusion,
where
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="script">C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">\ca{C}&#39;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>
is a completion of
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">\ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span>,</span>
but the situation applies just as well to any pair of functors — which
naturally fit into a commutative diagram</p>
<div class="diagram-container">
<img src="light-6a32e823706fad23aaaa018b81e7575133a4f0dc.svg" title="commutative diagram" class="diagram diagram-light quiver" />
<img src="dark-6a32e823706fad23aaaa018b81e7575133a4f0dc.svg" title="commutative diagram" class="diagram diagram-dark quiver" />
</div>
<p>but as we can see this is a particularly sad commutative diagram;
it’s crying out for a third edge
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="script">C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>→</mo><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">\ca{C}&#39; \to \ca{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span></p>
<div class="diagram-container">
<img src="light-835eef6d4aa8e64f94cef52f789dacbb0d6419b8.svg" title="commutative diagram" class="diagram diagram-light quiver" />
<img src="dark-835eef6d4aa8e64f94cef52f789dacbb0d6419b8.svg" title="commutative diagram" class="diagram diagram-dark quiver" />
</div>
<p>extending
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span>
to a functor
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="script">C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>→</mo><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">\ca{C}&#39; \to \ca{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span>.</span>
If there exists an <em>universal</em> such extension (we’ll define what
“universal” means in just a second), we call it the <strong>left Kan
extension</strong> of
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span>
along
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>,</span>
and denote it
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">L</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi></mrow><mi>p</mi></msub><mi>F</mi></mrow><annotation encoding="application/x-tex">\Lan_p F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">Lan</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span>.</span>
Such extensions do not come for free (in a sense they’re pretty hard to
come by), but concept of Kan extension can be used to rephrase the
definition of both <a href="Cat.Diagram.Limit.Base.html">limit</a> and
<a href="Cat.Functor.Adjoint.html">adjoint functor</a>.</p>
<p>A left Kan extension
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">L</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi></mrow><mi>p</mi></msub><mi>F</mi></mrow><annotation encoding="application/x-tex">\Lan_p F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">Lan</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span>
is equipped with a natural transformation
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>η</mi><mo>:</mo><mi>F</mi><mo>⇒</mo><msub><mrow><mi mathvariant="normal">L</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi></mrow><mi>p</mi></msub><mi>F</mi><mo>∘</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">\eta : F \To \Lan_p F \circ p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">η</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">Lan</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>
witnessing the (“directed”) commutativity of the triangle (so that it
need not commute on-the-nose) which is universal among such
transformations; Meaning that if
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>:</mo><msup><mi mathvariant="script">C</mi><mo mathvariant="script" lspace="0em" rspace="0em">′</mo></msup><mo>→</mo><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">M : \ca{C&#39;} \to \ca{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span>
is another functor with a transformation
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>:</mo><mi>M</mi><mo>⇒</mo><mi>M</mi><mo>∘</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">\alpha : M \To M \circ p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>,</span>
there is a unique natural transformation
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo>:</mo><msub><mrow><mi mathvariant="normal">L</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi></mrow><mi>p</mi></msub><mi>F</mi><mo>⇒</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">\sigma : \Lan_p F \To M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">Lan</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>
which commutes with
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>.</span></p>
<p>Note that in general the triangle commutes “weakly”, but when
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>
is <a href="Cat.Functor.Base.html#ff-functors">fully faithful</a> and
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">\ca{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span>
is <a href="Cat.Diagram.Colimit.Base.html#cocompleteness">cocomplete</a>,
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">L</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi></mrow><mi>p</mi></msub><mi>F</mi></mrow><annotation encoding="application/x-tex">\Lan_p F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">Lan</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span>
genuinely extends
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>,</span>
in that
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>η</mi></mrow><annotation encoding="application/x-tex">\eta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">η</span></span></span></span>
is a natural isomorphism.</p>
<pre class="Agda"><a id="2831" class="Keyword">record</a> <a id="Lan"></a><a id="2838" href="Cat.Functor.Kan.html#2838" data-type="(p : Functor C C′) (F : Functor C D) →
Type (C.o ⊔ C.ℓ ⊔ C′.o ⊔ C′.ℓ ⊔ D.o ⊔ D.ℓ)" class="Record">Lan</a> <a id="2842" class="Symbol">(</a><a id="2843" href="Cat.Functor.Kan.html#2843" class="Bound">p</a> <a id="2845" class="Symbol">:</a> <a id="2847" href="Cat.Base.html#7198" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="2855" href="Cat.Functor.Kan.html#423" class="Generalizable">C</a> <a id="2857" href="Cat.Functor.Kan.html#425" class="Generalizable">C′</a><a id="2859" class="Symbol">)</a> <a id="2861" class="Symbol">(</a><a id="2862" href="Cat.Functor.Kan.html#2862" class="Bound">F</a> <a id="2864" class="Symbol">:</a> <a id="2866" href="Cat.Base.html#7198" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="2874" href="Cat.Functor.Kan.html#423" class="Generalizable">C</a> <a id="2876" href="Cat.Functor.Kan.html#428" class="Generalizable">D</a><a id="2877" class="Symbol">)</a> <a id="2879" class="Symbol">:</a> <a id="2881" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="2886" class="Symbol">(</a><a id="2887" href="Cat.Functor.Kan.html#450" class="Function">kan-lvl</a> <a id="2895" href="Cat.Functor.Kan.html#2843" class="Bound">p</a> <a id="2897" href="Cat.Functor.Kan.html#2862" class="Bound">F</a><a id="2898" class="Symbol">)</a> <a id="2900" class="Keyword">where</a>
  <a id="2908" class="Keyword">field</a>
    <a id="Lan.Ext"></a><a id="2918" href="Cat.Functor.Kan.html#2918" data-type="Lan p F → Functor C′ D" class="Field">Ext</a> <a id="2922" class="Symbol">:</a> <a id="2924" href="Cat.Base.html#7198" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="2932" href="Cat.Functor.Kan.html#2857" class="Bound">C′</a> <a id="2935" href="Cat.Functor.Kan.html#2876" class="Bound">D</a>
    <a id="Lan.eta"></a><a id="2941" href="Cat.Functor.Kan.html#2941" data-type="(r : Lan p F) → F =&gt; r .Ext F∘ p" class="Field">eta</a> <a id="2945" class="Symbol">:</a> <a id="2947" href="Cat.Functor.Kan.html#2862" class="Bound">F</a> <a id="2949" href="Cat.Base.html#12227" data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" class="Record Operator">=&gt;</a> <a id="2952" href="Cat.Functor.Kan.html#2918" data-type="Lan p F → Functor C′ D" class="Field">Ext</a> <a id="2956" href="Cat.Base.html#9683" data-type="Functor D E → Functor C D → Functor C E" class="Function Operator">F∘</a> <a id="2959" href="Cat.Functor.Kan.html#2843" class="Bound">p</a>
</pre>
<p>Universality of
<span class="Agda"><a href="Cat.Functor.Kan.html#2941" class="Field">eta</a></span>
is witnessed by the following fields, which essentially say that, in the
diagram below (assuming
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>
has a natural transformation
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>
witnessing the same “directed commutativity” that
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>η</mi></mrow><annotation encoding="application/x-tex">\eta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">η</span></span></span></span>
does for
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">L</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi></mrow><mi>p</mi></msub><mi>F</mi></mrow><annotation encoding="application/x-tex">\Lan_p F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">Lan</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span>),</span>
the 2-cell exists and is unique.</p>
<div class="diagram-container">
<img src="light-f0ea9b4df8662303a1afd8dcde622d9329c08d48.svg" title="commutative diagram" class="diagram diagram-light quiver" />
<img src="dark-f0ea9b4df8662303a1afd8dcde622d9329c08d48.svg" title="commutative diagram" class="diagram diagram-dark quiver" />
</div>
<pre class="Agda">    <a id="Lan.σ"></a><a id="3692" href="Cat.Functor.Kan.html#3692" data-type="(r : Lan p F) → F =&gt; M F∘ p → r .Ext =&gt; M" class="Field">σ</a> <a id="3694" class="Symbol">:</a> <a id="3696" class="Symbol">{</a><a id="3697" href="Cat.Functor.Kan.html#3697" class="Bound">M</a> <a id="3699" class="Symbol">:</a> <a id="3701" href="Cat.Base.html#7198" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="3709" href="Cat.Functor.Kan.html#2857" class="Bound">C′</a> <a id="3712" href="Cat.Functor.Kan.html#2876" class="Bound">D</a><a id="3713" class="Symbol">}</a> <a id="3715" class="Symbol">(</a><a id="3716" href="Cat.Functor.Kan.html#3716" class="Bound">α</a> <a id="3718" class="Symbol">:</a> <a id="3720" href="Cat.Functor.Kan.html#2862" class="Bound">F</a> <a id="3722" href="Cat.Base.html#12227" data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" class="Record Operator">=&gt;</a> <a id="3725" href="Cat.Functor.Kan.html#3697" class="Bound">M</a> <a id="3727" href="Cat.Base.html#9683" data-type="Functor D E → Functor C D → Functor C E" class="Function Operator">F∘</a> <a id="3730" href="Cat.Functor.Kan.html#2843" class="Bound">p</a><a id="3731" class="Symbol">)</a> <a id="3733" class="Symbol">→</a> <a id="3735" href="Cat.Functor.Kan.html#2918" data-type="Lan p F → Functor C′ D" class="Field">Ext</a> <a id="3739" href="Cat.Base.html#12227" data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" class="Record Operator">=&gt;</a> <a id="3742" href="Cat.Functor.Kan.html#3697" class="Bound">M</a>
    <a id="Lan.σ-comm"></a><a id="3748" href="Cat.Functor.Kan.html#3748" data-type="(r : Lan p F) → (whiskerl (r .σ α) ∘nt r .eta) ≡ α" class="Field">σ-comm</a> <a id="3755" class="Symbol">:</a> <a id="3757" class="Symbol">{</a><a id="3758" href="Cat.Functor.Kan.html#3758" class="Bound">M</a> <a id="3760" class="Symbol">:</a> <a id="3762" href="Cat.Base.html#7198" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="3770" href="Cat.Functor.Kan.html#2857" class="Bound">C′</a> <a id="3773" href="Cat.Functor.Kan.html#2876" class="Bound">D</a><a id="3774" class="Symbol">}</a> <a id="3776" class="Symbol">{</a><a id="3777" href="Cat.Functor.Kan.html#3777" class="Bound">α</a> <a id="3779" class="Symbol">:</a> <a id="3781" href="Cat.Functor.Kan.html#2862" class="Bound">F</a> <a id="3783" href="Cat.Base.html#12227" data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" class="Record Operator">=&gt;</a> <a id="3786" href="Cat.Functor.Kan.html#3758" class="Bound">M</a> <a id="3788" href="Cat.Base.html#9683" data-type="Functor D E → Functor C D → Functor C E" class="Function Operator">F∘</a> <a id="3791" href="Cat.Functor.Kan.html#2843" class="Bound">p</a><a id="3792" class="Symbol">}</a> <a id="3794" class="Symbol">→</a> <a id="3796" href="Cat.Instances.Functor.html#13931" data-type="F =&gt; G → F F∘ H =&gt; G F∘ H" class="Function">whiskerl</a> <a id="3805" class="Symbol">(</a><a id="3806" href="Cat.Functor.Kan.html#3692" data-type="(r : Lan p F) → F =&gt; M F∘ p → r .Ext =&gt; M" class="Field">σ</a> <a id="3808" href="Cat.Functor.Kan.html#3777" class="Bound">α</a><a id="3809" class="Symbol">)</a> <a id="3811" href="Cat.Instances.Functor.html#890" data-type="G =&gt; H → F =&gt; G → F =&gt; H" class="Function Operator">∘nt</a> <a id="3815" href="Cat.Functor.Kan.html#2941" data-type="(r : Lan p F) → F =&gt; r .Ext F∘ p" class="Field">eta</a> <a id="3819" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="3821" href="Cat.Functor.Kan.html#3777" class="Bound">α</a>
    <a id="Lan.σ-uniq"></a><a id="3827" href="Cat.Functor.Kan.html#3827" data-type="(r : Lan p F) → α ≡ (whiskerl σ′ ∘nt r .eta) → r .σ α ≡ σ′" class="Field">σ-uniq</a> <a id="3834" class="Symbol">:</a> <a id="3836" class="Symbol">{</a><a id="3837" href="Cat.Functor.Kan.html#3837" class="Bound">M</a> <a id="3839" class="Symbol">:</a> <a id="3841" href="Cat.Base.html#7198" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="3849" href="Cat.Functor.Kan.html#2857" class="Bound">C′</a> <a id="3852" href="Cat.Functor.Kan.html#2876" class="Bound">D</a><a id="3853" class="Symbol">}</a> <a id="3855" class="Symbol">{</a><a id="3856" href="Cat.Functor.Kan.html#3856" class="Bound">α</a> <a id="3858" class="Symbol">:</a> <a id="3860" href="Cat.Functor.Kan.html#2862" class="Bound">F</a> <a id="3862" href="Cat.Base.html#12227" data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" class="Record Operator">=&gt;</a> <a id="3865" href="Cat.Functor.Kan.html#3837" class="Bound">M</a> <a id="3867" href="Cat.Base.html#9683" data-type="Functor D E → Functor C D → Functor C E" class="Function Operator">F∘</a> <a id="3870" href="Cat.Functor.Kan.html#2843" class="Bound">p</a><a id="3871" class="Symbol">}</a> <a id="3873" class="Symbol">{</a><a id="3874" href="Cat.Functor.Kan.html#3874" class="Bound">σ′</a> <a id="3877" class="Symbol">:</a> <a id="3879" href="Cat.Functor.Kan.html#2918" data-type="Lan p F → Functor C′ D" class="Field">Ext</a> <a id="3883" href="Cat.Base.html#12227" data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" class="Record Operator">=&gt;</a> <a id="3886" href="Cat.Functor.Kan.html#3837" class="Bound">M</a><a id="3887" class="Symbol">}</a>
           <a id="3900" class="Symbol">→</a> <a id="3902" href="Cat.Functor.Kan.html#3856" class="Bound">α</a> <a id="3904" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="3906" href="Cat.Instances.Functor.html#13931" data-type="F =&gt; G → F F∘ H =&gt; G F∘ H" class="Function">whiskerl</a> <a id="3915" href="Cat.Functor.Kan.html#3874" class="Bound">σ′</a> <a id="3918" href="Cat.Instances.Functor.html#890" data-type="G =&gt; H → F =&gt; G → F =&gt; H" class="Function Operator">∘nt</a> <a id="3922" href="Cat.Functor.Kan.html#2941" data-type="(r : Lan p F) → F =&gt; r .Ext F∘ p" class="Field">eta</a>
           <a id="3937" class="Symbol">→</a> <a id="3939" href="Cat.Functor.Kan.html#3692" data-type="(r : Lan p F) → F =&gt; M F∘ p → r .Ext =&gt; M" class="Field">σ</a> <a id="3941" href="Cat.Functor.Kan.html#3856" class="Bound">α</a> <a id="3943" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="3945" href="Cat.Functor.Kan.html#3874" class="Bound">σ′</a>
</pre>
<h2 id="ubiquity"><a href="#ubiquity" class="header-link">Ubiquity<span class="header-link-emoji">🔗</span></a></h2>
<p>The elevator pitch for Kan extensions is that “all concepts are Kan
extensions”. The example we will give here is that, if
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>⊣</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">F \dashv G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊣</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span>
is an adjunction, then
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>G</mi><mo separator="true">,</mo><mi>η</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(G, \eta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">η</span><span class="mclose">)</span></span></span></span>
gives
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">L</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi></mrow><mi>F</mi></msub><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">d</mi></mrow><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Lan_F(\id{Id})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">Lan</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">Id</span></span><span class="mclose">)</span></span></span></span>.</span>
This isn’t exactly enlightening: adjunctions and Kan extensions have
very different vibes, but the latter concept <em>is</em> a legitimate
generalisation.</p>
<!--
<pre class="Agda"><a id="4324" class="Keyword">module</a> <a id="4331" href="Cat.Functor.Kan.html#4331" class="Module">_</a> <a id="4333" class="Symbol">{</a><a id="4334" href="Cat.Functor.Kan.html#4334" class="Bound">F</a> <a id="4336" class="Symbol">:</a> <a id="4338" href="Cat.Base.html#7198" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="4346" href="Cat.Functor.Kan.html#423" class="Generalizable">C</a> <a id="4348" href="Cat.Functor.Kan.html#428" class="Generalizable">D</a><a id="4349" class="Symbol">}</a> <a id="4351" class="Symbol">{</a><a id="4352" href="Cat.Functor.Kan.html#4352" class="Bound">G</a> <a id="4354" class="Symbol">:</a> <a id="4356" href="Cat.Base.html#7198" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="4364" href="Cat.Functor.Kan.html#428" class="Generalizable">D</a> <a id="4366" href="Cat.Functor.Kan.html#423" class="Generalizable">C</a><a id="4367" class="Symbol">}</a> <a id="4369" class="Symbol">(</a><a id="4370" href="Cat.Functor.Kan.html#4370" class="Bound">adj</a> <a id="4374" class="Symbol">:</a> <a id="4376" href="Cat.Functor.Kan.html#4334" class="Bound">F</a> <a id="4378" href="Cat.Functor.Adjoint.html#2192" data-type="(L : Functor C D) (R₁ : Functor D C) → Type (C.o ⊔ C.h ⊔ D.o ⊔ D.h)" class="Record Operator">⊣</a> <a id="4380" href="Cat.Functor.Kan.html#4352" class="Bound">G</a><a id="4381" class="Symbol">)</a> <a id="4383" class="Keyword">where</a>
  <a id="4391" class="Keyword">open</a> <a id="4396" href="Cat.Functor.Kan.html#2838" data-type="(p : Functor C C′) (F : Functor C D) →
Type (C.o ⊔ C.ℓ ⊔ C′.o ⊔ C′.ℓ ⊔ D.o ⊔ D.ℓ)" class="Module">Lan</a>
  <a id="4402" class="Keyword">private</a>
    <a id="4414" class="Keyword">module</a> <a id="4421" href="Cat.Functor.Kan.html#4421" class="Module">F</a> <a id="4423" class="Symbol">=</a> <a id="4425" href="Cat.Base.html#7198" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Module">Functor</a> <a id="4433" href="Cat.Functor.Kan.html#4334" class="Bound">F</a>
    <a id="4439" class="Keyword">module</a> <a id="4446" href="Cat.Functor.Kan.html#4446" class="Module">G</a> <a id="4448" class="Symbol">=</a> <a id="4450" href="Cat.Base.html#7198" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Module">Functor</a> <a id="4458" href="Cat.Functor.Kan.html#4352" class="Bound">G</a>
    <a id="4464" class="Keyword">module</a> <a id="4471" href="Cat.Functor.Kan.html#4471" class="Module">C</a> <a id="4473" class="Symbol">=</a> <a id="4475" href="Cat.Reasoning.html" class="Module">Cat</a> <a id="4479" href="Cat.Functor.Kan.html#4346" class="Bound">C</a>
    <a id="4485" class="Keyword">module</a> <a id="4492" href="Cat.Functor.Kan.html#4492" class="Module">D</a> <a id="4494" class="Symbol">=</a> <a id="4496" href="Cat.Reasoning.html" class="Module">Cat</a> <a id="4500" href="Cat.Functor.Kan.html#4348" class="Bound">D</a>
  <a id="4504" class="Keyword">open</a> <a id="4509" href="Cat.Functor.Adjoint.html#2192" data-type="(L : Functor C D) (R₁ : Functor D C) → Type (C.o ⊔ C.h ⊔ D.o ⊔ D.h)" class="Module Operator">_⊣_</a> <a id="4513" href="Cat.Functor.Kan.html#4370" class="Bound">adj</a>
  <a id="4519" class="Keyword">open</a> <a id="4524" href="Cat.Base.html#12227" data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" class="Module Operator">_=&gt;_</a>
</pre>-->
<pre class="Agda">  <a id="4548" href="Cat.Functor.Kan.html#4548" data-type="(adj : F ⊣ G) → Lan F Id" class="Function">adjoint→lan</a> <a id="4560" class="Symbol">:</a> <a id="4562" href="Cat.Functor.Kan.html#2838" data-type="(p : Functor C C′) (F : Functor C D) →
Type (C.o ⊔ C.ℓ ⊔ C′.o ⊔ C′.ℓ ⊔ D.o ⊔ D.ℓ)" class="Record">Lan</a> <a id="4566" href="Cat.Functor.Kan.html#4334" class="Bound">F</a> <a id="4568" href="Cat.Base.html#11708" data-type="Functor C C" class="Function">Id</a>
  <a id="4573" href="Cat.Functor.Kan.html#4548" data-type="(adj : F ⊣ G) → Lan F Id" class="Function">adjoint→lan</a> <a id="4585" class="Symbol">.</a><a id="4586" href="Cat.Functor.Kan.html#2918" data-type="Lan p F → Functor C′ D" class="Field">Ext</a> <a id="4590" class="Symbol">=</a> <a id="4592" href="Cat.Functor.Kan.html#4352" class="Bound">G</a>
  <a id="4596" href="Cat.Functor.Kan.html#4548" data-type="(adj : F ⊣ G) → Lan F Id" class="Function">adjoint→lan</a> <a id="4608" class="Symbol">.</a><a id="4609" href="Cat.Functor.Kan.html#2941" data-type="(r : Lan p F) → F =&gt; r .Ext F∘ p" class="Field">eta</a> <a id="4613" class="Symbol">=</a> <a id="4615" href="Cat.Functor.Adjoint.html#2342" data-type="L ⊣ R₁ → Id =&gt; R₁ F∘ L" class="Field">unit</a>
</pre>
<p>The proof is mostly pushing symbols around, and the calculation is
available below unabridged. In components,
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">\sigma_x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
must give, assuming a map
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>:</mo><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">d</mi></mrow><mo>⇒</mo><mi>M</mi><mi>F</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">\alpha : \id{Id} \To MFx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">Id</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">MF</span><span class="mord mathnormal">x</span></span></span></span>,</span>
a map
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mi>x</mi><mo>→</mo><mi>M</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">Gx \to Mx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">x</span></span></span></span>.</span>
The transformation we’re looking for arises as the composite</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>G</mi><mi>x</mi><mover><mo stretchy="true" minsize="3.0em">→</mo><mpadded width="+0.6em" lspace="0.3em"><mi>α</mi></mpadded></mover><mi>M</mi><mi>F</mi><mi>G</mi><mi>x</mi><mover><mo stretchy="true" minsize="3.0em">→</mo><mpadded width="+0.6em" lspace="0.3em"><mrow><mi>M</mi><mi>ε</mi></mrow></mpadded></mover><mi>M</mi><mi>x</mi><mtext>,</mtext></mrow><annotation encoding="application/x-tex">
Gx \xto{\alpha} MFGx \xto{M\epsilon} Mx\text{,}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9344em;vertical-align:-0.011em;"></span><span class="mord mathnormal">G</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel x-arrow"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9234em;"><span style="top:-3.322em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.0037em;">α</span></span></span></span><span class="svg-align" style="top:-2.689em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.522em;min-width:1.469em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.522em" viewBox="0 0 400000 522" preserveAspectRatio="xMaxYMin slice"><path d="M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1113em;vertical-align:-0.011em;"></span><span class="mord mathnormal">MFG</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel x-arrow"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1003em;"><span style="top:-3.322em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord mathnormal mtight">Mε</span></span></span></span><span class="svg-align" style="top:-2.689em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.522em;min-width:1.469em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.522em" viewBox="0 0 400000 522" preserveAspectRatio="xMaxYMin slice"><path d="M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">x</span><span class="mord text"><span class="mord">,</span></span></span></span></span></span></p>
<p>where uniqueness and commutativity follows from the triangle
identities
<span class="Agda"><a href="Cat.Functor.Adjoint.html#2943" class="Field">zig</a></span>
and
<span class="Agda"><a href="Cat.Functor.Adjoint.html#3006" class="Field">zag</a></span>.</p>
<pre class="Agda">  <a id="5050" href="Cat.Functor.Kan.html#4548" data-type="(adj : F ⊣ G) → Lan F Id" class="Function">adjoint→lan</a> <a id="5062" class="Symbol">.</a><a id="5063" href="Cat.Functor.Kan.html#3692" data-type="(r : Lan p F) → F =&gt; M F∘ p → r .Ext =&gt; M" class="Field">σ</a> <a id="5065" class="Symbol">{</a><a id="5066" href="Cat.Functor.Kan.html#5066" class="Bound">M</a><a id="5067" class="Symbol">}</a> <a id="5069" href="Cat.Functor.Kan.html#5069" class="Bound">α</a> <a id="5071" class="Symbol">.</a><a id="5072" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="5074" href="Cat.Functor.Kan.html#5074" class="Bound">x</a> <a id="5076" class="Symbol">=</a> <a id="5078" href="Cat.Functor.Kan.html#5066" class="Bound">M</a> <a id="5080" class="Symbol">.</a><a id="5081" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">Functor.F₁</a> <a id="5092" class="Symbol">(</a><a id="5093" href="Cat.Functor.Adjoint.html#2466" class="Function">counit.ε</a> <a id="5102" class="Symbol">_)</a> <a id="5105" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="5109" href="Cat.Functor.Kan.html#5069" class="Bound">α</a> <a id="5111" class="Symbol">.</a><a id="5112" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="5114" class="Symbol">(</a><a id="5115" href="Cat.Base.html#8719" data-type="(r : Functor C D) → C .Ob → D .Ob" class="Function">G.₀</a> <a id="5119" href="Cat.Functor.Kan.html#5074" class="Bound">x</a><a id="5120" class="Symbol">)</a>
  <a id="5124" href="Cat.Functor.Kan.html#4548" data-type="(adj : F ⊣ G) → Lan F Id" class="Function">adjoint→lan</a> <a id="5136" class="Symbol">.</a><a id="5137" href="Cat.Functor.Kan.html#3692" data-type="(r : Lan p F) → F =&gt; M F∘ p → r .Ext =&gt; M" class="Field">σ</a> <a id="5139" class="Symbol">{</a><a id="5140" href="Cat.Functor.Kan.html#5140" class="Bound">M</a><a id="5141" class="Symbol">}</a> <a id="5143" href="Cat.Functor.Kan.html#5143" class="Bound">nt</a> <a id="5146" class="Symbol">.</a><a id="5147" href="Cat.Base.html#13355" data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" class="Field">is-natural</a> <a id="5158" href="Cat.Functor.Kan.html#5158" class="Bound">x</a> <a id="5160" href="Cat.Functor.Kan.html#5160" class="Bound">y</a> <a id="5162" href="Cat.Functor.Kan.html#5162" class="Bound">f</a> <a id="5164" class="Symbol">=</a>
    <a id="5170" class="Symbol">(</a><a id="5171" href="Cat.Base.html#8800" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">M.₁</a> <a id="5175" class="Symbol">(</a><a id="5176" href="Cat.Functor.Adjoint.html#2466" class="Function">counit.ε</a> <a id="5185" class="Symbol">_)</a> <a id="5188" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="5192" href="Cat.Functor.Kan.html#5143" class="Bound">nt</a> <a id="5195" class="Symbol">.</a><a id="5196" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="5198" class="Symbol">_)</a> <a id="5201" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="5205" href="Cat.Base.html#8800" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">G.₁</a> <a id="5209" href="Cat.Functor.Kan.html#5162" class="Bound">f</a>            <span class="reasoning-step"><span class="as-written Function"><a id="5222" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="5225" href="Cat.Reasoning.html#1711" data-type="(C : Precategory o ℓ) →
(C ∘ a) b ≡ c → (C ∘ (C ∘ f) a) b ≡ (C ∘ f) c" class="Function">C.pullr</a> <a id="5233" class="Symbol">(</a><a id="5234" href="Cat.Functor.Kan.html#5143" class="Bound">nt</a> <a id="5237" class="Symbol">.</a><a id="5238" href="Cat.Base.html#13355" data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" class="Field">is-natural</a> <a id="5249" class="Symbol">_</a> <a id="5251" class="Symbol">_</a> <a id="5253" class="Symbol">_)</a> <a id="5256" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="5262" href="Cat.Base.html#8800" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">M.₁</a> <a id="5266" class="Symbol">(</a><a id="5267" href="Cat.Functor.Adjoint.html#2466" class="Function">counit.ε</a> <a id="5276" class="Symbol">_)</a> <a id="5279" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="5283" href="Cat.Base.html#8800" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">M.₁</a> <a id="5287" class="Symbol">(</a><a id="5288" href="Cat.Base.html#8800" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">F.₁</a> <a id="5292" class="Symbol">(</a><a id="5293" href="Cat.Base.html#8800" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">G.₁</a> <a id="5297" href="Cat.Functor.Kan.html#5162" class="Bound">f</a><a id="5298" class="Symbol">))</a> <a id="5301" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="5305" href="Cat.Functor.Kan.html#5143" class="Bound">nt</a> <a id="5308" class="Symbol">.</a><a id="5309" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="5311" class="Symbol">_</a>  <span class="reasoning-step"><span class="as-written Function"><a id="5314" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="5317" href="Cat.Functor.Reasoning.html#1799" data-type="(F : Functor 𝒞 𝒟) →
(F ∘ a) c ≡ (F ∘ b) d →
(F ∘ F₁ F a) ((F ∘ F₁ F c) f) ≡ (F ∘ F₁ F b) ((F ∘ F₁ F d) f)" class="Function">M.extendl</a> <a id="5327" class="Symbol">(</a><a id="5328" href="Cat.Base.html#13355" data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" class="Function">counit.is-natural</a> <a id="5346" class="Symbol">_</a> <a id="5348" class="Symbol">_</a> <a id="5350" class="Symbol">_)</a> <a id="5353" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="5359" href="Cat.Base.html#8800" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">M.₁</a> <a id="5363" href="Cat.Functor.Kan.html#5162" class="Bound">f</a> <a id="5365" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="5369" href="Cat.Base.html#8800" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">M.₁</a> <a id="5373" class="Symbol">(</a><a id="5374" href="Cat.Functor.Adjoint.html#2466" class="Function">counit.ε</a> <a id="5383" class="Symbol">_)</a> <a id="5386" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="5390" href="Cat.Functor.Kan.html#5143" class="Bound">nt</a> <a id="5393" class="Symbol">.</a><a id="5394" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="5396" class="Symbol">_</a>              <a id="5411" href="1Lab.Path.html#46945" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
    <a id="5417" class="Keyword">where</a> <a id="5423" class="Keyword">module</a> <a id="5430" href="Cat.Functor.Kan.html#5430" class="Module">M</a> <a id="5432" class="Symbol">=</a> <a id="5434" href="Cat.Functor.Reasoning.html" class="Module">Func</a> <a id="5439" href="Cat.Functor.Kan.html#5140" class="Bound">M</a>

  <a id="5444" href="Cat.Functor.Kan.html#4548" data-type="(adj : F ⊣ G) → Lan F Id" class="Function">adjoint→lan</a> <a id="5456" class="Symbol">.</a><a id="5457" href="Cat.Functor.Kan.html#3748" data-type="(r : Lan p F) → (whiskerl (r .σ α) ∘nt r .eta) ≡ α" class="Field">σ-comm</a> <a id="5464" class="Symbol">{</a><a id="5465" href="Cat.Functor.Kan.html#5465" class="Bound">M</a><a id="5466" class="Symbol">}</a> <a id="5468" class="Symbol">{</a><a id="5469" href="Cat.Functor.Kan.html#5469" class="Bound">α</a><a id="5470" class="Symbol">}</a> <a id="5472" class="Symbol">=</a> <a id="5474" href="Cat.Base.html#15577" data-type="((x : C .Ob) → a .η x ≡ b .η x) → a ≡ b" class="Function">Nat-path</a> <a id="5483" class="Symbol">λ</a> <a id="5485" href="Cat.Functor.Kan.html#5485" class="Bound">_</a> <a id="5487" class="Symbol">→</a>
    <a id="5493" class="Symbol">(</a><a id="5494" href="Cat.Base.html#8800" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">M.₁</a> <a id="5498" class="Symbol">(</a><a id="5499" href="Cat.Functor.Adjoint.html#2466" class="Function">counit.ε</a> <a id="5508" class="Symbol">_)</a> <a id="5511" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="5515" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">α.η</a> <a id="5519" class="Symbol">_)</a> <a id="5522" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="5526" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Function">unit.η</a> <a id="5533" class="Symbol">_</a>              <span class="reasoning-step"><span class="as-written Function"><a id="5548" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="5551" href="Cat.Reasoning.html#1711" data-type="(C : Precategory o ℓ) →
(C ∘ a) b ≡ c → (C ∘ (C ∘ f) a) b ≡ (C ∘ f) c" class="Function">C.pullr</a> <a id="5559" class="Symbol">(</a><a id="5560" href="Cat.Base.html#13355" data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" class="Field">α.is-natural</a> <a id="5573" class="Symbol">_</a> <a id="5575" class="Symbol">_</a> <a id="5577" class="Symbol">_)</a> <a id="5580" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="5586" href="Cat.Base.html#8800" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">M.₁</a> <a id="5590" class="Symbol">(</a><a id="5591" href="Cat.Functor.Adjoint.html#2466" class="Function">counit.ε</a> <a id="5600" class="Symbol">_)</a> <a id="5603" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="5607" href="Cat.Base.html#8800" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">M.₁</a> <a id="5611" class="Symbol">(</a><a id="5612" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Function">F.F₁</a> <a id="5617" class="Symbol">(</a><a id="5618" href="Cat.Functor.Adjoint.html#2342" data-type="L ⊣ R₁ → Id =&gt; R₁ F∘ L" class="Field">unit</a> <a id="5623" class="Symbol">.</a><a id="5624" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="5626" class="Symbol">_))</a> <a id="5630" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="5634" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">α.η</a> <a id="5638" class="Symbol">_</a>  <span class="reasoning-step"><span class="as-written Function"><a id="5641" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="5644" href="Cat.Functor.Reasoning.html#2239" data-type="(F : Functor 𝒞 𝒟) →
(F ∘ a) b ≡ id F → (F ∘ F₁ F a) ((F ∘ F₁ F b) f) ≡ f" class="Function">M.cancell</a> <a id="5654" href="Cat.Functor.Adjoint.html#2943" data-type="(r : L ⊣ R₁) →
D ._∘_ (η (r .counit) (F₀ L A)) (F₁ L (r .unit .η A)) ≡ D .id" class="Field">zig</a> <a id="5658" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="5664" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">α.η</a> <a id="5668" class="Symbol">_</a>                                                  <a id="5719" href="1Lab.Path.html#46945" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
    <a id="5725" class="Keyword">where</a> <a id="5731" class="Keyword">module</a> <a id="5738" href="Cat.Functor.Kan.html#5738" class="Module">α</a> <a id="5740" class="Symbol">=</a> <a id="5742" href="Cat.Base.html#12227" data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" class="Module Operator">_=&gt;_</a> <a id="5747" href="Cat.Functor.Kan.html#5469" class="Bound">α</a>
          <a id="5759" class="Keyword">module</a> <a id="5766" href="Cat.Functor.Kan.html#5766" class="Module">M</a> <a id="5768" class="Symbol">=</a> <a id="5770" href="Cat.Functor.Reasoning.html" class="Module">Func</a> <a id="5775" href="Cat.Functor.Kan.html#5465" class="Bound">M</a>

  <a id="5780" href="Cat.Functor.Kan.html#4548" data-type="(adj : F ⊣ G) → Lan F Id" class="Function">adjoint→lan</a> <a id="5792" class="Symbol">.</a><a id="5793" href="Cat.Functor.Kan.html#3827" data-type="(r : Lan p F) → α ≡ (whiskerl σ′ ∘nt r .eta) → r .σ α ≡ σ′" class="Field">σ-uniq</a> <a id="5800" class="Symbol">{</a><a id="5801" href="Cat.Functor.Kan.html#5801" class="Bound">M</a><a id="5802" class="Symbol">}</a> <a id="5804" class="Symbol">{</a><a id="5805" href="Cat.Functor.Kan.html#5805" class="Bound">α</a><a id="5806" class="Symbol">}</a> <a id="5808" class="Symbol">{</a><a id="5809" href="Cat.Functor.Kan.html#5809" class="Bound">σ&#39;</a><a id="5811" class="Symbol">}</a> <a id="5813" href="Cat.Functor.Kan.html#5813" class="Bound">p</a> <a id="5815" class="Symbol">=</a> <a id="5817" href="Cat.Base.html#15577" data-type="((x : C .Ob) → a .η x ≡ b .η x) → a ≡ b" class="Function">Nat-path</a> <a id="5826" class="Symbol">λ</a> <a id="5828" href="Cat.Functor.Kan.html#5828" class="Bound">x</a> <a id="5830" class="Symbol">→</a>
    <a id="5836" href="Cat.Base.html#8800" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">M.₁</a> <a id="5840" class="Symbol">(</a><a id="5841" href="Cat.Functor.Adjoint.html#2466" class="Function">counit.ε</a> <a id="5850" class="Symbol">_)</a> <a id="5853" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="5857" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Function">α.η</a> <a id="5861" class="Symbol">_</a>                <span class="reasoning-step"><span class="as-written Function"><a id="5878" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="5881" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="5884" class="Symbol">(_</a> <a id="5887" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘_</a><a id="5891" class="Symbol">)</a> <a id="5893" class="Symbol">(</a><a id="5894" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="5897" class="Symbol">(λ</a> <a id="5900" href="Cat.Functor.Kan.html#5900" class="Bound">e</a> <a id="5902" class="Symbol">→</a> <a id="5904" href="Cat.Functor.Kan.html#5900" class="Bound">e</a> <a id="5906" class="Symbol">.</a><a id="5907" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="5909" class="Symbol">_)</a> <a id="5912" href="Cat.Functor.Kan.html#5813" class="Bound">p</a><a id="5913" class="Symbol">)</a> <a id="5915" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="5921" href="Cat.Base.html#8800" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">M.₁</a> <a id="5925" class="Symbol">(</a><a id="5926" href="Cat.Functor.Adjoint.html#2466" class="Function">counit.ε</a> <a id="5935" class="Symbol">_)</a> <a id="5938" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="5942" href="Cat.Functor.Kan.html#5809" class="Bound">σ&#39;</a> <a id="5945" class="Symbol">.</a><a id="5946" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="5948" class="Symbol">_</a> <a id="5950" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="5954" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Function">unit.η</a> <a id="5961" class="Symbol">_</a> <span class="reasoning-step"><span class="as-written Function"><a id="5963" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="5966" href="Cat.Reasoning.html#2057" data-type="(C : Precategory o ℓ) →
(C ∘ f) h ≡ (C ∘ g) i → (C ∘ f) ((C ∘ h) b) ≡ (C ∘ g) ((C ∘ i) b)" class="Function">C.extendl</a> <a id="5976" class="Symbol">(</a><a id="5977" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="5981" class="Symbol">(</a><a id="5982" href="Cat.Functor.Kan.html#5809" class="Bound">σ&#39;</a> <a id="5985" class="Symbol">.</a><a id="5986" href="Cat.Base.html#13355" data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" class="Field">is-natural</a> <a id="5997" class="Symbol">_</a> <a id="5999" class="Symbol">_</a> <a id="6001" class="Symbol">_))</a> <a id="6005" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="6011" href="Cat.Functor.Kan.html#5809" class="Bound">σ&#39;</a> <a id="6014" class="Symbol">.</a><a id="6015" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="6017" class="Symbol">_</a> <a id="6019" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="6023" href="Cat.Base.html#8800" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">G.₁</a> <a id="6027" class="Symbol">(</a><a id="6028" href="Cat.Functor.Adjoint.html#2466" class="Function">counit.ε</a> <a id="6037" class="Symbol">_)</a> <a id="6040" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="6044" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Function">unit.η</a> <a id="6051" class="Symbol">_</a> <span class="reasoning-step"><span class="as-written Function"><a id="6053" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="6056" href="Cat.Reasoning.html#1133" data-type="(C : Precategory o ℓ) → a ≡ id C → (C ∘ f) a ≡ f" class="Function">C.elimr</a> <a id="6064" href="Cat.Functor.Adjoint.html#3006" data-type="(r : L ⊣ R₁) →
C ._∘_ (F₁ R₁ (η (r .counit) B₁)) (r .unit .η (F₀ R₁ B₁)) ≡ C .id" class="Field">zag</a> <a id="6068" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="6074" href="Cat.Functor.Kan.html#5809" class="Bound">σ&#39;</a> <a id="6077" class="Symbol">.</a><a id="6078" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="6080" href="Cat.Functor.Kan.html#5828" class="Bound">x</a>                                   <a id="6116" href="1Lab.Path.html#46945" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
    <a id="6122" class="Keyword">where</a> <a id="6128" class="Keyword">module</a> <a id="6135" href="Cat.Functor.Kan.html#6135" class="Module">α</a> <a id="6137" class="Symbol">=</a> <a id="6139" href="Cat.Base.html#12227" data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" class="Module Operator">_=&gt;_</a> <a id="6144" href="Cat.Functor.Kan.html#5805" class="Bound">α</a>
          <a id="6156" class="Keyword">module</a> <a id="6163" href="Cat.Functor.Kan.html#6163" class="Module">M</a> <a id="6165" class="Symbol">=</a> <a id="6167" href="Cat.Functor.Reasoning.html" class="Module">Func</a> <a id="6172" href="Cat.Functor.Kan.html#5801" class="Bound">M</a>
</pre>
<h1 id="a-formula"><a href="#a-formula" class="header-link">A
formula<span class="header-link-emoji">🔗</span></a></h1>
<p>In the cases where
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi><mo separator="true">,</mo><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">\ca{C}, \ca{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span>
are “small enough” and
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">E</mi></mrow><annotation encoding="application/x-tex">\ca{E}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.08944em;">E</span></span></span></span>
is “cocomplete enough”, the left Kan extension of <em>any</em> functor
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>:</mo><mi mathvariant="script">C</mi><mo>→</mo><mi mathvariant="script">E</mi></mrow><annotation encoding="application/x-tex">F : \ca{C} \to \ca{E}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.08944em;">E</span></span></span></span>
along <em>any</em> functor
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>:</mo><mi mathvariant="script">C</mi><mo>→</mo><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">K : \ca{C} \to \ca{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span>
exists, and is computed as a colimit in
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">E</mi></mrow><annotation encoding="application/x-tex">\ca{E}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.08944em;">E</span></span></span></span>.</span>
The size concerns here are unavoidable, so let’s be explicit about them:
Suppose that
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">E</mi></mrow><annotation encoding="application/x-tex">\ca{E}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.08944em;">E</span></span></span></span>
admits colimits of <a href="1Lab.intro.html#universes-and-size-issues"><span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">κ</span></span></span></span>-small</span>
diagrams</a>, e.g. because it is
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="bold">S</mi><mi mathvariant="bold">e</mi><mi mathvariant="bold">t</mi><mi mathvariant="bold">s</mi></mrow><mi>κ</mi></msub></mrow><annotation encoding="application/x-tex">\sets_\kappa</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8361em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">Sets</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">κ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</span>
Then the category
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">\ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span>
must be
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">κ</span></span></span></span>-small,</span>
and
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">\ca{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span>
must be locally
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">κ</span></span></span></span>-small,</span>
i.e. its Hom-sets must live in the
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">κ</span></span></span></span>th</span>
universe.</p>
<!--
<pre class="Agda"><a id="6854" class="Keyword">module</a> <a id="6861" href="Cat.Functor.Kan.html#6861" class="Module">_</a>
  <a id="6865" class="Symbol">{</a><a id="6866" href="Cat.Functor.Kan.html#6866" class="Bound">o</a> <a id="6868" href="Cat.Functor.Kan.html#6868" class="Bound">o′</a> <a id="6871" href="Cat.Functor.Kan.html#6871" class="Bound">ℓ</a> <a id="6873" href="Cat.Functor.Kan.html#6873" class="Bound">κ</a><a id="6874" class="Symbol">}</a> <a id="6876" class="Symbol">{</a><a id="6877" href="Cat.Functor.Kan.html#6877" class="Bound">C</a> <a id="6879" class="Symbol">:</a> <a id="6881" href="Cat.Base.html#704" data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" class="Record">Precategory</a> <a id="6893" href="Cat.Functor.Kan.html#6873" class="Bound">κ</a> <a id="6895" href="Cat.Functor.Kan.html#6873" class="Bound">κ</a><a id="6896" class="Symbol">}</a> <a id="6898" class="Symbol">{</a><a id="6899" href="Cat.Functor.Kan.html#6899" class="Bound">D</a> <a id="6901" class="Symbol">:</a> <a id="6903" href="Cat.Base.html#704" data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" class="Record">Precategory</a> <a id="6915" href="Cat.Functor.Kan.html#6868" class="Bound">o′</a> <a id="6918" href="Cat.Functor.Kan.html#6873" class="Bound">κ</a><a id="6919" class="Symbol">}</a> <a id="6921" class="Symbol">{</a><a id="6922" href="Cat.Functor.Kan.html#6922" class="Bound">E</a> <a id="6924" class="Symbol">:</a> <a id="6926" href="Cat.Base.html#704" data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" class="Record">Precategory</a> <a id="6938" href="Cat.Functor.Kan.html#6866" class="Bound">o</a> <a id="6940" href="Cat.Functor.Kan.html#6871" class="Bound">ℓ</a><a id="6941" class="Symbol">}</a>
  <a id="6945" class="Symbol">(</a><a id="6946" href="Cat.Functor.Kan.html#6946" class="Bound">colim</a> <a id="6952" class="Symbol">:</a> <a id="6954" href="Cat.Diagram.Colimit.Base.html#8150" data-type="(o ℓ : Level) →
Precategory oc ℓc → Type (oc ⊔ ℓc ⊔ lsuc o ⊔ lsuc ℓ)" class="Function">is-cocomplete</a> <a id="6968" href="Cat.Functor.Kan.html#6873" class="Bound">κ</a> <a id="6970" href="Cat.Functor.Kan.html#6873" class="Bound">κ</a> <a id="6972" href="Cat.Functor.Kan.html#6922" class="Bound">E</a><a id="6973" class="Symbol">)</a>
  <a id="6977" class="Symbol">(</a><a id="6978" href="Cat.Functor.Kan.html#6978" class="Bound">K</a> <a id="6980" class="Symbol">:</a> <a id="6982" href="Cat.Base.html#7198" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="6990" href="Cat.Functor.Kan.html#6877" class="Bound">C</a> <a id="6992" href="Cat.Functor.Kan.html#6899" class="Bound">D</a><a id="6993" class="Symbol">)</a>
  <a id="6997" class="Symbol">(</a><a id="6998" href="Cat.Functor.Kan.html#6998" class="Bound">F</a> <a id="7000" class="Symbol">:</a> <a id="7002" href="Cat.Base.html#7198" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="7010" href="Cat.Functor.Kan.html#6877" class="Bound">C</a> <a id="7012" href="Cat.Functor.Kan.html#6922" class="Bound">E</a><a id="7013" class="Symbol">)</a>
  <a id="7017" class="Keyword">where</a>
  <a id="7025" class="Keyword">private</a>
    <a id="7037" class="Keyword">module</a> <a id="7044" href="Cat.Functor.Kan.html#7044" class="Module">C</a> <a id="7046" class="Symbol">=</a> <a id="7048" href="Cat.Reasoning.html" class="Module">Cat</a> <a id="7052" href="Cat.Functor.Kan.html#6877" class="Bound">C</a>
    <a id="7058" class="Keyword">module</a> <a id="7065" href="Cat.Functor.Kan.html#7065" class="Module">D</a> <a id="7067" class="Symbol">=</a> <a id="7069" href="Cat.Reasoning.html" class="Module">Cat</a> <a id="7073" href="Cat.Functor.Kan.html#6899" class="Bound">D</a>
    <a id="7079" class="Keyword">module</a> <a id="7086" href="Cat.Functor.Kan.html#7086" class="Module">E</a> <a id="7088" class="Symbol">=</a> <a id="7090" href="Cat.Reasoning.html" class="Module">Cat</a> <a id="7094" href="Cat.Functor.Kan.html#6922" class="Bound">E</a>
    <a id="7100" class="Keyword">module</a> <a id="7107" href="Cat.Functor.Kan.html#7107" class="Module">F</a> <a id="7109" class="Symbol">=</a> <a id="7111" href="Cat.Functor.Reasoning.html" class="Module">Func</a> <a id="7116" href="Cat.Functor.Kan.html#6998" class="Bound">F</a>
    <a id="7122" class="Keyword">module</a> <a id="7129" href="Cat.Functor.Kan.html#7129" class="Module">K</a> <a id="7131" class="Symbol">=</a> <a id="7133" href="Cat.Functor.Reasoning.html" class="Module">Func</a> <a id="7138" href="Cat.Functor.Kan.html#6978" class="Bound">K</a>
    <a id="7144" class="Keyword">open</a> <a id="7149" href="Cat.Diagram.Colimit.Base.html#4086" data-type="(F : Functor J₁ C) (x y : Cocone F) → Type (o ⊔ ℓ′)" class="Module">Cocone-hom</a>
    <a id="7164" class="Keyword">open</a> <a id="7169" href="Cat.Diagram.Initial.html#401" data-type="(C : Precategory o h) → Type (o ⊔ h)" class="Module">Initial</a>
    <a id="7181" class="Keyword">open</a> <a id="7186" href="Cat.Base.html#7198" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Module">Functor</a>
    <a id="7198" class="Keyword">open</a> <a id="7203" href="Cat.Diagram.Colimit.Base.html#2300" data-type="(F : Functor J₁ C) → Type (o ⊔ ℓ ⊔ o′ ⊔ ℓ′)" class="Module">Cocone</a>
    <a id="7214" class="Keyword">open</a> <a id="7219" href="Cat.Functor.Kan.html#2838" data-type="(p : Functor C C′) (F : Functor C D) →
Type (C.o ⊔ C.ℓ ⊔ C′.o ⊔ C′.ℓ ⊔ D.o ⊔ D.ℓ)" class="Module">Lan</a>
    <a id="7227" class="Keyword">open</a> <a id="7232" href="Cat.Instances.Comma.html#1730" data-type="(F : Functor A C) (G : Functor B₁ C) → Type (ao ⊔ bo ⊔ h)" class="Module">↓Obj</a>
    <a id="7241" class="Keyword">open</a> <a id="7246" href="Cat.Instances.Comma.html#2452" data-type="(F : Functor A C) (G : Functor B₁ C) (a b : ↓Obj F G) →
Type (ah ⊔ bh ⊔ h)" class="Module">↓Hom</a>
</pre>-->
<p>The size restrictions on
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">\ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span>
and
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">\ca{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span>
ensure that the <a href="Cat.Instances.Comma.html">comma category</a>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>↘</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">K \searrow d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↘</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span>
is
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">κ</span></span></span></span>-small,</span>
so that
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">E</mi></mrow><annotation encoding="application/x-tex">\ca{E}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.08944em;">E</span></span></span></span>
has a colimit for it. The objects of this category can be considered
“approximations of
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span>
coming from
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">\ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span>”,
so the colimit over this category is a “best approximation of
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span>”!
The rest of the computation is “straightforward” in the way that most
category-theoretic computations are: it looks mighty complicated from
the outside, but when you’re actually working them out, there’s only one
step you can take at each point. Agda’s goal-and-context display guides
you the whole way.</p>
<pre class="Agda">  <a id="7933" href="Cat.Functor.Kan.html#7933" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E) →
D .Hom d e → Cocone (F F∘ Dom K (const! d))" class="Function">lan-approximate</a> <a id="7949" class="Symbol">:</a> <a id="7951" class="Symbol">∀</a> <a id="7953" class="Symbol">{</a><a id="7954" href="Cat.Functor.Kan.html#7954" class="Bound">d</a> <a id="7956" href="Cat.Functor.Kan.html#7956" class="Bound">e</a><a id="7957" class="Symbol">}</a> <a id="7959" class="Symbol">(</a><a id="7960" href="Cat.Functor.Kan.html#7960" class="Bound">f</a> <a id="7962" class="Symbol">:</a> <a id="7964" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">D.Hom</a> <a id="7970" href="Cat.Functor.Kan.html#7954" class="Bound">d</a> <a id="7972" href="Cat.Functor.Kan.html#7956" class="Bound">e</a><a id="7973" class="Symbol">)</a> <a id="7975" class="Symbol">→</a> <a id="7977" href="Cat.Diagram.Colimit.Base.html#2300" data-type="(F : Functor J₁ C) → Type (o ⊔ ℓ ⊔ o′ ⊔ ℓ′)" class="Record">Cocone</a> <a id="7984" class="Symbol">(</a><a id="7985" href="Cat.Functor.Kan.html#6998" class="Bound">F</a> <a id="7987" href="Cat.Base.html#9683" data-type="Functor D E → Functor C D → Functor C E" class="Function Operator">F∘</a> <a id="7990" href="Cat.Instances.Comma.html#5380" data-type="(F : Functor A C) (G : Functor B₁ C) → Functor (F ↓ G) A" class="Function">Dom</a> <a id="7994" href="Cat.Functor.Kan.html#6978" class="Bound">K</a> <a id="7996" class="Symbol">(</a><a id="7997" href="Cat.Instances.Shape.Terminal.html#558" data-type="Ob A → Functor ⊤Cat A" class="Function">const!</a> <a id="8004" href="Cat.Functor.Kan.html#7954" class="Bound">d</a><a id="8005" class="Symbol">))</a>
  <a id="8010" href="Cat.Functor.Kan.html#7933" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E) →
D .Hom d e → Cocone (F F∘ Dom K (const! d))" class="Function">lan-approximate</a> <a id="8026" class="Symbol">{</a><a id="8027" class="Argument">e</a> <a id="8029" class="Symbol">=</a> <a id="8031" href="Cat.Functor.Kan.html#8031" class="Bound">e</a><a id="8032" class="Symbol">}</a> <a id="8034" href="Cat.Functor.Kan.html#8034" class="Bound">f</a> <a id="8036" class="Symbol">.</a><a id="8037" href="Cat.Diagram.Colimit.Base.html#2661" data-type="Cocone F → C .Ob" class="Field">coapex</a> <a id="8044" class="Symbol">=</a> <a id="8046" href="Cat.Functor.Kan.html#6946" class="Bound">colim</a> <a id="8052" class="Symbol">(</a><a id="8053" href="Cat.Functor.Kan.html#6998" class="Bound">F</a> <a id="8055" href="Cat.Base.html#9683" data-type="Functor D E → Functor C D → Functor C E" class="Function Operator">F∘</a> <a id="8058" href="Cat.Instances.Comma.html#5380" data-type="(F : Functor A C) (G : Functor B₁ C) → Functor (F ↓ G) A" class="Function">Dom</a> <a id="8062" href="Cat.Functor.Kan.html#6978" class="Bound">K</a> <a id="8064" class="Symbol">(</a><a id="8065" href="Cat.Instances.Shape.Terminal.html#558" data-type="Ob A → Functor ⊤Cat A" class="Function">const!</a> <a id="8072" href="Cat.Functor.Kan.html#8031" class="Bound">e</a><a id="8073" class="Symbol">))</a> <a id="8076" class="Symbol">.</a><a id="8077" href="Cat.Diagram.Initial.html#442" data-type="Initial C → Ob C" class="Field">bot</a> <a id="8081" class="Symbol">.</a><a id="8082" href="Cat.Diagram.Colimit.Base.html#2661" data-type="Cocone F → C .Ob" class="Field">coapex</a>
  <a id="8091" href="Cat.Functor.Kan.html#7933" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E) →
D .Hom d e → Cocone (F F∘ Dom K (const! d))" class="Function">lan-approximate</a> <a id="8107" class="Symbol">{</a><a id="8108" class="Argument">e</a> <a id="8110" class="Symbol">=</a> <a id="8112" href="Cat.Functor.Kan.html#8112" class="Bound">e</a><a id="8113" class="Symbol">}</a> <a id="8115" href="Cat.Functor.Kan.html#8115" class="Bound">f</a> <a id="8117" class="Symbol">.</a><a id="8118" href="Cat.Diagram.Colimit.Base.html#2681" data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" class="Field">ψ</a> <a id="8120" href="Cat.Functor.Kan.html#8120" class="Bound">x</a> <a id="8122" class="Symbol">=</a>
    <a id="8128" href="Cat.Functor.Kan.html#6946" class="Bound">colim</a> <a id="8134" class="Symbol">(</a><a id="8135" href="Cat.Functor.Kan.html#6998" class="Bound">F</a> <a id="8137" href="Cat.Base.html#9683" data-type="Functor D E → Functor C D → Functor C E" class="Function Operator">F∘</a> <a id="8140" href="Cat.Instances.Comma.html#5380" data-type="(F : Functor A C) (G : Functor B₁ C) → Functor (F ↓ G) A" class="Function">Dom</a> <a id="8144" href="Cat.Functor.Kan.html#6978" class="Bound">K</a> <a id="8146" class="Symbol">(</a><a id="8147" href="Cat.Instances.Shape.Terminal.html#558" data-type="Ob A → Functor ⊤Cat A" class="Function">const!</a> <a id="8154" href="Cat.Functor.Kan.html#8112" class="Bound">e</a><a id="8155" class="Symbol">))</a> <a id="8158" class="Symbol">.</a><a id="8159" href="Cat.Diagram.Initial.html#442" data-type="Initial C → Ob C" class="Field">bot</a> <a id="8163" class="Symbol">.</a><a id="8164" href="Cat.Diagram.Colimit.Base.html#2681" data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" class="Field">ψ</a> <a id="8166" class="Symbol">(</a><a id="8167" class="Keyword">record</a> <a id="8174" class="Symbol">{</a> <a id="8176" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">map</a> <a id="8180" class="Symbol">=</a> <a id="8182" href="Cat.Functor.Kan.html#8115" class="Bound">f</a> <a id="8184" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8188" href="Cat.Functor.Kan.html#8120" class="Bound">x</a> <a id="8190" class="Symbol">.</a><a id="8191" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">map</a> <a id="8195" class="Symbol">})</a>
  <a id="8200" href="Cat.Functor.Kan.html#7933" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E) →
D .Hom d e → Cocone (F F∘ Dom K (const! d))" class="Function">lan-approximate</a> <a id="8216" class="Symbol">{</a><a id="8217" class="Argument">e</a> <a id="8219" class="Symbol">=</a> <a id="8221" href="Cat.Functor.Kan.html#8221" class="Bound">e</a><a id="8222" class="Symbol">}</a> <a id="8224" href="Cat.Functor.Kan.html#8224" class="Bound">f</a> <a id="8226" class="Symbol">.</a><a id="8227" href="Cat.Diagram.Colimit.Base.html#3115" data-type="(r : Cocone F) (f : J₁ .Hom x y) → C ._∘_ (r .ψ y) (₁ F f) ≡ r .ψ x" class="Field">commutes</a> <a id="8236" class="Symbol">{</a><a id="8237" href="Cat.Functor.Kan.html#8237" class="Bound">x</a><a id="8238" class="Symbol">}</a> <a id="8240" class="Symbol">{</a><a id="8241" href="Cat.Functor.Kan.html#8241" class="Bound">y</a><a id="8242" class="Symbol">}</a> <a id="8244" href="Cat.Functor.Kan.html#8244" class="Bound">h</a> <a id="8246" class="Symbol">=</a>
    <a id="8252" href="Cat.Functor.Kan.html#6946" class="Bound">colim</a> <a id="8258" class="Symbol">(</a><a id="8259" href="Cat.Functor.Kan.html#6998" class="Bound">F</a> <a id="8261" href="Cat.Base.html#9683" data-type="Functor D E → Functor C D → Functor C E" class="Function Operator">F∘</a> <a id="8264" href="Cat.Instances.Comma.html#5380" data-type="(F : Functor A C) (G : Functor B₁ C) → Functor (F ↓ G) A" class="Function">Dom</a> <a id="8268" href="Cat.Functor.Kan.html#6978" class="Bound">K</a> <a id="8270" class="Symbol">(</a><a id="8271" href="Cat.Instances.Shape.Terminal.html#558" data-type="Ob A → Functor ⊤Cat A" class="Function">const!</a> <a id="8278" href="Cat.Functor.Kan.html#8221" class="Bound">e</a><a id="8279" class="Symbol">))</a> <a id="8282" class="Symbol">.</a><a id="8283" href="Cat.Diagram.Initial.html#442" data-type="Initial C → Ob C" class="Field">bot</a> <a id="8287" class="Symbol">.</a><a id="8288" href="Cat.Diagram.Colimit.Base.html#3115" data-type="(r : Cocone F) (f : J₁ .Hom x y) → C ._∘_ (r .ψ y) (₁ F f) ≡ r .ψ x" class="Field">commutes</a> <a id="8297" class="Symbol">(</a><a id="8298" class="Keyword">record</a> <a id="8305" class="Symbol">{</a> <a id="8307" href="Cat.Instances.Comma.html#2646" data-type="(r : ↓Hom F G a b) →
C ._∘_ (map b) (F₁ F (r .α)) ≡ C ._∘_ (F₁ G (r .β)) (a .map)" class="Field">sq</a> <a id="8310" class="Symbol">=</a> <a id="8312" href="Cat.Functor.Kan.html#8345" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E)
(f : D .Hom d e) (h : (K ↓ const! d) .Hom x y) →
D ._∘_ (D ._∘_ f (y .map)) (₁ K (h .α)) ≡
D ._∘_ (D .id) (D ._∘_ f (x .map))" class="Function">path</a> <a id="8317" class="Symbol">})</a>
    <a id="8324" class="Keyword">where</a> <a id="8330" class="Keyword">abstract</a>
      <a id="8345" href="Cat.Functor.Kan.html#8345" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E)
(f : D .Hom d e) (h : (K ↓ const! d) .Hom x y) →
D ._∘_ (D ._∘_ f (y .map)) (₁ K (h .α)) ≡
D ._∘_ (D .id) (D ._∘_ f (x .map))" class="Function">path</a> <a id="8350" class="Symbol">:</a> <a id="8352" class="Symbol">(</a><a id="8353" href="Cat.Functor.Kan.html#8224" class="Bound">f</a> <a id="8355" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8359" href="Cat.Functor.Kan.html#8241" class="Bound">y</a> <a id="8361" class="Symbol">.</a><a id="8362" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">map</a><a id="8365" class="Symbol">)</a> <a id="8367" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8371" href="Cat.Base.html#8800" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">K.₁</a> <a id="8375" class="Symbol">(</a><a id="8376" href="Cat.Functor.Kan.html#8244" class="Bound">h</a> <a id="8378" class="Symbol">.</a><a id="8379" href="Cat.Instances.Comma.html#2595" data-type="↓Hom F G a b → Hom A (a .x) (x b)" class="Field">α</a><a id="8380" class="Symbol">)</a> <a id="8382" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="8384" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">D.id</a> <a id="8389" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8393" class="Symbol">(</a><a id="8394" href="Cat.Functor.Kan.html#8224" class="Bound">f</a> <a id="8396" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8400" href="Cat.Functor.Kan.html#8237" class="Bound">x</a> <a id="8402" class="Symbol">.</a><a id="8403" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">map</a><a id="8406" class="Symbol">)</a>
      <a id="8414" href="Cat.Functor.Kan.html#8345" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E)
(f : D .Hom d e) (h : (K ↓ const! d) .Hom x y) →
D ._∘_ (D ._∘_ f (y .map)) (₁ K (h .α)) ≡
D ._∘_ (D .id) (D ._∘_ f (x .map))" class="Function">path</a> <a id="8419" class="Symbol">=</a>
        <a id="8429" class="Symbol">(</a><a id="8430" href="Cat.Functor.Kan.html#8224" class="Bound">f</a> <a id="8432" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8436" href="Cat.Functor.Kan.html#8241" class="Bound">y</a> <a id="8438" class="Symbol">.</a><a id="8439" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">map</a><a id="8442" class="Symbol">)</a> <a id="8444" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8448" href="Cat.Base.html#8800" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">K.₁</a> <a id="8452" class="Symbol">(</a><a id="8453" href="Cat.Functor.Kan.html#8244" class="Bound">h</a> <a id="8455" class="Symbol">.</a><a id="8456" href="Cat.Instances.Comma.html#2595" data-type="↓Hom F G a b → Hom A (a .x) (x b)" class="Field">α</a><a id="8457" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function"><a id="8459" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="8462" href="Cat.Reasoning.html#1711" data-type="(C : Precategory o ℓ) →
(C ∘ a) b ≡ c → (C ∘ (C ∘ f) a) b ≡ (C ∘ f) c" class="Function">D.pullr</a> <a id="8470" class="Symbol">(</a><a id="8471" href="Cat.Functor.Kan.html#8244" class="Bound">h</a> <a id="8473" class="Symbol">.</a><a id="8474" href="Cat.Instances.Comma.html#2646" data-type="(r : ↓Hom F G a b) →
C ._∘_ (map b) (F₁ F (r .α)) ≡ C ._∘_ (F₁ G (r .β)) (a .map)" class="Field">sq</a><a id="8476" class="Symbol">)</a> <a id="8478" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
        <a id="8488" href="Cat.Functor.Kan.html#8224" class="Bound">f</a> <a id="8490" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8494" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">D.id</a> <a id="8499" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8503" href="Cat.Functor.Kan.html#8237" class="Bound">x</a> <a id="8505" class="Symbol">.</a><a id="8506" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">map</a>         <span class="reasoning-step"><span class="as-written Function"><a id="8518" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="8521" href="Cat.Solver.html#7426" data-type="Term → Term → TC ⊤" class="Macro">solve</a> <a id="8527" href="Cat.Functor.Kan.html#6899" class="Bound">D</a> <a id="8529" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
        <a id="8539" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">D.id</a> <a id="8544" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8548" class="Symbol">(</a><a id="8549" href="Cat.Functor.Kan.html#8224" class="Bound">f</a> <a id="8551" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8555" href="Cat.Functor.Kan.html#8237" class="Bound">x</a> <a id="8557" class="Symbol">.</a><a id="8558" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">map</a><a id="8561" class="Symbol">)</a>       <a id="8569" href="1Lab.Path.html#46945" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>

  <a id="8574" href="Cat.Functor.Kan.html#8574" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E) →
Lan K F" class="Function">cocomplete→lan</a> <a id="8589" class="Symbol">:</a> <a id="8591" href="Cat.Functor.Kan.html#2838" data-type="(p : Functor C C′) (F : Functor C D) →
Type (C.o ⊔ C.ℓ ⊔ C′.o ⊔ C′.ℓ ⊔ D.o ⊔ D.ℓ)" class="Record">Lan</a> <a id="8595" href="Cat.Functor.Kan.html#6978" class="Bound">K</a> <a id="8597" href="Cat.Functor.Kan.html#6998" class="Bound">F</a>
  <a id="8601" href="Cat.Functor.Kan.html#8574" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E) →
Lan K F" class="Function">cocomplete→lan</a> <a id="8616" class="Symbol">=</a> <a id="8618" href="Cat.Functor.Kan.html#11143" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E) →
Lan K F" class="Function">lan</a> <a id="8622" class="Keyword">where</a>
    <a id="8632" href="Cat.Functor.Kan.html#8632" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) →
Functor C E → (d : D .Ob) → Functor (K ↘ d) E" class="Function">diagram</a> <a id="8640" class="Symbol">:</a> <a id="8642" class="Symbol">∀</a> <a id="8644" href="Cat.Functor.Kan.html#8644" class="Bound">d</a> <a id="8646" class="Symbol">→</a> <a id="8648" href="Cat.Base.html#7198" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="8656" class="Symbol">(</a><a id="8657" href="Cat.Functor.Kan.html#6978" class="Bound">K</a> <a id="8659" href="Cat.Instances.Comma.html#5869" data-type="Functor B₁ A →
A .Ob → Precategory (ah ⊔ bo ⊔ lzero) (ah ⊔ bh ⊔ lzero)" class="Function Operator">↘</a> <a id="8661" href="Cat.Functor.Kan.html#8644" class="Bound">d</a><a id="8662" class="Symbol">)</a> <a id="8664" href="Cat.Functor.Kan.html#6922" class="Bound">E</a>
    <a id="8670" href="Cat.Functor.Kan.html#8632" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) →
Functor C E → (d : D .Ob) → Functor (K ↘ d) E" class="Function">diagram</a> <a id="8678" href="Cat.Functor.Kan.html#8678" class="Bound">d</a> <a id="8680" class="Symbol">=</a> <a id="8682" href="Cat.Functor.Kan.html#6998" class="Bound">F</a> <a id="8684" href="Cat.Base.html#9683" data-type="Functor D E → Functor C D → Functor C E" class="Function Operator">F∘</a> <a id="8687" href="Cat.Instances.Comma.html#5380" data-type="(F : Functor A C) (G : Functor B₁ C) → Functor (F ↓ G) A" class="Function">Dom</a> <a id="8691" href="Cat.Functor.Kan.html#6978" class="Bound">K</a> <a id="8693" class="Symbol">(</a><a id="8694" href="Cat.Instances.Shape.Terminal.html#558" data-type="Ob A → Functor ⊤Cat A" class="Function">const!</a> <a id="8701" href="Cat.Functor.Kan.html#8678" class="Bound">d</a><a id="8702" class="Symbol">)</a>

    <a id="8709" href="Cat.Functor.Kan.html#8709" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E) →
D .Hom d e → Cocone (F F∘ Dom K (const! d))" class="Function">approx</a> <a id="8716" class="Symbol">=</a> <a id="8718" href="Cat.Functor.Kan.html#7933" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E) →
D .Hom d e → Cocone (F F∘ Dom K (const! d))" class="Function">lan-approximate</a>
</pre>
<p>Our extension will associate to each object
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span>
the colimit of</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mi>K</mi><mo>↘</mo><mi>d</mi><mo stretchy="false">)</mo><mover><mo stretchy="true" minsize="3.0em">→</mo><mpadded width="+0.6em" lspace="0.3em"><mrow><mi mathvariant="normal">D</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">m</mi></mrow></mpadded></mover><mi>C</mi><mover><mo stretchy="true" minsize="3.0em">→</mo><mpadded width="+0.6em" lspace="0.3em"><mi>F</mi></mpadded></mover><mi>E</mi><mtext>,</mtext></mrow><annotation encoding="application/x-tex">
(K \searrow d) \xto{\id{Dom}} C \xto{F} E\text{,}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↘</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3503em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel x-arrow"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1003em;"><span style="top:-3.322em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">Dom</span></span></span></span></span><span class="svg-align" style="top:-2.689em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.522em;min-width:1.469em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.522em" viewBox="0 0 400000 522" preserveAspectRatio="xMaxYMin slice"><path d="M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1113em;vertical-align:-0.011em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel x-arrow"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1003em;"><span style="top:-3.322em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="svg-align" style="top:-2.689em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.522em;min-width:1.469em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.522em" viewBox="0 0 400000 522" preserveAspectRatio="xMaxYMin slice"><path d="M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord text"><span class="mord">,</span></span></span></span></span></span></p>
<p>where
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">D</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">m</mi></mrow><annotation encoding="application/x-tex">\id{Dom}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathrm">Dom</span></span></span></span></span>
is the functor which projects out the <em>dom</em>ain of each object of
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>↘</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">K \searrow d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↘</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span>.</span>
Now, we must also associate <em>arrows</em>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>d</mi><mo>→</mo><mi>e</mi><mo>∈</mo><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">f : d \to e \in \ca{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span>
to arrows between the respective colimits of
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span>
and
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span>.</span>
What we note is that any arrow
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>d</mi><mo>→</mo><mi>e</mi></mrow><annotation encoding="application/x-tex">f : d \to e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span>
displays (the colimit associated with)
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span>
as a cocone under
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span>,</span>
as can be seen in the computation of
<span class="Agda"><a href="Cat.Functor.Kan.html#8709" class="Function">approx</a></span>
above.</p>
<p>Our functor can then take an arrow
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>d</mi><mo>→</mo><mi>e</mi></mrow><annotation encoding="application/x-tex">f : d \to e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span>
to the uniqueness arrow from
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">colim</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo><mo>→</mo><mi mathvariant="normal">colim</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\colim(d) \to \colim(e)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">colim</span></span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">colim</span></span><span class="mopen">(</span><span class="mord mathnormal">e</span><span class="mclose">)</span></span></span></span>
(punning
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span>
and
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span>
for their respective diagrams), which exists because
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">colim</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\colim(d)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">colim</span></span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mclose">)</span></span></span></span>
is initial. Uniqueness of this arrow ensures that this assignment is
functorial — but as the functoriality proof is (to use a technical term)
goddamn nasty, we leave it hidden from the page.</p>
<pre class="Agda">    <a id="9646" href="Cat.Functor.Kan.html#9646" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E) →
Functor D E" class="Function">func</a> <a id="9651" class="Symbol">:</a> <a id="9653" href="Cat.Base.html#7198" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="9661" href="Cat.Functor.Kan.html#6899" class="Bound">D</a> <a id="9663" href="Cat.Functor.Kan.html#6922" class="Bound">E</a>
    <a id="9669" href="Cat.Functor.Kan.html#9646" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E) →
Functor D E" class="Function">func</a> <a id="9674" class="Symbol">.</a><a id="9675" href="Cat.Base.html#7988" data-type="Functor C D → C .Ob → Ob D" class="Field">F₀</a> <a id="9678" href="Cat.Functor.Kan.html#9678" class="Bound">d</a> <a id="9680" class="Symbol">=</a> <a id="9682" href="Cat.Functor.Kan.html#6946" class="Bound">colim</a> <a id="9688" class="Symbol">(</a><a id="9689" href="Cat.Functor.Kan.html#8632" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) →
Functor C E → (d : D .Ob) → Functor (K ↘ d) E" class="Function">diagram</a> <a id="9697" href="Cat.Functor.Kan.html#9678" class="Bound">d</a><a id="9698" class="Symbol">)</a> <a id="9700" class="Symbol">.</a><a id="9701" href="Cat.Diagram.Initial.html#442" data-type="Initial C → Ob C" class="Field">bot</a> <a id="9705" class="Symbol">.</a><a id="9706" href="Cat.Diagram.Colimit.Base.html#2661" data-type="Cocone F → C .Ob" class="Field">coapex</a>
    <a id="9717" href="Cat.Functor.Kan.html#9646" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E) →
Functor D E" class="Function">func</a> <a id="9722" class="Symbol">.</a><a id="9723" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="9726" class="Symbol">{</a><a id="9727" href="Cat.Functor.Kan.html#9727" class="Bound">d</a><a id="9728" class="Symbol">}</a> <a id="9730" class="Symbol">{</a><a id="9731" href="Cat.Functor.Kan.html#9731" class="Bound">e</a><a id="9732" class="Symbol">}</a> <a id="9734" href="Cat.Functor.Kan.html#9734" class="Bound">f</a> <a id="9736" class="Symbol">=</a> <a id="9738" href="Cat.Functor.Kan.html#6946" class="Bound">colim</a> <a id="9744" class="Symbol">(</a><a id="9745" href="Cat.Functor.Kan.html#8632" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) →
Functor C E → (d : D .Ob) → Functor (K ↘ d) E" class="Function">diagram</a> <a id="9753" href="Cat.Functor.Kan.html#9727" class="Bound">d</a><a id="9754" class="Symbol">)</a> <a id="9756" class="Symbol">.</a><a id="9757" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Field">has⊥</a> <a id="9762" class="Symbol">(</a><a id="9763" href="Cat.Functor.Kan.html#8709" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E) →
D .Hom d e → Cocone (F F∘ Dom K (const! d))" class="Function">approx</a> <a id="9770" href="Cat.Functor.Kan.html#9734" class="Bound">f</a><a id="9771" class="Symbol">)</a> <a id="9773" class="Symbol">.</a><a id="9774" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a> <a id="9781" class="Symbol">.</a><a id="9782" href="Cat.Diagram.Colimit.Base.html#4197" data-type="Cocone-hom F x y → C .Hom (x .coapex) (y .coapex)" class="Field">hom</a>
</pre>
<!--
<pre class="Agda">    <a id="9808" href="Cat.Functor.Kan.html#9646" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E) →
Functor D E" class="Function">func</a> <a id="9813" class="Symbol">.</a><a id="9814" href="Cat.Base.html#8335" data-type="(r : Functor C D) → r .F₁ (C .id) ≡ id D" class="Field">F-id</a> <a id="9819" class="Symbol">{</a><a id="9820" href="Cat.Functor.Kan.html#9820" class="Bound">d</a><a id="9821" class="Symbol">}</a> <a id="9823" class="Symbol">=</a> <a id="9825" href="Cat.Functor.Kan.html#9851" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E) →
func colim K F .F₁ (D .id) ≡ E .id" class="Function">path</a> <a id="9830" class="Keyword">where</a> <a id="9836" class="Keyword">abstract</a>
      <a id="9851" href="Cat.Functor.Kan.html#9851" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E) →
func colim K F .F₁ (D .id) ≡ E .id" class="Function">path</a> <a id="9856" class="Symbol">:</a> <a id="9858" href="Cat.Functor.Kan.html#9646" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E) →
Functor D E" class="Function">func</a> <a id="9863" class="Symbol">.</a><a id="9864" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="9867" class="Symbol">(</a><a id="9868" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">D.id</a> <a id="9873" class="Symbol">{</a><a id="9874" class="Argument">x</a> <a id="9876" class="Symbol">=</a> <a id="9878" href="Cat.Functor.Kan.html#9820" class="Bound">d</a><a id="9879" class="Symbol">})</a> <a id="9882" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="9884" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">E.id</a>
      <a id="9895" href="Cat.Functor.Kan.html#9851" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E) →
func colim K F .F₁ (D .id) ≡ E .id" class="Function">path</a> <a id="9900" class="Symbol">=</a> <a id="9902" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="9905" href="Cat.Diagram.Colimit.Base.html#4197" data-type="Cocone-hom F x y → C .Hom (x .coapex) (y .coapex)" class="Field">hom</a> <a id="9909" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="9911" href="Cat.Functor.Kan.html#6946" class="Bound">colim</a> <a id="9917" class="Symbol">(</a><a id="9918" href="Cat.Functor.Kan.html#8632" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) →
Functor C E → (d : D .Ob) → Functor (K ↘ d) E" class="Function">diagram</a> <a id="9926" href="Cat.Functor.Kan.html#9820" class="Bound">d</a><a id="9927" class="Symbol">)</a> <a id="9929" class="Symbol">.</a><a id="9930" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Field">has⊥</a> <a id="9935" class="Symbol">(</a><a id="9936" href="Cat.Functor.Kan.html#8709" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E) →
D .Hom d e → Cocone (F F∘ Dom K (const! d))" class="Function">approx</a> <a id="9943" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">D.id</a><a id="9947" class="Symbol">)</a> <a id="9949" class="Symbol">.</a><a id="9950" href="1Lab.HLevel.html#1416" data-type="(r : is-contr A) (x : A) → r .centre ≡ x" class="Field">paths</a>
        <a id="9964" class="Symbol">(</a><a id="9965" href="Cat.Diagram.Colimit.Base.html#4170" data-type="(hom : C .Hom (x .coapex) (y .coapex))
(commutes : (o : J₁ .Ob) → C ._∘_ hom (x .ψ o) ≡ y .ψ o) →
Cocone-hom F x y" class="InductiveConstructor">cocone-hom</a> <a id="9976" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">E.id</a> <a id="9981" class="Symbol">(λ</a> <a id="9984" href="Cat.Functor.Kan.html#9984" class="Bound">o</a> <a id="9986" class="Symbol">→</a> <a id="9988" href="Cat.Base.html#3482" data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ (r .id) f ≡ f" class="Function">E.idl</a> <a id="9994" class="Symbol">_</a>
                         <a id="10021" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="10023" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="10026" class="Symbol">(</a><a id="10027" href="Cat.Functor.Kan.html#6946" class="Bound">colim</a> <a id="10033" class="Symbol">(</a><a id="10034" href="Cat.Functor.Kan.html#8632" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) →
Functor C E → (d : D .Ob) → Functor (K ↘ d) E" class="Function">diagram</a> <a id="10042" href="Cat.Functor.Kan.html#9820" class="Bound">d</a><a id="10043" class="Symbol">)</a> <a id="10045" class="Symbol">.</a><a id="10046" href="Cat.Diagram.Initial.html#442" data-type="Initial C → Ob C" class="Field">bot</a> <a id="10050" class="Symbol">.</a><a id="10051" href="Cat.Diagram.Colimit.Base.html#2681" data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" class="Field">ψ</a><a id="10052" class="Symbol">)</a>
                              <a id="10084" class="Symbol">(</a><a id="10085" href="Cat.Instances.Comma.html#3533" data-type="(F : Functor A C) (G : Functor B₁ C) (p : a .x ≡ b .x)
(q : a .y ≡ b .y) →
PathP (λ i → Hom C (F₀ F (p i)) (F₀ G (q i))) (a .map) (b .map) →
a ≡ b" class="Function">↓Obj-path</a> <a id="10095" class="Symbol">_</a> <a id="10097" class="Symbol">_</a> <a id="10099" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="10104" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="10109" class="Symbol">(</a><a id="10110" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="10114" class="Symbol">(</a><a id="10115" href="Cat.Base.html#3482" data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ (r .id) f ≡ f" class="Function">D.idl</a> <a id="10121" class="Symbol">_)))))</a>
    <a id="10132" href="Cat.Functor.Kan.html#9646" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E) →
Functor D E" class="Function">func</a> <a id="10137" class="Symbol">.</a><a id="10138" href="Cat.Base.html#8375" data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" class="Field">F-∘</a> <a id="10142" class="Symbol">{</a><a id="10143" href="Cat.Functor.Kan.html#10143" class="Bound">d</a><a id="10144" class="Symbol">}</a> <a id="10146" class="Symbol">{</a><a id="10147" href="Cat.Functor.Kan.html#10147" class="Bound">e</a><a id="10148" class="Symbol">}</a> <a id="10150" class="Symbol">{</a><a id="10151" href="Cat.Functor.Kan.html#10151" class="Bound">f</a><a id="10152" class="Symbol">}</a> <a id="10154" href="Cat.Functor.Kan.html#10154" class="Bound">g</a> <a id="10156" href="Cat.Functor.Kan.html#10156" class="Bound">h</a> <a id="10158" class="Symbol">=</a> <a id="10160" href="Cat.Functor.Kan.html#10186" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E)
(g : D .Hom e f) (h : D .Hom d e) →
func colim K F .F₁ (D ._∘_ g h) ≡
E ._∘_ (func colim K F .F₁ g) (func colim K F .F₁ h)" class="Function">path</a> <a id="10165" class="Keyword">where</a> <a id="10171" class="Keyword">abstract</a>
      <a id="10186" href="Cat.Functor.Kan.html#10186" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E)
(g : D .Hom e f) (h : D .Hom d e) →
func colim K F .F₁ (D ._∘_ g h) ≡
E ._∘_ (func colim K F .F₁ g) (func colim K F .F₁ h)" class="Function">path</a> <a id="10191" class="Symbol">:</a> <a id="10193" href="Cat.Functor.Kan.html#9646" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E) →
Functor D E" class="Function">func</a> <a id="10198" class="Symbol">.</a><a id="10199" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="10202" class="Symbol">(</a><a id="10203" href="Cat.Functor.Kan.html#10154" class="Bound">g</a> <a id="10205" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="10209" href="Cat.Functor.Kan.html#10156" class="Bound">h</a><a id="10210" class="Symbol">)</a> <a id="10212" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="10214" href="Cat.Functor.Kan.html#9646" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E) →
Functor D E" class="Function">func</a> <a id="10219" class="Symbol">.</a><a id="10220" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="10223" href="Cat.Functor.Kan.html#10154" class="Bound">g</a> <a id="10225" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">E.∘</a> <a id="10229" href="Cat.Functor.Kan.html#9646" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E) →
Functor D E" class="Function">func</a> <a id="10234" class="Symbol">.</a><a id="10235" href="Cat.Base.html#8009" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="10238" href="Cat.Functor.Kan.html#10156" class="Bound">h</a>
      <a id="10246" href="Cat.Functor.Kan.html#10186" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E)
(g : D .Hom e f) (h : D .Hom d e) →
func colim K F .F₁ (D ._∘_ g h) ≡
E ._∘_ (func colim K F .F₁ g) (func colim K F .F₁ h)" class="Function">path</a> <a id="10251" class="Symbol">=</a> <a id="10253" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="10256" href="Cat.Diagram.Colimit.Base.html#4197" data-type="Cocone-hom F x y → C .Hom (x .coapex) (y .coapex)" class="Field">hom</a> <a id="10260" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="10262" href="Cat.Functor.Kan.html#6946" class="Bound">colim</a> <a id="10268" class="Symbol">(</a><a id="10269" href="Cat.Functor.Kan.html#8632" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) →
Functor C E → (d : D .Ob) → Functor (K ↘ d) E" class="Function">diagram</a> <a id="10277" href="Cat.Functor.Kan.html#10143" class="Bound">d</a><a id="10278" class="Symbol">)</a> <a id="10280" class="Symbol">.</a><a id="10281" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Field">has⊥</a> <a id="10286" class="Symbol">(</a><a id="10287" href="Cat.Functor.Kan.html#8709" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E) →
D .Hom d e → Cocone (F F∘ Dom K (const! d))" class="Function">approx</a> <a id="10294" class="Symbol">_)</a> <a id="10297" class="Symbol">.</a><a id="10298" href="1Lab.HLevel.html#1416" data-type="(r : is-contr A) (x : A) → r .centre ≡ x" class="Field">paths</a>
        <a id="10312" class="Symbol">(</a><a id="10313" href="Cat.Diagram.Colimit.Base.html#4170" data-type="(hom : C .Hom (x .coapex) (y .coapex))
(commutes : (o : J₁ .Ob) → C ._∘_ hom (x .ψ o) ≡ y .ψ o) →
Cocone-hom F x y" class="InductiveConstructor">cocone-hom</a> <a id="10324" class="Symbol">_</a> <a id="10326" class="Symbol">λ</a> <a id="10328" href="Cat.Functor.Kan.html#10328" class="Bound">o</a> <a id="10330" class="Symbol">→</a>
            <a id="10344" href="Cat.Reasoning.html#1711" data-type="(C : Precategory o ℓ) →
(C ∘ a) b ≡ c → (C ∘ (C ∘ f) a) b ≡ (C ∘ f) c" class="Function">E.pullr</a> <a id="10352" class="Symbol">(</a><a id="10353" href="Cat.Functor.Kan.html#6946" class="Bound">colim</a> <a id="10359" class="Symbol">(</a><a id="10360" href="Cat.Functor.Kan.html#8632" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) →
Functor C E → (d : D .Ob) → Functor (K ↘ d) E" class="Function">diagram</a> <a id="10368" href="Cat.Functor.Kan.html#10143" class="Bound">d</a><a id="10369" class="Symbol">)</a> <a id="10371" class="Symbol">.</a><a id="10372" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Field">has⊥</a> <a id="10377" class="Symbol">(</a><a id="10378" href="Cat.Functor.Kan.html#8709" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E) →
D .Hom d e → Cocone (F F∘ Dom K (const! d))" class="Function">approx</a> <a id="10385" href="Cat.Functor.Kan.html#10156" class="Bound">h</a><a id="10386" class="Symbol">)</a> <a id="10388" class="Symbol">.</a><a id="10389" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a> <a id="10396" class="Symbol">.</a><a id="10397" href="Cat.Diagram.Colimit.Base.html#4239" data-type="(r : Cocone-hom F x y) (o : J₁ .Ob) →
C ._∘_ (r .hom) (x .ψ o) ≡ y .ψ o" class="Field">commutes</a> <a id="10406" class="Symbol">_)</a>
          <a id="10419" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="10421" href="Cat.Functor.Kan.html#6946" class="Bound">colim</a> <a id="10427" class="Symbol">(</a><a id="10428" href="Cat.Functor.Kan.html#8632" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) →
Functor C E → (d : D .Ob) → Functor (K ↘ d) E" class="Function">diagram</a> <a id="10436" href="Cat.Functor.Kan.html#10147" class="Bound">e</a><a id="10437" class="Symbol">)</a> <a id="10439" class="Symbol">.</a><a id="10440" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Field">has⊥</a> <a id="10445" class="Symbol">(</a><a id="10446" href="Cat.Functor.Kan.html#8709" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E) →
D .Hom d e → Cocone (F F∘ Dom K (const! d))" class="Function">approx</a> <a id="10453" href="Cat.Functor.Kan.html#10154" class="Bound">g</a><a id="10454" class="Symbol">)</a> <a id="10456" class="Symbol">.</a><a id="10457" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a> <a id="10464" class="Symbol">.</a><a id="10465" href="Cat.Diagram.Colimit.Base.html#4239" data-type="(r : Cocone-hom F x y) (o : J₁ .Ob) →
C ._∘_ (r .hom) (x .ψ o) ≡ y .ψ o" class="Field">commutes</a> <a id="10474" class="Symbol">_</a>
          <a id="10486" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="10488" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="10491" class="Symbol">(</a><a id="10492" href="Cat.Functor.Kan.html#6946" class="Bound">colim</a> <a id="10498" class="Symbol">(</a><a id="10499" href="Cat.Functor.Kan.html#8632" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) →
Functor C E → (d : D .Ob) → Functor (K ↘ d) E" class="Function">diagram</a> <a id="10507" href="Cat.Functor.Kan.html#10151" class="Bound">f</a><a id="10508" class="Symbol">)</a> <a id="10510" class="Symbol">.</a><a id="10511" href="Cat.Diagram.Initial.html#442" data-type="Initial C → Ob C" class="Field">bot</a> <a id="10515" class="Symbol">.</a><a id="10516" href="Cat.Diagram.Colimit.Base.html#2681" data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" class="Field">ψ</a><a id="10517" class="Symbol">)</a>
               <a id="10534" class="Symbol">(</a><a id="10535" href="Cat.Instances.Comma.html#3533" data-type="(F : Functor A C) (G : Functor B₁ C) (p : a .x ≡ b .x)
(q : a .y ≡ b .y) →
PathP (λ i → Hom C (F₀ F (p i)) (F₀ G (q i))) (a .map) (b .map) →
a ≡ b" class="Function">↓Obj-path</a> <a id="10545" class="Symbol">_</a> <a id="10547" class="Symbol">_</a> <a id="10549" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="10554" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="10559" class="Symbol">(</a><a id="10560" href="Cat.Base.html#3857" data-type="(r : Precategory o h) (f : r .Hom y z) (g : r .Hom x y)
(h : r .Hom w x) →
r ._∘_ f (r ._∘_ g h) ≡ r ._∘_ (r ._∘_ f g) h" class="Function">D.assoc</a> <a id="10568" class="Symbol">_</a> <a id="10570" class="Symbol">_</a> <a id="10572" class="Symbol">_)))</a>

    <a id="10582" class="Keyword">open</a> <a id="10587" href="Cat.Base.html#12227" data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" class="Module Operator">_=&gt;_</a>
</pre>-->
<p>It remains to show that our extension functor admits a natural
transformation (with components)
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>x</mi><mo>→</mo><mi mathvariant="normal">colim</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>F</mi><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Fx \to \colim(Fx)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">colim</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>,</span>
but we can take these arrows to be the colimit coprojections
<span class="Agda"><a href="Cat.Diagram.Colimit.Base.html#2681" class="Field">ψ</a></span>;
The factoring natural transformation
<span class="Agda"><a href="Cat.Functor.Kan.html#3692" class="Field">σ</a></span>
is given by eliminating the colimit, which ensures commutativity and
uniqueness. We leave the rest of the computation in this <code class="sourceCode html"><span class="kw">&lt;details&gt;</span></code>
tag, for the interested reader.</p>
<details>
<summary>
Fair advance warning that the computation here doesn’t have any further
comments.
</summary>
<pre class="Agda">    <a id="11143" href="Cat.Functor.Kan.html#11143" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E) →
Lan K F" class="Function">lan</a> <a id="11147" class="Symbol">:</a> <a id="11149" href="Cat.Functor.Kan.html#2838" data-type="(p : Functor C C′) (F : Functor C D) →
Type (C.o ⊔ C.ℓ ⊔ C′.o ⊔ C′.ℓ ⊔ D.o ⊔ D.ℓ)" class="Record">Lan</a> <a id="11153" href="Cat.Functor.Kan.html#6978" class="Bound">K</a> <a id="11155" href="Cat.Functor.Kan.html#6998" class="Bound">F</a>
    <a id="11161" href="Cat.Functor.Kan.html#11143" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E) →
Lan K F" class="Function">lan</a> <a id="11165" class="Symbol">.</a><a id="11166" href="Cat.Functor.Kan.html#2918" data-type="Lan p F → Functor C′ D" class="Field">Ext</a> <a id="11170" class="Symbol">=</a> <a id="11172" href="Cat.Functor.Kan.html#9646" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E) →
Functor D E" class="Function">func</a>
    <a id="11181" href="Cat.Functor.Kan.html#11143" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E) →
Lan K F" class="Function">lan</a> <a id="11185" class="Symbol">.</a><a id="11186" href="Cat.Functor.Kan.html#2941" data-type="(r : Lan p F) → F =&gt; r .Ext F∘ p" class="Field">eta</a> <a id="11190" class="Symbol">.</a><a id="11191" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="11193" href="Cat.Functor.Kan.html#11193" class="Bound">x</a> <a id="11195" class="Symbol">=</a> <a id="11197" href="Cat.Functor.Kan.html#6946" class="Bound">colim</a> <a id="11203" class="Symbol">(</a><a id="11204" href="Cat.Functor.Kan.html#8632" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) →
Functor C E → (d : D .Ob) → Functor (K ↘ d) E" class="Function">diagram</a> <a id="11212" class="Symbol">(</a><a id="11213" href="Cat.Base.html#8719" data-type="(r : Functor C D) → C .Ob → D .Ob" class="Function">K.₀</a> <a id="11217" href="Cat.Functor.Kan.html#11193" class="Bound">x</a><a id="11218" class="Symbol">))</a> <a id="11221" class="Symbol">.</a><a id="11222" href="Cat.Diagram.Initial.html#442" data-type="Initial C → Ob C" class="Field">bot</a> <a id="11226" class="Symbol">.</a><a id="11227" href="Cat.Diagram.Colimit.Base.html#2681" data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" class="Field">ψ</a> <a id="11229" class="Symbol">(</a><a id="11230" class="Keyword">record</a> <a id="11237" class="Symbol">{</a> <a id="11239" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">map</a> <a id="11243" class="Symbol">=</a> <a id="11245" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">D.id</a> <a id="11250" class="Symbol">})</a>

    <a id="11258" href="Cat.Functor.Kan.html#11143" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E) →
Lan K F" class="Function">lan</a> <a id="11262" class="Symbol">.</a><a id="11263" href="Cat.Functor.Kan.html#3692" data-type="(r : Lan p F) → F =&gt; M F∘ p → r .Ext =&gt; M" class="Field">σ</a> <a id="11265" class="Symbol">{</a><a id="11266" href="Cat.Functor.Kan.html#11266" class="Bound">M</a><a id="11267" class="Symbol">}</a> <a id="11269" href="Cat.Functor.Kan.html#11269" class="Bound">α</a> <a id="11271" class="Symbol">.</a><a id="11272" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="11274" href="Cat.Functor.Kan.html#11274" class="Bound">x</a> <a id="11276" class="Symbol">=</a> <a id="11278" href="Cat.Functor.Kan.html#6946" class="Bound">colim</a> <a id="11284" class="Symbol">(</a><a id="11285" href="Cat.Functor.Kan.html#8632" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) →
Functor C E → (d : D .Ob) → Functor (K ↘ d) E" class="Function">diagram</a> <a id="11293" href="Cat.Functor.Kan.html#11274" class="Bound">x</a><a id="11294" class="Symbol">)</a> <a id="11296" class="Symbol">.</a><a id="11297" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Field">has⊥</a> <a id="11302" href="Cat.Functor.Kan.html#11370" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E)
(α : F =&gt; M F∘ K) (x : D .Ob) →
Cocone (diagram colim K F x)" class="Function">cocone′</a> <a id="11310" class="Symbol">.</a><a id="11311" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a> <a id="11318" class="Symbol">.</a><a id="11319" href="Cat.Diagram.Colimit.Base.html#4197" data-type="Cocone-hom F x y → C .Hom (x .coapex) (y .coapex)" class="Field">hom</a>
      <a id="11329" class="Keyword">where</a>
        <a id="11343" class="Keyword">module</a> <a id="11350" href="Cat.Functor.Kan.html#11350" class="Module">M</a> <a id="11352" class="Symbol">=</a> <a id="11354" href="Cat.Functor.Reasoning.html" class="Module">Func</a> <a id="11359" href="Cat.Functor.Kan.html#11266" class="Bound">M</a>

        <a id="11370" href="Cat.Functor.Kan.html#11370" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E)
(α : F =&gt; M F∘ K) (x : D .Ob) →
Cocone (diagram colim K F x)" class="Function">cocone′</a> <a id="11378" class="Symbol">:</a> <a id="11380" href="Cat.Diagram.Colimit.Base.html#2300" data-type="(F : Functor J₁ C) → Type (o ⊔ ℓ ⊔ o′ ⊔ ℓ′)" class="Record">Cocone</a> <a id="11387" class="Symbol">_</a>
        <a id="11397" href="Cat.Functor.Kan.html#11370" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E)
(α : F =&gt; M F∘ K) (x : D .Ob) →
Cocone (diagram colim K F x)" class="Function">cocone′</a> <a id="11405" class="Symbol">.</a><a id="11406" href="Cat.Diagram.Colimit.Base.html#2661" data-type="Cocone F → C .Ob" class="Field">coapex</a> <a id="11413" class="Symbol">=</a> <a id="11415" href="Cat.Base.html#8719" data-type="(r : Functor C D) → C .Ob → D .Ob" class="Function">M.₀</a> <a id="11419" href="Cat.Functor.Kan.html#11274" class="Bound">x</a>
        <a id="11429" href="Cat.Functor.Kan.html#11370" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E)
(α : F =&gt; M F∘ K) (x : D .Ob) →
Cocone (diagram colim K F x)" class="Function">cocone′</a> <a id="11437" class="Symbol">.</a><a id="11438" href="Cat.Diagram.Colimit.Base.html#2681" data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" class="Field">ψ</a> <a id="11440" href="Cat.Functor.Kan.html#11440" class="Bound">ob</a> <a id="11443" class="Symbol">=</a> <a id="11445" href="Cat.Base.html#8800" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">M.₁</a> <a id="11449" class="Symbol">(</a><a id="11450" href="Cat.Functor.Kan.html#11440" class="Bound">ob</a> <a id="11453" class="Symbol">.</a><a id="11454" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">map</a><a id="11457" class="Symbol">)</a> <a id="11459" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">E.∘</a> <a id="11463" href="Cat.Functor.Kan.html#11269" class="Bound">α</a> <a id="11465" class="Symbol">.</a><a id="11466" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="11468" class="Symbol">_</a>
        <a id="11478" href="Cat.Functor.Kan.html#11370" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E)
(α : F =&gt; M F∘ K) (x : D .Ob) →
Cocone (diagram colim K F x)" class="Function">cocone′</a> <a id="11486" class="Symbol">.</a><a id="11487" href="Cat.Diagram.Colimit.Base.html#3115" data-type="(r : Cocone F) (f : J₁ .Hom x y) → C ._∘_ (r .ψ y) (₁ F f) ≡ r .ψ x" class="Field">commutes</a> <a id="11496" class="Symbol">{</a><a id="11497" href="Cat.Functor.Kan.html#11497" class="Bound">x</a><a id="11498" class="Symbol">}</a> <a id="11500" class="Symbol">{</a><a id="11501" href="Cat.Functor.Kan.html#11501" class="Bound">y</a><a id="11502" class="Symbol">}</a> <a id="11504" href="Cat.Functor.Kan.html#11504" class="Bound">f</a> <a id="11506" class="Symbol">=</a>
          <a id="11518" class="Symbol">(</a><a id="11519" href="Cat.Base.html#8800" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">M.₁</a> <a id="11523" class="Symbol">(</a><a id="11524" href="Cat.Functor.Kan.html#11501" class="Bound">y</a> <a id="11526" class="Symbol">.</a><a id="11527" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">map</a><a id="11530" class="Symbol">)</a> <a id="11532" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">E.∘</a> <a id="11536" href="Cat.Functor.Kan.html#11269" class="Bound">α</a> <a id="11538" class="Symbol">.</a><a id="11539" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="11541" class="Symbol">_)</a> <a id="11544" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">E.∘</a> <a id="11548" href="Cat.Base.html#8800" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">F.₁</a> <a id="11552" class="Symbol">(</a><a id="11553" href="Cat.Functor.Kan.html#11504" class="Bound">f</a> <a id="11555" class="Symbol">.</a><a id="11556" href="Cat.Instances.Comma.html#2595" data-type="↓Hom F G a b → Hom A (a .x) (x b)" class="Field">↓Hom.α</a><a id="11562" class="Symbol">)</a>      <span class="reasoning-step"><span class="as-written Function"><a id="11569" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="11572" href="Cat.Reasoning.html#1711" data-type="(C : Precategory o ℓ) →
(C ∘ a) b ≡ c → (C ∘ (C ∘ f) a) b ≡ (C ∘ f) c" class="Function">E.pullr</a> <a id="11580" class="Symbol">(</a><a id="11581" href="Cat.Functor.Kan.html#11269" class="Bound">α</a> <a id="11583" class="Symbol">.</a><a id="11584" href="Cat.Base.html#13355" data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" class="Field">is-natural</a> <a id="11595" class="Symbol">_</a> <a id="11597" class="Symbol">_</a> <a id="11599" class="Symbol">_)</a> <a id="11602" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
          <a id="11614" href="Cat.Base.html#8800" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">M.₁</a> <a id="11618" class="Symbol">(</a><a id="11619" href="Cat.Functor.Kan.html#11501" class="Bound">y</a> <a id="11621" class="Symbol">.</a><a id="11622" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">map</a><a id="11625" class="Symbol">)</a> <a id="11627" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">E.∘</a> <a id="11631" href="Cat.Base.html#8800" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">M.₁</a> <a id="11635" class="Symbol">(</a><a id="11636" href="Cat.Base.html#8800" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">K.₁</a> <a id="11640" class="Symbol">(</a><a id="11641" href="Cat.Functor.Kan.html#11504" class="Bound">f</a> <a id="11643" class="Symbol">.</a><a id="11644" href="Cat.Instances.Comma.html#2595" data-type="↓Hom F G a b → Hom A (a .x) (x b)" class="Field">↓Hom.α</a><a id="11650" class="Symbol">))</a> <a id="11653" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">E.∘</a> <a id="11657" href="Cat.Functor.Kan.html#11269" class="Bound">α</a> <a id="11659" class="Symbol">.</a><a id="11660" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="11662" class="Symbol">_</a>  <span class="reasoning-step"><span class="as-written Function"><a id="11665" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="11668" href="Cat.Functor.Reasoning.html#1281" data-type="(F : Functor 𝒞 𝒟) →
(F ∘ a) b ≡ c → (F ∘ F₁ F a) ((F ∘ F₁ F b) f) ≡ (F ∘ F₁ F c) f" class="Function">M.pulll</a> <a id="11676" class="Symbol">(</a><a id="11677" href="Cat.Functor.Kan.html#11504" class="Bound">f</a> <a id="11679" class="Symbol">.</a><a id="11680" href="Cat.Instances.Comma.html#2646" data-type="(r : ↓Hom F G a b) →
C ._∘_ (map b) (F₁ F (r .α)) ≡ C ._∘_ (F₁ G (r .β)) (a .map)" class="Field">↓Hom.sq</a> <a id="11688" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="11690" href="Cat.Base.html#3482" data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ (r .id) f ≡ f" class="Function">D.idl</a> <a id="11696" class="Symbol">_)</a> <a id="11699" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
          <a id="11711" href="Cat.Base.html#8800" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">M.₁</a> <a id="11715" class="Symbol">(</a><a id="11716" href="Cat.Functor.Kan.html#11497" class="Bound">x</a> <a id="11718" class="Symbol">.</a><a id="11719" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">map</a><a id="11722" class="Symbol">)</a> <a id="11724" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">E.∘</a> <a id="11728" href="Cat.Functor.Kan.html#11269" class="Bound">α</a> <a id="11730" class="Symbol">.</a><a id="11731" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="11733" class="Symbol">_</a>                            <a id="11762" href="1Lab.Path.html#46945" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>

    <a id="11769" href="Cat.Functor.Kan.html#11143" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E) →
Lan K F" class="Function">lan</a> <a id="11773" class="Symbol">.</a><a id="11774" href="Cat.Functor.Kan.html#2941" data-type="(r : Lan p F) → F =&gt; r .Ext F∘ p" class="Field">eta</a> <a id="11778" class="Symbol">.</a><a id="11779" href="Cat.Base.html#13355" data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" class="Field">is-natural</a> <a id="11790" href="Cat.Functor.Kan.html#11790" class="Bound">x</a> <a id="11792" href="Cat.Functor.Kan.html#11792" class="Bound">y</a> <a id="11794" href="Cat.Functor.Kan.html#11794" class="Bound">f</a> <a id="11796" class="Symbol">=</a> <a id="11798" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="11802" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a>
        <a id="11812" href="Cat.Functor.Kan.html#6946" class="Bound">colim</a> <a id="11818" class="Symbol">(</a><a id="11819" href="Cat.Functor.Kan.html#8632" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) →
Functor C E → (d : D .Ob) → Functor (K ↘ d) E" class="Function">diagram</a> <a id="11827" class="Symbol">(</a><a id="11828" href="Cat.Base.html#8719" data-type="(r : Functor C D) → C .Ob → D .Ob" class="Function">K.₀</a> <a id="11832" href="Cat.Functor.Kan.html#11790" class="Bound">x</a><a id="11833" class="Symbol">))</a> <a id="11836" class="Symbol">.</a><a id="11837" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Field">has⊥</a> <a id="11842" class="Symbol">(</a><a id="11843" href="Cat.Functor.Kan.html#8709" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E) →
D .Hom d e → Cocone (F F∘ Dom K (const! d))" class="Function">approx</a> <a id="11850" class="Symbol">(</a><a id="11851" href="Cat.Base.html#8800" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">K.₁</a> <a id="11855" href="Cat.Functor.Kan.html#11794" class="Bound">f</a><a id="11856" class="Symbol">))</a> <a id="11859" class="Symbol">.</a><a id="11860" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a> <a id="11867" class="Symbol">.</a><a id="11868" href="Cat.Diagram.Colimit.Base.html#4239" data-type="(r : Cocone-hom F x y) (o : J₁ .Ob) →
C ._∘_ (r .hom) (x .ψ o) ≡ y .ψ o" class="Field">commutes</a> <a id="11877" class="Symbol">_</a>
      <a id="11885" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="11887" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="11891" class="Symbol">(</a><a id="11892" href="Cat.Functor.Kan.html#6946" class="Bound">colim</a> <a id="11898" class="Symbol">(</a><a id="11899" href="Cat.Functor.Kan.html#8632" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) →
Functor C E → (d : D .Ob) → Functor (K ↘ d) E" class="Function">diagram</a> <a id="11907" class="Symbol">(</a><a id="11908" href="Cat.Base.html#8719" data-type="(r : Functor C D) → C .Ob → D .Ob" class="Function">K.₀</a> <a id="11912" href="Cat.Functor.Kan.html#11792" class="Bound">y</a><a id="11913" class="Symbol">))</a> <a id="11916" class="Symbol">.</a><a id="11917" href="Cat.Diagram.Initial.html#442" data-type="Initial C → Ob C" class="Field">bot</a> <a id="11921" class="Symbol">.</a><a id="11922" href="Cat.Diagram.Colimit.Base.html#3115" data-type="(r : Cocone F) (f : J₁ .Hom x y) → C ._∘_ (r .ψ y) (₁ F f) ≡ r .ψ x" class="Field">commutes</a>
            <a id="11943" class="Symbol">(</a><a id="11944" class="Keyword">record</a> <a id="11951" class="Symbol">{</a> <a id="11953" href="Cat.Instances.Comma.html#2646" data-type="(r : ↓Hom F G a b) →
C ._∘_ (map b) (F₁ F (r .α)) ≡ C ._∘_ (F₁ G (r .β)) (a .map)" class="Field">sq</a> <a id="11956" class="Symbol">=</a> <a id="11958" href="Cat.Reasoning.html#1232" data-type="(C : Precategory o ℓ) → a ≡ id C → f ≡ (C ∘ a) f" class="Function">D.introl</a> <a id="11967" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="11972" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="11974" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="11978" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D._∘_</a> <a id="11984" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="11989" class="Symbol">(</a><a id="11990" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="11994" href="Cat.Reasoning.html#800" data-type="(C : Precategory o ℓ) → (C ∘ f) (id C) ≡ (C ∘ id C) f" class="Function">D.id-comm</a><a id="12003" class="Symbol">)</a> <a id="12005" class="Symbol">}))</a>

    <a id="12014" href="Cat.Functor.Kan.html#11143" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E) →
Lan K F" class="Function">lan</a> <a id="12018" class="Symbol">.</a><a id="12019" href="Cat.Functor.Kan.html#3692" data-type="(r : Lan p F) → F =&gt; M F∘ p → r .Ext =&gt; M" class="Field">σ</a> <a id="12021" class="Symbol">{</a><a id="12022" href="Cat.Functor.Kan.html#12022" class="Bound">M</a><a id="12023" class="Symbol">}</a> <a id="12025" href="Cat.Functor.Kan.html#12025" class="Bound">α</a> <a id="12027" class="Symbol">.</a><a id="12028" href="Cat.Base.html#13355" data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" class="Field">is-natural</a> <a id="12039" href="Cat.Functor.Kan.html#12039" class="Bound">x</a> <a id="12041" href="Cat.Functor.Kan.html#12041" class="Bound">y</a> <a id="12043" href="Cat.Functor.Kan.html#12043" class="Bound">f</a> <a id="12045" class="Symbol">=</a>
      <a id="12053" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="12056" href="Cat.Diagram.Colimit.Base.html#4197" data-type="Cocone-hom F x y → C .Hom (x .coapex) (y .coapex)" class="Field">hom</a> <a id="12060" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="12062" href="1Lab.HLevel.html#3818" data-type="is-contr A → is-prop A" class="Function">is-contr→is-prop</a> <a id="12079" class="Symbol">(</a><a id="12080" href="Cat.Functor.Kan.html#6946" class="Bound">colim</a> <a id="12086" class="Symbol">(</a><a id="12087" href="Cat.Functor.Kan.html#8632" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) →
Functor C E → (d : D .Ob) → Functor (K ↘ d) E" class="Function">diagram</a> <a id="12095" href="Cat.Functor.Kan.html#12039" class="Bound">x</a><a id="12096" class="Symbol">)</a> <a id="12098" class="Symbol">.</a><a id="12099" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Field">has⊥</a> <a id="12104" href="Cat.Functor.Kan.html#12454" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E)
(α : F =&gt; M F∘ K) (x y : D .Ob) (f : D .Hom x y) →
Cocone (diagram colim K F x)" class="Function">cocone′</a><a id="12111" class="Symbol">)</a>
        <a id="12121" class="Symbol">(</a><a id="12122" href="Cat.Diagram.Colimit.Base.html#4170" data-type="(hom : C .Hom (x .coapex) (y .coapex))
(commutes : (o : J₁ .Ob) → C ._∘_ hom (x .ψ o) ≡ y .ψ o) →
Cocone-hom F x y" class="InductiveConstructor">cocone-hom</a> <a id="12133" class="Symbol">_</a> <a id="12135" class="Symbol">λ</a> <a id="12137" href="Cat.Functor.Kan.html#12137" class="Bound">o</a> <a id="12139" class="Symbol">→</a> <a id="12141" href="Cat.Reasoning.html#1711" data-type="(C : Precategory o ℓ) →
(C ∘ a) b ≡ c → (C ∘ (C ∘ f) a) b ≡ (C ∘ f) c" class="Function">E.pullr</a> <a id="12149" class="Symbol">(</a><a id="12150" href="Cat.Functor.Kan.html#6946" class="Bound">colim</a> <a id="12156" class="Symbol">(</a><a id="12157" href="Cat.Functor.Kan.html#8632" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) →
Functor C E → (d : D .Ob) → Functor (K ↘ d) E" class="Function">diagram</a> <a id="12165" href="Cat.Functor.Kan.html#12039" class="Bound">x</a><a id="12166" class="Symbol">)</a> <a id="12168" class="Symbol">.</a><a id="12169" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Field">has⊥</a> <a id="12174" class="Symbol">(</a><a id="12175" href="Cat.Functor.Kan.html#8709" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E) →
D .Hom d e → Cocone (F F∘ Dom K (const! d))" class="Function">approx</a> <a id="12182" href="Cat.Functor.Kan.html#12043" class="Bound">f</a><a id="12183" class="Symbol">)</a> <a id="12185" class="Symbol">.</a><a id="12186" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a> <a id="12193" class="Symbol">.</a><a id="12194" href="Cat.Diagram.Colimit.Base.html#4239" data-type="(r : Cocone-hom F x y) (o : J₁ .Ob) →
C ._∘_ (r .hom) (x .ψ o) ≡ y .ψ o" class="Field">commutes</a> <a id="12203" class="Symbol">_)</a>
                          <a id="12232" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="12234" href="Cat.Functor.Kan.html#6946" class="Bound">colim</a> <a id="12240" class="Symbol">(</a><a id="12241" href="Cat.Functor.Kan.html#8632" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) →
Functor C E → (d : D .Ob) → Functor (K ↘ d) E" class="Function">diagram</a> <a id="12249" href="Cat.Functor.Kan.html#12041" class="Bound">y</a><a id="12250" class="Symbol">)</a> <a id="12252" class="Symbol">.</a><a id="12253" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Field">has⊥</a> <a id="12258" class="Symbol">_</a> <a id="12260" class="Symbol">.</a><a id="12261" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a> <a id="12268" class="Symbol">.</a><a id="12269" href="Cat.Diagram.Colimit.Base.html#4239" data-type="(r : Cocone-hom F x y) (o : J₁ .Ob) →
C ._∘_ (r .hom) (x .ψ o) ≡ y .ψ o" class="Field">commutes</a> <a id="12278" class="Symbol">_)</a>
        <a id="12289" class="Symbol">(</a><a id="12290" href="Cat.Diagram.Colimit.Base.html#4170" data-type="(hom : C .Hom (x .coapex) (y .coapex))
(commutes : (o : J₁ .Ob) → C ._∘_ hom (x .ψ o) ≡ y .ψ o) →
Cocone-hom F x y" class="InductiveConstructor">cocone-hom</a> <a id="12301" class="Symbol">_</a> <a id="12303" class="Symbol">λ</a> <a id="12305" href="Cat.Functor.Kan.html#12305" class="Bound">o</a> <a id="12307" class="Symbol">→</a> <a id="12309" href="Cat.Reasoning.html#1711" data-type="(C : Precategory o ℓ) →
(C ∘ a) b ≡ c → (C ∘ (C ∘ f) a) b ≡ (C ∘ f) c" class="Function">E.pullr</a> <a id="12317" class="Symbol">(</a><a id="12318" href="Cat.Functor.Kan.html#6946" class="Bound">colim</a> <a id="12324" class="Symbol">(</a><a id="12325" href="Cat.Functor.Kan.html#8632" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) →
Functor C E → (d : D .Ob) → Functor (K ↘ d) E" class="Function">diagram</a> <a id="12333" href="Cat.Functor.Kan.html#12039" class="Bound">x</a><a id="12334" class="Symbol">)</a> <a id="12336" class="Symbol">.</a><a id="12337" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Field">has⊥</a> <a id="12342" class="Symbol">_</a> <a id="12344" class="Symbol">.</a><a id="12345" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a> <a id="12352" class="Symbol">.</a><a id="12353" href="Cat.Diagram.Colimit.Base.html#4239" data-type="(r : Cocone-hom F x y) (o : J₁ .Ob) →
C ._∘_ (r .hom) (x .ψ o) ≡ y .ψ o" class="Field">commutes</a> <a id="12362" class="Symbol">_)</a>
                          <a id="12391" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="12393" href="Cat.Functor.Reasoning.html#1281" data-type="(F : Functor 𝒞 𝒟) →
(F ∘ a) b ≡ c → (F ∘ F₁ F a) ((F ∘ F₁ F b) f) ≡ (F ∘ F₁ F c) f" class="Function">M.pulll</a> <a id="12401" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a><a id="12405" class="Symbol">)</a>
      <a id="12413" class="Keyword">where</a>
        <a id="12427" class="Keyword">module</a> <a id="12434" href="Cat.Functor.Kan.html#12434" class="Module">M</a> <a id="12436" class="Symbol">=</a> <a id="12438" href="Cat.Functor.Reasoning.html" class="Module">Func</a> <a id="12443" href="Cat.Functor.Kan.html#12022" class="Bound">M</a>

        <a id="12454" href="Cat.Functor.Kan.html#12454" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E)
(α : F =&gt; M F∘ K) (x y : D .Ob) (f : D .Hom x y) →
Cocone (diagram colim K F x)" class="Function">cocone′</a> <a id="12462" class="Symbol">:</a> <a id="12464" href="Cat.Diagram.Colimit.Base.html#2300" data-type="(F : Functor J₁ C) → Type (o ⊔ ℓ ⊔ o′ ⊔ ℓ′)" class="Record">Cocone</a> <a id="12471" class="Symbol">_</a>
        <a id="12481" href="Cat.Functor.Kan.html#12454" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E)
(α : F =&gt; M F∘ K) (x y : D .Ob) (f : D .Hom x y) →
Cocone (diagram colim K F x)" class="Function">cocone′</a> <a id="12489" class="Symbol">.</a><a id="12490" href="Cat.Diagram.Colimit.Base.html#2661" data-type="Cocone F → C .Ob" class="Field">coapex</a> <a id="12497" class="Symbol">=</a> <a id="12499" href="Cat.Base.html#8719" data-type="(r : Functor C D) → C .Ob → D .Ob" class="Function">M.₀</a> <a id="12503" href="Cat.Functor.Kan.html#12041" class="Bound">y</a>
        <a id="12513" href="Cat.Functor.Kan.html#12454" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E)
(α : F =&gt; M F∘ K) (x y : D .Ob) (f : D .Hom x y) →
Cocone (diagram colim K F x)" class="Function">cocone′</a> <a id="12521" class="Symbol">.</a><a id="12522" href="Cat.Diagram.Colimit.Base.html#2681" data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" class="Field">ψ</a> <a id="12524" href="Cat.Functor.Kan.html#12524" class="Bound">x</a> <a id="12526" class="Symbol">=</a> <a id="12528" class="Symbol">_</a>
        <a id="12538" href="Cat.Functor.Kan.html#12454" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E)
(α : F =&gt; M F∘ K) (x y : D .Ob) (f : D .Hom x y) →
Cocone (diagram colim K F x)" class="Function">cocone′</a> <a id="12546" class="Symbol">.</a><a id="12547" href="Cat.Diagram.Colimit.Base.html#3115" data-type="(r : Cocone F) (f : J₁ .Hom x y) → C ._∘_ (r .ψ y) (₁ F f) ≡ r .ψ x" class="Field">commutes</a> <a id="12556" class="Symbol">{</a><a id="12557" href="Cat.Functor.Kan.html#12557" class="Bound">x</a><a id="12558" class="Symbol">}</a> <a id="12560" class="Symbol">{</a><a id="12561" href="Cat.Functor.Kan.html#12561" class="Bound">y</a><a id="12562" class="Symbol">}</a> <a id="12564" href="Cat.Functor.Kan.html#12564" class="Bound">f</a> <a id="12566" class="Symbol">=</a>
            <a id="12580" href="Cat.Reasoning.html#1711" data-type="(C : Precategory o ℓ) →
(C ∘ a) b ≡ c → (C ∘ (C ∘ f) a) b ≡ (C ∘ f) c" class="Function">E.pullr</a> <a id="12588" class="Symbol">(</a><a id="12589" href="Cat.Functor.Kan.html#12025" class="Bound">α</a> <a id="12591" class="Symbol">.</a><a id="12592" href="Cat.Base.html#13355" data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" class="Field">is-natural</a> <a id="12603" class="Symbol">_</a> <a id="12605" class="Symbol">_</a> <a id="12607" class="Symbol">_)</a>
          <a id="12620" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="12622" href="Cat.Functor.Reasoning.html#1281" data-type="(F : Functor 𝒞 𝒟) →
(F ∘ a) b ≡ c → (F ∘ F₁ F a) ((F ∘ F₁ F b) f) ≡ (F ∘ F₁ F c) f" class="Function">M.pulll</a> <a id="12630" class="Symbol">(</a><a id="12631" href="Cat.Reasoning.html#1711" data-type="(C : Precategory o ℓ) →
(C ∘ a) b ≡ c → (C ∘ (C ∘ f) a) b ≡ (C ∘ f) c" class="Function">D.pullr</a> <a id="12639" class="Symbol">(</a><a id="12640" href="Cat.Functor.Kan.html#12564" class="Bound">f</a> <a id="12642" class="Symbol">.</a><a id="12643" href="Cat.Instances.Comma.html#2646" data-type="(r : ↓Hom F G a b) →
C ._∘_ (map b) (F₁ F (r .α)) ≡ C ._∘_ (F₁ G (r .β)) (a .map)" class="Field">↓Hom.sq</a> <a id="12651" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="12653" href="Cat.Base.html#3482" data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ (r .id) f ≡ f" class="Function">D.idl</a> <a id="12659" class="Symbol">_))</a>

    <a id="12668" href="Cat.Functor.Kan.html#11143" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E) →
Lan K F" class="Function">lan</a> <a id="12672" class="Symbol">.</a><a id="12673" href="Cat.Functor.Kan.html#3748" data-type="(r : Lan p F) → (whiskerl (r .σ α) ∘nt r .eta) ≡ α" class="Field">σ-comm</a> <a id="12680" class="Symbol">{</a><a id="12681" class="Argument">M</a> <a id="12683" class="Symbol">=</a> <a id="12685" href="Cat.Functor.Kan.html#12685" class="Bound">M</a><a id="12686" class="Symbol">}</a> <a id="12688" class="Symbol">=</a>
      <a id="12696" href="Cat.Base.html#15577" data-type="((x : C .Ob) → a .η x ≡ b .η x) → a ≡ b" class="Function">Nat-path</a> <a id="12705" class="Symbol">λ</a> <a id="12707" href="Cat.Functor.Kan.html#12707" class="Bound">x</a> <a id="12709" class="Symbol">→</a> <a id="12711" href="Cat.Functor.Kan.html#6946" class="Bound">colim</a> <a id="12717" class="Symbol">(</a><a id="12718" href="Cat.Functor.Kan.html#8632" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) →
Functor C E → (d : D .Ob) → Functor (K ↘ d) E" class="Function">diagram</a> <a id="12726" class="Symbol">(</a><a id="12727" href="Cat.Base.html#8719" data-type="(r : Functor C D) → C .Ob → D .Ob" class="Function">K.₀</a> <a id="12731" href="Cat.Functor.Kan.html#12707" class="Bound">x</a><a id="12732" class="Symbol">))</a> <a id="12735" class="Symbol">.</a><a id="12736" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Field">has⊥</a> <a id="12741" class="Symbol">_</a>  <a id="12744" class="Symbol">.</a><a id="12745" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a> <a id="12752" class="Symbol">.</a><a id="12753" href="Cat.Diagram.Colimit.Base.html#4239" data-type="(r : Cocone-hom F x y) (o : J₁ .Ob) →
C ._∘_ (r .hom) (x .ψ o) ≡ y .ψ o" class="Field">commutes</a> <a id="12762" class="Symbol">_</a> <a id="12764" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="12766" href="Cat.Functor.Reasoning.html#936" data-type="(F : Functor 𝒞 𝒟) → a ≡ id F → (F ∘ F₁ F a) f ≡ f" class="Function">M.eliml</a> <a id="12774" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
      <a id="12785" class="Keyword">where</a> <a id="12791" class="Keyword">module</a> <a id="12798" href="Cat.Functor.Kan.html#12798" class="Module">M</a> <a id="12800" class="Symbol">=</a> <a id="12802" href="Cat.Functor.Reasoning.html" class="Module">Func</a> <a id="12807" href="Cat.Functor.Kan.html#12685" class="Bound">M</a>

    <a id="12814" href="Cat.Functor.Kan.html#11143" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E) →
Lan K F" class="Function">lan</a> <a id="12818" class="Symbol">.</a><a id="12819" href="Cat.Functor.Kan.html#3827" data-type="(r : Lan p F) → α ≡ (whiskerl σ′ ∘nt r .eta) → r .σ α ≡ σ′" class="Field">σ-uniq</a> <a id="12826" class="Symbol">{</a><a id="12827" class="Argument">M</a> <a id="12829" class="Symbol">=</a> <a id="12831" href="Cat.Functor.Kan.html#12831" class="Bound">M</a><a id="12832" class="Symbol">}</a> <a id="12834" class="Symbol">{</a><a id="12835" href="Cat.Functor.Kan.html#12835" class="Bound">α</a><a id="12836" class="Symbol">}</a> <a id="12838" class="Symbol">{</a><a id="12839" href="Cat.Functor.Kan.html#12839" class="Bound">σ&#39;</a><a id="12841" class="Symbol">}</a> <a id="12843" href="Cat.Functor.Kan.html#12843" class="Bound">path</a> <a id="12848" class="Symbol">=</a> <a id="12850" href="Cat.Base.html#15577" data-type="((x : C .Ob) → a .η x ≡ b .η x) → a ≡ b" class="Function">Nat-path</a> <a id="12859" class="Symbol">λ</a> <a id="12861" href="Cat.Functor.Kan.html#12861" class="Bound">x</a> <a id="12863" class="Symbol">→</a>
      <a id="12871" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="12874" href="Cat.Diagram.Colimit.Base.html#4197" data-type="Cocone-hom F x y → C .Hom (x .coapex) (y .coapex)" class="Field">hom</a> <a id="12878" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="12880" href="Cat.Functor.Kan.html#6946" class="Bound">colim</a> <a id="12886" class="Symbol">(</a><a id="12887" href="Cat.Functor.Kan.html#8632" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) →
Functor C E → (d : D .Ob) → Functor (K ↘ d) E" class="Function">diagram</a> <a id="12895" class="Symbol">_)</a> <a id="12898" class="Symbol">.</a><a id="12899" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Field">has⊥</a> <a id="12904" class="Symbol">_</a> <a id="12906" class="Symbol">.</a><a id="12907" href="1Lab.HLevel.html#1416" data-type="(r : is-contr A) (x : A) → r .centre ≡ x" class="Field">paths</a>
        <a id="12921" class="Symbol">(</a><a id="12922" href="Cat.Diagram.Colimit.Base.html#4170" data-type="(hom : C .Hom (x .coapex) (y .coapex))
(commutes : (o : J₁ .Ob) → C ._∘_ hom (x .ψ o) ≡ y .ψ o) →
Cocone-hom F x y" class="InductiveConstructor">cocone-hom</a> <a id="12933" class="Symbol">_</a> <a id="12935" class="Symbol">λ</a> <a id="12937" href="Cat.Functor.Kan.html#12937" class="Bound">o</a> <a id="12939" class="Symbol">→</a> <a id="12941" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="12945" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a>
            <a id="12959" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="12963" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">E._∘_</a> <a id="12969" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="12974" class="Symbol">(</a><a id="12975" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="12978" class="Symbol">(λ</a> <a id="12981" href="Cat.Functor.Kan.html#12981" class="Bound">e</a> <a id="12983" class="Symbol">→</a> <a id="12985" href="Cat.Functor.Kan.html#12981" class="Bound">e</a> <a id="12987" class="Symbol">.</a><a id="12988" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="12990" class="Symbol">_)</a> <a id="12993" href="Cat.Functor.Kan.html#12843" class="Bound">path</a><a id="12997" class="Symbol">)</a>
          <a id="13009" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="13011" href="Cat.Reasoning.html#1581" data-type="(C : Precategory o ℓ) →
(C ∘ a) b ≡ c → (C ∘ a) ((C ∘ b) f) ≡ (C ∘ c) f" class="Function">E.pulll</a> <a id="13019" class="Symbol">(</a><a id="13020" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="13024" class="Symbol">(</a><a id="13025" href="Cat.Functor.Kan.html#12839" class="Bound">σ&#39;</a> <a id="13028" class="Symbol">.</a><a id="13029" href="Cat.Base.html#13355" data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" class="Field">is-natural</a> <a id="13040" class="Symbol">_</a> <a id="13042" class="Symbol">_</a> <a id="13044" class="Symbol">_))</a>
          <a id="13058" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="13060" href="Cat.Reasoning.html#1711" data-type="(C : Precategory o ℓ) →
(C ∘ a) b ≡ c → (C ∘ (C ∘ f) a) b ≡ (C ∘ f) c" class="Function">E.pullr</a> <a id="13068" class="Symbol">(</a> <a id="13070" href="Cat.Functor.Kan.html#6946" class="Bound">colim</a> <a id="13076" class="Symbol">_</a> <a id="13078" class="Symbol">.</a><a id="13079" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Field">has⊥</a> <a id="13084" class="Symbol">_</a> <a id="13086" class="Symbol">.</a><a id="13087" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a> <a id="13094" class="Symbol">.</a><a id="13095" href="Cat.Diagram.Colimit.Base.html#4239" data-type="(r : Cocone-hom F x y) (o : J₁ .Ob) →
C ._∘_ (r .hom) (x .ψ o) ≡ y .ψ o" class="Field">commutes</a> <a id="13104" class="Symbol">_</a>
                    <a id="13126" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="13128" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="13131" class="Symbol">(</a><a id="13132" href="Cat.Functor.Kan.html#6946" class="Bound">colim</a> <a id="13138" class="Symbol">(</a><a id="13139" href="Cat.Functor.Kan.html#8632" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) →
Functor C E → (d : D .Ob) → Functor (K ↘ d) E" class="Function">diagram</a> <a id="13147" href="Cat.Functor.Kan.html#12861" class="Bound">x</a><a id="13148" class="Symbol">)</a> <a id="13150" class="Symbol">.</a><a id="13151" href="Cat.Diagram.Initial.html#442" data-type="Initial C → Ob C" class="Field">bot</a> <a id="13155" class="Symbol">.</a><a id="13156" href="Cat.Diagram.Colimit.Base.html#2681" data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" class="Field">ψ</a><a id="13157" class="Symbol">)</a>
                         <a id="13184" class="Symbol">(</a><a id="13185" href="Cat.Instances.Comma.html#3533" data-type="(F : Functor A C) (G : Functor B₁ C) (p : a .x ≡ b .x)
(q : a .y ≡ b .y) →
PathP (λ i → Hom C (F₀ F (p i)) (F₀ G (q i))) (a .map) (b .map) →
a ≡ b" class="Function">↓Obj-path</a> <a id="13195" class="Symbol">_</a> <a id="13197" class="Symbol">_</a> <a id="13199" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="13204" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="13209" class="Symbol">(</a><a id="13210" href="Cat.Base.html#3437" data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ f (r .id) ≡ f" class="Function">D.idr</a> <a id="13216" class="Symbol">_))))</a>
</pre>
</details>
<p>A useful result about this calculation of
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">L</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi></mrow><mi>F</mi></msub><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Lan_F(G)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">Lan</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mclose">)</span></span></span></span>
is that, if
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span>
is fully faithful, then
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">L</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi></mrow><mi>F</mi></msub><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mo>∘</mo><mi>F</mi><mo>≅</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">\Lan_F(G) \circ F \cong G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">Lan</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span>
— the left Kan extension along a fully-faithful functor does actually
<em>extend</em>.</p>
<pre class="Agda">  <a id="13453" class="Keyword">private</a> <a id="13461" class="Keyword">module</a> <a id="13468" href="Cat.Functor.Kan.html#13468" class="Module">Fn</a> <a id="13471" class="Symbol">=</a> <a id="13473" href="Cat.Reasoning.html" class="Module">Cat</a> <a id="13477" href="Cat.Instances.Functor.html#2100" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Precategory (o₁ ⊔ o₂ ⊔ h₁ ⊔ h₂) (o₁ ⊔ h₁ ⊔ h₂)" class="Function Operator">Cat[</a> <a id="13482" href="Cat.Functor.Kan.html#6877" class="Bound">C</a> <a id="13484" href="Cat.Instances.Functor.html#2100" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Precategory (o₁ ⊔ o₂ ⊔ h₁ ⊔ h₂) (o₁ ⊔ h₁ ⊔ h₂)" class="Function Operator">,</a> <a id="13486" href="Cat.Functor.Kan.html#6922" class="Bound">E</a> <a id="13488" href="Cat.Instances.Functor.html#2100" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Precategory (o₁ ⊔ o₂ ⊔ h₁ ⊔ h₂) (o₁ ⊔ h₁ ⊔ h₂)" class="Function Operator">]</a>
  <a id="13492" class="Keyword">open</a> <a id="13497" href="Cat.Base.html#12227" data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" class="Module Operator">_=&gt;_</a>

  <a id="13505" href="Cat.Functor.Kan.html#13505" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E) →
is-fully-faithful K →
(Cat[ C , E ] ≅ (cocomplete→lan colim K F .Ext F∘ K)) F" class="Function">ff-lan-ext</a> <a id="13516" class="Symbol">:</a> <a id="13518" href="Cat.Functor.Base.html#1110" data-type="Functor C D → Type (C.o ⊔ C.h ⊔ D.h)" class="Function">is-fully-faithful</a> <a id="13536" href="Cat.Functor.Kan.html#6978" class="Bound">K</a> <a id="13538" class="Symbol">→</a> <a id="13540" href="Cat.Functor.Kan.html#8574" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E) →
Lan K F" class="Function">cocomplete→lan</a> <a id="13555" class="Symbol">.</a><a id="13556" href="Cat.Functor.Kan.html#2918" data-type="Lan p F → Functor C′ D" class="Field">Ext</a> <a id="13560" href="Cat.Base.html#9683" data-type="Functor D E → Functor C D → Functor C E" class="Function Operator">F∘</a> <a id="13563" href="Cat.Functor.Kan.html#6978" class="Bound">K</a> <a id="13565" href="Cat.Morphism.html#2202" data-type="(C : Precategory o h) (a b : Ob C) → Type h" class="Record Operator">Fn.≅</a> <a id="13570" href="Cat.Functor.Kan.html#6998" class="Bound">F</a>
  <a id="13574" href="Cat.Functor.Kan.html#13505" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E) →
is-fully-faithful K →
(Cat[ C , E ] ≅ (cocomplete→lan colim K F .Ext F∘ K)) F" class="Function">ff-lan-ext</a> <a id="13585" href="Cat.Functor.Kan.html#13585" class="Bound">ff</a> <a id="13588" class="Symbol">=</a> <a id="13590" href="Cat.Morphism.html#7747" data-type="(C : Precategory o h) → (C ≅ a) b → (C ≅ b) a" class="Function Operator">Fn._Iso⁻¹</a> <a id="13600" class="Symbol">(</a><a id="13601" href="Cat.Morphism.html#3941" data-type="(C : Precategory o h) (f : Hom C a b) →
is-invertible C f → (C ≅ a) b" class="Function">Fn.invertible→iso</a> <a id="13619" class="Symbol">(</a><a id="13620" href="Cat.Functor.Kan.html#8574" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E) →
Lan K F" class="Function">cocomplete→lan</a> <a id="13635" class="Symbol">.</a><a id="13636" href="Cat.Functor.Kan.html#2941" data-type="(r : Lan p F) → F =&gt; r .Ext F∘ p" class="Field">eta</a><a id="13639" class="Symbol">)</a> <a id="13641" href="Cat.Functor.Kan.html#14806" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E)
(ff : is-fully-faithful K) →
is-invertible Cat[ C , E ] (cocomplete→lan colim K F .eta)" class="Function">inv</a><a id="13644" class="Symbol">)</a> <a id="13646" class="Keyword">where</a>
    <a id="13656" href="Cat.Functor.Kan.html#13656" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E) →
is-fully-faithful K →
(x : C .Ob) → is-invertible E (cocomplete→lan colim K F .eta .η x)" class="Function">inv′</a> <a id="13661" class="Symbol">:</a> <a id="13663" class="Symbol">∀</a> <a id="13665" href="Cat.Functor.Kan.html#13665" class="Bound">x</a> <a id="13667" class="Symbol">→</a> <a id="13669" href="Cat.Morphism.html#1930" data-type="(C : Precategory o h) (f : Hom C a b) → Type h" class="Record">E.is-invertible</a> <a id="13685" class="Symbol">(</a><a id="13686" href="Cat.Functor.Kan.html#8574" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E) →
Lan K F" class="Function">cocomplete→lan</a> <a id="13701" class="Symbol">.</a><a id="13702" href="Cat.Functor.Kan.html#2941" data-type="(r : Lan p F) → F =&gt; r .Ext F∘ p" class="Field">eta</a> <a id="13706" class="Symbol">.</a><a id="13707" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="13709" href="Cat.Functor.Kan.html#13665" class="Bound">x</a><a id="13710" class="Symbol">)</a>
    <a id="13716" href="Cat.Functor.Kan.html#13656" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E) →
is-fully-faithful K →
(x : C .Ob) → is-invertible E (cocomplete→lan colim K F .eta .η x)" class="Function">inv′</a> <a id="13721" href="Cat.Functor.Kan.html#13721" class="Bound">x</a> <a id="13723" class="Symbol">=</a> <a id="13725" href="Cat.Morphism.html#3457" data-type="(C : Precategory o h) (g : Hom C b a) →
(C ∘ f) g ≡ id C → (C ∘ g) f ≡ id C → is-invertible C f" class="Function">E.make-invertible</a> <a id="13743" href="Cat.Functor.Kan.html#14129" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E)
(ff : is-fully-faithful K) (x : C .Ob) →
E .Hom (colim (diagram colim K F (F₀ K x)) .bot .coapex) (₀ F x)" class="Function">to</a> <a id="13746" href="Cat.Functor.Kan.html#14203" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E)
(ff : is-fully-faithful K) (x : C .Ob) →
E ._∘_ (cocomplete→lan colim K F .eta .η x) (to colim K F ff x) ≡
E .id" class="Function">invl</a> <a id="13751" href="Cat.Functor.Kan.html#14588" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E)
(ff : is-fully-faithful K) (x : C .Ob) →
E ._∘_ (to colim K F ff x) (cocomplete→lan colim K F .eta .η x) ≡
E .id" class="Function">invr</a> <a id="13756" class="Keyword">where</a>
      <a id="13768" href="Cat.Functor.Kan.html#13768" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E)
(ff : is-fully-faithful K) (x : C .Ob) →
Cocone (diagram colim K F (F₀ K x))" class="Function">cocone′</a> <a id="13776" class="Symbol">:</a> <a id="13778" href="Cat.Diagram.Colimit.Base.html#2300" data-type="(F : Functor J₁ C) → Type (o ⊔ ℓ ⊔ o′ ⊔ ℓ′)" class="Record">Cocone</a> <a id="13785" class="Symbol">_</a>
      <a id="13793" href="Cat.Functor.Kan.html#13768" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E)
(ff : is-fully-faithful K) (x : C .Ob) →
Cocone (diagram colim K F (F₀ K x))" class="Function">cocone′</a> <a id="13801" class="Symbol">.</a><a id="13802" href="Cat.Diagram.Colimit.Base.html#2661" data-type="Cocone F → C .Ob" class="Field">coapex</a> <a id="13809" class="Symbol">=</a> <a id="13811" href="Cat.Base.html#8719" data-type="(r : Functor C D) → C .Ob → D .Ob" class="Function">F.₀</a> <a id="13815" href="Cat.Functor.Kan.html#13721" class="Bound">x</a>
      <a id="13823" href="Cat.Functor.Kan.html#13768" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E)
(ff : is-fully-faithful K) (x : C .Ob) →
Cocone (diagram colim K F (F₀ K x))" class="Function">cocone′</a> <a id="13831" class="Symbol">.</a><a id="13832" href="Cat.Diagram.Colimit.Base.html#2681" data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" class="Field">ψ</a> <a id="13834" href="Cat.Functor.Kan.html#13834" class="Bound">ob</a> <a id="13837" class="Symbol">=</a> <a id="13839" href="Cat.Base.html#8800" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">F.₁</a> <a id="13843" class="Symbol">(</a><a id="13844" href="1Lab.Equiv.html#6449" data-type="is-equiv f → B₁ → A" class="Function">equiv→inverse</a> <a id="13858" href="Cat.Functor.Kan.html#13585" class="Bound">ff</a> <a id="13861" class="Symbol">(</a><a id="13862" href="Cat.Functor.Kan.html#13834" class="Bound">ob</a> <a id="13865" class="Symbol">.</a><a id="13866" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">map</a><a id="13869" class="Symbol">))</a>
      <a id="13878" href="Cat.Functor.Kan.html#13768" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E)
(ff : is-fully-faithful K) (x : C .Ob) →
Cocone (diagram colim K F (F₀ K x))" class="Function">cocone′</a> <a id="13886" class="Symbol">.</a><a id="13887" href="Cat.Diagram.Colimit.Base.html#3115" data-type="(r : Cocone F) (f : J₁ .Hom x y) → C ._∘_ (r .ψ y) (₁ F f) ≡ r .ψ x" class="Field">commutes</a> <a id="13896" class="Symbol">{</a><a id="13897" class="Argument">x</a> <a id="13899" class="Symbol">=</a> <a id="13901" href="Cat.Functor.Kan.html#13901" class="Bound">y</a><a id="13902" class="Symbol">}</a> <a id="13904" class="Symbol">{</a><a id="13905" href="Cat.Functor.Kan.html#13905" class="Bound">z</a><a id="13906" class="Symbol">}</a> <a id="13908" href="Cat.Functor.Kan.html#13908" class="Bound">f</a> <a id="13910" class="Symbol">=</a>
        <a id="13920" href="Cat.Functor.Reasoning.html#1206" data-type="(F : Functor 𝒞 𝒟) (ab≡c : (F ∘ a) b ≡ c) →
(F ∘ F₁ F a) (F₁ F b) ≡ F₁ F c" class="Function">F.collapse</a> <a id="13931" class="Symbol">(</a><a id="13932" href="Cat.Functor.Base.html#1212" data-type="is-fully-faithful F → is-faithful F" class="Function">fully-faithful→faithful</a> <a id="13956" class="Symbol">{</a><a id="13957" class="Argument">F</a> <a id="13959" class="Symbol">=</a> <a id="13961" href="Cat.Functor.Kan.html#6978" class="Bound">K</a><a id="13962" class="Symbol">}</a> <a id="13964" href="Cat.Functor.Kan.html#13585" class="Bound">ff</a>
          <a id="13977" class="Symbol">(</a> <a id="13979" href="Cat.Functor.Kan.html#6978" class="Bound">K</a> <a id="13981" class="Symbol">.</a><a id="13982" href="Cat.Base.html#8375" data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" class="Field">Functor.F-∘</a>  <a id="13995" class="Symbol">_</a> <a id="13997" class="Symbol">_</a>
          <a id="14009" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="14011" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="14015" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D._∘_</a> <a id="14021" class="Symbol">(</a><a id="14022" href="1Lab.Equiv.html#6548" data-type="(eqv : is-equiv f) (x : B₁) → f (equiv→inverse eqv x) ≡ x" class="Function">equiv→counit</a> <a id="14035" href="Cat.Functor.Kan.html#13585" class="Bound">ff</a> <a id="14038" class="Symbol">_)</a> <a id="14041" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
          <a id="14056" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="14058" href="Cat.Functor.Kan.html#13908" class="Bound">f</a> <a id="14060" class="Symbol">.</a><a id="14061" href="Cat.Instances.Comma.html#2646" data-type="(r : ↓Hom F G a b) →
C ._∘_ (map b) (F₁ F (r .α)) ≡ C ._∘_ (F₁ G (r .β)) (a .map)" class="Field">sq</a>
          <a id="14074" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="14076" href="Cat.Base.html#3482" data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ (r .id) f ≡ f" class="Function">D.idl</a> <a id="14082" class="Symbol">_</a>
          <a id="14094" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="14096" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="14100" class="Symbol">(</a><a id="14101" href="1Lab.Equiv.html#6548" data-type="(eqv : is-equiv f) (x : B₁) → f (equiv→inverse eqv x) ≡ x" class="Function">equiv→counit</a> <a id="14114" href="Cat.Functor.Kan.html#13585" class="Bound">ff</a> <a id="14117" class="Symbol">_)))</a>

      <a id="14129" href="Cat.Functor.Kan.html#14129" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E)
(ff : is-fully-faithful K) (x : C .Ob) →
E .Hom (colim (diagram colim K F (F₀ K x)) .bot .coapex) (₀ F x)" class="Function">to</a> <a id="14132" class="Symbol">:</a> <a id="14134" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">E.Hom</a> <a id="14140" class="Symbol">_</a> <a id="14142" class="Symbol">(</a><a id="14143" href="Cat.Base.html#8719" data-type="(r : Functor C D) → C .Ob → D .Ob" class="Function">F.₀</a> <a id="14147" href="Cat.Functor.Kan.html#13721" class="Bound">x</a><a id="14148" class="Symbol">)</a>
      <a id="14156" href="Cat.Functor.Kan.html#14129" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E)
(ff : is-fully-faithful K) (x : C .Ob) →
E .Hom (colim (diagram colim K F (F₀ K x)) .bot .coapex) (₀ F x)" class="Function">to</a> <a id="14159" class="Symbol">=</a> <a id="14161" href="Cat.Functor.Kan.html#6946" class="Bound">colim</a> <a id="14167" class="Symbol">_</a> <a id="14169" class="Symbol">.</a><a id="14170" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Field">has⊥</a> <a id="14175" href="Cat.Functor.Kan.html#13768" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E)
(ff : is-fully-faithful K) (x : C .Ob) →
Cocone (diagram colim K F (F₀ K x))" class="Function">cocone′</a> <a id="14183" class="Symbol">.</a><a id="14184" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a> <a id="14191" class="Symbol">.</a><a id="14192" href="Cat.Diagram.Colimit.Base.html#4197" data-type="Cocone-hom F x y → C .Hom (x .coapex) (y .coapex)" class="Field">hom</a>

      <a id="14203" href="Cat.Functor.Kan.html#14203" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E)
(ff : is-fully-faithful K) (x : C .Ob) →
E ._∘_ (cocomplete→lan colim K F .eta .η x) (to colim K F ff x) ≡
E .id" class="Function">invl</a> <a id="14208" class="Symbol">:</a> <a id="14210" href="Cat.Functor.Kan.html#8574" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E) →
Lan K F" class="Function">cocomplete→lan</a> <a id="14225" class="Symbol">.</a><a id="14226" href="Cat.Functor.Kan.html#2941" data-type="(r : Lan p F) → F =&gt; r .Ext F∘ p" class="Field">eta</a> <a id="14230" class="Symbol">.</a><a id="14231" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="14233" href="Cat.Functor.Kan.html#13721" class="Bound">x</a> <a id="14235" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">E.∘</a> <a id="14239" href="Cat.Functor.Kan.html#14129" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E)
(ff : is-fully-faithful K) (x : C .Ob) →
E .Hom (colim (diagram colim K F (F₀ K x)) .bot .coapex) (₀ F x)" class="Function">to</a> <a id="14242" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="14244" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">E.id</a>
      <a id="14255" href="Cat.Functor.Kan.html#14203" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E)
(ff : is-fully-faithful K) (x : C .Ob) →
E ._∘_ (cocomplete→lan colim K F .eta .η x) (to colim K F ff x) ≡
E .id" class="Function">invl</a> <a id="14260" class="Symbol">=</a> <a id="14262" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="14265" href="Cat.Diagram.Colimit.Base.html#4197" data-type="Cocone-hom F x y → C .Hom (x .coapex) (y .coapex)" class="Field">hom</a> <a id="14269" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="14271" href="1Lab.HLevel.html#3818" data-type="is-contr A → is-prop A" class="Function">is-contr→is-prop</a>
        <a id="14296" class="Symbol">(</a><a id="14297" href="Cat.Functor.Kan.html#6946" class="Bound">colim</a> <a id="14303" class="Symbol">_</a> <a id="14305" class="Symbol">.</a><a id="14306" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Field">has⊥</a> <a id="14311" class="Symbol">(</a><a id="14312" href="Cat.Functor.Kan.html#6946" class="Bound">colim</a> <a id="14318" class="Symbol">(</a><a id="14319" href="Cat.Functor.Kan.html#6998" class="Bound">F</a> <a id="14321" href="Cat.Base.html#9683" data-type="Functor D E → Functor C D → Functor C E" class="Function Operator">F∘</a> <a id="14324" href="Cat.Instances.Comma.html#5380" data-type="(F : Functor A C) (G : Functor B₁ C) → Functor (F ↓ G) A" class="Function">Dom</a> <a id="14328" href="Cat.Functor.Kan.html#6978" class="Bound">K</a> <a id="14330" class="Symbol">(</a><a id="14331" href="Cat.Instances.Shape.Terminal.html#558" data-type="Ob A → Functor ⊤Cat A" class="Function">const!</a> <a id="14338" class="Symbol">_))</a> <a id="14342" class="Symbol">.</a><a id="14343" href="Cat.Diagram.Initial.html#442" data-type="Initial C → Ob C" class="Field">bot</a><a id="14346" class="Symbol">))</a>
        <a id="14357" class="Symbol">(</a><a id="14358" href="Cat.Diagram.Colimit.Base.html#4170" data-type="(hom : C .Hom (x .coapex) (y .coapex))
(commutes : (o : J₁ .Ob) → C ._∘_ hom (x .ψ o) ≡ y .ψ o) →
Cocone-hom F x y" class="InductiveConstructor">cocone-hom</a> <a id="14369" class="Symbol">_</a> <a id="14371" class="Symbol">λ</a> <a id="14373" href="Cat.Functor.Kan.html#14373" class="Bound">o</a> <a id="14375" class="Symbol">→</a>
            <a id="14389" href="Cat.Reasoning.html#1711" data-type="(C : Precategory o ℓ) →
(C ∘ a) b ≡ c → (C ∘ (C ∘ f) a) b ≡ (C ∘ f) c" class="Function">E.pullr</a> <a id="14397" class="Symbol">(</a><a id="14398" href="Cat.Functor.Kan.html#6946" class="Bound">colim</a> <a id="14404" class="Symbol">_</a> <a id="14406" class="Symbol">.</a><a id="14407" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Field">has⊥</a> <a id="14412" href="Cat.Functor.Kan.html#13768" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E)
(ff : is-fully-faithful K) (x : C .Ob) →
Cocone (diagram colim K F (F₀ K x))" class="Function">cocone′</a> <a id="14420" class="Symbol">.</a><a id="14421" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a> <a id="14428" class="Symbol">.</a><a id="14429" href="Cat.Diagram.Colimit.Base.html#4239" data-type="(r : Cocone-hom F x y) (o : J₁ .Ob) →
C ._∘_ (r .hom) (x .ψ o) ≡ y .ψ o" class="Field">commutes</a> <a id="14438" class="Symbol">_)</a>
          <a id="14451" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="14453" href="Cat.Functor.Kan.html#6946" class="Bound">colim</a> <a id="14459" class="Symbol">_</a> <a id="14461" class="Symbol">.</a><a id="14462" href="Cat.Diagram.Initial.html#442" data-type="Initial C → Ob C" class="Field">bot</a> <a id="14466" class="Symbol">.</a><a id="14467" href="Cat.Diagram.Colimit.Base.html#3115" data-type="(r : Cocone F) (f : J₁ .Hom x y) → C ._∘_ (r .ψ y) (₁ F f) ≡ r .ψ x" class="Field">commutes</a>
              <a id="14490" class="Symbol">(</a><a id="14491" class="Keyword">record</a> <a id="14498" class="Symbol">{</a> <a id="14500" href="Cat.Instances.Comma.html#2646" data-type="(r : ↓Hom F G a b) →
C ._∘_ (map b) (F₁ F (r .α)) ≡ C ._∘_ (F₁ G (r .β)) (a .map)" class="Field">sq</a> <a id="14503" class="Symbol">=</a> <a id="14505" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="14508" class="Symbol">(</a><a id="14509" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">D.id</a> <a id="14514" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘_</a><a id="14518" class="Symbol">)</a> <a id="14520" class="Symbol">(</a><a id="14521" href="1Lab.Equiv.html#6548" data-type="(eqv : is-equiv f) (x : B₁) → f (equiv→inverse eqv x) ≡ x" class="Function">equiv→counit</a> <a id="14534" href="Cat.Functor.Kan.html#13585" class="Bound">ff</a> <a id="14537" class="Symbol">_)</a> <a id="14540" class="Symbol">}))</a>
        <a id="14552" class="Symbol">(</a><a id="14553" href="Cat.Diagram.Colimit.Base.html#4170" data-type="(hom : C .Hom (x .coapex) (y .coapex))
(commutes : (o : J₁ .Ob) → C ._∘_ hom (x .ψ o) ≡ y .ψ o) →
Cocone-hom F x y" class="InductiveConstructor">cocone-hom</a> <a id="14564" class="Symbol">_</a> <a id="14566" class="Symbol">λ</a> <a id="14568" href="Cat.Functor.Kan.html#14568" class="Bound">o</a> <a id="14570" class="Symbol">→</a> <a id="14572" href="Cat.Base.html#3482" data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ (r .id) f ≡ f" class="Function">E.idl</a> <a id="14578" class="Symbol">_)</a>

      <a id="14588" href="Cat.Functor.Kan.html#14588" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E)
(ff : is-fully-faithful K) (x : C .Ob) →
E ._∘_ (to colim K F ff x) (cocomplete→lan colim K F .eta .η x) ≡
E .id" class="Function">invr</a> <a id="14593" class="Symbol">:</a> <a id="14595" href="Cat.Functor.Kan.html#14129" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E)
(ff : is-fully-faithful K) (x : C .Ob) →
E .Hom (colim (diagram colim K F (F₀ K x)) .bot .coapex) (₀ F x)" class="Function">to</a> <a id="14598" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">E.∘</a> <a id="14602" href="Cat.Functor.Kan.html#8574" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E) →
Lan K F" class="Function">cocomplete→lan</a> <a id="14617" class="Symbol">.</a><a id="14618" href="Cat.Functor.Kan.html#2941" data-type="(r : Lan p F) → F =&gt; r .Ext F∘ p" class="Field">eta</a> <a id="14622" class="Symbol">.</a><a id="14623" href="Cat.Base.html#12777" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="14625" href="Cat.Functor.Kan.html#13721" class="Bound">x</a> <a id="14627" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="14629" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">E.id</a>
      <a id="14640" href="Cat.Functor.Kan.html#14588" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E)
(ff : is-fully-faithful K) (x : C .Ob) →
E ._∘_ (to colim K F ff x) (cocomplete→lan colim K F .eta .η x) ≡
E .id" class="Function">invr</a> <a id="14645" class="Symbol">=</a> <a id="14647" href="Cat.Functor.Kan.html#6946" class="Bound">colim</a> <a id="14653" class="Symbol">_</a> <a id="14655" class="Symbol">.</a><a id="14656" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Field">has⊥</a> <a id="14661" href="Cat.Functor.Kan.html#13768" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E)
(ff : is-fully-faithful K) (x : C .Ob) →
Cocone (diagram colim K F (F₀ K x))" class="Function">cocone′</a> <a id="14669" class="Symbol">.</a><a id="14670" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a> <a id="14677" class="Symbol">.</a><a id="14678" href="Cat.Diagram.Colimit.Base.html#4239" data-type="(r : Cocone-hom F x y) (o : J₁ .Ob) →
C ._∘_ (r .hom) (x .ψ o) ≡ y .ψ o" class="Field">commutes</a> <a id="14687" class="Symbol">_</a>
           <a id="14700" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="14702" href="Cat.Functor.Reasoning.html#887" data-type="(F : Functor 𝒞 𝒟) (a≡id : a ≡ id F) → F₁ F a ≡ id F" class="Function">F.elim</a> <a id="14709" class="Symbol">(</a><a id="14710" href="Cat.Functor.Base.html#1212" data-type="is-fully-faithful F → is-faithful F" class="Function">fully-faithful→faithful</a> <a id="14734" class="Symbol">{</a><a id="14735" class="Argument">F</a> <a id="14737" class="Symbol">=</a> <a id="14739" href="Cat.Functor.Kan.html#6978" class="Bound">K</a><a id="14740" class="Symbol">}</a> <a id="14742" href="Cat.Functor.Kan.html#13585" class="Bound">ff</a>
                      <a id="14767" class="Symbol">(</a><a id="14768" href="1Lab.Equiv.html#6548" data-type="(eqv : is-equiv f) (x : B₁) → f (equiv→inverse eqv x) ≡ x" class="Function">equiv→counit</a> <a id="14781" href="Cat.Functor.Kan.html#13585" class="Bound">ff</a> <a id="14784" class="Symbol">_</a> <a id="14786" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="14788" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="14792" href="Cat.Base.html#8335" data-type="(r : Functor C D) → r .F₁ (C .id) ≡ id D" class="Function">K.F-id</a><a id="14798" class="Symbol">))</a>

    <a id="14806" href="Cat.Functor.Kan.html#14806" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E)
(ff : is-fully-faithful K) →
is-invertible Cat[ C , E ] (cocomplete→lan colim K F .eta)" class="Function">inv</a> <a id="14810" class="Symbol">:</a> <a id="14812" href="Cat.Morphism.html#1930" data-type="(C : Precategory o h) (f : Hom C a b) → Type h" class="Record">Fn.is-invertible</a> <a id="14829" class="Symbol">(</a><a id="14830" href="Cat.Functor.Kan.html#8574" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E) →
Lan K F" class="Function">cocomplete→lan</a> <a id="14845" class="Symbol">.</a><a id="14846" href="Cat.Functor.Kan.html#2941" data-type="(r : Lan p F) → F =&gt; r .Ext F∘ p" class="Field">eta</a><a id="14849" class="Symbol">)</a>
    <a id="14855" href="Cat.Functor.Kan.html#14806" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E)
(ff : is-fully-faithful K) →
is-invertible Cat[ C , E ] (cocomplete→lan colim K F .eta)" class="Function">inv</a> <a id="14859" class="Symbol">=</a> <a id="14861" href="Cat.Instances.Functor.html#8551" data-type="(eta : F =&gt; G) →
((x : C .Ob) → is-invertible D (eta .η x)) →
is-invertible Cat[ C , D ] eta" class="Function">componentwise-invertible→invertible</a> <a id="14897" class="Symbol">(</a><a id="14898" href="Cat.Functor.Kan.html#8574" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E) →
Lan K F" class="Function">cocomplete→lan</a> <a id="14913" class="Symbol">.</a><a id="14914" href="Cat.Functor.Kan.html#2941" data-type="(r : Lan p F) → F =&gt; r .Ext F∘ p" class="Field">eta</a><a id="14917" class="Symbol">)</a> <a id="14919" href="Cat.Functor.Kan.html#13656" data-type="(colim : is-cocomplete κ κ E) (K : Functor C D) (F : Functor C E) →
is-fully-faithful K →
(x : C .Ob) → is-invertible E (cocomplete→lan colim K F .eta .η x)" class="Function">inv′</a>
</pre>
  </article>
</div>
</main>
</body>
</html>
