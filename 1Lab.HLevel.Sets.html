<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="keywords" content="Agda,categories,topos" />

  <title>1Lab.HLevel.Sets - 1Lab</title>

  <link rel="stylesheet" href="/css/default.css" />
  <link rel="stylesheet" href="/css/katex.min.css" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="1Lab.HLevel.Sets - 1Lab" />
  <meta name="twitter:image" content="https://1lab.dev/static/cube-128x.png" />

  <meta name="og:title" content="1Lab.HLevel.Sets - 1Lab" />
  <meta name="og:image" content="https://1lab.dev/static/cube-128x.png" />
  <meta name="og:site-name" content="1Lab" />
  <meta name="og:type" content="website" />

    <meta name="og:description" content="&lt;p&gt;We characterise alternative
definitions of the types with h-level 2, the sets.&lt;/p&gt;" />
  <meta name="twitter:description" content="&lt;p&gt;We characterise
alternative definitions of the types with h-level 2, the sets.&lt;/p&gt;" />
  <meta name="description" content="&lt;p&gt;We characterise alternative
definitions of the types with h-level 2, the sets.&lt;/p&gt;" />
  
  <script defer src="/main.js"></script>

  <noscript>
    <style>
      body span.reasoning-step .as-written {
        display: inline;
      }

      body span.reasoning-step .alternate {
        display: none;
      }
    </style>
  </noscript>

  <!-- Google font embeds -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;0,800;1,400;1,500;1,600;1,700;1,800&amp;family=Inria+Sans:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&amp;display=swap" rel="stylesheet">
</head>

<body class="text-page">
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <!-- Table of contents (only if the page has a table of contents) -->
    <aside id="toc">
    <div id="toc-container" style="min-width: 10em; font-size: 15pt;">
      <!-- Title for the page -->
      <h3 class="Agda" style="margin-top: 0; margin-bottom: 0; white-space: pre;">
                <a class="Module">1Lab.HLevel.Sets</a>
              </h3>

      <!-- Cube logo -->
      <a id="logo" href="/">
        <img alt="1Lab" src="/static/cube-72x.png" style="display: block; margin-bottom: 1em; margin: auto;" width="32px" height="32px" />
      </a>

      <!-- Actual table of contents (separated from the rest by
      horizontal rules) -->
      <hr />
      <ul>
      <li><a href="#sets"><a href="#sets" class="header-link">Sets<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#rijkes-theorem"><a href="#rijkes-theorem" class="header-link">Rijke’s
      Theorem<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#hedbergs-theorem"><a href="#hedbergs-theorem" class="header-link">Hedberg’s
      Theorem<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      </ul>
      <hr />

      <!-- Sidebar controls -->
      <div style="display: flex; gap: 0.25em; flex-flow: row wrap;">
        <!-- Sidebar equations control -->
        <span class="equations" style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-eqns" type="checkbox" class="equations" id="sidebar-eqns">
          <label for="sidebar-eqns">Equations</label>
        </span>

        <!-- Sidebar fonts control -->
        <span style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-font" type="checkbox" id="toggle-fonts">
          <label for="toggle-fonts">Serif Font</label>
        </span>

        <!-- Sidebar footnotes control -->
        <span class="inline-footnotes" style="display: none; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-fns" type="checkbox" class="inline-footnotes" id="sidebar-fns">
          <label for="sidebar-fns">Inline Footnotes</label>
        </span>
      </div>

      <hr />

      <!-- Navbar navigation (lol) -->
      <div id="return" style="white-space: nowrap;">
        <div class="search-form search-form-proxy" role="form">
          <input id="search-box-proxy" type_="text" placeholder="Search..." autocomplete="off" tabindex="0"></input>
        </div>

              <a href="/">back to index</a> <br />
              <a href="all-pages.html">view all pages</a> <br />
        <a href="https://github.com/plt-amy/cubical-1lab/blob/2062bad7140078f9f32ed0b855d1bcbd0e3244f1/src/1Lab/HLevel/Sets.lagda.md">link to source</a> <br />
                <hr /> <div class="author-list">Written by Amélia Liao and uni</div> <br />
              </div>
    </div>
  </aside>
  
  <article>
    <!-- Article navigation (narrow screens only) -->
    <div class="narrow-only" id="article-nav">
      <!-- Index return anchor (only if the page is not the index) -->
            <div id="return">
        <a href="/">back to index</a>
      </div>
      
      <!-- Navbar equations control -->
      <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-eqns" type="checkbox" class="equations" id="navbar-eqns">
        <label for="navbar-eqns">Equations</label>
      </span>

      <!-- Navbar footnotes control -->
      <span class="inline-footnotes" style="display: none; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-fns" type="checkbox" class="inline-footnotes" id="navbar-fns">
        <label for="navbar-fns">Inline Footnotes</label>
      </span>
    </div>

<pre class="Agda"><a id="115" class="Keyword">open</a> <a id="120" class="Keyword">import</a> <a id="127" href="1Lab.Equiv.Fibrewise.html" class="Module">1Lab.Equiv.Fibrewise</a>
<a id="148" class="Keyword">open</a> <a id="153" class="Keyword">import</a> <a id="160" href="1Lab.HLevel.Retracts.html" class="Module">1Lab.HLevel.Retracts</a>
<a id="181" class="Keyword">open</a> <a id="186" class="Keyword">import</a> <a id="193" href="1Lab.Type.Dec.html" class="Module">1Lab.Type.Dec</a>
<a id="207" class="Keyword">open</a> <a id="212" class="Keyword">import</a> <a id="219" href="1Lab.HLevel.html" class="Module">1Lab.HLevel</a>
<a id="231" class="Keyword">open</a> <a id="236" class="Keyword">import</a> <a id="243" href="1Lab.Equiv.html" class="Module">1Lab.Equiv</a>
<a id="254" class="Keyword">open</a> <a id="259" class="Keyword">import</a> <a id="266" href="1Lab.Path.html" class="Module">1Lab.Path</a>
<a id="276" class="Keyword">open</a> <a id="281" class="Keyword">import</a> <a id="288" href="1Lab.Type.html" class="Module">1Lab.Type</a>

<a id="299" class="Keyword">module</a> <a id="306" href="1Lab.HLevel.Sets.html" class="Module">1Lab.HLevel.Sets</a> <a id="323" class="Keyword">where</a>
</pre>
<!--
<pre class="Agda"><a id="343" class="Keyword">private</a> <a id="351" class="Keyword">variable</a>
  <a id="362" href="1Lab.HLevel.Sets.html#362" class="Generalizable">ℓ</a> <a id="364" class="Symbol">:</a> <a id="366" href="Agda.Primitive.html#582" data-type="Type" class="Postulate">Level</a>
  <a id="374" href="1Lab.HLevel.Sets.html#374" class="Generalizable">A</a> <a id="376" class="Symbol">:</a> <a id="378" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="383" href="1Lab.HLevel.Sets.html#362" class="Generalizable">ℓ</a>
  <a id="387" href="1Lab.HLevel.Sets.html#387" class="Generalizable">x</a> <a id="389" href="1Lab.HLevel.Sets.html#389" class="Generalizable">y</a> <a id="391" class="Symbol">:</a> <a id="393" href="1Lab.HLevel.Sets.html#374" class="Generalizable">A</a>
  <a id="397" href="1Lab.HLevel.Sets.html#397" class="Generalizable">p</a> <a id="399" href="1Lab.HLevel.Sets.html#399" class="Generalizable">q</a> <a id="401" class="Symbol">:</a> <a id="403" href="1Lab.HLevel.Sets.html#387" class="Generalizable">x</a> <a id="405" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="407" href="1Lab.HLevel.Sets.html#389" class="Generalizable">y</a>
</pre>-->
<h1 id="sets"><a href="#sets" class="header-link">Sets<span class="header-link-emoji">🔗</span></a></h1>
<p>A set, in HoTT, is a type that validates UIP (uniqueness of equality
proofs): Any two proofs of the same equality are equal. There are many
ways to prove that a type is a set. An equivalence that is well-known in
type theory is that UIP is equivalent to <strong>Axiom K</strong>:</p>
<pre class="Agda"><a id="hasK"></a><a id="702" href="1Lab.HLevel.Sets.html#702" data-type="Type ℓ → Typeω" class="Function">hasK</a> <a id="707" class="Symbol">:</a> <a id="709" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="714" href="1Lab.HLevel.Sets.html#362" class="Generalizable">ℓ</a> <a id="716" class="Symbol">→</a> <a id="718" href="1Lab.Type.html#406" class="Primitive">Typeω</a>
<a id="724" href="1Lab.HLevel.Sets.html#702" data-type="Type ℓ → Typeω" class="Function">hasK</a> <a id="729" href="1Lab.HLevel.Sets.html#729" class="Bound">A</a> <a id="731" class="Symbol">=</a> <a id="733" class="Symbol">∀</a> <a id="735" class="Symbol">{</a><a id="736" href="1Lab.HLevel.Sets.html#736" class="Bound">ℓ</a><a id="737" class="Symbol">}</a> <a id="739" class="Symbol">{</a><a id="740" href="1Lab.HLevel.Sets.html#740" class="Bound">x</a> <a id="742" class="Symbol">:</a> <a id="744" href="1Lab.HLevel.Sets.html#729" class="Bound">A</a><a id="745" class="Symbol">}</a> <a id="747" class="Symbol">(</a><a id="748" href="1Lab.HLevel.Sets.html#748" class="Bound">P</a> <a id="750" class="Symbol">:</a> <a id="752" href="1Lab.HLevel.Sets.html#740" class="Bound">x</a> <a id="754" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="756" href="1Lab.HLevel.Sets.html#740" class="Bound">x</a> <a id="758" class="Symbol">→</a> <a id="760" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="765" href="1Lab.HLevel.Sets.html#736" class="Bound">ℓ</a><a id="766" class="Symbol">)</a> <a id="768" class="Symbol">→</a> <a id="770" href="1Lab.HLevel.Sets.html#748" class="Bound">P</a> <a id="772" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="777" class="Symbol">→</a> <a id="779" class="Symbol">(</a><a id="780" href="1Lab.HLevel.Sets.html#780" class="Bound">p</a> <a id="782" class="Symbol">:</a> <a id="784" href="1Lab.HLevel.Sets.html#740" class="Bound">x</a> <a id="786" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="788" href="1Lab.HLevel.Sets.html#740" class="Bound">x</a><a id="789" class="Symbol">)</a> <a id="791" class="Symbol">→</a> <a id="793" href="1Lab.HLevel.Sets.html#748" class="Bound">P</a> <a id="795" href="1Lab.HLevel.Sets.html#780" class="Bound">p</a>
</pre>
<p>A type is a Set if, and only if, it satisfies K:</p>
<pre class="Agda"><a id="K→is-set"></a><a id="860" href="1Lab.HLevel.Sets.html#860" data-type="hasK A → is-set A" class="Function">K→is-set</a> <a id="869" class="Symbol">:</a> <a id="871" href="1Lab.HLevel.Sets.html#702" data-type="Type ℓ → Typeω" class="Function">hasK</a> <a id="876" href="1Lab.HLevel.Sets.html#374" class="Generalizable">A</a> <a id="878" class="Symbol">→</a> <a id="880" href="1Lab.HLevel.html#3356" data-type="Type ℓ → Type ℓ" class="Function">is-set</a> <a id="887" href="1Lab.HLevel.Sets.html#374" class="Generalizable">A</a>
<a id="889" href="1Lab.HLevel.Sets.html#860" data-type="hasK A → is-set A" class="Function">K→is-set</a> <a id="898" href="1Lab.HLevel.Sets.html#898" class="Bound">K</a> <a id="900" href="1Lab.HLevel.Sets.html#900" class="Bound">x</a> <a id="902" href="1Lab.HLevel.Sets.html#902" class="Bound">y</a> <a id="904" class="Symbol">=</a>
  <a id="908" href="1Lab.Path.html#19544" data-type="(P : (y : A) → x ≡ y → Type ℓ₂) → P x refl → (p : x ≡ y) → P y p" class="Function">J</a> <a id="910" class="Symbol">(λ</a> <a id="913" href="1Lab.HLevel.Sets.html#913" class="Bound">y</a> <a id="915" href="1Lab.HLevel.Sets.html#915" class="Bound">p</a> <a id="917" class="Symbol">→</a> <a id="919" class="Symbol">(</a><a id="920" href="1Lab.HLevel.Sets.html#920" class="Bound">q</a> <a id="922" class="Symbol">:</a> <a id="924" href="1Lab.HLevel.Sets.html#900" class="Bound">x</a> <a id="926" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="928" href="1Lab.HLevel.Sets.html#913" class="Bound">y</a><a id="929" class="Symbol">)</a> <a id="931" class="Symbol">→</a> <a id="933" href="1Lab.HLevel.Sets.html#915" class="Bound">p</a> <a id="935" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="937" href="1Lab.HLevel.Sets.html#920" class="Bound">q</a><a id="938" class="Symbol">)</a> <a id="940" class="Symbol">(λ</a> <a id="943" href="1Lab.HLevel.Sets.html#943" class="Bound">q</a> <a id="945" class="Symbol">→</a> <a id="947" href="1Lab.HLevel.Sets.html#898" class="Bound">K</a> <a id="949" class="Symbol">(λ</a> <a id="952" href="1Lab.HLevel.Sets.html#952" class="Bound">q</a> <a id="954" class="Symbol">→</a> <a id="956" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="961" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="963" href="1Lab.HLevel.Sets.html#952" class="Bound">q</a><a id="964" class="Symbol">)</a> <a id="966" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="971" href="1Lab.HLevel.Sets.html#943" class="Bound">q</a><a id="972" class="Symbol">)</a>

<a id="is-set→K"></a><a id="975" href="1Lab.HLevel.Sets.html#975" data-type="is-set A → hasK A" class="Function">is-set→K</a> <a id="984" class="Symbol">:</a> <a id="986" href="1Lab.HLevel.html#3356" data-type="Type ℓ → Type ℓ" class="Function">is-set</a> <a id="993" href="1Lab.HLevel.Sets.html#374" class="Generalizable">A</a> <a id="995" class="Symbol">→</a> <a id="997" href="1Lab.HLevel.Sets.html#702" data-type="Type ℓ → Typeω" class="Function">hasK</a> <a id="1002" href="1Lab.HLevel.Sets.html#374" class="Generalizable">A</a>
<a id="1004" href="1Lab.HLevel.Sets.html#975" data-type="is-set A → hasK A" class="Function">is-set→K</a> <a id="1013" href="1Lab.HLevel.Sets.html#1013" class="Bound">Aset</a> <a id="1018" class="Symbol">{</a><a id="1019" class="Argument">x</a> <a id="1021" class="Symbol">=</a> <a id="1023" href="1Lab.HLevel.Sets.html#1023" class="Bound">x</a><a id="1024" class="Symbol">}</a> <a id="1026" href="1Lab.HLevel.Sets.html#1026" class="Bound">P</a> <a id="1028" href="1Lab.HLevel.Sets.html#1028" class="Bound">prefl</a> <a id="1034" href="1Lab.HLevel.Sets.html#1034" class="Bound">p</a> <a id="1036" class="Symbol">=</a> <a id="1038" href="1Lab.Path.html#11776" data-type="A ≡ B₁ → A → B₁" class="Function">transport</a> <a id="1048" class="Symbol">(λ</a> <a id="1051" href="1Lab.HLevel.Sets.html#1051" class="Bound">i</a> <a id="1053" class="Symbol">→</a> <a id="1055" href="1Lab.HLevel.Sets.html#1026" class="Bound">P</a> <a id="1057" class="Symbol">(</a><a id="1058" href="1Lab.HLevel.Sets.html#1013" class="Bound">Aset</a> <a id="1063" class="Symbol">_</a> <a id="1065" class="Symbol">_</a> <a id="1067" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="1072" href="1Lab.HLevel.Sets.html#1034" class="Bound">p</a> <a id="1074" href="1Lab.HLevel.Sets.html#1051" class="Bound">i</a><a id="1075" class="Symbol">))</a> <a id="1078" href="1Lab.HLevel.Sets.html#1028" class="Bound">prefl</a>
</pre>
<h2 id="rijkes-theorem"><a href="#rijkes-theorem" class="header-link">Rijke’s
Theorem<span class="header-link-emoji">🔗</span></a></h2>
<p>Another useful way of showing that a type is a set is <strong>Rijke’s
theorem.</strong><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> Suppose we have the following setup:
<code>R</code> is a relation on the elements of <code>A</code>;
<code>R x y</code> is always a proposition; <code>R</code> is reflexive,
and <code>R x y</code> implies <code>x ≡ y</code>. Then we have that
<code>(x ≡ y) ≃ R x y</code>, and by closure of h-levels under
equivalences, <code>A</code> is a set.</p>
<pre class="Agda"><a id="Rijke-equivalence"></a><a id="1454" href="1Lab.HLevel.Sets.html#1454" data-type="R₁ x x → (toid : R₁ x y → x ≡ y) → is-prop (R₁ x y) → is-equiv toid" class="Function">Rijke-equivalence</a> <a id="1472" class="Symbol">:</a> <a id="1474" class="Symbol">{</a><a id="1475" href="1Lab.HLevel.Sets.html#1475" class="Bound">R</a> <a id="1477" class="Symbol">:</a> <a id="1479" href="1Lab.HLevel.Sets.html#374" class="Generalizable">A</a> <a id="1481" class="Symbol">→</a> <a id="1483" href="1Lab.HLevel.Sets.html#374" class="Generalizable">A</a> <a id="1485" class="Symbol">→</a> <a id="1487" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="1492" href="1Lab.HLevel.Sets.html#362" class="Generalizable">ℓ</a><a id="1493" class="Symbol">}</a>
                  <a id="1513" class="Symbol">→</a> <a id="1515" class="Symbol">(</a><a id="1516" href="1Lab.HLevel.Sets.html#1516" class="Bound">refl</a> <a id="1521" class="Symbol">:</a> <a id="1523" class="Symbol">{</a><a id="1524" href="1Lab.HLevel.Sets.html#1524" class="Bound">x</a> <a id="1526" class="Symbol">:</a> <a id="1528" href="1Lab.HLevel.Sets.html#374" class="Generalizable">A</a><a id="1529" class="Symbol">}</a> <a id="1531" class="Symbol">→</a> <a id="1533" href="1Lab.HLevel.Sets.html#1475" class="Bound">R</a> <a id="1535" href="1Lab.HLevel.Sets.html#1524" class="Bound">x</a> <a id="1537" href="1Lab.HLevel.Sets.html#1524" class="Bound">x</a><a id="1538" class="Symbol">)</a>
                  <a id="1558" class="Symbol">→</a> <a id="1560" class="Symbol">(</a><a id="1561" href="1Lab.HLevel.Sets.html#1561" class="Bound">toid</a> <a id="1566" class="Symbol">:</a> <a id="1568" class="Symbol">{</a><a id="1569" href="1Lab.HLevel.Sets.html#1569" class="Bound">x</a> <a id="1571" href="1Lab.HLevel.Sets.html#1571" class="Bound">y</a> <a id="1573" class="Symbol">:</a> <a id="1575" href="1Lab.HLevel.Sets.html#374" class="Generalizable">A</a><a id="1576" class="Symbol">}</a> <a id="1578" class="Symbol">→</a> <a id="1580" href="1Lab.HLevel.Sets.html#1475" class="Bound">R</a> <a id="1582" href="1Lab.HLevel.Sets.html#1569" class="Bound">x</a> <a id="1584" href="1Lab.HLevel.Sets.html#1571" class="Bound">y</a> <a id="1586" class="Symbol">→</a> <a id="1588" href="1Lab.HLevel.Sets.html#1569" class="Bound">x</a> <a id="1590" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="1592" href="1Lab.HLevel.Sets.html#1571" class="Bound">y</a><a id="1593" class="Symbol">)</a>
                  <a id="1613" class="Symbol">→</a> <a id="1615" class="Symbol">(</a><a id="1616" href="1Lab.HLevel.Sets.html#1616" class="Bound">is-prop</a> <a id="1624" class="Symbol">:</a> <a id="1626" class="Symbol">{</a><a id="1627" href="1Lab.HLevel.Sets.html#1627" class="Bound">x</a> <a id="1629" href="1Lab.HLevel.Sets.html#1629" class="Bound">y</a> <a id="1631" class="Symbol">:</a> <a id="1633" href="1Lab.HLevel.Sets.html#374" class="Generalizable">A</a><a id="1634" class="Symbol">}</a> <a id="1636" class="Symbol">→</a> <a id="1638" href="1Lab.HLevel.html#2597" data-type="Type ℓ → Type ℓ" class="Function">is-prop</a> <a id="1646" class="Symbol">(</a><a id="1647" href="1Lab.HLevel.Sets.html#1475" class="Bound">R</a> <a id="1649" href="1Lab.HLevel.Sets.html#1627" class="Bound">x</a> <a id="1651" href="1Lab.HLevel.Sets.html#1629" class="Bound">y</a><a id="1652" class="Symbol">))</a>
                  <a id="1673" class="Symbol">→</a> <a id="1675" class="Symbol">{</a><a id="1676" href="1Lab.HLevel.Sets.html#1676" class="Bound">x</a> <a id="1678" href="1Lab.HLevel.Sets.html#1678" class="Bound">y</a> <a id="1680" class="Symbol">:</a> <a id="1682" href="1Lab.HLevel.Sets.html#374" class="Generalizable">A</a><a id="1683" class="Symbol">}</a> <a id="1685" class="Symbol">→</a> <a id="1687" href="1Lab.Equiv.html#2286" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-equiv</a> <a id="1696" class="Symbol">(</a><a id="1697" href="1Lab.HLevel.Sets.html#1561" class="Bound">toid</a> <a id="1702" class="Symbol">{</a><a id="1703" href="1Lab.HLevel.Sets.html#1676" class="Bound">x</a><a id="1704" class="Symbol">}</a> <a id="1706" class="Symbol">{</a><a id="1707" href="1Lab.HLevel.Sets.html#1678" class="Bound">y</a><a id="1708" class="Symbol">})</a>
<a id="1711" href="1Lab.HLevel.Sets.html#1454" data-type="R₁ x x → (toid : R₁ x y → x ≡ y) → is-prop (R₁ x y) → is-equiv toid" class="Function">Rijke-equivalence</a> <a id="1729" class="Symbol">{</a><a id="1730" class="Argument">A</a> <a id="1732" class="Symbol">=</a> <a id="1734" href="1Lab.HLevel.Sets.html#1734" class="Bound">A</a><a id="1735" class="Symbol">}</a> <a id="1737" class="Symbol">{</a><a id="1738" class="Argument">R</a> <a id="1740" class="Symbol">=</a> <a id="1742" href="1Lab.HLevel.Sets.html#1742" class="Bound">R</a><a id="1743" class="Symbol">}</a> <a id="1745" href="1Lab.HLevel.Sets.html#1745" class="Bound">refl</a> <a id="1750" href="1Lab.HLevel.Sets.html#1750" class="Bound">toid</a> <a id="1755" href="1Lab.HLevel.Sets.html#1755" class="Bound">isprop</a> <a id="1762" class="Symbol">=</a> <a id="1764" href="1Lab.Equiv.Fibrewise.html#2067" data-type="is-equiv (total f) → is-equiv (f x)" class="Function">total→equiv</a> <a id="1776" href="1Lab.HLevel.Sets.html#1790" data-type="R₁ x x →
(toid : R₁ x y → x ≡ y) →
is-prop (R₁ x y) → is-equiv (total (λ y → toid))" class="Function">equiv</a> <a id="1782" class="Keyword">where</a>
  <a id="1790" href="1Lab.HLevel.Sets.html#1790" data-type="R₁ x x →
(toid : R₁ x y → x ≡ y) →
is-prop (R₁ x y) → is-equiv (total (λ y → toid))" class="Function">equiv</a> <a id="1796" class="Symbol">:</a> <a id="1798" class="Symbol">{</a><a id="1799" href="1Lab.HLevel.Sets.html#1799" class="Bound">x</a> <a id="1801" class="Symbol">:</a> <a id="1803" href="1Lab.HLevel.Sets.html#1734" class="Bound">A</a><a id="1804" class="Symbol">}</a> <a id="1806" class="Symbol">→</a> <a id="1808" href="1Lab.Equiv.html#2286" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-equiv</a> <a id="1817" class="Symbol">(</a><a id="1818" href="1Lab.Equiv.Fibrewise.html#767" data-type="((x : A) → P x → Q x) → Σ P → Σ Q" class="Function">total</a> <a id="1824" class="Symbol">{</a><a id="1825" class="Argument">P</a> <a id="1827" class="Symbol">=</a> <a id="1829" href="1Lab.HLevel.Sets.html#1742" class="Bound">R</a> <a id="1831" href="1Lab.HLevel.Sets.html#1799" class="Bound">x</a><a id="1832" class="Symbol">}</a> <a id="1834" class="Symbol">{</a><a id="1835" class="Argument">Q</a> <a id="1837" class="Symbol">=</a> <a id="1839" href="1Lab.HLevel.Sets.html#1799" class="Bound">x</a> <a id="1841" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡_</a><a id="1843" class="Symbol">}</a> <a id="1845" class="Symbol">(λ</a> <a id="1848" href="1Lab.HLevel.Sets.html#1848" class="Bound">y</a> <a id="1850" class="Symbol">→</a> <a id="1852" href="1Lab.HLevel.Sets.html#1750" class="Bound">toid</a> <a id="1857" class="Symbol">{</a><a id="1858" href="1Lab.HLevel.Sets.html#1799" class="Bound">x</a><a id="1859" class="Symbol">}</a> <a id="1861" class="Symbol">{</a><a id="1862" href="1Lab.HLevel.Sets.html#1848" class="Bound">y</a><a id="1863" class="Symbol">}))</a>
  <a id="1869" href="1Lab.HLevel.Sets.html#1790" data-type="R₁ x x →
(toid : R₁ x y → x ≡ y) →
is-prop (R₁ x y) → is-equiv (total (λ y → toid))" class="Function">equiv</a> <a id="1875" class="Symbol">{</a><a id="1876" href="1Lab.HLevel.Sets.html#1876" class="Bound">x</a><a id="1877" class="Symbol">}</a> <a id="1879" class="Symbol">=</a> <a id="1881" href="1Lab.Equiv.html#20733" data-type="is-contr A → is-contr B₁ → is-equiv f" class="Function">is-contr→is-equiv</a>
    <a id="1903" class="Symbol">(</a><a id="1904" href="1Lab.HLevel.html#1383" data-type="(centre₁ : A) (paths₁ : (x : A) → centre₁ ≡ x) → is-contr A" class="InductiveConstructor">contr</a> <a id="1910" class="Symbol">(</a><a id="1911" href="1Lab.HLevel.Sets.html#1876" class="Bound">x</a> <a id="1913" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="1915" href="1Lab.HLevel.Sets.html#1745" class="Bound">refl</a><a id="1919" class="Symbol">)</a> <a id="1921" class="Symbol">λ</a> <a id="1923" class="Symbol">{</a> <a id="1925" class="Symbol">(</a><a id="1926" href="1Lab.HLevel.Sets.html#1926" class="Bound">x</a> <a id="1928" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="1930" href="1Lab.HLevel.Sets.html#1930" class="Bound">q</a><a id="1931" class="Symbol">)</a> <a id="1933" class="Symbol">→</a> <a id="1935" href="1Lab.Path.html#57659" data-type="(p : x .fst ≡ y .fst) → subst B₁ p (x .snd) ≡ y .snd → x ≡ y" class="Function">Σ-path</a> <a id="1942" class="Symbol">(</a><a id="1943" href="1Lab.HLevel.Sets.html#1750" class="Bound">toid</a> <a id="1948" href="1Lab.HLevel.Sets.html#1930" class="Bound">q</a><a id="1949" class="Symbol">)</a> <a id="1951" class="Symbol">(</a><a id="1952" href="1Lab.HLevel.Sets.html#1755" class="Bound">isprop</a> <a id="1959" class="Symbol">_</a> <a id="1961" class="Symbol">_)</a> <a id="1964" class="Symbol">})</a>
    <a id="1971" class="Symbol">(</a><a id="1972" href="1Lab.HLevel.html#1383" data-type="(centre₁ : A) (paths₁ : (x : A) → centre₁ ≡ x) → is-contr A" class="InductiveConstructor">contr</a> <a id="1978" class="Symbol">(</a><a id="1979" href="1Lab.HLevel.Sets.html#1876" class="Bound">x</a> <a id="1981" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="1983" class="Symbol">λ</a> <a id="1985" href="1Lab.HLevel.Sets.html#1985" class="Bound">i</a> <a id="1987" class="Symbol">→</a> <a id="1989" href="1Lab.HLevel.Sets.html#1876" class="Bound">x</a><a id="1990" class="Symbol">)</a> <a id="1992" class="Symbol">λ</a> <a id="1994" class="Symbol">{</a> <a id="1996" class="Symbol">(</a><a id="1997" href="1Lab.HLevel.Sets.html#1997" class="Bound">x</a> <a id="1999" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="2001" href="1Lab.HLevel.Sets.html#2001" class="Bound">q</a><a id="2002" class="Symbol">)</a> <a id="2004" href="1Lab.HLevel.Sets.html#2004" class="Bound">i</a> <a id="2006" class="Symbol">→</a> <a id="2008" href="1Lab.HLevel.Sets.html#2001" class="Bound">q</a> <a id="2010" href="1Lab.HLevel.Sets.html#2004" class="Bound">i</a> <a id="2012" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="2014" class="Symbol">λ</a> <a id="2016" href="1Lab.HLevel.Sets.html#2016" class="Bound">j</a> <a id="2018" class="Symbol">→</a> <a id="2020" href="1Lab.HLevel.Sets.html#2001" class="Bound">q</a> <a id="2022" class="Symbol">(</a><a id="2023" href="1Lab.HLevel.Sets.html#2004" class="Bound">i</a> <a id="2025" href="1Lab.Path.html#2191" class="Primitive Operator">∧</a> <a id="2027" href="1Lab.HLevel.Sets.html#2016" class="Bound">j</a><a id="2028" class="Symbol">)</a> <a id="2030" class="Symbol">})</a>
</pre>
<p>By the characterisation of <a href="1Lab.Equiv.Fibrewise.html">fibrewise equivalences</a>, it
suffices to show that <code>total toid</code> induces an equivalence of
total spaces. By J, the total space of <code>x ≡_</code> is
contractible; By <code>toid</code>, and the fact that <code>R</code> is
propositional, we can contract the total space of <code>R x</code> to
<code>(x , refl)</code>.</p>
<pre class="Agda"><a id="Rijke-is-set"></a><a id="2391" href="1Lab.HLevel.Sets.html#2391" data-type="R₁ x x → (R₁ x y → x ≡ y) → is-prop (R₁ x y) → is-set A" class="Function">Rijke-is-set</a> <a id="2404" class="Symbol">:</a> <a id="2406" class="Symbol">{</a><a id="2407" href="1Lab.HLevel.Sets.html#2407" class="Bound">R</a> <a id="2409" class="Symbol">:</a> <a id="2411" href="1Lab.HLevel.Sets.html#374" class="Generalizable">A</a> <a id="2413" class="Symbol">→</a> <a id="2415" href="1Lab.HLevel.Sets.html#374" class="Generalizable">A</a> <a id="2417" class="Symbol">→</a> <a id="2419" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="2424" href="1Lab.HLevel.Sets.html#362" class="Generalizable">ℓ</a><a id="2425" class="Symbol">}</a>
            <a id="2439" class="Symbol">→</a> <a id="2441" class="Symbol">(</a><a id="2442" href="1Lab.HLevel.Sets.html#2442" class="Bound">refl</a> <a id="2447" class="Symbol">:</a> <a id="2449" class="Symbol">{</a><a id="2450" href="1Lab.HLevel.Sets.html#2450" class="Bound">x</a> <a id="2452" class="Symbol">:</a> <a id="2454" href="1Lab.HLevel.Sets.html#374" class="Generalizable">A</a><a id="2455" class="Symbol">}</a> <a id="2457" class="Symbol">→</a> <a id="2459" href="1Lab.HLevel.Sets.html#2407" class="Bound">R</a> <a id="2461" href="1Lab.HLevel.Sets.html#2450" class="Bound">x</a> <a id="2463" href="1Lab.HLevel.Sets.html#2450" class="Bound">x</a><a id="2464" class="Symbol">)</a>
            <a id="2478" class="Symbol">→</a> <a id="2480" class="Symbol">(</a><a id="2481" href="1Lab.HLevel.Sets.html#2481" class="Bound">toid</a> <a id="2486" class="Symbol">:</a> <a id="2488" class="Symbol">{</a><a id="2489" href="1Lab.HLevel.Sets.html#2489" class="Bound">x</a> <a id="2491" href="1Lab.HLevel.Sets.html#2491" class="Bound">y</a> <a id="2493" class="Symbol">:</a> <a id="2495" href="1Lab.HLevel.Sets.html#374" class="Generalizable">A</a><a id="2496" class="Symbol">}</a> <a id="2498" class="Symbol">→</a> <a id="2500" href="1Lab.HLevel.Sets.html#2407" class="Bound">R</a> <a id="2502" href="1Lab.HLevel.Sets.html#2489" class="Bound">x</a> <a id="2504" href="1Lab.HLevel.Sets.html#2491" class="Bound">y</a> <a id="2506" class="Symbol">→</a> <a id="2508" href="1Lab.HLevel.Sets.html#2489" class="Bound">x</a> <a id="2510" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="2512" href="1Lab.HLevel.Sets.html#2491" class="Bound">y</a><a id="2513" class="Symbol">)</a>
            <a id="2527" class="Symbol">→</a> <a id="2529" class="Symbol">(</a><a id="2530" href="1Lab.HLevel.Sets.html#2530" class="Bound">is-prop</a> <a id="2538" class="Symbol">:</a> <a id="2540" class="Symbol">{</a><a id="2541" href="1Lab.HLevel.Sets.html#2541" class="Bound">x</a> <a id="2543" href="1Lab.HLevel.Sets.html#2543" class="Bound">y</a> <a id="2545" class="Symbol">:</a> <a id="2547" href="1Lab.HLevel.Sets.html#374" class="Generalizable">A</a><a id="2548" class="Symbol">}</a> <a id="2550" class="Symbol">→</a> <a id="2552" href="1Lab.HLevel.html#2597" data-type="Type ℓ → Type ℓ" class="Function">is-prop</a> <a id="2560" class="Symbol">(</a><a id="2561" href="1Lab.HLevel.Sets.html#2407" class="Bound">R</a> <a id="2563" href="1Lab.HLevel.Sets.html#2541" class="Bound">x</a> <a id="2565" href="1Lab.HLevel.Sets.html#2543" class="Bound">y</a><a id="2566" class="Symbol">))</a>
            <a id="2581" class="Symbol">→</a> <a id="2583" href="1Lab.HLevel.html#3356" data-type="Type ℓ → Type ℓ" class="Function">is-set</a> <a id="2590" href="1Lab.HLevel.Sets.html#374" class="Generalizable">A</a>
<a id="2592" href="1Lab.HLevel.Sets.html#2391" data-type="R₁ x x → (R₁ x y → x ≡ y) → is-prop (R₁ x y) → is-set A" class="Function">Rijke-is-set</a> <a id="2605" href="1Lab.HLevel.Sets.html#2605" class="Bound">refl</a> <a id="2610" href="1Lab.HLevel.Sets.html#2610" class="Bound">toid</a> <a id="2615" href="1Lab.HLevel.Sets.html#2615" class="Bound">isprop</a> <a id="2622" href="1Lab.HLevel.Sets.html#2622" class="Bound">x</a> <a id="2624" href="1Lab.HLevel.Sets.html#2624" class="Bound">y</a> <a id="2626" class="Symbol">=</a>
  <a id="2630" href="1Lab.HLevel.Retracts.html#4068" data-type="(n : Nat) (f : A → B₁) →
is-equiv f → is-hlevel A n → is-hlevel B₁ n" class="Function">equiv→is-hlevel</a> <a id="2646" class="Number">1</a>
    <a id="2652" href="1Lab.HLevel.Sets.html#2610" class="Bound">toid</a> <a id="2657" class="Symbol">(</a><a id="2658" href="1Lab.HLevel.Sets.html#1454" data-type="R₁ x x → (toid : R₁ x y → x ≡ y) → is-prop (R₁ x y) → is-equiv toid" class="Function">Rijke-equivalence</a> <a id="2676" href="1Lab.HLevel.Sets.html#2605" class="Bound">refl</a> <a id="2681" href="1Lab.HLevel.Sets.html#2610" class="Bound">toid</a> <a id="2686" href="1Lab.HLevel.Sets.html#2615" class="Bound">isprop</a><a id="2692" class="Symbol">)</a> <a id="2694" href="1Lab.HLevel.Sets.html#2615" class="Bound">isprop</a>
</pre>
<h2 id="hedbergs-theorem"><a href="#hedbergs-theorem" class="header-link">Hedberg’s
Theorem<span class="header-link-emoji">🔗</span></a></h2>
<p>As a consequence of Rijke’s theorem, we get that any type for which
we can conclude equality from a double-negated equality is a set:</p>
<pre class="Agda"><a id="¬¬-separated→is-set"></a><a id="2871" href="1Lab.HLevel.Sets.html#2871" data-type="(((x ≡ y → ⊥) → ⊥) → x ≡ y) → is-set A" class="Function">¬¬-separated→is-set</a> <a id="2891" class="Symbol">:</a> <a id="2893" class="Symbol">({</a><a id="2895" href="1Lab.HLevel.Sets.html#2895" class="Bound">x</a> <a id="2897" href="1Lab.HLevel.Sets.html#2897" class="Bound">y</a> <a id="2899" class="Symbol">:</a> <a id="2901" href="1Lab.HLevel.Sets.html#374" class="Generalizable">A</a><a id="2902" class="Symbol">}</a> <a id="2904" class="Symbol">→</a> <a id="2906" class="Symbol">((</a><a id="2908" href="1Lab.HLevel.Sets.html#2895" class="Bound">x</a> <a id="2910" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="2912" href="1Lab.HLevel.Sets.html#2897" class="Bound">y</a> <a id="2914" class="Symbol">→</a> <a id="2916" href="1Lab.Type.html#1336" data-type="Type" class="Datatype">⊥</a><a id="2917" class="Symbol">)</a> <a id="2919" class="Symbol">→</a> <a id="2921" href="1Lab.Type.html#1336" data-type="Type" class="Datatype">⊥</a><a id="2922" class="Symbol">)</a> <a id="2924" class="Symbol">→</a> <a id="2926" href="1Lab.HLevel.Sets.html#2895" class="Bound">x</a> <a id="2928" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="2930" href="1Lab.HLevel.Sets.html#2897" class="Bound">y</a><a id="2931" class="Symbol">)</a>
                    <a id="2953" class="Symbol">→</a> <a id="2955" href="1Lab.HLevel.html#3356" data-type="Type ℓ → Type ℓ" class="Function">is-set</a> <a id="2962" href="1Lab.HLevel.Sets.html#374" class="Generalizable">A</a>
<a id="2964" href="1Lab.HLevel.Sets.html#2871" data-type="(((x ≡ y → ⊥) → ⊥) → x ≡ y) → is-set A" class="Function">¬¬-separated→is-set</a> <a id="2984" href="1Lab.HLevel.Sets.html#2984" class="Bound">stable</a> <a id="2991" class="Symbol">=</a> <a id="2993" href="1Lab.HLevel.Sets.html#2391" data-type="R₁ x x → (R₁ x y → x ≡ y) → is-prop (R₁ x y) → is-set A" class="Function">Rijke-is-set</a> <a id="3006" class="Symbol">(λ</a> <a id="3009" href="1Lab.HLevel.Sets.html#3009" class="Bound">x</a> <a id="3011" class="Symbol">→</a> <a id="3013" href="1Lab.HLevel.Sets.html#3009" class="Bound">x</a> <a id="3015" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a><a id="3019" class="Symbol">)</a> <a id="3021" href="1Lab.HLevel.Sets.html#2984" class="Bound">stable</a> <a id="3028" href="1Lab.HLevel.Sets.html#3041" data-type="(((x ≡ y → ⊥) → ⊥) → x ≡ y) → is-prop ((x ≡ y → ⊥) → ⊥)" class="Function">prop</a> <a id="3033" class="Keyword">where</a>
  <a id="3041" href="1Lab.HLevel.Sets.html#3041" data-type="(((x ≡ y → ⊥) → ⊥) → x ≡ y) → is-prop ((x ≡ y → ⊥) → ⊥)" class="Function">prop</a> <a id="3046" class="Symbol">:</a> <a id="3048" class="Symbol">{</a><a id="3049" href="1Lab.HLevel.Sets.html#3049" class="Bound">x</a> <a id="3051" href="1Lab.HLevel.Sets.html#3051" class="Bound">y</a> <a id="3053" class="Symbol">:</a> <a id="3055" href="1Lab.HLevel.Sets.html#374" class="Generalizable">A</a><a id="3056" class="Symbol">}</a> <a id="3058" class="Symbol">→</a> <a id="3060" href="1Lab.HLevel.html#2597" data-type="Type ℓ → Type ℓ" class="Function">is-prop</a> <a id="3068" class="Symbol">((</a><a id="3070" href="1Lab.HLevel.Sets.html#3049" class="Bound">x</a> <a id="3072" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="3074" href="1Lab.HLevel.Sets.html#3051" class="Bound">y</a> <a id="3076" class="Symbol">→</a> <a id="3078" href="1Lab.Type.html#1336" data-type="Type" class="Datatype">⊥</a><a id="3079" class="Symbol">)</a> <a id="3081" class="Symbol">→</a> <a id="3083" href="1Lab.Type.html#1336" data-type="Type" class="Datatype">⊥</a><a id="3084" class="Symbol">)</a>
  <a id="3088" href="1Lab.HLevel.Sets.html#3041" data-type="(((x ≡ y → ⊥) → ⊥) → x ≡ y) → is-prop ((x ≡ y → ⊥) → ⊥)" class="Function">prop</a> <a id="3093" href="1Lab.HLevel.Sets.html#3093" class="Bound">p</a> <a id="3095" href="1Lab.HLevel.Sets.html#3095" class="Bound">q</a> <a id="3097" href="1Lab.HLevel.Sets.html#3097" class="Bound">i</a> <a id="3099" href="1Lab.HLevel.Sets.html#3099" class="Bound">x</a> <a id="3101" class="Symbol">=</a> <a id="3103" href="1Lab.Type.html#1352" data-type="⊥ → A" class="Function">absurd</a> <a id="3110" class="Symbol">{</a><a id="3111" class="Argument">A</a> <a id="3113" class="Symbol">=</a> <a id="3115" href="1Lab.HLevel.Sets.html#3093" class="Bound">p</a> <a id="3117" href="1Lab.HLevel.Sets.html#3099" class="Bound">x</a> <a id="3119" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="3121" href="1Lab.HLevel.Sets.html#3095" class="Bound">q</a> <a id="3123" href="1Lab.HLevel.Sets.html#3099" class="Bound">x</a><a id="3124" class="Symbol">}</a> <a id="3126" class="Symbol">(</a><a id="3127" href="1Lab.HLevel.Sets.html#3093" class="Bound">p</a> <a id="3129" href="1Lab.HLevel.Sets.html#3099" class="Bound">x</a><a id="3130" class="Symbol">)</a> <a id="3132" href="1Lab.HLevel.Sets.html#3097" class="Bound">i</a>
</pre>
<p>From this we get <strong>Hedberg’s theorem</strong>: Any type with
decidable equality is a set.</p>
<pre class="Agda"><a id="Discrete→is-set"></a><a id="3231" href="1Lab.HLevel.Sets.html#3231" data-type="Discrete A → is-set A" class="Function">Discrete→is-set</a> <a id="3247" class="Symbol">:</a> <a id="3249" href="1Lab.Type.Dec.html#585" data-type="Type ℓ → Type ℓ" class="Function">Discrete</a> <a id="3258" href="1Lab.HLevel.Sets.html#374" class="Generalizable">A</a> <a id="3260" class="Symbol">→</a> <a id="3262" href="1Lab.HLevel.html#3356" data-type="Type ℓ → Type ℓ" class="Function">is-set</a> <a id="3269" href="1Lab.HLevel.Sets.html#374" class="Generalizable">A</a>
<a id="3271" href="1Lab.HLevel.Sets.html#3231" data-type="Discrete A → is-set A" class="Function">Discrete→is-set</a> <a id="3287" class="Symbol">{</a><a id="3288" class="Argument">A</a> <a id="3290" class="Symbol">=</a> <a id="3292" href="1Lab.HLevel.Sets.html#3292" class="Bound">A</a><a id="3293" class="Symbol">}</a> <a id="3295" href="1Lab.HLevel.Sets.html#3295" class="Bound">dec</a> <a id="3299" class="Symbol">=</a> <a id="3301" href="1Lab.HLevel.Sets.html#2871" data-type="(((x ≡ y → ⊥) → ⊥) → x ≡ y) → is-set A" class="Function">¬¬-separated→is-set</a> <a id="3321" href="1Lab.HLevel.Sets.html#3333" data-type="Discrete A → ((x ≡ y → ⊥) → ⊥) → x ≡ y" class="Function">sep</a> <a id="3325" class="Keyword">where</a>
  <a id="3333" href="1Lab.HLevel.Sets.html#3333" data-type="Discrete A → ((x ≡ y → ⊥) → ⊥) → x ≡ y" class="Function">sep</a> <a id="3337" class="Symbol">:</a> <a id="3339" class="Symbol">{</a><a id="3340" href="1Lab.HLevel.Sets.html#3340" class="Bound">x</a> <a id="3342" href="1Lab.HLevel.Sets.html#3342" class="Bound">y</a> <a id="3344" class="Symbol">:</a> <a id="3346" href="1Lab.HLevel.Sets.html#3292" class="Bound">A</a><a id="3347" class="Symbol">}</a> <a id="3349" class="Symbol">→</a> <a id="3351" class="Symbol">((</a><a id="3353" href="1Lab.HLevel.Sets.html#3340" class="Bound">x</a> <a id="3355" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="3357" href="1Lab.HLevel.Sets.html#3342" class="Bound">y</a> <a id="3359" class="Symbol">→</a> <a id="3361" href="1Lab.Type.html#1336" data-type="Type" class="Datatype">⊥</a><a id="3362" class="Symbol">)</a> <a id="3364" class="Symbol">→</a> <a id="3366" href="1Lab.Type.html#1336" data-type="Type" class="Datatype">⊥</a><a id="3367" class="Symbol">)</a> <a id="3369" class="Symbol">→</a> <a id="3371" href="1Lab.HLevel.Sets.html#3340" class="Bound">x</a> <a id="3373" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="3375" href="1Lab.HLevel.Sets.html#3342" class="Bound">y</a>
  <a id="3379" href="1Lab.HLevel.Sets.html#3333" data-type="Discrete A → ((x ≡ y → ⊥) → ⊥) → x ≡ y" class="Function">sep</a> <a id="3383" class="Symbol">{</a><a id="3384" class="Argument">x</a> <a id="3386" class="Symbol">=</a> <a id="3388" href="1Lab.HLevel.Sets.html#3388" class="Bound">x</a><a id="3389" class="Symbol">}</a> <a id="3391" class="Symbol">{</a><a id="3392" class="Argument">y</a> <a id="3394" class="Symbol">=</a> <a id="3396" href="1Lab.HLevel.Sets.html#3396" class="Bound">y</a><a id="3397" class="Symbol">}</a> <a id="3399" href="1Lab.HLevel.Sets.html#3399" class="Bound">¬¬p</a> <a id="3403" class="Keyword">with</a> <a id="3408" href="1Lab.HLevel.Sets.html#3295" class="Bound">dec</a> <a id="3412" href="1Lab.HLevel.Sets.html#3388" class="Bound">x</a> <a id="3414" href="1Lab.HLevel.Sets.html#3396" class="Bound">y</a>
  <a id="3418" class="Symbol">...</a> <a id="3422" class="Symbol">|</a> <a id="3424" href="1Lab.Type.Dec.html#292" data-type="A → Dec A" class="InductiveConstructor">yes</a> <a id="3428" href="1Lab.HLevel.Sets.html#3428" class="Bound">p</a> <a id="3430" class="Symbol">=</a> <a id="3432" href="1Lab.HLevel.Sets.html#3428" class="Bound">p</a>
  <a id="3436" class="Symbol">...</a> <a id="3440" class="Symbol">|</a> <a id="3442" href="1Lab.Type.Dec.html#310" data-type="(A → ⊥) → Dec A" class="InductiveConstructor">no</a> <a id="3445" href="1Lab.HLevel.Sets.html#3445" class="Bound">¬p</a> <a id="3448" class="Symbol">=</a> <a id="3450" href="1Lab.Type.html#1352" data-type="⊥ → A" class="Function">absurd</a> <a id="3457" class="Symbol">(</a><a id="3458" class="Bound">¬¬p</a> <a id="3462" href="1Lab.HLevel.Sets.html#3445" class="Bound">¬p</a><a id="3464" class="Symbol">)</a>
</pre>
<section class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>Named after a Twitter mutual of mine
:)<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
  </article>
</div>
</main>
</body>
<style>.equations { display: none !important; }</style></html>
