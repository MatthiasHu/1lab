<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="keywords" content="Agda,categories,topos" />

  <title>Cat.Diagram.Colimit.Base - 1Lab</title>

  <link rel="stylesheet" href="/css/default.css" />
  <link rel="stylesheet" href="/css/katex.min.css" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Cat.Diagram.Colimit.Base - 1Lab" />
  <meta name="twitter:image" content="https://1lab.dev/static/cube-128x.png" />

  <meta name="og:title" content="Cat.Diagram.Colimit.Base - 1Lab" />
  <meta name="og:image" content="https://1lab.dev/static/cube-128x.png" />
  <meta name="og:site-name" content="1Lab" />
  <meta name="og:type" content="website" />

    <meta name="og:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="twitter:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  
  <script defer src="/main.js"></script>

  <noscript>
    <style>
      body span.reasoning-step .as-written {
        display: inline;
      }

      body span.reasoning-step .alternate {
        display: none;
      }
    </style>
  </noscript>

  <!-- Google font embeds -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;0,800;1,400;1,500;1,600;1,700;1,800&amp;family=Inria+Sans:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&amp;display=swap" rel="stylesheet">
</head>

<body class="text-page">
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <!-- Table of contents (only if the page has a table of contents) -->
    <aside id="toc">
    <div id="toc-container" style="min-width: 10em; font-size: 15pt;">
      <!-- Title for the page -->
      <h3 class="Agda" style="margin-top: 0; margin-bottom: 0; white-space: pre;">
                <a class="Module">Cat.Diagram.Colimit.Base</a>
              </h3>

      <!-- Cube logo -->
      <a id="logo" href="/">
        <img alt="1Lab" src="/static/cube-72x.png" style="display: block; margin-bottom: 1em; margin: auto;" width="32px" height="32px" />
      </a>

      <!-- Actual table of contents (separated from the rest by
      horizontal rules) -->
      <hr />
      <ul>
      <li><a href="#idea"><a href="#idea" class="header-link">Idea<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#construction"><a href="#construction" class="header-link">Construction<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#cocone-maps"><a href="#cocone-maps" class="header-link">Cocone
      Maps<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#colimits"><a href="#colimits" class="header-link">Colimits<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      <li><a href="#preservation-of-colimits"><a href="#preservation-of-colimits" class="header-link">Preservation
      of Colimits<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#cocompleteness"><a href="#cocompleteness" class="header-link">Cocompleteness<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      </ul>
      <hr />

      <!-- Sidebar controls -->
      <div style="display: flex; gap: 0.25em; flex-flow: row wrap;">
        <!-- Sidebar equations control -->
        <span class="equations" style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-eqns" type="checkbox" class="equations" id="sidebar-eqns">
          <label for="sidebar-eqns">Equations</label>
        </span>

        <!-- Sidebar fonts control -->
        <span style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-font" type="checkbox" id="toggle-fonts">
          <label for="toggle-fonts">Serif Font</label>
        </span>

        <!-- Sidebar footnotes control -->
        <span class="inline-footnotes" style="display: none; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-fns" type="checkbox" class="inline-footnotes" id="sidebar-fns">
          <label for="sidebar-fns">Inline Footnotes</label>
        </span>
      </div>

      <hr />

      <!-- Navbar navigation (lol) -->
      <div id="return" style="white-space: nowrap;">
        <div class="search-form search-form-proxy" role="form">
          <input id="search-box-proxy" type_="text" placeholder="Search..." autocomplete="off" tabindex="0"></input>
        </div>

              <a href="/">back to index</a> <br />
              <a href="all-pages.html">view all pages</a> <br />
        <a href="https://github.com/plt-amy/cubical-1lab/blob/0af92a12556d0d0102bdeabe42d05bd5d1ccb605/src/Cat/Diagram/Colimit/Base.lagda.md">link to source</a> <br />
                <hr /> <div class="author-list">Written by Amélia Liao and Reed Mullanix</div> <br />
              </div>
    </div>
  </aside>
  
  <article>
    <!-- Article navigation (narrow screens only) -->
    <div class="narrow-only" id="article-nav">
      <!-- Index return anchor (only if the page is not the index) -->
            <div id="return">
        <a href="/">back to index</a>
      </div>
      
      <!-- Navbar equations control -->
      <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-eqns" type="checkbox" class="equations" id="navbar-eqns">
        <label for="navbar-eqns">Equations</label>
      </span>

      <!-- Navbar footnotes control -->
      <span class="inline-footnotes" style="display: none; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-fns" type="checkbox" class="inline-footnotes" id="navbar-fns">
        <label for="navbar-fns">Inline Footnotes</label>
      </span>
    </div>

<pre class="Agda"><a id="9" class="Keyword">open</a> <a id="14" class="Keyword">import</a> <a id="21" href="Cat.Diagram.Initial.html" class="Module">Cat.Diagram.Initial</a>
<a id="41" class="Keyword">open</a> <a id="46" class="Keyword">import</a> <a id="53" href="Cat.Prelude.html" class="Module">Cat.Prelude</a>

<a id="66" class="Keyword">import</a> <a id="73" href="Cat.Functor.Reasoning.html" class="Module">Cat.Functor.Reasoning</a> <a id="95" class="Symbol">as</a> <a id="98" class="Module">Func</a>
<a id="103" class="Keyword">import</a> <a id="110" href="Cat.Morphism.html" class="Module">Cat.Morphism</a>

<a id="124" class="Keyword">module</a> <a id="131" href="Cat.Diagram.Colimit.Base.html" class="Module">Cat.Diagram.Colimit.Base</a> <a id="156" class="Keyword">where</a>
</pre>
<!--
<pre class="Agda"><a id="180" class="Keyword">private</a> <a id="188" class="Keyword">variable</a>
  <a id="199" href="Cat.Diagram.Colimit.Base.html#199" class="Generalizable">o</a> <a id="201" href="Cat.Diagram.Colimit.Base.html#201" class="Generalizable">ℓ</a> <a id="203" href="Cat.Diagram.Colimit.Base.html#203" class="Generalizable">o′</a> <a id="206" href="Cat.Diagram.Colimit.Base.html#206" class="Generalizable">ℓ′</a> <a id="209" class="Symbol">:</a> <a id="211" href="Agda.Primitive.html#582" data-type="Type" class="Postulate">Level</a>
</pre>-->
<h1 id="idea"><a href="#idea" class="header-link">Idea<span class="header-link-emoji">🔗</span></a></h1>
<p>Colimits are dual to limits <a href="Cat.Diagram.Limit.Base.html">limit</a>; much like their cousins,
they generalize constructions in several settings to arbitrary
categories. A colimit (if it exists), is the “best solution” to an
“identification problem”. This is in contrast to the limit, which acts
as a solution to an “equational problem”.</p>
<h1 id="construction"><a href="#construction" class="header-link">Construction<span class="header-link-emoji">🔗</span></a></h1>
<p>Every concrete colimit (<a href="Cat.Diagra.Coproduct">coproducts</a>, <a href="Cat.Diagra.Coequaliser">coequalisers</a>, <a href="Cat.Diagra.Initial">initial objects</a>) we have seen so far
consists of roughly the same data. We begin with some collection of
objects and morphisms, and then state that the colimit of that
collection is some object with a universal property relating all of
those objects and morphisms.</p>
<p>It would be convienent to be able to talk about <em>all</em> of these
situations at once, as opposed to on a case-by-case basis. To do this,
we need to introduce a bit of categorical machinery: the Cocone.</p>
<p>The first step is to generalize the “collection of objects and
morphisms” involved. Luckily, this step involves no new ideas, just a
change in perspective. We already have a way of describing a collection
of objects and morphisms: it’s a category! As an example, the starting
data of a coproduct is a pair of objects, which can be thought of as a
very simple category, with only identity morphisms.</p>
<div class="diagram-container">
<img src="light-456f1760f1961d4382237acb757e2adbcf467813.svg" title="commutative diagram" class="diagram diagram-light quiver short-2" />
<img src="dark-456f1760f1961d4382237acb757e2adbcf467813.svg" title="commutative diagram" class="diagram diagram-dark quiver short-2" />
</div>
<p>The next step also involves nothing more than a change in
perspective. Let’s denote our “diagram” category from earlier as
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>J</mi></mrow><annotation encoding="application/x-tex">J</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span></span></span></span>.</span>
Then, a means of picking out a
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>J</mi></mrow><annotation encoding="application/x-tex">J</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span></span></span></span>
shaped figure in
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>
is… a functor
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>:</mo><mi>J</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">F : J \to C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>!</span>
Going back to the coproduct example, a functor from our 2 object
category into
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>
selects 2 (not necessarily distinct!) objects in
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>.</span>
We this pair of category and functor a <em>diagram</em> in
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>.</span></p>
<pre class="Agda"><a id="2112" class="Keyword">module</a> <a id="2119" href="Cat.Diagram.Colimit.Base.html#2119" class="Module">_</a> <a id="2121" class="Symbol">{</a><a id="2122" href="Cat.Diagram.Colimit.Base.html#2122" class="Bound">J</a> <a id="2124" class="Symbol">:</a> <a id="2126" href="Cat.Base.html#704" data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" class="Record">Precategory</a> <a id="2138" href="Cat.Diagram.Colimit.Base.html#199" class="Generalizable">o</a> <a id="2140" href="Cat.Diagram.Colimit.Base.html#201" class="Generalizable">ℓ</a><a id="2141" class="Symbol">}</a> <a id="2143" class="Symbol">{</a><a id="2144" href="Cat.Diagram.Colimit.Base.html#2144" class="Bound">C</a> <a id="2146" class="Symbol">:</a> <a id="2148" href="Cat.Base.html#704" data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" class="Record">Precategory</a> <a id="2160" href="Cat.Diagram.Colimit.Base.html#203" class="Generalizable">o′</a> <a id="2163" href="Cat.Diagram.Colimit.Base.html#206" class="Generalizable">ℓ′</a><a id="2165" class="Symbol">}</a> <a id="2167" class="Symbol">(</a><a id="2168" href="Cat.Diagram.Colimit.Base.html#2168" class="Bound">F</a> <a id="2170" class="Symbol">:</a> <a id="2172" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="2180" href="Cat.Diagram.Colimit.Base.html#2122" class="Bound">J</a> <a id="2182" href="Cat.Diagram.Colimit.Base.html#2144" class="Bound">C</a><a id="2183" class="Symbol">)</a> <a id="2185" class="Keyword">where</a>
  <a id="2193" class="Keyword">private</a>
    <a id="2205" class="Keyword">import</a> <a id="2212" href="Cat.Reasoning.html" class="Module">Cat.Reasoning</a> <a id="2226" href="Cat.Diagram.Colimit.Base.html#2122" class="Bound">J</a> as <a id="2231" href="Cat.Diagram.Colimit.Base.html#2231" class="Module">J</a>
    <a id="2237" class="Keyword">import</a> <a id="2244" href="Cat.Reasoning.html" class="Module">Cat.Reasoning</a> <a id="2258" href="Cat.Diagram.Colimit.Base.html#2144" class="Bound">C</a> as <a id="2263" href="Cat.Diagram.Colimit.Base.html#2263" class="Module">C</a>
    <a id="2269" class="Keyword">module</a> <a id="2276" href="Cat.Diagram.Colimit.Base.html#2276" class="Module">F</a> <a id="2278" class="Symbol">=</a> <a id="2280" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Module">Functor</a> <a id="2288" href="Cat.Diagram.Colimit.Base.html#2168" class="Bound">F</a>

  <a id="2293" class="Keyword">record</a> <a id="2300" href="Cat.Diagram.Colimit.Base.html#2300" data-type="(F : Functor J₁ C) → Type (o ⊔ ℓ ⊔ o′ ⊔ ℓ′)" class="Record">Cocone</a> <a id="2307" class="Symbol">:</a> <a id="2309" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="2314" class="Symbol">(</a><a id="2315" href="Cat.Diagram.Colimit.Base.html#2138" class="Bound">o</a> <a id="2317" href="Agda.Primitive.html#795" data-type="Level → Level → Level" class="Primitive Operator">⊔</a> <a id="2319" href="Cat.Diagram.Colimit.Base.html#2140" class="Bound">ℓ</a> <a id="2321" href="Agda.Primitive.html#795" data-type="Level → Level → Level" class="Primitive Operator">⊔</a> <a id="2323" href="Cat.Diagram.Colimit.Base.html#2160" class="Bound">o′</a> <a id="2326" href="Agda.Primitive.html#795" data-type="Level → Level → Level" class="Primitive Operator">⊔</a> <a id="2328" href="Cat.Diagram.Colimit.Base.html#2163" class="Bound">ℓ′</a><a id="2330" class="Symbol">)</a> <a id="2332" class="Keyword">where</a>
    <a id="2342" class="Keyword">no-eta-equality</a>
    <a id="2362" class="Keyword">constructor</a> <a id="2374" href="Cat.Diagram.Colimit.Base.html#2374" data-type="(coapex : C .Ob) (ψ : (x : J₁ .Ob) → C .Hom (₀ F x) coapex)
(commutes : (f : J₁ .Hom x y) → C ._∘_ (ψ y) (₁ F f) ≡ ψ x) →
Cocone F" class="InductiveConstructor">cocone</a>
</pre>
<p>Now, for the actual machinery! If we want to capture the essence of
all of our concrete examples of colimits, we a notion of an object
equipped with maps <em>from</em> every object in our diagram. We call
this designated object the “coapex” of the cocone.</p>
<pre class="Agda">    <a id="2649" class="Keyword">field</a>
      <a id="2661" href="Cat.Diagram.Colimit.Base.html#2661" data-type="Cocone F → C .Ob" class="Field">coapex</a> <a id="2668" class="Symbol">:</a> <a id="2670" href="Cat.Base.html#1419" data-type="Precategory o h → Type o" class="Function">C.Ob</a>
      <a id="2681" href="Cat.Diagram.Colimit.Base.html#2681" data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" class="Field">ψ</a>      <a id="2688" class="Symbol">:</a> <a id="2690" class="Symbol">(</a><a id="2691" href="Cat.Diagram.Colimit.Base.html#2691" class="Bound">x</a> <a id="2693" class="Symbol">:</a> <a id="2695" href="Cat.Base.html#1419" data-type="Precategory o h → Type o" class="Function">J.Ob</a><a id="2699" class="Symbol">)</a> <a id="2701" class="Symbol">→</a> <a id="2703" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">C.Hom</a> <a id="2709" class="Symbol">(</a><a id="2710" href="Cat.Base.html#8727" data-type="(r : Functor C D) → C .Ob → D .Ob" class="Function">F.₀</a> <a id="2714" href="Cat.Diagram.Colimit.Base.html#2691" class="Bound">x</a><a id="2715" class="Symbol">)</a> <a id="2717" href="Cat.Diagram.Colimit.Base.html#2661" data-type="Cocone F → C .Ob" class="Field">coapex</a>
</pre>
<p>If our diagram consisted of only objects, we would be done! However,
some diagrams contan non-identity morphisms, so we need to take those
into account as well. This bit is best understood through the lens of
the coequaliser: in order to describe the commuting condition there, we
want every injection map from the codomain of a morphism to factor
through that morphism.</p>
<pre class="Agda">      <a id="3115" href="Cat.Diagram.Colimit.Base.html#3115" data-type="(r : Cocone F) (f : J₁ .Hom x y) → C ._∘_ (r .ψ y) (₁ F f) ≡ r .ψ x" class="Field">commutes</a> <a id="3124" class="Symbol">:</a> <a id="3126" class="Symbol">∀</a> <a id="3128" class="Symbol">{</a><a id="3129" href="Cat.Diagram.Colimit.Base.html#3129" class="Bound">x</a> <a id="3131" href="Cat.Diagram.Colimit.Base.html#3131" class="Bound">y</a><a id="3132" class="Symbol">}</a> <a id="3134" class="Symbol">(</a><a id="3135" href="Cat.Diagram.Colimit.Base.html#3135" class="Bound">f</a> <a id="3137" class="Symbol">:</a> <a id="3139" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">J.Hom</a> <a id="3145" href="Cat.Diagram.Colimit.Base.html#3129" class="Bound">x</a> <a id="3147" href="Cat.Diagram.Colimit.Base.html#3131" class="Bound">y</a><a id="3148" class="Symbol">)</a> <a id="3150" class="Symbol">→</a> <a id="3152" href="Cat.Diagram.Colimit.Base.html#2681" data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" class="Field">ψ</a> <a id="3154" href="Cat.Diagram.Colimit.Base.html#3131" class="Bound">y</a> <a id="3156" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="3160" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">F.₁</a> <a id="3164" href="Cat.Diagram.Colimit.Base.html#3135" class="Bound">f</a> <a id="3166" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="3168" href="Cat.Diagram.Colimit.Base.html#2681" data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" class="Field">ψ</a> <a id="3170" href="Cat.Diagram.Colimit.Base.html#3129" class="Bound">x</a>
</pre>
<p>As per usual, we define a helper lemma charaterizing the path space
of cones:</p>
<pre class="Agda">  <a id="3266" class="Keyword">open</a> <a id="3271" href="Cat.Diagram.Colimit.Base.html#2300" data-type="(F : Functor J₁ C) → Type (o ⊔ ℓ ⊔ o′ ⊔ ℓ′)" class="Module">Cocone</a>

  <a id="3281" href="Cat.Diagram.Colimit.Base.html#3281" data-type="(F : Functor J₁ C) (p : coapex x ≡ coapex y) →
((o : J₁ .Ob) →
 PathP (λ i → C .Hom (₀ F o) (p i)) (ψ x o) (ψ y o)) →
x ≡ y" class="Function">Cocone-path</a> <a id="3293" class="Symbol">:</a> <a id="3295" class="Symbol">{</a><a id="3296" href="Cat.Diagram.Colimit.Base.html#3296" class="Bound">x</a> <a id="3298" href="Cat.Diagram.Colimit.Base.html#3298" class="Bound">y</a> <a id="3300" class="Symbol">:</a> <a id="3302" href="Cat.Diagram.Colimit.Base.html#2300" data-type="(F : Functor J₁ C) → Type (o ⊔ ℓ ⊔ o′ ⊔ ℓ′)" class="Record">Cocone</a><a id="3308" class="Symbol">}</a>
              <a id="3324" class="Symbol">→</a> <a id="3326" class="Symbol">(</a><a id="3327" href="Cat.Diagram.Colimit.Base.html#3327" class="Bound">p</a> <a id="3329" class="Symbol">:</a> <a id="3331" href="Cat.Diagram.Colimit.Base.html#2661" data-type="Cocone F → C .Ob" class="Field">coapex</a> <a id="3338" href="Cat.Diagram.Colimit.Base.html#3296" class="Bound">x</a> <a id="3340" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="3342" href="Cat.Diagram.Colimit.Base.html#2661" data-type="Cocone F → C .Ob" class="Field">coapex</a> <a id="3349" href="Cat.Diagram.Colimit.Base.html#3298" class="Bound">y</a><a id="3350" class="Symbol">)</a>
              <a id="3366" class="Symbol">→</a> <a id="3368" class="Symbol">(∀</a> <a id="3371" href="Cat.Diagram.Colimit.Base.html#3371" class="Bound">o</a> <a id="3373" class="Symbol">→</a> <a id="3375" href="Agda.Primitive.Cubical.html#2013" class="Postulate">PathP</a> <a id="3381" class="Symbol">(λ</a> <a id="3384" href="Cat.Diagram.Colimit.Base.html#3384" class="Bound">i</a> <a id="3386" class="Symbol">→</a> <a id="3388" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">C.Hom</a> <a id="3394" class="Symbol">(</a><a id="3395" href="Cat.Base.html#8727" data-type="(r : Functor C D) → C .Ob → D .Ob" class="Function">F.₀</a> <a id="3399" href="Cat.Diagram.Colimit.Base.html#3371" class="Bound">o</a><a id="3400" class="Symbol">)</a> <a id="3402" class="Symbol">(</a><a id="3403" href="Cat.Diagram.Colimit.Base.html#3327" class="Bound">p</a> <a id="3405" href="Cat.Diagram.Colimit.Base.html#3384" class="Bound">i</a><a id="3406" class="Symbol">))</a> <a id="3409" class="Symbol">(</a><a id="3410" href="Cat.Diagram.Colimit.Base.html#2681" data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" class="Field">ψ</a> <a id="3412" href="Cat.Diagram.Colimit.Base.html#3296" class="Bound">x</a> <a id="3414" href="Cat.Diagram.Colimit.Base.html#3371" class="Bound">o</a><a id="3415" class="Symbol">)</a> <a id="3417" class="Symbol">(</a><a id="3418" href="Cat.Diagram.Colimit.Base.html#2681" data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" class="Field">ψ</a> <a id="3420" href="Cat.Diagram.Colimit.Base.html#3298" class="Bound">y</a> <a id="3422" href="Cat.Diagram.Colimit.Base.html#3371" class="Bound">o</a><a id="3423" class="Symbol">))</a>
              <a id="3440" class="Symbol">→</a> <a id="3442" href="Cat.Diagram.Colimit.Base.html#3296" class="Bound">x</a> <a id="3444" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="3446" href="Cat.Diagram.Colimit.Base.html#3298" class="Bound">y</a>
  <a id="3450" href="Cat.Diagram.Colimit.Base.html#3281" data-type="(F : Functor J₁ C) (p : coapex x ≡ coapex y) →
((o : J₁ .Ob) →
 PathP (λ i → C .Hom (₀ F o) (p i)) (ψ x o) (ψ y o)) →
x ≡ y" class="Function">Cocone-path</a> <a id="3462" href="Cat.Diagram.Colimit.Base.html#3462" class="Bound">p</a> <a id="3464" href="Cat.Diagram.Colimit.Base.html#3464" class="Bound">q</a> <a id="3466" href="Cat.Diagram.Colimit.Base.html#3466" class="Bound">i</a> <a id="3468" class="Symbol">.</a><a id="3469" href="Cat.Diagram.Colimit.Base.html#2661" data-type="Cocone F → C .Ob" class="Field">coapex</a> <a id="3476" class="Symbol">=</a> <a id="3478" href="Cat.Diagram.Colimit.Base.html#3462" class="Bound">p</a> <a id="3480" href="Cat.Diagram.Colimit.Base.html#3466" class="Bound">i</a>
  <a id="3484" href="Cat.Diagram.Colimit.Base.html#3281" data-type="(F : Functor J₁ C) (p : coapex x ≡ coapex y) →
((o : J₁ .Ob) →
 PathP (λ i → C .Hom (₀ F o) (p i)) (ψ x o) (ψ y o)) →
x ≡ y" class="Function">Cocone-path</a> <a id="3496" href="Cat.Diagram.Colimit.Base.html#3496" class="Bound">p</a> <a id="3498" href="Cat.Diagram.Colimit.Base.html#3498" class="Bound">q</a> <a id="3500" href="Cat.Diagram.Colimit.Base.html#3500" class="Bound">i</a> <a id="3502" class="Symbol">.</a><a id="3503" href="Cat.Diagram.Colimit.Base.html#2681" data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" class="Field">ψ</a> <a id="3505" href="Cat.Diagram.Colimit.Base.html#3505" class="Bound">o</a> <a id="3507" class="Symbol">=</a> <a id="3509" href="Cat.Diagram.Colimit.Base.html#3498" class="Bound">q</a> <a id="3511" href="Cat.Diagram.Colimit.Base.html#3505" class="Bound">o</a> <a id="3513" href="Cat.Diagram.Colimit.Base.html#3500" class="Bound">i</a>
  <a id="3517" href="Cat.Diagram.Colimit.Base.html#3281" data-type="(F : Functor J₁ C) (p : coapex x ≡ coapex y) →
((o : J₁ .Ob) →
 PathP (λ i → C .Hom (₀ F o) (p i)) (ψ x o) (ψ y o)) →
x ≡ y" class="Function">Cocone-path</a> <a id="3529" class="Symbol">{</a><a id="3530" class="Argument">x</a> <a id="3532" class="Symbol">=</a> <a id="3534" href="Cat.Diagram.Colimit.Base.html#3534" class="Bound">x</a><a id="3535" class="Symbol">}</a> <a id="3537" class="Symbol">{</a><a id="3538" class="Argument">y</a> <a id="3540" class="Symbol">=</a> <a id="3542" href="Cat.Diagram.Colimit.Base.html#3542" class="Bound">y</a><a id="3543" class="Symbol">}</a> <a id="3545" href="Cat.Diagram.Colimit.Base.html#3545" class="Bound">p</a> <a id="3547" href="Cat.Diagram.Colimit.Base.html#3547" class="Bound">q</a> <a id="3549" href="Cat.Diagram.Colimit.Base.html#3549" class="Bound">i</a> <a id="3551" class="Symbol">.</a><a id="3552" href="Cat.Diagram.Colimit.Base.html#3115" data-type="(r : Cocone F) (f : J₁ .Hom x y) → C ._∘_ (r .ψ y) (₁ F f) ≡ r .ψ x" class="Field">commutes</a> <a id="3561" class="Symbol">{</a><a id="3562" class="Argument">x</a> <a id="3564" class="Symbol">=</a> <a id="3566" href="Cat.Diagram.Colimit.Base.html#3566" class="Bound">a</a><a id="3567" class="Symbol">}</a> <a id="3569" class="Symbol">{</a><a id="3570" class="Argument">y</a> <a id="3572" class="Symbol">=</a> <a id="3574" href="Cat.Diagram.Colimit.Base.html#3574" class="Bound">b</a><a id="3575" class="Symbol">}</a> <a id="3577" href="Cat.Diagram.Colimit.Base.html#3577" class="Bound">f</a> <a id="3579" class="Symbol">=</a>
    <a id="3585" href="1Lab.HLevel.html#13498" data-type="((i : I) → is-prop (B₁ i)) →
(b0 : B₁ i0) (b1 : B₁ i1) → PathP B₁ b0 b1" class="Function">is-prop→pathp</a> <a id="3599" class="Symbol">(λ</a> <a id="3602" href="Cat.Diagram.Colimit.Base.html#3602" class="Bound">i</a> <a id="3604" class="Symbol">→</a> <a id="3606" href="Cat.Base.html#1784" data-type="(r : Precategory o h) (x y : r .Ob) → is-set (r .Hom x y)" class="Function">C.Hom-set</a> <a id="3616" class="Symbol">_</a> <a id="3618" class="Symbol">_</a> <a id="3620" class="Symbol">(</a><a id="3621" href="Cat.Diagram.Colimit.Base.html#3547" class="Bound">q</a> <a id="3623" href="Cat.Diagram.Colimit.Base.html#3574" class="Bound">b</a> <a id="3625" href="Cat.Diagram.Colimit.Base.html#3602" class="Bound">i</a> <a id="3627" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="3631" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">F.₁</a> <a id="3635" href="Cat.Diagram.Colimit.Base.html#3577" class="Bound">f</a><a id="3636" class="Symbol">)</a> <a id="3638" class="Symbol">(</a><a id="3639" href="Cat.Diagram.Colimit.Base.html#3547" class="Bound">q</a> <a id="3641" href="Cat.Diagram.Colimit.Base.html#3566" class="Bound">a</a> <a id="3643" href="Cat.Diagram.Colimit.Base.html#3602" class="Bound">i</a><a id="3644" class="Symbol">))</a>
      <a id="3653" class="Symbol">(</a><a id="3654" href="Cat.Diagram.Colimit.Base.html#3534" class="Bound">x</a> <a id="3656" class="Symbol">.</a><a id="3657" href="Cat.Diagram.Colimit.Base.html#3115" data-type="(r : Cocone F) (f : J₁ .Hom x y) → C ._∘_ (r .ψ y) (₁ F f) ≡ r .ψ x" class="Field">commutes</a> <a id="3666" href="Cat.Diagram.Colimit.Base.html#3577" class="Bound">f</a><a id="3667" class="Symbol">)</a> <a id="3669" class="Symbol">(</a><a id="3670" href="Cat.Diagram.Colimit.Base.html#3542" class="Bound">y</a> <a id="3672" class="Symbol">.</a><a id="3673" href="Cat.Diagram.Colimit.Base.html#3115" data-type="(r : Cocone F) (f : J₁ .Hom x y) → C ._∘_ (r .ψ y) (₁ F f) ≡ r .ψ x" class="Field">commutes</a> <a id="3682" href="Cat.Diagram.Colimit.Base.html#3577" class="Bound">f</a><a id="3683" class="Symbol">)</a> <a id="3685" href="Cat.Diagram.Colimit.Base.html#3549" class="Bound">i</a>
</pre>
<h2 id="cocone-maps"><a href="#cocone-maps" class="header-link">Cocone
Maps<span class="header-link-emoji">🔗</span></a></h2>
<p>Now that we’ve defined cocones, we need a way to figure out how to
express universal properties. Like most things categorical, we begin by
considering a “cocone morphism”, which will give us a category that we
can work within. The idea here is that a morphism of cocones is a
morphism in
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>
between the coapicies, such that all of the injection maps commute.</p>
<pre class="Agda">  <a id="4079" class="Keyword">record</a> <a id="4086" href="Cat.Diagram.Colimit.Base.html#4086" data-type="(F : Functor J₁ C) (x y : Cocone F) → Type (o ⊔ ℓ′)" class="Record">Cocone-hom</a> <a id="4097" class="Symbol">(</a><a id="4098" href="Cat.Diagram.Colimit.Base.html#4098" class="Bound">x</a> <a id="4100" href="Cat.Diagram.Colimit.Base.html#4100" class="Bound">y</a> <a id="4102" class="Symbol">:</a> <a id="4104" href="Cat.Diagram.Colimit.Base.html#2300" data-type="(F : Functor J₁ C) → Type (o ⊔ ℓ ⊔ o′ ⊔ ℓ′)" class="Record">Cocone</a><a id="4110" class="Symbol">)</a> <a id="4112" class="Symbol">:</a> <a id="4114" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="4119" class="Symbol">(</a><a id="4120" href="Cat.Diagram.Colimit.Base.html#2138" class="Bound">o</a> <a id="4122" href="Agda.Primitive.html#795" data-type="Level → Level → Level" class="Primitive Operator">⊔</a> <a id="4124" href="Cat.Diagram.Colimit.Base.html#2163" class="Bound">ℓ′</a><a id="4126" class="Symbol">)</a> <a id="4128" class="Keyword">where</a>
    <a id="4138" class="Keyword">no-eta-equality</a>
    <a id="4158" class="Keyword">constructor</a> <a id="4170" href="Cat.Diagram.Colimit.Base.html#4170" data-type="(hom : C .Hom (x .coapex) (y .coapex))
(commutes : (o : J₁ .Ob) → C ._∘_ hom (x .ψ o) ≡ y .ψ o) →
Cocone-hom F x y" class="InductiveConstructor">cocone-hom</a>
    <a id="4185" class="Keyword">field</a>
      <a id="4197" href="Cat.Diagram.Colimit.Base.html#4197" data-type="Cocone-hom F x y → C .Hom (x .coapex) (y .coapex)" class="Field">hom</a> <a id="4201" class="Symbol">:</a> <a id="4203" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">C.Hom</a> <a id="4209" class="Symbol">(</a><a id="4210" href="Cat.Diagram.Colimit.Base.html#4098" class="Bound">x</a> <a id="4212" class="Symbol">.</a><a id="4213" href="Cat.Diagram.Colimit.Base.html#2661" data-type="Cocone F → C .Ob" class="Field">coapex</a><a id="4219" class="Symbol">)</a> <a id="4221" class="Symbol">(</a><a id="4222" href="Cat.Diagram.Colimit.Base.html#4100" class="Bound">y</a> <a id="4224" class="Symbol">.</a><a id="4225" href="Cat.Diagram.Colimit.Base.html#2661" data-type="Cocone F → C .Ob" class="Field">coapex</a><a id="4231" class="Symbol">)</a>
      <a id="4239" href="Cat.Diagram.Colimit.Base.html#4239" data-type="(r : Cocone-hom F x y) (o : J₁ .Ob) →
C ._∘_ (r .hom) (x .ψ o) ≡ y .ψ o" class="Field">commutes</a> <a id="4248" class="Symbol">:</a> <a id="4250" class="Symbol">∀</a> <a id="4252" href="Cat.Diagram.Colimit.Base.html#4252" class="Bound">o</a> <a id="4254" class="Symbol">→</a> <a id="4256" href="Cat.Diagram.Colimit.Base.html#4197" data-type="Cocone-hom F x y → C .Hom (x .coapex) (y .coapex)" class="Field">hom</a> <a id="4260" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="4264" href="Cat.Diagram.Colimit.Base.html#4098" class="Bound">x</a> <a id="4266" class="Symbol">.</a><a id="4267" href="Cat.Diagram.Colimit.Base.html#2681" data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" class="Field">ψ</a> <a id="4269" href="Cat.Diagram.Colimit.Base.html#4252" class="Bound">o</a> <a id="4271" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="4273" href="Cat.Diagram.Colimit.Base.html#4100" class="Bound">y</a> <a id="4275" class="Symbol">.</a><a id="4276" href="Cat.Diagram.Colimit.Base.html#2681" data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" class="Field">ψ</a> <a id="4278" href="Cat.Diagram.Colimit.Base.html#4252" class="Bound">o</a>
</pre>
<!--
<pre class="Agda">  <a id="4300" class="Keyword">private</a> <a id="4308" class="Keyword">unquoteDecl</a> <a id="4320" href="Cat.Diagram.Colimit.Base.html#4320" data-type="(F : Functor J₁ C) →
Iso (Cocone-hom F x y)
(∑ (C .Hom (coapex x) (coapex y))
 (λ hom → (o₁ : J₁ .Ob) → C ._∘_ hom (ψ x o₁) ≡ ψ y o₁))" class="Function">eqv</a> <a id="4324" class="Symbol">=</a> <a id="4326" href="1Lab.Reflection.Record.html#5139" data-type="Name → Name → TC ⊤" class="Function">declare-record-iso</a> <a id="4345" href="Cat.Diagram.Colimit.Base.html#4320" data-type="(F : Functor J₁ C) →
Iso (Cocone-hom F x y)
(∑ (C .Hom (coapex x) (coapex y))
 (λ hom → (o₁ : J₁ .Ob) → C ._∘_ hom (ψ x o₁) ≡ ψ y o₁))" class="Function">eqv</a> <a id="4349" class="Symbol">(</a><a id="4350" class="Keyword">quote</a> <a id="4356" href="Cat.Diagram.Colimit.Base.html#4086" data-type="(F : Functor J₁ C) (x y : Cocone F) → Type (o ⊔ ℓ′)" class="Record">Cocone-hom</a><a id="4366" class="Symbol">)</a>
</pre>-->
<p>We define yet another helper lemma that describes the path space of
cocone morphisms.</p>
<pre class="Agda">  <a id="4474" class="Keyword">open</a> <a id="4479" href="Cat.Diagram.Colimit.Base.html#4086" data-type="(F : Functor J₁ C) (x y : Cocone F) → Type (o ⊔ ℓ′)" class="Module">Cocone-hom</a>

  <a id="4493" href="Cat.Diagram.Colimit.Base.html#4493" data-type="(F : Functor J₁ C) → f .hom ≡ g .hom → f ≡ g" class="Function">Cocone-hom-path</a> <a id="4509" class="Symbol">:</a> <a id="4511" class="Symbol">∀</a> <a id="4513" class="Symbol">{</a><a id="4514" href="Cat.Diagram.Colimit.Base.html#4514" class="Bound">x</a> <a id="4516" href="Cat.Diagram.Colimit.Base.html#4516" class="Bound">y</a><a id="4517" class="Symbol">}</a> <a id="4519" class="Symbol">{</a><a id="4520" href="Cat.Diagram.Colimit.Base.html#4520" class="Bound">f</a> <a id="4522" href="Cat.Diagram.Colimit.Base.html#4522" class="Bound">g</a> <a id="4524" class="Symbol">:</a> <a id="4526" href="Cat.Diagram.Colimit.Base.html#4086" data-type="(F : Functor J₁ C) (x y : Cocone F) → Type (o ⊔ ℓ′)" class="Record">Cocone-hom</a> <a id="4537" href="Cat.Diagram.Colimit.Base.html#4514" class="Bound">x</a> <a id="4539" href="Cat.Diagram.Colimit.Base.html#4516" class="Bound">y</a><a id="4540" class="Symbol">}</a> <a id="4542" class="Symbol">→</a> <a id="4544" href="Cat.Diagram.Colimit.Base.html#4520" class="Bound">f</a> <a id="4546" class="Symbol">.</a><a id="4547" href="Cat.Diagram.Colimit.Base.html#4197" data-type="Cocone-hom F x y → C .Hom (x .coapex) (y .coapex)" class="Field">hom</a> <a id="4551" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="4553" href="Cat.Diagram.Colimit.Base.html#4522" class="Bound">g</a> <a id="4555" class="Symbol">.</a><a id="4556" href="Cat.Diagram.Colimit.Base.html#4197" data-type="Cocone-hom F x y → C .Hom (x .coapex) (y .coapex)" class="Field">hom</a> <a id="4560" class="Symbol">→</a> <a id="4562" href="Cat.Diagram.Colimit.Base.html#4520" class="Bound">f</a> <a id="4564" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="4566" href="Cat.Diagram.Colimit.Base.html#4522" class="Bound">g</a>
  <a id="4570" href="Cat.Diagram.Colimit.Base.html#4493" data-type="(F : Functor J₁ C) → f .hom ≡ g .hom → f ≡ g" class="Function">Cocone-hom-path</a> <a id="4586" href="Cat.Diagram.Colimit.Base.html#4586" class="Bound">p</a> <a id="4588" href="Cat.Diagram.Colimit.Base.html#4588" class="Bound">i</a> <a id="4590" class="Symbol">.</a><a id="4591" href="Cat.Diagram.Colimit.Base.html#4197" data-type="Cocone-hom F x y → C .Hom (x .coapex) (y .coapex)" class="Field">hom</a> <a id="4595" class="Symbol">=</a> <a id="4597" href="Cat.Diagram.Colimit.Base.html#4586" class="Bound">p</a> <a id="4599" href="Cat.Diagram.Colimit.Base.html#4588" class="Bound">i</a>
  <a id="4603" href="Cat.Diagram.Colimit.Base.html#4493" data-type="(F : Functor J₁ C) → f .hom ≡ g .hom → f ≡ g" class="Function">Cocone-hom-path</a> <a id="4619" class="Symbol">{</a><a id="4620" class="Argument">x</a> <a id="4622" class="Symbol">=</a> <a id="4624" href="Cat.Diagram.Colimit.Base.html#4624" class="Bound">x</a><a id="4625" class="Symbol">}</a> <a id="4627" class="Symbol">{</a><a id="4628" class="Argument">y</a> <a id="4630" class="Symbol">=</a> <a id="4632" href="Cat.Diagram.Colimit.Base.html#4632" class="Bound">y</a><a id="4633" class="Symbol">}</a> <a id="4635" class="Symbol">{</a><a id="4636" class="Argument">f</a> <a id="4638" class="Symbol">=</a> <a id="4640" href="Cat.Diagram.Colimit.Base.html#4640" class="Bound">f</a><a id="4641" class="Symbol">}</a> <a id="4643" class="Symbol">{</a><a id="4644" class="Argument">g</a> <a id="4646" class="Symbol">=</a> <a id="4648" href="Cat.Diagram.Colimit.Base.html#4648" class="Bound">g</a><a id="4649" class="Symbol">}</a> <a id="4651" href="Cat.Diagram.Colimit.Base.html#4651" class="Bound">p</a> <a id="4653" href="Cat.Diagram.Colimit.Base.html#4653" class="Bound">i</a> <a id="4655" class="Symbol">.</a><a id="4656" href="Cat.Diagram.Colimit.Base.html#4239" data-type="(r : Cocone-hom F x y) (o : J₁ .Ob) →
C ._∘_ (r .hom) (x .ψ o) ≡ y .ψ o" class="Field">commutes</a> <a id="4665" href="Cat.Diagram.Colimit.Base.html#4665" class="Bound">o</a> <a id="4667" href="Cat.Diagram.Colimit.Base.html#4667" class="Bound">j</a> <a id="4669" class="Symbol">=</a>
    <a id="4675" href="1Lab.HLevel.html#15401" data-type="((i j : I) → is-set (A i j)) →
(p : PathP (λ j → A j i0) a c) (q : PathP (A i0) a b)
(s : PathP (A i1) c d) (r : PathP (λ j → A j i1) b d) →
SquareP A p q s r" class="Function">is-set→squarep</a> <a id="4690" class="Symbol">(λ</a> <a id="4693" href="Cat.Diagram.Colimit.Base.html#4693" class="Bound">i</a> <a id="4695" href="Cat.Diagram.Colimit.Base.html#4695" class="Bound">j</a> <a id="4697" class="Symbol">→</a> <a id="4699" href="Cat.Base.html#1784" data-type="(r : Precategory o h) (x y : r .Ob) → is-set (r .Hom x y)" class="Function">C.Hom-set</a> <a id="4709" class="Symbol">_</a> <a id="4711" class="Symbol">_)</a>
      <a id="4720" class="Symbol">(λ</a> <a id="4723" href="Cat.Diagram.Colimit.Base.html#4723" class="Bound">j</a> <a id="4725" class="Symbol">→</a> <a id="4727" href="Cat.Diagram.Colimit.Base.html#4651" class="Bound">p</a> <a id="4729" href="Cat.Diagram.Colimit.Base.html#4723" class="Bound">j</a> <a id="4731" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="4735" href="Cat.Diagram.Colimit.Base.html#4624" class="Bound">x</a> <a id="4737" class="Symbol">.</a><a id="4738" href="Cat.Diagram.Colimit.Base.html#2681" data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" class="Field">ψ</a> <a id="4740" href="Cat.Diagram.Colimit.Base.html#4665" class="Bound">o</a><a id="4741" class="Symbol">)</a> <a id="4743" class="Symbol">(</a><a id="4744" href="Cat.Diagram.Colimit.Base.html#4640" class="Bound">f</a> <a id="4746" class="Symbol">.</a><a id="4747" href="Cat.Diagram.Colimit.Base.html#4239" data-type="(r : Cocone-hom F x y) (o : J₁ .Ob) →
C ._∘_ (r .hom) (x .ψ o) ≡ y .ψ o" class="Field">commutes</a> <a id="4756" href="Cat.Diagram.Colimit.Base.html#4665" class="Bound">o</a><a id="4757" class="Symbol">)</a> <a id="4759" class="Symbol">(</a><a id="4760" href="Cat.Diagram.Colimit.Base.html#4648" class="Bound">g</a> <a id="4762" class="Symbol">.</a><a id="4763" href="Cat.Diagram.Colimit.Base.html#4239" data-type="(r : Cocone-hom F x y) (o : J₁ .Ob) →
C ._∘_ (r .hom) (x .ψ o) ≡ y .ψ o" class="Field">commutes</a> <a id="4772" href="Cat.Diagram.Colimit.Base.html#4665" class="Bound">o</a><a id="4773" class="Symbol">)</a> <a id="4775" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="4780" href="Cat.Diagram.Colimit.Base.html#4653" class="Bound">i</a> <a id="4782" href="Cat.Diagram.Colimit.Base.html#4667" class="Bound">j</a>
</pre>
<p>Now, we can define the category of cocones over a given diagram:</p>
<pre class="Agda">  <a id="4865" href="Cat.Diagram.Colimit.Base.html#4865" data-type="(F : Functor J₁ C) → Precategory (o ⊔ ℓ ⊔ o′ ⊔ ℓ′) (o ⊔ ℓ′)" class="Function">Cocones</a> <a id="4873" class="Symbol">:</a> <a id="4875" href="Cat.Base.html#704" data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" class="Record">Precategory</a> <a id="4887" class="Symbol">_</a> <a id="4889" class="Symbol">_</a>
  <a id="4893" href="Cat.Diagram.Colimit.Base.html#4865" data-type="(F : Functor J₁ C) → Precategory (o ⊔ ℓ ⊔ o′ ⊔ ℓ′) (o ⊔ ℓ′)" class="Function">Cocones</a> <a id="4901" class="Symbol">=</a> <a id="4903" href="Cat.Diagram.Colimit.Base.html#5271" data-type="(F : Functor J₁ C) → Precategory (o ⊔ ℓ ⊔ o′ ⊔ ℓ′) (o ⊔ ℓ′)" class="Function">cat</a> <a id="4907" class="Keyword">where</a>
    <a id="4917" class="Keyword">open</a> <a id="4922" href="Cat.Base.html#704" data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" class="Module">Precategory</a>

    <a id="4939" href="Cat.Diagram.Colimit.Base.html#4939" data-type="(F : Functor J₁ C) →
Cocone-hom F y z → Cocone-hom F x y → Cocone-hom F x z" class="Function">compose</a> <a id="4947" class="Symbol">:</a> <a id="4949" class="Symbol">∀</a> <a id="4951" class="Symbol">{</a><a id="4952" href="Cat.Diagram.Colimit.Base.html#4952" class="Bound">x</a> <a id="4954" href="Cat.Diagram.Colimit.Base.html#4954" class="Bound">y</a> <a id="4956" href="Cat.Diagram.Colimit.Base.html#4956" class="Bound">z</a><a id="4957" class="Symbol">}</a> <a id="4959" class="Symbol">→</a> <a id="4961" href="Cat.Diagram.Colimit.Base.html#4086" data-type="(F : Functor J₁ C) (x y : Cocone F) → Type (o ⊔ ℓ′)" class="Record">Cocone-hom</a> <a id="4972" href="Cat.Diagram.Colimit.Base.html#4954" class="Bound">y</a> <a id="4974" href="Cat.Diagram.Colimit.Base.html#4956" class="Bound">z</a> <a id="4976" class="Symbol">→</a> <a id="4978" href="Cat.Diagram.Colimit.Base.html#4086" data-type="(F : Functor J₁ C) (x y : Cocone F) → Type (o ⊔ ℓ′)" class="Record">Cocone-hom</a> <a id="4989" href="Cat.Diagram.Colimit.Base.html#4952" class="Bound">x</a> <a id="4991" href="Cat.Diagram.Colimit.Base.html#4954" class="Bound">y</a> <a id="4993" class="Symbol">→</a> <a id="4995" href="Cat.Diagram.Colimit.Base.html#4086" data-type="(F : Functor J₁ C) (x y : Cocone F) → Type (o ⊔ ℓ′)" class="Record">Cocone-hom</a> <a id="5006" href="Cat.Diagram.Colimit.Base.html#4952" class="Bound">x</a> <a id="5008" href="Cat.Diagram.Colimit.Base.html#4956" class="Bound">z</a>
    <a id="5014" href="Cat.Diagram.Colimit.Base.html#4939" data-type="(F : Functor J₁ C) →
Cocone-hom F y z → Cocone-hom F x y → Cocone-hom F x z" class="Function">compose</a> <a id="5022" href="Cat.Diagram.Colimit.Base.html#5022" class="Bound">K</a> <a id="5024" href="Cat.Diagram.Colimit.Base.html#5024" class="Bound">L</a> <a id="5026" class="Symbol">.</a><a id="5027" href="Cat.Diagram.Colimit.Base.html#4197" data-type="Cocone-hom F x y → C .Hom (x .coapex) (y .coapex)" class="Field">hom</a> <a id="5031" class="Symbol">=</a> <a id="5033" href="Cat.Diagram.Colimit.Base.html#5022" class="Bound">K</a> <a id="5035" class="Symbol">.</a><a id="5036" href="Cat.Diagram.Colimit.Base.html#4197" data-type="Cocone-hom F x y → C .Hom (x .coapex) (y .coapex)" class="Field">hom</a> <a id="5040" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="5044" href="Cat.Diagram.Colimit.Base.html#5024" class="Bound">L</a> <a id="5046" class="Symbol">.</a><a id="5047" href="Cat.Diagram.Colimit.Base.html#4197" data-type="Cocone-hom F x y → C .Hom (x .coapex) (y .coapex)" class="Field">hom</a>
    <a id="5055" href="Cat.Diagram.Colimit.Base.html#4939" data-type="(F : Functor J₁ C) →
Cocone-hom F y z → Cocone-hom F x y → Cocone-hom F x z" class="Function">compose</a> <a id="5063" class="Symbol">{</a><a id="5064" class="Argument">x</a> <a id="5066" class="Symbol">=</a> <a id="5068" href="Cat.Diagram.Colimit.Base.html#5068" class="Bound">x</a><a id="5069" class="Symbol">}</a> <a id="5071" class="Symbol">{</a><a id="5072" class="Argument">y</a> <a id="5074" class="Symbol">=</a> <a id="5076" href="Cat.Diagram.Colimit.Base.html#5076" class="Bound">y</a><a id="5077" class="Symbol">}</a> <a id="5079" class="Symbol">{</a><a id="5080" class="Argument">z</a> <a id="5082" class="Symbol">=</a> <a id="5084" href="Cat.Diagram.Colimit.Base.html#5084" class="Bound">z</a><a id="5085" class="Symbol">}</a> <a id="5087" href="Cat.Diagram.Colimit.Base.html#5087" class="Bound">K</a> <a id="5089" href="Cat.Diagram.Colimit.Base.html#5089" class="Bound">L</a> <a id="5091" class="Symbol">.</a><a id="5092" href="Cat.Diagram.Colimit.Base.html#4239" data-type="(r : Cocone-hom F x y) (o : J₁ .Ob) →
C ._∘_ (r .hom) (x .ψ o) ≡ y .ψ o" class="Field">commutes</a> <a id="5101" href="Cat.Diagram.Colimit.Base.html#5101" class="Bound">o</a> <a id="5103" class="Symbol">=</a>
      <a id="5111" class="Symbol">(</a><a id="5112" href="Cat.Diagram.Colimit.Base.html#5087" class="Bound">K</a> <a id="5114" class="Symbol">.</a><a id="5115" href="Cat.Diagram.Colimit.Base.html#4197" data-type="Cocone-hom F x y → C .Hom (x .coapex) (y .coapex)" class="Field">hom</a> <a id="5119" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="5123" href="Cat.Diagram.Colimit.Base.html#5089" class="Bound">L</a> <a id="5125" class="Symbol">.</a><a id="5126" href="Cat.Diagram.Colimit.Base.html#4197" data-type="Cocone-hom F x y → C .Hom (x .coapex) (y .coapex)" class="Field">hom</a><a id="5129" class="Symbol">)</a> <a id="5131" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="5135" href="Cat.Diagram.Colimit.Base.html#5068" class="Bound">x</a> <a id="5137" class="Symbol">.</a><a id="5138" href="Cat.Diagram.Colimit.Base.html#2681" data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" class="Field">ψ</a> <a id="5140" href="Cat.Diagram.Colimit.Base.html#5101" class="Bound">o</a> <span class="reasoning-step"><span class="as-written Function"><a id="5142" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="5145" href="Cat.Reasoning.html#1678" data-type="(C : Precategory o ℓ) →
(C ∘ a) b ≡ c → (C ∘ (C ∘ f) a) b ≡ (C ∘ f) c" class="Function">C.pullr</a> <a id="5153" class="Symbol">(</a><a id="5154" href="Cat.Diagram.Colimit.Base.html#5089" class="Bound">L</a> <a id="5156" class="Symbol">.</a><a id="5157" href="Cat.Diagram.Colimit.Base.html#4239" data-type="(r : Cocone-hom F x y) (o : J₁ .Ob) →
C ._∘_ (r .hom) (x .ψ o) ≡ y .ψ o" class="Field">commutes</a> <a id="5166" href="Cat.Diagram.Colimit.Base.html#5101" class="Bound">o</a><a id="5167" class="Symbol">)</a> <a id="5169" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="5177" href="Cat.Diagram.Colimit.Base.html#5087" class="Bound">K</a> <a id="5179" class="Symbol">.</a><a id="5180" href="Cat.Diagram.Colimit.Base.html#4197" data-type="Cocone-hom F x y → C .Hom (x .coapex) (y .coapex)" class="Field">hom</a> <a id="5184" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="5188" href="Cat.Diagram.Colimit.Base.html#5076" class="Bound">y</a> <a id="5190" class="Symbol">.</a><a id="5191" href="Cat.Diagram.Colimit.Base.html#2681" data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" class="Field">ψ</a> <a id="5193" href="Cat.Diagram.Colimit.Base.html#5101" class="Bound">o</a>              <span class="reasoning-step"><span class="as-written Function"><a id="5208" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="5211" href="Cat.Diagram.Colimit.Base.html#5087" class="Bound">K</a> <a id="5213" class="Symbol">.</a><a id="5214" href="Cat.Diagram.Colimit.Base.html#4239" data-type="(r : Cocone-hom F x y) (o : J₁ .Ob) →
C ._∘_ (r .hom) (x .ψ o) ≡ y .ψ o" class="Field">commutes</a> <a id="5223" href="Cat.Diagram.Colimit.Base.html#5101" class="Bound">o</a> <a id="5225" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="5233" href="Cat.Diagram.Colimit.Base.html#5084" class="Bound">z</a> <a id="5235" class="Symbol">.</a><a id="5236" href="Cat.Diagram.Colimit.Base.html#2681" data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" class="Field">ψ</a> <a id="5238" href="Cat.Diagram.Colimit.Base.html#5101" class="Bound">o</a>                         <a id="5264" href="1Lab.Path.html#46945" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>

    <a id="5271" href="Cat.Diagram.Colimit.Base.html#5271" data-type="(F : Functor J₁ C) → Precategory (o ⊔ ℓ ⊔ o′ ⊔ ℓ′) (o ⊔ ℓ′)" class="Function">cat</a> <a id="5275" class="Symbol">:</a> <a id="5277" href="Cat.Base.html#704" data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" class="Record">Precategory</a> <a id="5289" class="Symbol">_</a> <a id="5291" class="Symbol">_</a>
    <a id="5297" href="Cat.Diagram.Colimit.Base.html#5271" data-type="(F : Functor J₁ C) → Precategory (o ⊔ ℓ ⊔ o′ ⊔ ℓ′) (o ⊔ ℓ′)" class="Function">cat</a> <a id="5301" class="Symbol">.</a><a id="5302" href="Cat.Base.html#1419" data-type="Precategory o h → Type o" class="Field">Ob</a> <a id="5305" class="Symbol">=</a> <a id="5307" href="Cat.Diagram.Colimit.Base.html#2300" data-type="(F : Functor J₁ C) → Type (o ⊔ ℓ ⊔ o′ ⊔ ℓ′)" class="Record">Cocone</a>
    <a id="5318" href="Cat.Diagram.Colimit.Base.html#5271" data-type="(F : Functor J₁ C) → Precategory (o ⊔ ℓ ⊔ o′ ⊔ ℓ′) (o ⊔ ℓ′)" class="Function">cat</a> <a id="5322" class="Symbol">.</a><a id="5323" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Field">Hom</a> <a id="5327" class="Symbol">=</a> <a id="5329" href="Cat.Diagram.Colimit.Base.html#4086" data-type="(F : Functor J₁ C) (x y : Cocone F) → Type (o ⊔ ℓ′)" class="Record">Cocone-hom</a>
    <a id="5344" href="Cat.Diagram.Colimit.Base.html#5271" data-type="(F : Functor J₁ C) → Precategory (o ⊔ ℓ ⊔ o′ ⊔ ℓ′) (o ⊔ ℓ′)" class="Function">cat</a> <a id="5348" class="Symbol">.</a><a id="5349" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Field">id</a> <a id="5352" class="Symbol">=</a> <a id="5354" href="Cat.Diagram.Colimit.Base.html#4170" data-type="(hom : C .Hom (x .coapex) (y .coapex))
(commutes : (o : J₁ .Ob) → C ._∘_ hom (x .ψ o) ≡ y .ψ o) →
Cocone-hom F x y" class="InductiveConstructor">cocone-hom</a> <a id="5365" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">C.id</a> <a id="5370" class="Symbol">(λ</a> <a id="5373" href="Cat.Diagram.Colimit.Base.html#5373" class="Bound">_</a> <a id="5375" class="Symbol">→</a> <a id="5377" href="Cat.Base.html#3482" data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ (r .id) f ≡ f" class="Function">C.idl</a> <a id="5383" class="Symbol">_)</a>
    <a id="5390" href="Cat.Diagram.Colimit.Base.html#5271" data-type="(F : Functor J₁ C) → Precategory (o ⊔ ℓ ⊔ o′ ⊔ ℓ′) (o ⊔ ℓ′)" class="Function">cat</a> <a id="5394" class="Symbol">.</a><a id="5395" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Field Operator">_∘_</a> <a id="5399" class="Symbol">=</a> <a id="5401" href="Cat.Diagram.Colimit.Base.html#4939" data-type="(F : Functor J₁ C) →
Cocone-hom F y z → Cocone-hom F x y → Cocone-hom F x z" class="Function">compose</a>
    <a id="5413" href="Cat.Diagram.Colimit.Base.html#5271" data-type="(F : Functor J₁ C) → Precategory (o ⊔ ℓ ⊔ o′ ⊔ ℓ′) (o ⊔ ℓ′)" class="Function">cat</a> <a id="5417" class="Symbol">.</a><a id="5418" href="Cat.Base.html#3437" data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ f (r .id) ≡ f" class="Field">idr</a> <a id="5422" href="Cat.Diagram.Colimit.Base.html#5422" class="Bound">f</a> <a id="5424" class="Symbol">=</a> <a id="5426" href="Cat.Diagram.Colimit.Base.html#4493" data-type="(F : Functor J₁ C) → f .hom ≡ g .hom → f ≡ g" class="Function">Cocone-hom-path</a> <a id="5442" class="Symbol">(</a><a id="5443" href="Cat.Base.html#3437" data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ f (r .id) ≡ f" class="Function">C.idr</a> <a id="5449" class="Symbol">(</a><a id="5450" href="Cat.Diagram.Colimit.Base.html#5422" class="Bound">f</a> <a id="5452" class="Symbol">.</a><a id="5453" href="Cat.Diagram.Colimit.Base.html#4197" data-type="Cocone-hom F x y → C .Hom (x .coapex) (y .coapex)" class="Field">hom</a><a id="5456" class="Symbol">))</a>
    <a id="5463" href="Cat.Diagram.Colimit.Base.html#5271" data-type="(F : Functor J₁ C) → Precategory (o ⊔ ℓ ⊔ o′ ⊔ ℓ′) (o ⊔ ℓ′)" class="Function">cat</a> <a id="5467" class="Symbol">.</a><a id="5468" href="Cat.Base.html#3482" data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ (r .id) f ≡ f" class="Field">idl</a> <a id="5472" href="Cat.Diagram.Colimit.Base.html#5472" class="Bound">f</a> <a id="5474" class="Symbol">=</a> <a id="5476" href="Cat.Diagram.Colimit.Base.html#4493" data-type="(F : Functor J₁ C) → f .hom ≡ g .hom → f ≡ g" class="Function">Cocone-hom-path</a> <a id="5492" class="Symbol">(</a><a id="5493" href="Cat.Base.html#3482" data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ (r .id) f ≡ f" class="Function">C.idl</a> <a id="5499" class="Symbol">(</a><a id="5500" href="Cat.Diagram.Colimit.Base.html#5472" class="Bound">f</a> <a id="5502" class="Symbol">.</a><a id="5503" href="Cat.Diagram.Colimit.Base.html#4197" data-type="Cocone-hom F x y → C .Hom (x .coapex) (y .coapex)" class="Field">hom</a><a id="5506" class="Symbol">))</a>
    <a id="5513" href="Cat.Diagram.Colimit.Base.html#5271" data-type="(F : Functor J₁ C) → Precategory (o ⊔ ℓ ⊔ o′ ⊔ ℓ′) (o ⊔ ℓ′)" class="Function">cat</a> <a id="5517" class="Symbol">.</a><a id="5518" href="Cat.Base.html#3857" data-type="(r : Precategory o h) (f : r .Hom y z) (g : r .Hom x y)
(h : r .Hom w x) →
r ._∘_ f (r ._∘_ g h) ≡ r ._∘_ (r ._∘_ f g) h" class="Field">assoc</a> <a id="5524" href="Cat.Diagram.Colimit.Base.html#5524" class="Bound">f</a> <a id="5526" href="Cat.Diagram.Colimit.Base.html#5526" class="Bound">g</a> <a id="5528" href="Cat.Diagram.Colimit.Base.html#5528" class="Bound">h</a> <a id="5530" class="Symbol">=</a> <a id="5532" href="Cat.Diagram.Colimit.Base.html#4493" data-type="(F : Functor J₁ C) → f .hom ≡ g .hom → f ≡ g" class="Function">Cocone-hom-path</a> <a id="5548" class="Symbol">(</a><a id="5549" href="Cat.Base.html#3857" data-type="(r : Precategory o h) (f : r .Hom y z) (g : r .Hom x y)
(h : r .Hom w x) →
r ._∘_ f (r ._∘_ g h) ≡ r ._∘_ (r ._∘_ f g) h" class="Function">C.assoc</a> <a id="5557" class="Symbol">(</a><a id="5558" href="Cat.Diagram.Colimit.Base.html#5524" class="Bound">f</a> <a id="5560" class="Symbol">.</a><a id="5561" href="Cat.Diagram.Colimit.Base.html#4197" data-type="Cocone-hom F x y → C .Hom (x .coapex) (y .coapex)" class="Field">hom</a><a id="5564" class="Symbol">)</a> <a id="5566" class="Symbol">(</a><a id="5567" href="Cat.Diagram.Colimit.Base.html#5526" class="Bound">g</a> <a id="5569" class="Symbol">.</a><a id="5570" href="Cat.Diagram.Colimit.Base.html#4197" data-type="Cocone-hom F x y → C .Hom (x .coapex) (y .coapex)" class="Field">hom</a><a id="5573" class="Symbol">)</a> <a id="5575" class="Symbol">(</a><a id="5576" href="Cat.Diagram.Colimit.Base.html#5528" class="Bound">h</a> <a id="5578" class="Symbol">.</a><a id="5579" href="Cat.Diagram.Colimit.Base.html#4197" data-type="Cocone-hom F x y → C .Hom (x .coapex) (y .coapex)" class="Field">hom</a><a id="5582" class="Symbol">))</a>

</pre>
<!--
<pre class="Agda">    <a id="5608" href="Cat.Diagram.Colimit.Base.html#5271" data-type="(F : Functor J₁ C) → Precategory (o ⊔ ℓ ⊔ o′ ⊔ ℓ′) (o ⊔ ℓ′)" class="Function">cat</a> <a id="5612" class="Symbol">.</a><a id="5613" href="Cat.Base.html#1784" data-type="(r : Precategory o h) (x y : r .Ob) → is-set (r .Hom x y)" class="Field">Hom-set</a> <a id="5621" href="Cat.Diagram.Colimit.Base.html#5621" class="Bound">x</a> <a id="5623" href="Cat.Diagram.Colimit.Base.html#5623" class="Bound">y</a> <a id="5625" class="Symbol">=</a> <a id="5627" href="1Lab.HLevel.Retracts.html#4220" data-type="(n : Nat) → A ≃ B₁ → is-hlevel A n → is-hlevel B₁ n" class="Function">is-hlevel≃</a> <a id="5638" class="Number">2</a> <a id="5640" class="Symbol">(</a><a id="5641" href="1Lab.Equiv.html#20161" data-type="Iso A B₁ → A ≃ B₁" class="Function">Iso→Equiv</a> <a id="5651" href="Cat.Diagram.Colimit.Base.html#4320" data-type="(F : Functor J₁ C) →
Iso (Cocone-hom F x y)
(∑ (C .Hom (coapex x) (coapex y))
 (λ hom → (o₁ : J₁ .Ob) → C ._∘_ hom (ψ x o₁) ≡ ψ y o₁))" class="Function">eqv</a> <a id="5655" href="1Lab.Equiv.html#21355" data-type="A ≃ B₁ → B₁ ≃ A" class="Function Operator">e⁻¹</a><a id="5658" class="Symbol">)</a> <a id="5660" class="Symbol">(</a><a id="5661" href="1Lab.HLevel.Retracts.html#8061" data-type="(n : Nat) ⦃ x : H-Level T n ⦄ → is-hlevel T n" class="Function">hlevel</a> <a id="5668" class="Number">2</a><a id="5669" class="Symbol">)</a>
      <a id="5677" class="Keyword">where</a> <a id="5683" class="Keyword">open</a> <a id="5688" href="Cat.Base.html#3984" class="Module">C.HLevel-instance</a>
</pre>-->
<h2 id="colimits"><a href="#colimits" class="header-link">Colimits<span class="header-link-emoji">🔗</span></a></h2>
We now have all of the machinery in place! What remains is the universal
property, which expresses that a <em>particular</em> cocone is
universal, in the sense that it has a <em>unique</em> map to any other
cocone. However, we already have something that captures this idea, it’s
the initial object! This leads to the following terse definition: A
colimit over a diagram is an initial object in the category of cocones
over that diagram.
<pre class="Agda">  <a id="6158" href="Cat.Diagram.Colimit.Base.html#6158" data-type="(F : Functor J₁ C) → Cocone F → Type (o ⊔ ℓ ⊔ o′ ⊔ ℓ′)" class="Function">is-colimit</a> <a id="6169" class="Symbol">:</a> <a id="6171" href="Cat.Diagram.Colimit.Base.html#2300" data-type="(F : Functor J₁ C) → Type (o ⊔ ℓ ⊔ o′ ⊔ ℓ′)" class="Record">Cocone</a> <a id="6178" class="Symbol">→</a> <a id="6180" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="6185" class="Symbol">_</a>
  <a id="6189" href="Cat.Diagram.Colimit.Base.html#6158" data-type="(F : Functor J₁ C) → Cocone F → Type (o ⊔ ℓ ⊔ o′ ⊔ ℓ′)" class="Function">is-colimit</a> <a id="6200" href="Cat.Diagram.Colimit.Base.html#6200" class="Bound">K</a> <a id="6202" class="Symbol">=</a> <a id="6204" href="Cat.Diagram.Initial.html#326" data-type="(C : Precategory o h) → Ob C → Type (o ⊔ h)" class="Function">is-initial</a> <a id="6215" href="Cat.Diagram.Colimit.Base.html#4865" data-type="(F : Functor J₁ C) → Precategory (o ⊔ ℓ ⊔ o′ ⊔ ℓ′) (o ⊔ ℓ′)" class="Function">Cocones</a> <a id="6223" href="Cat.Diagram.Colimit.Base.html#6200" class="Bound">K</a>

  <a id="6228" href="Cat.Diagram.Colimit.Base.html#6228" data-type="(F : Functor J₁ C) → Type (o ⊔ ℓ ⊔ o′ ⊔ ℓ′)" class="Function">Colimit</a> <a id="6236" class="Symbol">:</a> <a id="6238" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="6243" class="Symbol">_</a>
  <a id="6247" href="Cat.Diagram.Colimit.Base.html#6228" data-type="(F : Functor J₁ C) → Type (o ⊔ ℓ ⊔ o′ ⊔ ℓ′)" class="Function">Colimit</a> <a id="6255" class="Symbol">=</a> <a id="6257" href="Cat.Diagram.Initial.html#401" data-type="(C : Precategory o h) → Type (o ⊔ h)" class="Record">Initial</a> <a id="6265" href="Cat.Diagram.Colimit.Base.html#4865" data-type="(F : Functor J₁ C) → Precategory (o ⊔ ℓ ⊔ o′ ⊔ ℓ′) (o ⊔ ℓ′)" class="Function">Cocones</a>

  <a id="6276" href="Cat.Diagram.Colimit.Base.html#6276" data-type="(F : Functor J₁ C) → Colimit F → C .Ob" class="Function">Colimit-apex</a> <a id="6289" class="Symbol">:</a> <a id="6291" href="Cat.Diagram.Colimit.Base.html#6228" data-type="(F : Functor J₁ C) → Type (o ⊔ ℓ ⊔ o′ ⊔ ℓ′)" class="Function">Colimit</a> <a id="6299" class="Symbol">→</a> <a id="6301" href="Cat.Base.html#1419" data-type="Precategory o h → Type o" class="Function">C.Ob</a>
  <a id="6308" href="Cat.Diagram.Colimit.Base.html#6276" data-type="(F : Functor J₁ C) → Colimit F → C .Ob" class="Function">Colimit-apex</a> <a id="6321" href="Cat.Diagram.Colimit.Base.html#6321" class="Bound">x</a> <a id="6323" class="Symbol">=</a> <a id="6325" href="Cat.Diagram.Colimit.Base.html#2661" data-type="Cocone F → C .Ob" class="Field">coapex</a> <a id="6332" class="Symbol">(</a><a id="6333" href="Cat.Diagram.Initial.html#442" data-type="Initial C → Ob C" class="Field">Initial.bot</a> <a id="6345" href="Cat.Diagram.Colimit.Base.html#6321" class="Bound">x</a><a id="6346" class="Symbol">)</a>
</pre>
<!--
<pre class="Agda"><a id="6367" class="Keyword">module</a> <a id="6374" href="Cat.Diagram.Colimit.Base.html#6374" class="Module">_</a> <a id="6376" class="Symbol">{</a><a id="6377" href="Cat.Diagram.Colimit.Base.html#6377" class="Bound">o₁</a> <a id="6380" href="Cat.Diagram.Colimit.Base.html#6380" class="Bound">h₁</a> <a id="6383" href="Cat.Diagram.Colimit.Base.html#6383" class="Bound">o₂</a> <a id="6386" href="Cat.Diagram.Colimit.Base.html#6386" class="Bound">h₂</a> <a id="6389" href="Cat.Diagram.Colimit.Base.html#6389" class="Bound">o₃</a> <a id="6392" href="Cat.Diagram.Colimit.Base.html#6392" class="Bound">h₃</a> <a id="6395" class="Symbol">:</a> <a id="6397" class="Symbol">_}</a>
         <a id="6409" class="Symbol">{</a><a id="6410" href="Cat.Diagram.Colimit.Base.html#6410" class="Bound">J</a> <a id="6412" class="Symbol">:</a> <a id="6414" href="Cat.Base.html#704" data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" class="Record">Precategory</a> <a id="6426" href="Cat.Diagram.Colimit.Base.html#6377" class="Bound">o₁</a> <a id="6429" href="Cat.Diagram.Colimit.Base.html#6380" class="Bound">h₁</a><a id="6431" class="Symbol">}</a>
         <a id="6442" class="Symbol">{</a><a id="6443" href="Cat.Diagram.Colimit.Base.html#6443" class="Bound">C</a> <a id="6445" class="Symbol">:</a> <a id="6447" href="Cat.Base.html#704" data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" class="Record">Precategory</a> <a id="6459" href="Cat.Diagram.Colimit.Base.html#6383" class="Bound">o₂</a> <a id="6462" href="Cat.Diagram.Colimit.Base.html#6386" class="Bound">h₂</a><a id="6464" class="Symbol">}</a>
         <a id="6475" class="Symbol">{</a><a id="6476" href="Cat.Diagram.Colimit.Base.html#6476" class="Bound">D</a> <a id="6478" class="Symbol">:</a> <a id="6480" href="Cat.Base.html#704" data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" class="Record">Precategory</a> <a id="6492" href="Cat.Diagram.Colimit.Base.html#6389" class="Bound">o₃</a> <a id="6495" href="Cat.Diagram.Colimit.Base.html#6392" class="Bound">h₃</a><a id="6497" class="Symbol">}</a>
         <a id="6508" class="Symbol">{</a><a id="6509" href="Cat.Diagram.Colimit.Base.html#6509" class="Bound">Dia</a> <a id="6513" class="Symbol">:</a> <a id="6515" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="6523" href="Cat.Diagram.Colimit.Base.html#6410" class="Bound">J</a> <a id="6525" href="Cat.Diagram.Colimit.Base.html#6443" class="Bound">C</a><a id="6526" class="Symbol">}</a>
         <a id="6537" class="Symbol">(</a><a id="6538" href="Cat.Diagram.Colimit.Base.html#6538" class="Bound">F</a> <a id="6540" class="Symbol">:</a> <a id="6542" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="6550" href="Cat.Diagram.Colimit.Base.html#6443" class="Bound">C</a> <a id="6552" href="Cat.Diagram.Colimit.Base.html#6476" class="Bound">D</a><a id="6553" class="Symbol">)</a>
  <a id="6557" class="Keyword">where</a>

  <a id="6566" class="Keyword">private</a>
    <a id="6578" class="Keyword">module</a> <a id="6585" href="Cat.Diagram.Colimit.Base.html#6585" class="Module">D</a> <a id="6587" class="Symbol">=</a> <a id="6589" href="Cat.Base.html#704" data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" class="Module">Precategory</a> <a id="6601" href="Cat.Diagram.Colimit.Base.html#6476" class="Bound">D</a>
    <a id="6607" class="Keyword">module</a> <a id="6614" href="Cat.Diagram.Colimit.Base.html#6614" class="Module">C</a> <a id="6616" class="Symbol">=</a> <a id="6618" href="Cat.Base.html#704" data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" class="Module">Precategory</a> <a id="6630" href="Cat.Diagram.Colimit.Base.html#6443" class="Bound">C</a>
    <a id="6636" class="Keyword">module</a> <a id="6643" href="Cat.Diagram.Colimit.Base.html#6643" class="Module">J</a> <a id="6645" class="Symbol">=</a> <a id="6647" href="Cat.Base.html#704" data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" class="Module">Precategory</a> <a id="6659" href="Cat.Diagram.Colimit.Base.html#6410" class="Bound">J</a>
    <a id="6665" class="Keyword">module</a> <a id="6672" href="Cat.Diagram.Colimit.Base.html#6672" class="Module">F</a> <a id="6674" class="Symbol">=</a> <a id="6676" href="Cat.Functor.Reasoning.html" class="Module">Func</a> <a id="6681" href="Cat.Diagram.Colimit.Base.html#6538" class="Bound">F</a>

  <a id="6686" class="Keyword">open</a> <a id="6691" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Module">Functor</a>
</pre>-->
<h1 id="preservation-of-colimits"><a href="#preservation-of-colimits" class="header-link">Preservation
of Colimits<span class="header-link-emoji">🔗</span></a></h1>
<p>Because a cocone is a commutative diagram, any given functor
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>:</mo><mi mathvariant="script">C</mi><mo>→</mo><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">F : \ca{C} \to \ca{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span>
takes cocones in
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">\ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span>
to cocones in
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">\ca{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span>,</span>
as functors preserve commutative diagrams.</p>
<pre class="Agda">  <a id="6925" href="Cat.Diagram.Colimit.Base.html#6925" data-type="(F : Functor C D) → Cocone Dia → Cocone (F F∘ Dia)" class="Function">F-map-cocone</a> <a id="6938" class="Symbol">:</a> <a id="6940" href="Cat.Diagram.Colimit.Base.html#2300" data-type="(F : Functor J₁ C) → Type (o ⊔ ℓ ⊔ o′ ⊔ ℓ′)" class="Record">Cocone</a> <a id="6947" href="Cat.Diagram.Colimit.Base.html#6509" class="Bound">Dia</a> <a id="6951" class="Symbol">→</a> <a id="6953" href="Cat.Diagram.Colimit.Base.html#2300" data-type="(F : Functor J₁ C) → Type (o ⊔ ℓ ⊔ o′ ⊔ ℓ′)" class="Record">Cocone</a> <a id="6960" class="Symbol">(</a><a id="6961" href="Cat.Diagram.Colimit.Base.html#6538" class="Bound">F</a> <a id="6963" href="Cat.Base.html#9697" data-type="Functor D E → Functor C D → Functor C E" class="Function Operator">F∘</a> <a id="6966" href="Cat.Diagram.Colimit.Base.html#6509" class="Bound">Dia</a><a id="6969" class="Symbol">)</a>
  <a id="6973" href="Cat.Diagram.Colimit.Base.html#6925" data-type="(F : Functor C D) → Cocone Dia → Cocone (F F∘ Dia)" class="Function">F-map-cocone</a> <a id="6986" href="Cat.Diagram.Colimit.Base.html#6986" class="Bound">x</a> <a id="6988" class="Symbol">.</a><a id="6989" href="Cat.Diagram.Colimit.Base.html#2661" data-type="Cocone F → C .Ob" class="Field">Cocone.coapex</a> <a id="7003" class="Symbol">=</a> <a id="7005" href="Cat.Base.html#8727" data-type="(r : Functor C D) → C .Ob → D .Ob" class="Function">F.₀</a> <a id="7009" class="Symbol">(</a><a id="7010" href="Cat.Diagram.Colimit.Base.html#2661" data-type="Cocone F → C .Ob" class="Field">Cocone.coapex</a> <a id="7024" href="Cat.Diagram.Colimit.Base.html#6986" class="Bound">x</a><a id="7025" class="Symbol">)</a>
  <a id="7029" href="Cat.Diagram.Colimit.Base.html#6925" data-type="(F : Functor C D) → Cocone Dia → Cocone (F F∘ Dia)" class="Function">F-map-cocone</a> <a id="7042" href="Cat.Diagram.Colimit.Base.html#7042" class="Bound">x</a> <a id="7044" class="Symbol">.</a><a id="7045" href="Cat.Diagram.Colimit.Base.html#2681" data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" class="Field">Cocone.ψ</a> <a id="7054" href="Cat.Diagram.Colimit.Base.html#7054" class="Bound">f</a> <a id="7056" class="Symbol">=</a> <a id="7058" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">F.₁</a> <a id="7062" class="Symbol">(</a><a id="7063" href="Cat.Diagram.Colimit.Base.html#2681" data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" class="Field">Cocone.ψ</a> <a id="7072" href="Cat.Diagram.Colimit.Base.html#7042" class="Bound">x</a> <a id="7074" href="Cat.Diagram.Colimit.Base.html#7054" class="Bound">f</a><a id="7075" class="Symbol">)</a>
  <a id="7079" href="Cat.Diagram.Colimit.Base.html#6925" data-type="(F : Functor C D) → Cocone Dia → Cocone (F F∘ Dia)" class="Function">F-map-cocone</a> <a id="7092" href="Cat.Diagram.Colimit.Base.html#7092" class="Bound">x</a> <a id="7094" class="Symbol">.</a><a id="7095" href="Cat.Diagram.Colimit.Base.html#3115" data-type="(r : Cocone F) (f : J₁ .Hom x y) → C ._∘_ (r .ψ y) (₁ F f) ≡ r .ψ x" class="Field">Cocone.commutes</a> <a id="7111" class="Symbol">{</a><a id="7112" class="Argument">y</a> <a id="7114" class="Symbol">=</a> <a id="7116" href="Cat.Diagram.Colimit.Base.html#7116" class="Bound">y</a><a id="7117" class="Symbol">}</a> <a id="7119" href="Cat.Diagram.Colimit.Base.html#7119" class="Bound">f</a> <a id="7121" class="Symbol">=</a>
    <a id="7127" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">F.₁</a> <a id="7131" class="Symbol">(</a><a id="7132" href="Cat.Diagram.Colimit.Base.html#2681" data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" class="Field">Cocone.ψ</a> <a id="7141" href="Cat.Diagram.Colimit.Base.html#7092" class="Bound">x</a> <a id="7143" href="Cat.Diagram.Colimit.Base.html#7116" class="Bound">y</a><a id="7144" class="Symbol">)</a> <a id="7146" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="7150" href="Cat.Diagram.Colimit.Base.html#6538" class="Bound">F</a> <a id="7152" class="Symbol">.</a><a id="7153" href="Cat.Base.html#8017" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="7156" class="Symbol">_</a> <span class="reasoning-step"><span class="as-written Function"><a id="7158" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="7161" href="Cat.Functor.Reasoning.html#1206" data-type="(F : Functor 𝒞 𝒟) (ab≡c : (F ∘ a) b ≡ c) →
(F ∘ F₁ F a) (F₁ F b) ≡ F₁ F c" class="Function">F.collapse</a> <a id="7172" class="Symbol">(</a><a id="7173" href="Cat.Diagram.Colimit.Base.html#3115" data-type="(r : Cocone F) (f : J₁ .Hom x y) → C ._∘_ (r .ψ y) (₁ F f) ≡ r .ψ x" class="Field">Cocone.commutes</a> <a id="7189" href="Cat.Diagram.Colimit.Base.html#7092" class="Bound">x</a> <a id="7191" class="Symbol">_)</a> <a id="7194" href="1Lab.Path.html#46617" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="7200" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">F.₁</a> <a id="7204" class="Symbol">(</a><a id="7205" href="Cat.Diagram.Colimit.Base.html#2681" data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" class="Field">Cocone.ψ</a> <a id="7214" href="Cat.Diagram.Colimit.Base.html#7092" class="Bound">x</a> <a id="7216" class="Symbol">_)</a>             <a id="7231" href="1Lab.Path.html#46945" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
</pre>
<p>Though functors must take cocones to cocones, they may not
necessarily take colimiting cocones to colimiting cocones! When a
functor does, we say that it <em>preserves</em> colimits.</p>
<pre class="Agda">  <a id="7425" href="Cat.Diagram.Colimit.Base.html#7425" data-type="(F : Functor C D) → Cocone Dia → Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂ ⊔ o₃ ⊔ h₃)" class="Function">Preserves-colimit</a> <a id="7443" class="Symbol">:</a> <a id="7445" href="Cat.Diagram.Colimit.Base.html#2300" data-type="(F : Functor J₁ C) → Type (o ⊔ ℓ ⊔ o′ ⊔ ℓ′)" class="Record">Cocone</a> <a id="7452" href="Cat.Diagram.Colimit.Base.html#6509" class="Bound">Dia</a> <a id="7456" class="Symbol">→</a> <a id="7458" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="7463" class="Symbol">_</a>
  <a id="7467" href="Cat.Diagram.Colimit.Base.html#7425" data-type="(F : Functor C D) → Cocone Dia → Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂ ⊔ o₃ ⊔ h₃)" class="Function">Preserves-colimit</a> <a id="7485" href="Cat.Diagram.Colimit.Base.html#7485" class="Bound">K</a> <a id="7487" class="Symbol">=</a> <a id="7489" href="Cat.Diagram.Colimit.Base.html#6158" data-type="(F : Functor J₁ C) → Cocone F → Type (o ⊔ ℓ ⊔ o′ ⊔ ℓ′)" class="Function">is-colimit</a> <a id="7500" href="Cat.Diagram.Colimit.Base.html#6509" class="Bound">Dia</a> <a id="7504" href="Cat.Diagram.Colimit.Base.html#7485" class="Bound">K</a> <a id="7506" class="Symbol">→</a> <a id="7508" href="Cat.Diagram.Colimit.Base.html#6158" data-type="(F : Functor J₁ C) → Cocone F → Type (o ⊔ ℓ ⊔ o′ ⊔ ℓ′)" class="Function">is-colimit</a> <a id="7519" class="Symbol">(</a><a id="7520" href="Cat.Diagram.Colimit.Base.html#6538" class="Bound">F</a> <a id="7522" href="Cat.Base.html#9697" data-type="Functor D E → Functor C D → Functor C E" class="Function Operator">F∘</a> <a id="7525" href="Cat.Diagram.Colimit.Base.html#6509" class="Bound">Dia</a><a id="7528" class="Symbol">)</a> <a id="7530" class="Symbol">(</a><a id="7531" href="Cat.Diagram.Colimit.Base.html#6925" data-type="(F : Functor C D) → Cocone Dia → Cocone (F F∘ Dia)" class="Function">F-map-cocone</a> <a id="7544" href="Cat.Diagram.Colimit.Base.html#7485" class="Bound">K</a><a id="7545" class="Symbol">)</a>
</pre>
<h2 id="cocompleteness"><a href="#cocompleteness" class="header-link">Cocompleteness<span class="header-link-emoji">🔗</span></a></h2>
<p>A category is <strong>cocomplete</strong> if admits for limits of
arbitrary shape. However, in the presence of excluded middle, if a
category admits coproducts indexed by its class of morphisms, then it is
automatically [thin]. Since excluded middle is independent of type
theory, we can not prove that any non-thin categories have arbitrary
colimits.</p>
<p>Instead, categories are cocomplete <em>with respect to</em> a pair of
universes: A category is
<strong><span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>o</mi><mo separator="true">,</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(o, \ell)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">o</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">ℓ</span><span class="mclose">)</span></span></span></span>-cocomplete</span></strong>
if it has colimits for any diagram indexed by a precategory with objects
in
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">T</mi><mi mathvariant="normal">y</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">e</mi></mrow><mtext> </mtext><mi>o</mi></mrow><annotation encoding="application/x-tex">\ty\ o</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathrm">Type</span></span><span class="mspace"> </span><span class="mord mathnormal">o</span></span></span></span>
and morphisms in
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">T</mi><mi mathvariant="normal">y</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">e</mi></mrow><mtext> </mtext><mi mathvariant="normal">ℓ</mi></mrow><annotation encoding="application/x-tex">\ty\ \ell</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathrm">Type</span></span><span class="mspace"> </span><span class="mord">ℓ</span></span></span></span>.</span></p>
<pre class="Agda"><a id="is-cocomplete"></a><a id="8150" href="Cat.Diagram.Colimit.Base.html#8150" data-type="(o ℓ : Level) →
Precategory oc ℓc → Type (oc ⊔ ℓc ⊔ lsuc o ⊔ lsuc ℓ)" class="Function">is-cocomplete</a> <a id="8164" class="Symbol">:</a> <a id="8166" class="Symbol">∀</a> <a id="8168" class="Symbol">{</a><a id="8169" href="Cat.Diagram.Colimit.Base.html#8169" class="Bound">oc</a> <a id="8172" href="Cat.Diagram.Colimit.Base.html#8172" class="Bound">ℓc</a><a id="8174" class="Symbol">}</a> <a id="8176" href="Cat.Diagram.Colimit.Base.html#8176" class="Bound">o</a> <a id="8178" href="Cat.Diagram.Colimit.Base.html#8178" class="Bound">ℓ</a> <a id="8180" class="Symbol">→</a> <a id="8182" href="Cat.Base.html#704" data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" class="Record">Precategory</a> <a id="8194" href="Cat.Diagram.Colimit.Base.html#8169" class="Bound">oc</a> <a id="8197" href="Cat.Diagram.Colimit.Base.html#8172" class="Bound">ℓc</a> <a id="8200" class="Symbol">→</a> <a id="8202" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="8207" class="Symbol">_</a>
<a id="8209" href="Cat.Diagram.Colimit.Base.html#8150" data-type="(o ℓ : Level) →
Precategory oc ℓc → Type (oc ⊔ ℓc ⊔ lsuc o ⊔ lsuc ℓ)" class="Function">is-cocomplete</a> <a id="8223" href="Cat.Diagram.Colimit.Base.html#8223" class="Bound">o</a> <a id="8225" href="Cat.Diagram.Colimit.Base.html#8225" class="Bound">ℓ</a> <a id="8227" href="Cat.Diagram.Colimit.Base.html#8227" class="Bound">C</a> <a id="8229" class="Symbol">=</a> <a id="8231" class="Symbol">∀</a> <a id="8233" class="Symbol">{</a><a id="8234" href="Cat.Diagram.Colimit.Base.html#8234" class="Bound">D</a> <a id="8236" class="Symbol">:</a> <a id="8238" href="Cat.Base.html#704" data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" class="Record">Precategory</a> <a id="8250" href="Cat.Diagram.Colimit.Base.html#8223" class="Bound">o</a> <a id="8252" href="Cat.Diagram.Colimit.Base.html#8225" class="Bound">ℓ</a><a id="8253" class="Symbol">}</a> <a id="8255" class="Symbol">(</a><a id="8256" href="Cat.Diagram.Colimit.Base.html#8256" class="Bound">F</a> <a id="8258" class="Symbol">:</a> <a id="8260" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="8268" href="Cat.Diagram.Colimit.Base.html#8234" class="Bound">D</a> <a id="8270" href="Cat.Diagram.Colimit.Base.html#8227" class="Bound">C</a><a id="8271" class="Symbol">)</a> <a id="8273" class="Symbol">→</a> <a id="8275" href="Cat.Diagram.Colimit.Base.html#6228" data-type="(F : Functor J₁ C) → Type (o ⊔ ℓ ⊔ o′ ⊔ ℓ′)" class="Function">Colimit</a> <a id="8283" href="Cat.Diagram.Colimit.Base.html#8256" class="Bound">F</a>
</pre>
  </article>
</div>
</main>
</body>
</html>
