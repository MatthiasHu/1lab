<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="keywords" content="Agda,categories,topos" />

  <title>Cat.Abelian.Base - 1Lab</title>

  <link rel="stylesheet" href="/css/default.css" />
  <link rel="stylesheet" href="/css/katex.min.css" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Cat.Abelian.Base - 1Lab" />
  <meta name="twitter:image" content="https://1lab.dev/static/cube-128x.png" />

  <meta name="og:title" content="Cat.Abelian.Base - 1Lab" />
  <meta name="og:image" content="https://1lab.dev/static/cube-128x.png" />
  <meta name="og:site-name" content="1Lab" />
  <meta name="og:type" content="website" />

    <meta name="og:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="twitter:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  
  <script defer src="/main.js"></script>

  <noscript>
    <style>
      body span.reasoning-step .as-written {
        display: inline;
      }

      body span.reasoning-step .alternate {
        display: none;
      }
    </style>
  </noscript>

  <!-- Google font embeds -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;0,800;1,400;1,500;1,600;1,700;1,800&amp;family=Inria+Sans:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&amp;display=swap" rel="stylesheet">
</head>

<body class="text-page">
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <!-- Table of contents (only if the page has a table of contents) -->
    <aside id="toc">
    <div id="toc-container" style="min-width: 10em; font-size: 15pt;">
      <!-- Title for the page -->
      <h3 class="Agda" style="margin-top: 0; margin-bottom: 0; white-space: pre;">
                <a class="Module">Cat.Abelian.Base</a>
              </h3>

      <!-- Cube logo -->
      <a id="logo" href="/">
        <img alt="1Lab" src="/static/cube-72x.png" style="display: block; margin-bottom: 1em; margin: auto;" width="32px" height="32px" />
      </a>

      <!-- Actual table of contents (separated from the rest by
      horizontal rules) -->
      <hr />
      <ul>
      <li><a href="#abelian-categories"><a href="#abelian-categories" class="header-link">Abelian
      categories<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#ab-enriched-categories"><a href="#ab-enriched-categories" class="header-link">Ab-enriched
      categories<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      <li><a href="#additive-categories"><a href="#additive-categories" class="header-link">Additive
      categories<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#pre-abelian-abelian-categories"><a href="#pre-abelian-abelian-categories" class="header-link">Pre-abelian
      &amp; abelian
      categories<span class="header-link-emoji">🔗</span></a></a></li>
      </ul>
      <hr />

      <!-- Sidebar controls -->
      <div style="display: flex; gap: 0.25em; flex-flow: row wrap;">
        <!-- Sidebar equations control -->
        <span class="equations" style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-eqns" type="checkbox" class="equations" id="sidebar-eqns">
          <label for="sidebar-eqns">Equations</label>
        </span>

        <!-- Sidebar fonts control -->
        <span style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-font" type="checkbox" id="toggle-fonts">
          <label for="toggle-fonts">Serif Font</label>
        </span>

        <!-- Sidebar footnotes control -->
        <span class="inline-footnotes" style="display: none; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-fns" type="checkbox" class="inline-footnotes" id="sidebar-fns">
          <label for="sidebar-fns">Inline Footnotes</label>
        </span>
      </div>

      <hr />

      <!-- Navbar navigation (lol) -->
      <div id="return" style="white-space: nowrap;">
        <div class="search-form search-form-proxy" role="form">
          <input id="search-box-proxy" type_="text" placeholder="Search..." autocomplete="off" tabindex="0"></input>
        </div>

              <a href="/">back to index</a> <br />
              <a href="all-pages.html">view all pages</a> <br />
        <a href="https://github.com/plt-amy/cubical-1lab/blob/c4a8622243c83c929bba8590e960752ac2ff2a88/src/Cat/Abelian/Base.lagda.md">link to source</a> <br />
                <hr /> <div class="author-list">Written by Amélia Liao</div> <br />
              </div>
    </div>
  </aside>
  
  <article>
    <!-- Article navigation (narrow screens only) -->
    <div class="narrow-only" id="article-nav">
      <!-- Index return anchor (only if the page is not the index) -->
            <div id="return">
        <a href="/">back to index</a>
      </div>
      
      <!-- Navbar equations control -->
      <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-eqns" type="checkbox" class="equations" id="navbar-eqns">
        <label for="navbar-eqns">Equations</label>
      </span>

      <!-- Navbar footnotes control -->
      <span class="inline-footnotes" style="display: none; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-fns" type="checkbox" class="inline-footnotes" id="navbar-fns">
        <label for="navbar-fns">Inline Footnotes</label>
      </span>
    </div>

<pre class="Agda"><a id="9" class="Keyword">open</a> <a id="14" class="Keyword">import</a> <a id="21" href="Algebra.Magma.Unital.html" class="Module">Algebra.Magma.Unital</a>
<a id="42" class="Keyword">open</a> <a id="47" class="Keyword">import</a> <a id="54" href="Algebra.Group.Ab.html" class="Module">Algebra.Group.Ab</a>
<a id="71" class="Keyword">open</a> <a id="76" class="Keyword">import</a> <a id="83" href="Algebra.Prelude.html" class="Module">Algebra.Prelude</a>
<a id="99" class="Keyword">open</a> <a id="104" class="Keyword">import</a> <a id="111" href="Algebra.Monoid.html" class="Module">Algebra.Monoid</a>
<a id="126" class="Keyword">open</a> <a id="131" class="Keyword">import</a> <a id="138" href="Algebra.Group.html" class="Module">Algebra.Group</a>

<a id="153" class="Keyword">open</a> <a id="158" class="Keyword">import</a> <a id="165" href="Cat.Diagram.Equaliser.Kernel.html" class="Module">Cat.Diagram.Equaliser.Kernel</a>

<a id="195" class="Keyword">import</a> <a id="202" href="Algebra.Group.Cat.Base.html" class="Module">Algebra.Group.Cat.Base</a> <a id="225" class="Symbol">as</a> <a id="228" class="Module">Grp</a>

<a id="233" class="Keyword">module</a> <a id="240" href="Cat.Abelian.Base.html" class="Module">Cat.Abelian.Base</a> <a id="257" class="Keyword">where</a>
</pre>
<h1 id="abelian-categories"><a href="#abelian-categories" class="header-link">Abelian
categories<span class="header-link-emoji">🔗</span></a></h1>
<p>This module defines the sequence of properties which “work up to”
abelian categories: Ab-enriched categories, pre-additive categories,
pre-abelian categories, and abelian categories. Each concept builds on
the last by adding a new categorical property on top of a
precategory.</p>
<h2 id="ab-enriched-categories"><a href="#ab-enriched-categories" class="header-link">Ab-enriched
categories<span class="header-link-emoji">🔗</span></a></h2>
<p>An
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi><mi mathvariant="bold">b</mi></mrow><annotation encoding="application/x-tex">\Ab</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathbf">Ab</span></span></span></span></span>-enriched</span>
category is one where each
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>hom</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\hom</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mop">hom</span></span></span></span>
set carries the structure of an <a href="Algebra.Group.Ab.html">Abelian
group</a>, such that the composition map is <em>bilinear</em>, hence
extending to an Abelian group homomorphism</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">)</mo><mo>⊗</mo><mi>hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>→</mo><mi>hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">)</mo><mtext>,</mtext></mrow><annotation encoding="application/x-tex">
\hom(b, c) \otimes \hom(a, b) \to \hom(a, c)\text{,}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">hom</span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">hom</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">hom</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mclose">)</span><span class="mord text"><span class="mord">,</span></span></span></span></span></span></p>
<p>where the term on the left is the <a href="Algebra.Group.Ab.html#the-tensor-product">tensor product</a> of
the corresponding
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>hom</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\hom</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mop">hom</span></span></span></span>-groups.</span>
As the name implies, every such category has a canonical
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi><mi mathvariant="bold">b</mi></mrow><annotation encoding="application/x-tex">\Ab</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathbf">Ab</span></span></span></span></span>-enrichment</span>
(made monoidal using
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mo>⊗</mo><mo>−</mo></mrow><annotation encoding="application/x-tex">- \otimes -</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">−</span></span></span></span>),</span>
but we do not use the language of enriched category theory in our
development of Abelian categories.</p>
<pre class="Agda"><a id="1295" class="Keyword">record</a> <a id="Ab-category"></a><a id="1302" href="Cat.Abelian.Base.html#1302" data-type="(C : Precategory o ℓ) → Type (o ⊔ lsuc ℓ)" class="Record">Ab-category</a> <a id="1314" class="Symbol">{</a><a id="1315" href="Cat.Abelian.Base.html#1315" class="Bound">o</a> <a id="1317" href="Cat.Abelian.Base.html#1317" class="Bound">ℓ</a><a id="1318" class="Symbol">}</a> <a id="1320" class="Symbol">(</a><a id="1321" href="Cat.Abelian.Base.html#1321" class="Bound">C</a> <a id="1323" class="Symbol">:</a> <a id="1325" href="Cat.Base.html#704" data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" class="Record">Precategory</a> <a id="1337" href="Cat.Abelian.Base.html#1315" class="Bound">o</a> <a id="1339" href="Cat.Abelian.Base.html#1317" class="Bound">ℓ</a><a id="1340" class="Symbol">)</a> <a id="1342" class="Symbol">:</a> <a id="1344" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="1349" class="Symbol">(</a><a id="1350" href="Cat.Abelian.Base.html#1315" class="Bound">o</a> <a id="1352" href="Agda.Primitive.html#810" data-type="Level → Level → Level" class="Primitive Operator">⊔</a> <a id="1354" href="Agda.Primitive.html#780" data-type="Level → Level" class="Primitive">lsuc</a> <a id="1359" href="Cat.Abelian.Base.html#1317" class="Bound">ℓ</a><a id="1360" class="Symbol">)</a> <a id="1362" class="Keyword">where</a>
  <a id="1370" class="Keyword">open</a> <a id="1375" href="Algebra.Prelude.html#883" class="Module">Cat</a> <a id="1379" href="Cat.Abelian.Base.html#1321" class="Bound">C</a> <a id="1381" class="Keyword">public</a>
  <a id="1390" class="Keyword">field</a>
    <a id="Ab-category.Group-on-hom"></a><a id="1400" href="Cat.Abelian.Base.html#1400" data-type="Ab-category C → (A B₁ : C .Ob) → Group-on (Hom C A B₁)" class="Field">Group-on-hom</a> <a id="1413" class="Symbol">:</a> <a id="1415" class="Symbol">∀</a> <a id="1417" href="Cat.Abelian.Base.html#1417" class="Bound">A</a> <a id="1419" href="Cat.Abelian.Base.html#1419" class="Bound">B</a> <a id="1421" class="Symbol">→</a> <a id="1423" href="Algebra.Group.html#5853" data-type="(A : Type ℓ) → Type ℓ" class="Record">Group-on</a> <a id="1432" class="Symbol">(</a><a id="1433" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">Hom</a> <a id="1437" href="Cat.Abelian.Base.html#1417" class="Bound">A</a> <a id="1439" href="Cat.Abelian.Base.html#1419" class="Bound">B</a><a id="1440" class="Symbol">)</a>

  <a id="Ab-category._+_"></a><a id="1445" href="Cat.Abelian.Base.html#1445" data-type="(r : Ab-category C) → Hom r A B₁ → Hom r A B₁ → Hom r A B₁" class="Function Operator">_+_</a> <a id="1449" class="Symbol">:</a> <a id="1451" class="Symbol">∀</a> <a id="1453" class="Symbol">{</a><a id="1454" href="Cat.Abelian.Base.html#1454" class="Bound">A</a> <a id="1456" href="Cat.Abelian.Base.html#1456" class="Bound">B</a><a id="1457" class="Symbol">}</a> <a id="1459" class="Symbol">(</a><a id="1460" href="Cat.Abelian.Base.html#1460" class="Bound">f</a> <a id="1462" href="Cat.Abelian.Base.html#1462" class="Bound">g</a> <a id="1464" class="Symbol">:</a> <a id="1466" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">Hom</a> <a id="1470" href="Cat.Abelian.Base.html#1454" class="Bound">A</a> <a id="1472" href="Cat.Abelian.Base.html#1456" class="Bound">B</a><a id="1473" class="Symbol">)</a> <a id="1475" class="Symbol">→</a> <a id="1477" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">Hom</a> <a id="1481" href="Cat.Abelian.Base.html#1454" class="Bound">A</a> <a id="1483" href="Cat.Abelian.Base.html#1456" class="Bound">B</a>
  <a id="1487" href="Cat.Abelian.Base.html#1487" class="Bound">f</a> <a id="1489" href="Cat.Abelian.Base.html#1445" data-type="(r : Ab-category C) → Hom r A B₁ → Hom r A B₁ → Hom r A B₁" class="Function Operator">+</a> <a id="1491" href="Cat.Abelian.Base.html#1491" class="Bound">g</a> <a id="1493" class="Symbol">=</a> <a id="1495" href="Cat.Abelian.Base.html#1400" data-type="Ab-category C → (A B₁ : C .Ob) → Group-on (Hom C A B₁)" class="Field">Group-on-hom</a> <a id="1508" class="Symbol">_</a> <a id="1510" class="Symbol">_</a> <a id="1512" class="Symbol">.</a><a id="1513" href="Algebra.Group.html#5906" data-type="Group-on A → A → A → A" class="Field Operator">Group-on._⋆_</a> <a id="1526" href="Cat.Abelian.Base.html#1487" class="Bound">f</a> <a id="1528" href="Cat.Abelian.Base.html#1491" class="Bound">g</a>

  <a id="Ab-category.0m"></a><a id="1533" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a> <a id="1536" class="Symbol">:</a> <a id="1538" class="Symbol">∀</a> <a id="1540" class="Symbol">{</a><a id="1541" href="Cat.Abelian.Base.html#1541" class="Bound">A</a> <a id="1543" href="Cat.Abelian.Base.html#1543" class="Bound">B</a><a id="1544" class="Symbol">}</a> <a id="1546" class="Symbol">→</a> <a id="1548" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">Hom</a> <a id="1552" href="Cat.Abelian.Base.html#1541" class="Bound">A</a> <a id="1554" href="Cat.Abelian.Base.html#1543" class="Bound">B</a>
  <a id="1558" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a> <a id="1561" class="Symbol">=</a> <a id="1563" href="Cat.Abelian.Base.html#1400" data-type="Ab-category C → (A B₁ : C .Ob) → Group-on (Hom C A B₁)" class="Field">Group-on-hom</a> <a id="1576" class="Symbol">_</a> <a id="1578" class="Symbol">_</a> <a id="1580" class="Symbol">.</a><a id="1581" href="Algebra.Group.html#1060" data-type="is-group _*₁_ → A" class="Function">Group-on.unit</a>

  <a id="1598" class="Keyword">field</a>
    <a id="Ab-category.Hom-grp-ab"></a><a id="1608" href="Cat.Abelian.Base.html#1608" data-type="(r : Ab-category C) (A B₁ : C .Ob) (f g : Hom C A B₁) →
r .Group-on-hom A B₁ ._⋆_ f g ≡ r .Group-on-hom A B₁ ._⋆_ g f" class="Field">Hom-grp-ab</a> <a id="1619" class="Symbol">:</a> <a id="1621" class="Symbol">∀</a> <a id="1623" href="Cat.Abelian.Base.html#1623" class="Bound">A</a> <a id="1625" href="Cat.Abelian.Base.html#1625" class="Bound">B</a> <a id="1627" class="Symbol">(</a><a id="1628" href="Cat.Abelian.Base.html#1628" class="Bound">f</a> <a id="1630" href="Cat.Abelian.Base.html#1630" class="Bound">g</a> <a id="1632" class="Symbol">:</a> <a id="1634" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">Hom</a> <a id="1638" href="Cat.Abelian.Base.html#1623" class="Bound">A</a> <a id="1640" href="Cat.Abelian.Base.html#1625" class="Bound">B</a><a id="1641" class="Symbol">)</a> <a id="1643" class="Symbol">→</a> <a id="1645" href="Cat.Abelian.Base.html#1628" class="Bound">f</a> <a id="1647" href="Cat.Abelian.Base.html#1445" data-type="(r : Ab-category C) → Hom r A B₁ → Hom r A B₁ → Hom r A B₁" class="Function Operator">+</a> <a id="1649" href="Cat.Abelian.Base.html#1630" class="Bound">g</a> <a id="1651" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="1653" href="Cat.Abelian.Base.html#1630" class="Bound">g</a> <a id="1655" href="Cat.Abelian.Base.html#1445" data-type="(r : Ab-category C) → Hom r A B₁ → Hom r A B₁ → Hom r A B₁" class="Function Operator">+</a> <a id="1657" href="Cat.Abelian.Base.html#1628" class="Bound">f</a>

  <a id="Ab-category.Hom-grp"></a><a id="1662" href="Cat.Abelian.Base.html#1662" data-type="(r : Ab-category C) (A : C .Ob) → C .Ob → AbGroup ℓ" class="Function">Hom-grp</a> <a id="1670" class="Symbol">:</a> <a id="1672" class="Symbol">∀</a> <a id="1674" href="Cat.Abelian.Base.html#1674" class="Bound">A</a> <a id="1676" href="Cat.Abelian.Base.html#1676" class="Bound">B</a> <a id="1678" class="Symbol">→</a> <a id="1680" href="Algebra.Group.Ab.html#1602" data-type="(ℓ : Level) → Type (lsuc ℓ)" class="Function">AbGroup</a> <a id="1688" href="Cat.Abelian.Base.html#1317" class="Bound">ℓ</a>
  <a id="1692" href="Cat.Abelian.Base.html#1662" data-type="(r : Ab-category C) (A : C .Ob) → C .Ob → AbGroup ℓ" class="Function">Hom-grp</a> <a id="1700" href="Cat.Abelian.Base.html#1700" class="Bound">A</a> <a id="1702" href="Cat.Abelian.Base.html#1702" class="Bound">B</a> <a id="1704" class="Symbol">=</a> <a id="1706" class="Symbol">(</a><a id="1707" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">Hom</a> <a id="1711" href="Cat.Abelian.Base.html#1700" class="Bound">A</a> <a id="1713" href="Cat.Abelian.Base.html#1702" class="Bound">B</a> <a id="1715" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="1717" href="Cat.Abelian.Base.html#1400" data-type="Ab-category C → (A B₁ : C .Ob) → Group-on (Hom C A B₁)" class="Field">Group-on-hom</a> <a id="1730" href="Cat.Abelian.Base.html#1700" class="Bound">A</a> <a id="1732" href="Cat.Abelian.Base.html#1702" class="Bound">B</a><a id="1733" class="Symbol">)</a> <a id="1735" href="Cat.Functor.FullSubcategory.html#1047" data-type="(object₁ : Ob C) (witness₁ : P object₁) → Restrict-ob P" class="InductiveConstructor Operator">,</a> <a id="1737" href="Cat.Abelian.Base.html#1608" data-type="(r : Ab-category C) (A B₁ : C .Ob) (f g : Hom C A B₁) →
r .Group-on-hom A B₁ ._⋆_ f g ≡ r .Group-on-hom A B₁ ._⋆_ g f" class="Field">Hom-grp-ab</a> <a id="1748" href="Cat.Abelian.Base.html#1700" class="Bound">A</a> <a id="1750" href="Cat.Abelian.Base.html#1702" class="Bound">B</a>

  <a id="1755" class="Keyword">field</a>
    <a id="1765" class="Comment">-- Composition is multilinear:</a>
    <a id="Ab-category.∘-linear-l"></a><a id="1800" href="Cat.Abelian.Base.html#1800" data-type="(r : Ab-category C) (f g : Hom C B₁ C) (h : Hom C A B₁) →
r .Group-on-hom A C ._⋆_ ((C ∘ f) h) ((C ∘ g) h) ≡
(C ∘ r .Group-on-hom B₁ C ._⋆_ f g) h" class="Field">∘-linear-l</a>
      <a id="1817" class="Symbol">:</a> <a id="1819" class="Symbol">∀</a> <a id="1821" class="Symbol">{</a><a id="1822" href="Cat.Abelian.Base.html#1822" class="Bound">A</a> <a id="1824" href="Cat.Abelian.Base.html#1824" class="Bound">B</a> <a id="1826" href="Cat.Abelian.Base.html#1826" class="Bound">C</a><a id="1827" class="Symbol">}</a> <a id="1829" class="Symbol">(</a><a id="1830" href="Cat.Abelian.Base.html#1830" class="Bound">f</a> <a id="1832" href="Cat.Abelian.Base.html#1832" class="Bound">g</a> <a id="1834" class="Symbol">:</a> <a id="1836" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">Hom</a> <a id="1840" href="Cat.Abelian.Base.html#1824" class="Bound">B</a> <a id="1842" href="Cat.Abelian.Base.html#1826" class="Bound">C</a><a id="1843" class="Symbol">)</a> <a id="1845" class="Symbol">(</a><a id="1846" href="Cat.Abelian.Base.html#1846" class="Bound">h</a> <a id="1848" class="Symbol">:</a> <a id="1850" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">Hom</a> <a id="1854" href="Cat.Abelian.Base.html#1822" class="Bound">A</a> <a id="1856" href="Cat.Abelian.Base.html#1824" class="Bound">B</a><a id="1857" class="Symbol">)</a>
      <a id="1865" class="Symbol">→</a> <a id="1867" class="Symbol">(</a><a id="1868" href="Cat.Abelian.Base.html#1830" class="Bound">f</a> <a id="1870" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="1872" href="Cat.Abelian.Base.html#1846" class="Bound">h</a><a id="1873" class="Symbol">)</a> <a id="1875" href="Cat.Abelian.Base.html#1445" data-type="(r : Ab-category C) → Hom r A B₁ → Hom r A B₁ → Hom r A B₁" class="Function Operator">+</a> <a id="1877" class="Symbol">(</a><a id="1878" href="Cat.Abelian.Base.html#1832" class="Bound">g</a> <a id="1880" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="1882" href="Cat.Abelian.Base.html#1846" class="Bound">h</a><a id="1883" class="Symbol">)</a> <a id="1885" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="1887" class="Symbol">(</a><a id="1888" href="Cat.Abelian.Base.html#1830" class="Bound">f</a> <a id="1890" href="Cat.Abelian.Base.html#1445" data-type="(r : Ab-category C) → Hom r A B₁ → Hom r A B₁ → Hom r A B₁" class="Function Operator">+</a> <a id="1892" href="Cat.Abelian.Base.html#1832" class="Bound">g</a><a id="1893" class="Symbol">)</a> <a id="1895" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="1897" href="Cat.Abelian.Base.html#1846" class="Bound">h</a>
    <a id="Ab-category.∘-linear-r"></a><a id="1903" href="Cat.Abelian.Base.html#1903" data-type="(r : Ab-category C) (f : Hom C B₁ C) (g h : Hom C A B₁) →
r .Group-on-hom A C ._⋆_ ((C ∘ f) g) ((C ∘ f) h) ≡
(C ∘ f) (r .Group-on-hom A B₁ ._⋆_ g h)" class="Field">∘-linear-r</a>
      <a id="1920" class="Symbol">:</a> <a id="1922" class="Symbol">∀</a> <a id="1924" class="Symbol">{</a><a id="1925" href="Cat.Abelian.Base.html#1925" class="Bound">A</a> <a id="1927" href="Cat.Abelian.Base.html#1927" class="Bound">B</a> <a id="1929" href="Cat.Abelian.Base.html#1929" class="Bound">C</a><a id="1930" class="Symbol">}</a> <a id="1932" class="Symbol">(</a><a id="1933" href="Cat.Abelian.Base.html#1933" class="Bound">f</a> <a id="1935" class="Symbol">:</a> <a id="1937" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">Hom</a> <a id="1941" href="Cat.Abelian.Base.html#1927" class="Bound">B</a> <a id="1943" href="Cat.Abelian.Base.html#1929" class="Bound">C</a><a id="1944" class="Symbol">)</a> <a id="1946" class="Symbol">(</a><a id="1947" href="Cat.Abelian.Base.html#1947" class="Bound">g</a> <a id="1949" href="Cat.Abelian.Base.html#1949" class="Bound">h</a> <a id="1951" class="Symbol">:</a> <a id="1953" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">Hom</a> <a id="1957" href="Cat.Abelian.Base.html#1925" class="Bound">A</a> <a id="1959" href="Cat.Abelian.Base.html#1927" class="Bound">B</a><a id="1960" class="Symbol">)</a>
      <a id="1968" class="Symbol">→</a> <a id="1970" class="Symbol">(</a><a id="1971" href="Cat.Abelian.Base.html#1933" class="Bound">f</a> <a id="1973" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="1975" href="Cat.Abelian.Base.html#1947" class="Bound">g</a><a id="1976" class="Symbol">)</a> <a id="1978" href="Cat.Abelian.Base.html#1445" data-type="(r : Ab-category C) → Hom r A B₁ → Hom r A B₁ → Hom r A B₁" class="Function Operator">+</a> <a id="1980" class="Symbol">(</a><a id="1981" href="Cat.Abelian.Base.html#1933" class="Bound">f</a> <a id="1983" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="1985" href="Cat.Abelian.Base.html#1949" class="Bound">h</a><a id="1986" class="Symbol">)</a> <a id="1988" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="1990" href="Cat.Abelian.Base.html#1933" class="Bound">f</a> <a id="1992" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="1994" class="Symbol">(</a><a id="1995" href="Cat.Abelian.Base.html#1947" class="Bound">g</a> <a id="1997" href="Cat.Abelian.Base.html#1445" data-type="(r : Ab-category C) → Hom r A B₁ → Hom r A B₁ → Hom r A B₁" class="Function Operator">+</a> <a id="1999" href="Cat.Abelian.Base.html#1949" class="Bound">h</a><a id="2000" class="Symbol">)</a>

  <a id="Ab-category.∘map"></a><a id="2005" href="Cat.Abelian.Base.html#2005" data-type="(r : Ab-category C) →
Hom (Hom-grp r B₁ C ⊗ Hom-grp r A B₁) (Hom-grp r A C)" class="Function">∘map</a> <a id="2010" class="Symbol">:</a> <a id="2012" class="Symbol">∀</a> <a id="2014" class="Symbol">{</a><a id="2015" href="Cat.Abelian.Base.html#2015" class="Bound">A</a> <a id="2017" href="Cat.Abelian.Base.html#2017" class="Bound">B</a> <a id="2019" href="Cat.Abelian.Base.html#2019" class="Bound">C</a><a id="2020" class="Symbol">}</a> <a id="2022" class="Symbol">→</a> <a id="2024" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">Ab.Hom</a> <a id="2031" class="Symbol">(</a><a id="2032" href="Cat.Abelian.Base.html#1662" data-type="(r : Ab-category C) (A : C .Ob) → C .Ob → AbGroup ℓ" class="Function">Hom-grp</a> <a id="2040" href="Cat.Abelian.Base.html#2017" class="Bound">B</a> <a id="2042" href="Cat.Abelian.Base.html#2019" class="Bound">C</a> <a id="2044" href="Algebra.Group.Ab.html#8396" data-type="(A B₁ : AbGroup ℓ) → AbGroup ℓ" class="Function Operator">⊗</a> <a id="2046" href="Cat.Abelian.Base.html#1662" data-type="(r : Ab-category C) (A : C .Ob) → C .Ob → AbGroup ℓ" class="Function">Hom-grp</a> <a id="2054" href="Cat.Abelian.Base.html#2015" class="Bound">A</a> <a id="2056" href="Cat.Abelian.Base.html#2017" class="Bound">B</a><a id="2057" class="Symbol">)</a> <a id="2059" class="Symbol">(</a><a id="2060" href="Cat.Abelian.Base.html#1662" data-type="(r : Ab-category C) (A : C .Ob) → C .Ob → AbGroup ℓ" class="Function">Hom-grp</a> <a id="2068" href="Cat.Abelian.Base.html#2015" class="Bound">A</a> <a id="2070" href="Cat.Abelian.Base.html#2019" class="Bound">C</a><a id="2071" class="Symbol">)</a>
  <a id="2075" href="Cat.Abelian.Base.html#2005" data-type="(r : Ab-category C) →
Hom (Hom-grp r B₁ C ⊗ Hom-grp r A B₁) (Hom-grp r A C)" class="Function">∘map</a> <a id="2080" class="Symbol">{</a><a id="2081" href="Cat.Abelian.Base.html#2081" class="Bound">A</a><a id="2082" class="Symbol">}</a> <a id="2084" class="Symbol">{</a><a id="2085" href="Cat.Abelian.Base.html#2085" class="Bound">B</a><a id="2086" class="Symbol">}</a> <a id="2088" class="Symbol">{</a><a id="2089" href="Cat.Abelian.Base.html#2089" class="Bound">C</a><a id="2090" class="Symbol">}</a> <a id="2092" class="Symbol">=</a>
    <a id="2098" href="Algebra.Group.Ab.html#10575" data-type="(f : ₀ A → ₀ B₁ → ₀ C) →
((x y : A .object .fst) (z : ₀ B₁) →
 f ((A ⋆ x) y) z ≡ (C ⋆ f x z) (f y z)) →
((x y : B₁ .object .fst) (z : ₀ A) →
 f z ((B₁ ⋆ x) y) ≡ (C ⋆ f z x) (f z y)) →
Hom (A ⊗ B₁) C" class="Function">from-multilinear-map</a> <a id="2119" class="Symbol">{</a><a id="2120" class="Argument">A</a> <a id="2122" class="Symbol">=</a> <a id="2124" href="Cat.Abelian.Base.html#1662" data-type="(r : Ab-category C) (A : C .Ob) → C .Ob → AbGroup ℓ" class="Function">Hom-grp</a> <a id="2132" href="Cat.Abelian.Base.html#2085" class="Bound">B</a> <a id="2134" href="Cat.Abelian.Base.html#2089" class="Bound">C</a><a id="2135" class="Symbol">}</a> <a id="2137" class="Symbol">{</a><a id="2138" class="Argument">B</a> <a id="2140" class="Symbol">=</a> <a id="2142" href="Cat.Abelian.Base.html#1662" data-type="(r : Ab-category C) (A : C .Ob) → C .Ob → AbGroup ℓ" class="Function">Hom-grp</a> <a id="2150" href="Cat.Abelian.Base.html#2081" class="Bound">A</a> <a id="2152" href="Cat.Abelian.Base.html#2085" class="Bound">B</a><a id="2153" class="Symbol">}</a> <a id="2155" class="Symbol">{</a><a id="2156" class="Argument">C</a> <a id="2158" class="Symbol">=</a> <a id="2160" href="Cat.Abelian.Base.html#1662" data-type="(r : Ab-category C) (A : C .Ob) → C .Ob → AbGroup ℓ" class="Function">Hom-grp</a> <a id="2168" href="Cat.Abelian.Base.html#2081" class="Bound">A</a> <a id="2170" href="Cat.Abelian.Base.html#2089" class="Bound">C</a><a id="2171" class="Symbol">}</a>
      <a id="2179" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">_∘_</a>
      <a id="2189" class="Symbol">(λ</a> <a id="2192" href="Cat.Abelian.Base.html#2192" class="Bound">f</a> <a id="2194" href="Cat.Abelian.Base.html#2194" class="Bound">g</a> <a id="2196" href="Cat.Abelian.Base.html#2196" class="Bound">h</a> <a id="2198" class="Symbol">→</a> <a id="2200" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="2204" class="Symbol">(</a><a id="2205" href="Cat.Abelian.Base.html#1800" data-type="(r : Ab-category C) (f g : Hom C B₁ C) (h : Hom C A B₁) →
r .Group-on-hom A C ._⋆_ ((C ∘ f) h) ((C ∘ g) h) ≡
(C ∘ r .Group-on-hom B₁ C ._⋆_ f g) h" class="Field">∘-linear-l</a> <a id="2216" class="Symbol">_</a> <a id="2218" class="Symbol">_</a> <a id="2220" class="Symbol">_))</a>
      <a id="2230" class="Symbol">(λ</a> <a id="2233" href="Cat.Abelian.Base.html#2233" class="Bound">f</a> <a id="2235" href="Cat.Abelian.Base.html#2235" class="Bound">g</a> <a id="2237" href="Cat.Abelian.Base.html#2237" class="Bound">h</a> <a id="2239" class="Symbol">→</a> <a id="2241" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="2245" class="Symbol">(</a><a id="2246" href="Cat.Abelian.Base.html#1903" data-type="(r : Ab-category C) (f : Hom C B₁ C) (g h : Hom C A B₁) →
r .Group-on-hom A C ._⋆_ ((C ∘ f) g) ((C ∘ f) h) ≡
(C ∘ f) (r .Group-on-hom A B₁ ._⋆_ g h)" class="Field">∘-linear-r</a> <a id="2257" class="Symbol">_</a> <a id="2259" class="Symbol">_</a> <a id="2261" class="Symbol">_))</a>

  <a id="2268" class="Keyword">module</a> <a id="Ab-category.Hom"></a><a id="2275" href="Cat.Abelian.Base.html#2275" class="Module">Hom</a> <a id="2279" class="Symbol">{</a><a id="2280" href="Cat.Abelian.Base.html#2280" class="Bound">A</a> <a id="2282" href="Cat.Abelian.Base.html#2282" class="Bound">B</a><a id="2283" class="Symbol">}</a> <a id="2285" class="Symbol">=</a> <a id="2287" href="Algebra.Group.Ab.html#1916" class="Module">AbGrp</a> <a id="2293" class="Symbol">(</a><a id="2294" href="Cat.Abelian.Base.html#1662" data-type="(r : Ab-category C) (A : C .Ob) → C .Ob → AbGroup ℓ" class="Function">Hom-grp</a> <a id="2302" href="Cat.Abelian.Base.html#2280" class="Bound">A</a> <a id="2304" href="Cat.Abelian.Base.html#2282" class="Bound">B</a><a id="2305" class="Symbol">)</a>
  <a id="2309" class="Keyword">open</a> <a id="2314" href="Cat.Abelian.Base.html#2275" class="Module">Hom</a>
    <a id="2322" class="Keyword">using</a> <a id="2328" class="Symbol">(</a><a id="2329" href="Algebra.Group.html#2225" data-type="(r : is-group _*₁_) → (r — x) y ≡ unit r → x ≡ y" class="Function">zero-diff</a><a id="2338" class="Symbol">)</a>
    <a id="2344" class="Keyword">renaming</a> <a id="2353" class="Symbol">(</a><a id="2354" href="Algebra.Group.html#1488" data-type="(r : is-group _*₁_) → A → A → A" class="Function Operator">_—_</a> <a id="2358" class="Symbol">to</a> <a id="2361" class="Function Operator">_-_</a><a id="2364" class="Symbol">)</a>
    <a id="2370" class="Keyword">public</a>
</pre>
<details>
<summary>
Note that from multilinearity of composition, it follows that the
addition of
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>hom</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\hom</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mop">hom</span></span></span></span>-groups</span>
and composition<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> operations satisfy familiar
algebraic identities,
e.g. <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mi>f</mi><mo>=</mo><mi>f</mi><mn>0</mn><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">0f = f0 = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">0</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>,</span>
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mi>a</mi><mi>b</mi><mo>=</mo><mo stretchy="false">(</mo><mo>−</mo><mi>a</mi><mo stretchy="false">)</mo><mi>b</mi><mo>=</mo><mi>a</mi><mo stretchy="false">(</mo><mo>−</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">-ab = (-a)b = a(-b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord mathnormal">ab</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord mathnormal">a</span><span class="mclose">)</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">(</span><span class="mord">−</span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>,</span>
etc.
</summary>
<pre class="Agda">  <a id="Ab-category.∘-zero-r"></a><a id="2648" href="Cat.Abelian.Base.html#2648" data-type="(r : Ab-category C) → (r ∘ f) (0m r) ≡ 0m r" class="Function">∘-zero-r</a> <a id="2657" class="Symbol">:</a> <a id="2659" class="Symbol">∀</a> <a id="2661" class="Symbol">{</a><a id="2662" href="Cat.Abelian.Base.html#2662" class="Bound">A</a> <a id="2664" href="Cat.Abelian.Base.html#2664" class="Bound">B</a> <a id="2666" href="Cat.Abelian.Base.html#2666" class="Bound">C</a><a id="2667" class="Symbol">}</a> <a id="2669" class="Symbol">{</a><a id="2670" href="Cat.Abelian.Base.html#2670" class="Bound">f</a> <a id="2672" class="Symbol">:</a> <a id="2674" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">Hom</a> <a id="2678" href="Cat.Abelian.Base.html#2664" class="Bound">B</a> <a id="2680" href="Cat.Abelian.Base.html#2666" class="Bound">C</a><a id="2681" class="Symbol">}</a> <a id="2683" class="Symbol">→</a> <a id="2685" href="Cat.Abelian.Base.html#2670" class="Bound">f</a> <a id="2687" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="2689" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a> <a id="2692" class="Symbol">{</a><a id="2693" href="Cat.Abelian.Base.html#2662" class="Bound">A</a><a id="2694" class="Symbol">}</a> <a id="2696" class="Symbol">{</a><a id="2697" href="Cat.Abelian.Base.html#2664" class="Bound">B</a><a id="2698" class="Symbol">}</a> <a id="2700" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="2702" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a>
  <a id="2707" href="Cat.Abelian.Base.html#2648" data-type="(r : Ab-category C) → (r ∘ f) (0m r) ≡ 0m r" class="Function">∘-zero-r</a> <a id="2716" class="Symbol">{</a><a id="2717" class="Argument">f</a> <a id="2719" class="Symbol">=</a> <a id="2721" href="Cat.Abelian.Base.html#2721" class="Bound">f</a><a id="2722" class="Symbol">}</a> <a id="2724" class="Symbol">=</a>
    <a id="2730" href="Cat.Abelian.Base.html#2721" class="Bound">f</a> <a id="2732" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="2734" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a>                     <span class="reasoning-step"><span class="as-written Function"><a id="2757" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="2760" href="Cat.Reasoning.html#1250" data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → f ≡ (C ∘ f) a" class="Function">Hom.intror</a> <a id="2771" href="Algebra.Group.html#1387" data-type="(r : is-group _*₁_) → (x *₁ r .inverse x) ≡ r .unit" class="Function">Hom.inverser</a> <a id="2784" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="2790" href="Cat.Abelian.Base.html#2721" class="Bound">f</a> <a id="2792" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="2794" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a> <a id="2797" href="Cat.Abelian.Base.html#1445" data-type="(r : Ab-category C) → Hom r A B₁ → Hom r A B₁ → Hom r A B₁" class="Function Operator">+</a> <a id="2799" class="Symbol">(</a><a id="2800" href="Cat.Abelian.Base.html#2721" class="Bound">f</a> <a id="2802" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="2804" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a> <a id="2807" href="Cat.Abelian.Base.html#2361" class="Function Operator">-</a> <a id="2809" href="Cat.Abelian.Base.html#2721" class="Bound">f</a> <a id="2811" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="2813" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a><a id="2815" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function"><a id="2817" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="2820" href="Algebra.Semigroup.html#453" data-type="is-semigroup _⋆₁_ → (x ⋆₁ (y ⋆₁ z)) ≡ ((x ⋆₁ y) ⋆₁ z)" class="Function">Hom.associative</a> <a id="2836" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="2842" class="Symbol">(</a><a id="2843" href="Cat.Abelian.Base.html#2721" class="Bound">f</a> <a id="2845" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="2847" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a> <a id="2850" href="Cat.Abelian.Base.html#1445" data-type="(r : Ab-category C) → Hom r A B₁ → Hom r A B₁ → Hom r A B₁" class="Function Operator">+</a> <a id="2852" href="Cat.Abelian.Base.html#2721" class="Bound">f</a> <a id="2854" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="2856" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a><a id="2858" class="Symbol">)</a> <a id="2860" href="Cat.Abelian.Base.html#2361" class="Function Operator">-</a> <a id="2862" href="Cat.Abelian.Base.html#2721" class="Bound">f</a> <a id="2864" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="2866" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a> <span class="reasoning-step"><span class="as-written Function"><a id="2869" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="2872" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="2875" class="Symbol">(</a><a id="2876" href="Cat.Abelian.Base.html#2361" class="Function Operator">_-</a> <a id="2879" href="Cat.Abelian.Base.html#2721" class="Bound">f</a> <a id="2881" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="2883" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a><a id="2885" class="Symbol">)</a> <a id="2887" class="Symbol">(</a><a id="2888" href="Cat.Abelian.Base.html#1903" data-type="(r : Ab-category C) (f : Hom C B₁ C) (g h : Hom C A B₁) →
r .Group-on-hom A C ._⋆_ ((C ∘ f) g) ((C ∘ f) h) ≡
(C ∘ f) (r .Group-on-hom A B₁ ._⋆_ g h)" class="Field">∘-linear-r</a> <a id="2899" class="Symbol">_</a> <a id="2901" class="Symbol">_</a> <a id="2903" class="Symbol">_)</a> <a id="2906" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="2912" class="Symbol">(</a><a id="2913" href="Cat.Abelian.Base.html#2721" class="Bound">f</a> <a id="2915" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="2917" class="Symbol">(</a><a id="2918" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a> <a id="2921" href="Cat.Abelian.Base.html#1445" data-type="(r : Ab-category C) → Hom r A B₁ → Hom r A B₁ → Hom r A B₁" class="Function Operator">+</a> <a id="2923" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a><a id="2925" class="Symbol">))</a> <a id="2928" href="Cat.Abelian.Base.html#2361" class="Function Operator">-</a> <a id="2930" href="Cat.Abelian.Base.html#2721" class="Bound">f</a> <a id="2932" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="2934" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a>   <span class="reasoning-step"><span class="as-written Function"><a id="2939" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="2942" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="2945" class="Symbol">((</a><a id="2947" href="Cat.Abelian.Base.html#2361" class="Function Operator">_-</a> <a id="2950" href="Cat.Abelian.Base.html#2721" class="Bound">f</a> <a id="2952" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="2954" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a><a id="2956" class="Symbol">)</a> <a id="2958" href="Cat.Prelude.html#232" class="Function Operator">⊙</a> <a id="2960" class="Symbol">(</a><a id="2961" href="Cat.Abelian.Base.html#2721" class="Bound">f</a> <a id="2963" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘_</a><a id="2965" class="Symbol">))</a> <a id="2968" href="Algebra.Monoid.html#1088" data-type="is-monoid id₁ _⋆₁_ → (id₁ ⋆₁ x) ≡ x" class="Function">Hom.idl</a> <a id="2976" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="2982" class="Symbol">(</a><a id="2983" href="Cat.Abelian.Base.html#2721" class="Bound">f</a> <a id="2985" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="2987" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a><a id="2989" class="Symbol">)</a> <a id="2991" href="Cat.Abelian.Base.html#2361" class="Function Operator">-</a> <a id="2993" href="Cat.Abelian.Base.html#2721" class="Bound">f</a> <a id="2995" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="2997" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a>          <span class="reasoning-step"><span class="as-written Function"><a id="3009" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="3012" href="Algebra.Group.html#1387" data-type="(r : is-group _*₁_) → (x *₁ r .inverse x) ≡ r .unit" class="Function">Hom.inverser</a> <a id="3025" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="3031" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a>                         <a id="3058" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>

  <a id="Ab-category.∘-zero-l"></a><a id="3063" href="Cat.Abelian.Base.html#3063" data-type="(r : Ab-category C) → (r ∘ 0m r) f ≡ 0m r" class="Function">∘-zero-l</a> <a id="3072" class="Symbol">:</a> <a id="3074" class="Symbol">∀</a> <a id="3076" class="Symbol">{</a><a id="3077" href="Cat.Abelian.Base.html#3077" class="Bound">A</a> <a id="3079" href="Cat.Abelian.Base.html#3079" class="Bound">B</a> <a id="3081" href="Cat.Abelian.Base.html#3081" class="Bound">C</a><a id="3082" class="Symbol">}</a> <a id="3084" class="Symbol">{</a><a id="3085" href="Cat.Abelian.Base.html#3085" class="Bound">f</a> <a id="3087" class="Symbol">:</a> <a id="3089" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">Hom</a> <a id="3093" href="Cat.Abelian.Base.html#3077" class="Bound">A</a> <a id="3095" href="Cat.Abelian.Base.html#3079" class="Bound">B</a><a id="3096" class="Symbol">}</a> <a id="3098" class="Symbol">→</a> <a id="3100" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a> <a id="3103" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="3105" href="Cat.Abelian.Base.html#3085" class="Bound">f</a> <a id="3107" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="3109" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a> <a id="3112" class="Symbol">{</a><a id="3113" href="Cat.Abelian.Base.html#3077" class="Bound">A</a><a id="3114" class="Symbol">}</a> <a id="3116" class="Symbol">{</a><a id="3117" href="Cat.Abelian.Base.html#3081" class="Bound">C</a><a id="3118" class="Symbol">}</a>
  <a id="3122" href="Cat.Abelian.Base.html#3063" data-type="(r : Ab-category C) → (r ∘ 0m r) f ≡ 0m r" class="Function">∘-zero-l</a> <a id="3131" class="Symbol">{</a><a id="3132" class="Argument">f</a> <a id="3134" class="Symbol">=</a> <a id="3136" href="Cat.Abelian.Base.html#3136" class="Bound">f</a><a id="3137" class="Symbol">}</a> <a id="3139" class="Symbol">=</a>
    <a id="3145" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a> <a id="3148" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="3150" href="Cat.Abelian.Base.html#3136" class="Bound">f</a>                                   <span class="reasoning-step"><span class="as-written Function"><a id="3186" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="3189" href="Cat.Reasoning.html#1207" data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → f ≡ (C ∘ a) f" class="Function">Hom.introl</a> <a id="3200" href="Algebra.Group.html#1341" data-type="(r : is-group _*₁_) → (r .inverse x *₁ x) ≡ r .unit" class="Function">Hom.inversel</a> <a id="3213" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="3219" class="Symbol">(</a><a id="3220" href="Algebra.Group.html#1320" data-type="is-group _*₁_ → A → A" class="Function">Hom.inverse</a> <a id="3232" class="Symbol">(</a><a id="3233" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a> <a id="3236" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="3238" href="Cat.Abelian.Base.html#3136" class="Bound">f</a><a id="3239" class="Symbol">)</a> <a id="3241" href="Cat.Abelian.Base.html#1445" data-type="(r : Ab-category C) → Hom r A B₁ → Hom r A B₁ → Hom r A B₁" class="Function Operator">+</a> <a id="3243" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a> <a id="3246" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="3248" href="Cat.Abelian.Base.html#3136" class="Bound">f</a><a id="3249" class="Symbol">)</a> <a id="3251" href="Cat.Abelian.Base.html#1445" data-type="(r : Ab-category C) → Hom r A B₁ → Hom r A B₁ → Hom r A B₁" class="Function Operator">+</a> <a id="3253" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a> <a id="3256" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="3258" href="Cat.Abelian.Base.html#3136" class="Bound">f</a> <span class="reasoning-step"><span class="as-written Function"><a id="3260" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="3263" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="3267" href="Algebra.Semigroup.html#453" data-type="is-semigroup _⋆₁_ → (x ⋆₁ (y ⋆₁ z)) ≡ ((x ⋆₁ y) ⋆₁ z)" class="Function">Hom.associative</a> <a id="3283" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="3289" href="Algebra.Group.html#1320" data-type="is-group _*₁_ → A → A" class="Function">Hom.inverse</a> <a id="3301" class="Symbol">(</a><a id="3302" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a> <a id="3305" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="3307" href="Cat.Abelian.Base.html#3136" class="Bound">f</a><a id="3308" class="Symbol">)</a> <a id="3310" href="Cat.Abelian.Base.html#1445" data-type="(r : Ab-category C) → Hom r A B₁ → Hom r A B₁ → Hom r A B₁" class="Function Operator">+</a> <a id="3312" class="Symbol">(</a><a id="3313" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a> <a id="3316" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="3318" href="Cat.Abelian.Base.html#3136" class="Bound">f</a> <a id="3320" href="Cat.Abelian.Base.html#1445" data-type="(r : Ab-category C) → Hom r A B₁ → Hom r A B₁ → Hom r A B₁" class="Function Operator">+</a> <a id="3322" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a> <a id="3325" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="3327" href="Cat.Abelian.Base.html#3136" class="Bound">f</a><a id="3328" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function"><a id="3330" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="3333" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="3336" class="Symbol">(</a><a id="3337" href="Algebra.Group.html#1320" data-type="is-group _*₁_ → A → A" class="Function">Hom.inverse</a> <a id="3349" class="Symbol">(</a><a id="3350" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a> <a id="3353" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="3355" href="Cat.Abelian.Base.html#3136" class="Bound">f</a><a id="3356" class="Symbol">)</a> <a id="3358" href="Cat.Abelian.Base.html#1445" data-type="(r : Ab-category C) → Hom r A B₁ → Hom r A B₁ → Hom r A B₁" class="Function Operator">+_</a><a id="3360" class="Symbol">)</a> <a id="3362" class="Symbol">(</a><a id="3363" href="Cat.Abelian.Base.html#1800" data-type="(r : Ab-category C) (f g : Hom C B₁ C) (h : Hom C A B₁) →
r .Group-on-hom A C ._⋆_ ((C ∘ f) h) ((C ∘ g) h) ≡
(C ∘ r .Group-on-hom B₁ C ._⋆_ f g) h" class="Field">∘-linear-l</a> <a id="3374" class="Symbol">_</a> <a id="3376" class="Symbol">_</a> <a id="3378" class="Symbol">_)</a> <a id="3381" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="3387" href="Algebra.Group.html#1320" data-type="is-group _*₁_ → A → A" class="Function">Hom.inverse</a> <a id="3399" class="Symbol">(</a><a id="3400" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a> <a id="3403" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="3405" href="Cat.Abelian.Base.html#3136" class="Bound">f</a><a id="3406" class="Symbol">)</a> <a id="3408" href="Cat.Abelian.Base.html#1445" data-type="(r : Ab-category C) → Hom r A B₁ → Hom r A B₁ → Hom r A B₁" class="Function Operator">+</a> <a id="3410" class="Symbol">((</a><a id="3412" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a> <a id="3415" href="Cat.Abelian.Base.html#1445" data-type="(r : Ab-category C) → Hom r A B₁ → Hom r A B₁ → Hom r A B₁" class="Function Operator">+</a> <a id="3417" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a><a id="3419" class="Symbol">)</a> <a id="3421" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="3423" href="Cat.Abelian.Base.html#3136" class="Bound">f</a><a id="3424" class="Symbol">)</a>   <span class="reasoning-step"><span class="as-written Function"><a id="3428" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="3431" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="3434" class="Symbol">((</a><a id="3436" href="Algebra.Group.html#1320" data-type="is-group _*₁_ → A → A" class="Function">Hom.inverse</a> <a id="3448" class="Symbol">(</a><a id="3449" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a> <a id="3452" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="3454" href="Cat.Abelian.Base.html#3136" class="Bound">f</a><a id="3455" class="Symbol">)</a> <a id="3457" href="Cat.Abelian.Base.html#1445" data-type="(r : Ab-category C) → Hom r A B₁ → Hom r A B₁ → Hom r A B₁" class="Function Operator">+_</a><a id="3459" class="Symbol">)</a> <a id="3461" href="Cat.Prelude.html#232" class="Function Operator">⊙</a> <a id="3463" class="Symbol">(</a><a id="3464" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">_∘</a> <a id="3467" href="Cat.Abelian.Base.html#3136" class="Bound">f</a><a id="3468" class="Symbol">))</a> <a id="3471" href="Algebra.Monoid.html#1088" data-type="is-monoid id₁ _⋆₁_ → (id₁ ⋆₁ x) ≡ x" class="Function">Hom.idl</a> <a id="3479" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="3485" href="Algebra.Group.html#1320" data-type="is-group _*₁_ → A → A" class="Function">Hom.inverse</a> <a id="3497" class="Symbol">(</a><a id="3498" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a> <a id="3501" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="3503" href="Cat.Abelian.Base.html#3136" class="Bound">f</a><a id="3504" class="Symbol">)</a> <a id="3506" href="Cat.Abelian.Base.html#1445" data-type="(r : Ab-category C) → Hom r A B₁ → Hom r A B₁ → Hom r A B₁" class="Function Operator">+</a> <a id="3508" class="Symbol">(</a><a id="3509" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a> <a id="3512" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="3514" href="Cat.Abelian.Base.html#3136" class="Bound">f</a><a id="3515" class="Symbol">)</a>          <span class="reasoning-step"><span class="as-written Function"><a id="3526" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="3529" href="Algebra.Group.html#1341" data-type="(r : is-group _*₁_) → (r .inverse x *₁ x) ≡ r .unit" class="Function">Hom.inversel</a> <a id="3542" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="3548" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a>                                       <a id="3589" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>

  <a id="Ab-category.neg-∘-l"></a><a id="3594" href="Cat.Abelian.Base.html#3594" data-type="(r : Ab-category C) → inverse r ((r ∘ g) h) ≡ (r ∘ inverse r g) h" class="Function">neg-∘-l</a>
    <a id="3606" class="Symbol">:</a> <a id="3608" class="Symbol">∀</a> <a id="3610" class="Symbol">{</a><a id="3611" href="Cat.Abelian.Base.html#3611" class="Bound">A</a> <a id="3613" href="Cat.Abelian.Base.html#3613" class="Bound">B</a> <a id="3615" href="Cat.Abelian.Base.html#3615" class="Bound">C</a><a id="3616" class="Symbol">}</a> <a id="3618" class="Symbol">{</a><a id="3619" href="Cat.Abelian.Base.html#3619" class="Bound">g</a> <a id="3621" class="Symbol">:</a> <a id="3623" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">Hom</a> <a id="3627" href="Cat.Abelian.Base.html#3613" class="Bound">B</a> <a id="3629" href="Cat.Abelian.Base.html#3615" class="Bound">C</a><a id="3630" class="Symbol">}</a> <a id="3632" class="Symbol">{</a><a id="3633" href="Cat.Abelian.Base.html#3633" class="Bound">h</a> <a id="3635" class="Symbol">:</a> <a id="3637" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">Hom</a> <a id="3641" href="Cat.Abelian.Base.html#3611" class="Bound">A</a> <a id="3643" href="Cat.Abelian.Base.html#3613" class="Bound">B</a><a id="3644" class="Symbol">}</a>
    <a id="3650" class="Symbol">→</a> <a id="3652" href="Algebra.Group.html#1320" data-type="is-group _*₁_ → A → A" class="Function">Hom.inverse</a> <a id="3664" class="Symbol">(</a><a id="3665" href="Cat.Abelian.Base.html#3619" class="Bound">g</a> <a id="3667" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="3669" href="Cat.Abelian.Base.html#3633" class="Bound">h</a><a id="3670" class="Symbol">)</a> <a id="3672" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="3674" href="Algebra.Group.html#1320" data-type="is-group _*₁_ → A → A" class="Function">Hom.inverse</a> <a id="3686" href="Cat.Abelian.Base.html#3619" class="Bound">g</a> <a id="3688" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="3690" href="Cat.Abelian.Base.html#3633" class="Bound">h</a>
  <a id="3694" href="Cat.Abelian.Base.html#3594" data-type="(r : Ab-category C) → inverse r ((r ∘ g) h) ≡ (r ∘ inverse r g) h" class="Function">neg-∘-l</a> <a id="3702" class="Symbol">{</a><a id="3703" class="Argument">g</a> <a id="3705" class="Symbol">=</a> <a id="3707" href="Cat.Abelian.Base.html#3707" class="Bound">g</a><a id="3708" class="Symbol">}</a> <a id="3710" class="Symbol">{</a><a id="3711" href="Cat.Abelian.Base.html#3711" class="Bound">h</a><a id="3712" class="Symbol">}</a> <a id="3714" class="Symbol">=</a> <a id="3716" href="Algebra.Monoid.html#5105" data-type="is-monoid 1M _⋆₁_ →
(e x y : A) → (x ⋆₁ e) ≡ 1M → (e ⋆₁ y) ≡ 1M → x ≡ y" class="Function">monoid-inverse-unique</a> <a id="3738" href="Algebra.Group.html#1073" data-type="(r : is-group _*₁_) → is-monoid (r .unit) _*₁_" class="Function">Hom.has-is-monoid</a> <a id="3756" class="Symbol">(</a><a id="3757" href="Cat.Abelian.Base.html#3707" class="Bound">g</a> <a id="3759" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="3761" href="Cat.Abelian.Base.html#3711" class="Bound">h</a><a id="3762" class="Symbol">)</a> <a id="3764" class="Symbol">_</a> <a id="3766" class="Symbol">_</a>
    <a id="3772" href="Algebra.Group.html#1341" data-type="(r : is-group _*₁_) → (r .inverse x *₁ x) ≡ r .unit" class="Function">Hom.inversel</a>
    <a id="3789" class="Symbol">(</a><a id="3790" href="Cat.Abelian.Base.html#1800" data-type="(r : Ab-category C) (f g : Hom C B₁ C) (h : Hom C A B₁) →
r .Group-on-hom A C ._⋆_ ((C ∘ f) h) ((C ∘ g) h) ≡
(C ∘ r .Group-on-hom B₁ C ._⋆_ f g) h" class="Field">∘-linear-l</a> <a id="3801" class="Symbol">_</a> <a id="3803" class="Symbol">_</a> <a id="3805" class="Symbol">_</a> <a id="3807" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="3809" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="3812" class="Symbol">(</a><a id="3813" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">_∘</a> <a id="3816" href="Cat.Abelian.Base.html#3711" class="Bound">h</a><a id="3817" class="Symbol">)</a> <a id="3819" href="Algebra.Group.html#1387" data-type="(r : is-group _*₁_) → (x *₁ r .inverse x) ≡ r .unit" class="Function">Hom.inverser</a> <a id="3832" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="3834" href="Cat.Abelian.Base.html#3063" data-type="(r : Ab-category C) → (r ∘ 0m r) f ≡ 0m r" class="Function">∘-zero-l</a><a id="3842" class="Symbol">)</a>

  <a id="Ab-category.neg-∘-r"></a><a id="3847" href="Cat.Abelian.Base.html#3847" data-type="(r : Ab-category C) → inverse r ((r ∘ g) h) ≡ (r ∘ g) (inverse r h)" class="Function">neg-∘-r</a>
    <a id="3859" class="Symbol">:</a> <a id="3861" class="Symbol">∀</a> <a id="3863" class="Symbol">{</a><a id="3864" href="Cat.Abelian.Base.html#3864" class="Bound">A</a> <a id="3866" href="Cat.Abelian.Base.html#3866" class="Bound">B</a> <a id="3868" href="Cat.Abelian.Base.html#3868" class="Bound">C</a><a id="3869" class="Symbol">}</a> <a id="3871" class="Symbol">{</a><a id="3872" href="Cat.Abelian.Base.html#3872" class="Bound">g</a> <a id="3874" class="Symbol">:</a> <a id="3876" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">Hom</a> <a id="3880" href="Cat.Abelian.Base.html#3866" class="Bound">B</a> <a id="3882" href="Cat.Abelian.Base.html#3868" class="Bound">C</a><a id="3883" class="Symbol">}</a> <a id="3885" class="Symbol">{</a><a id="3886" href="Cat.Abelian.Base.html#3886" class="Bound">h</a> <a id="3888" class="Symbol">:</a> <a id="3890" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">Hom</a> <a id="3894" href="Cat.Abelian.Base.html#3864" class="Bound">A</a> <a id="3896" href="Cat.Abelian.Base.html#3866" class="Bound">B</a><a id="3897" class="Symbol">}</a>
    <a id="3903" class="Symbol">→</a> <a id="3905" href="Algebra.Group.html#1320" data-type="is-group _*₁_ → A → A" class="Function">Hom.inverse</a> <a id="3917" class="Symbol">(</a><a id="3918" href="Cat.Abelian.Base.html#3872" class="Bound">g</a> <a id="3920" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="3922" href="Cat.Abelian.Base.html#3886" class="Bound">h</a><a id="3923" class="Symbol">)</a> <a id="3925" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="3927" href="Cat.Abelian.Base.html#3872" class="Bound">g</a> <a id="3929" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="3931" href="Algebra.Group.html#1320" data-type="is-group _*₁_ → A → A" class="Function">Hom.inverse</a> <a id="3943" href="Cat.Abelian.Base.html#3886" class="Bound">h</a>
  <a id="3947" href="Cat.Abelian.Base.html#3847" data-type="(r : Ab-category C) → inverse r ((r ∘ g) h) ≡ (r ∘ g) (inverse r h)" class="Function">neg-∘-r</a> <a id="3955" class="Symbol">{</a><a id="3956" class="Argument">g</a> <a id="3958" class="Symbol">=</a> <a id="3960" href="Cat.Abelian.Base.html#3960" class="Bound">g</a><a id="3961" class="Symbol">}</a> <a id="3963" class="Symbol">{</a><a id="3964" href="Cat.Abelian.Base.html#3964" class="Bound">h</a><a id="3965" class="Symbol">}</a> <a id="3967" class="Symbol">=</a> <a id="3969" href="Algebra.Monoid.html#5105" data-type="is-monoid 1M _⋆₁_ →
(e x y : A) → (x ⋆₁ e) ≡ 1M → (e ⋆₁ y) ≡ 1M → x ≡ y" class="Function">monoid-inverse-unique</a> <a id="3991" href="Algebra.Group.html#1073" data-type="(r : is-group _*₁_) → is-monoid (r .unit) _*₁_" class="Function">Hom.has-is-monoid</a> <a id="4009" class="Symbol">(</a><a id="4010" href="Cat.Abelian.Base.html#3960" class="Bound">g</a> <a id="4012" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="4014" href="Cat.Abelian.Base.html#3964" class="Bound">h</a><a id="4015" class="Symbol">)</a> <a id="4017" class="Symbol">_</a> <a id="4019" class="Symbol">_</a>
    <a id="4025" href="Algebra.Group.html#1341" data-type="(r : is-group _*₁_) → (r .inverse x *₁ x) ≡ r .unit" class="Function">Hom.inversel</a>
    <a id="4042" class="Symbol">(</a><a id="4043" href="Cat.Abelian.Base.html#1903" data-type="(r : Ab-category C) (f : Hom C B₁ C) (g h : Hom C A B₁) →
r .Group-on-hom A C ._⋆_ ((C ∘ f) g) ((C ∘ f) h) ≡
(C ∘ f) (r .Group-on-hom A B₁ ._⋆_ g h)" class="Field">∘-linear-r</a> <a id="4054" class="Symbol">_</a> <a id="4056" class="Symbol">_</a> <a id="4058" class="Symbol">_</a> <a id="4060" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="4062" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="4065" class="Symbol">(</a><a id="4066" href="Cat.Abelian.Base.html#3960" class="Bound">g</a> <a id="4068" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘_</a><a id="4070" class="Symbol">)</a> <a id="4072" href="Algebra.Group.html#1387" data-type="(r : is-group _*₁_) → (x *₁ r .inverse x) ≡ r .unit" class="Function">Hom.inverser</a> <a id="4085" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="4087" href="Cat.Abelian.Base.html#2648" data-type="(r : Ab-category C) → (r ∘ f) (0m r) ≡ 0m r" class="Function">∘-zero-r</a><a id="4095" class="Symbol">)</a>

  <a id="Ab-category.∘-minus-l"></a><a id="4100" href="Cat.Abelian.Base.html#4100" data-type="(r : Ab-category C) (f g : Hom r B₁ C) (h : Hom r A B₁) →
(r - (r ∘ f) h) ((r ∘ g) h) ≡ (r ∘ (r - f) g) h" class="Function">∘-minus-l</a>
    <a id="4114" class="Symbol">:</a> <a id="4116" class="Symbol">∀</a> <a id="4118" class="Symbol">{</a><a id="4119" href="Cat.Abelian.Base.html#4119" class="Bound">A</a> <a id="4121" href="Cat.Abelian.Base.html#4121" class="Bound">B</a> <a id="4123" href="Cat.Abelian.Base.html#4123" class="Bound">C</a><a id="4124" class="Symbol">}</a> <a id="4126" class="Symbol">(</a><a id="4127" href="Cat.Abelian.Base.html#4127" class="Bound">f</a> <a id="4129" href="Cat.Abelian.Base.html#4129" class="Bound">g</a> <a id="4131" class="Symbol">:</a> <a id="4133" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">Hom</a> <a id="4137" href="Cat.Abelian.Base.html#4121" class="Bound">B</a> <a id="4139" href="Cat.Abelian.Base.html#4123" class="Bound">C</a><a id="4140" class="Symbol">)</a> <a id="4142" class="Symbol">(</a><a id="4143" href="Cat.Abelian.Base.html#4143" class="Bound">h</a> <a id="4145" class="Symbol">:</a> <a id="4147" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">Hom</a> <a id="4151" href="Cat.Abelian.Base.html#4119" class="Bound">A</a> <a id="4153" href="Cat.Abelian.Base.html#4121" class="Bound">B</a><a id="4154" class="Symbol">)</a>
    <a id="4160" class="Symbol">→</a> <a id="4162" class="Symbol">(</a><a id="4163" href="Cat.Abelian.Base.html#4127" class="Bound">f</a> <a id="4165" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="4167" href="Cat.Abelian.Base.html#4143" class="Bound">h</a><a id="4168" class="Symbol">)</a> <a id="4170" href="Cat.Abelian.Base.html#2361" class="Function Operator">-</a> <a id="4172" class="Symbol">(</a><a id="4173" href="Cat.Abelian.Base.html#4129" class="Bound">g</a> <a id="4175" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="4177" href="Cat.Abelian.Base.html#4143" class="Bound">h</a><a id="4178" class="Symbol">)</a> <a id="4180" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="4182" class="Symbol">(</a><a id="4183" href="Cat.Abelian.Base.html#4127" class="Bound">f</a> <a id="4185" href="Cat.Abelian.Base.html#2361" class="Function Operator">-</a> <a id="4187" href="Cat.Abelian.Base.html#4129" class="Bound">g</a><a id="4188" class="Symbol">)</a> <a id="4190" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="4192" href="Cat.Abelian.Base.html#4143" class="Bound">h</a>
  <a id="4196" href="Cat.Abelian.Base.html#4100" data-type="(r : Ab-category C) (f g : Hom r B₁ C) (h : Hom r A B₁) →
(r - (r ∘ f) h) ((r ∘ g) h) ≡ (r ∘ (r - f) g) h" class="Function">∘-minus-l</a> <a id="4206" href="Cat.Abelian.Base.html#4206" class="Bound">f</a> <a id="4208" href="Cat.Abelian.Base.html#4208" class="Bound">g</a> <a id="4210" href="Cat.Abelian.Base.html#4210" class="Bound">h</a> <a id="4212" class="Symbol">=</a>
    <a id="4218" href="Cat.Abelian.Base.html#4206" class="Bound">f</a> <a id="4220" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="4222" href="Cat.Abelian.Base.html#4210" class="Bound">h</a> <a id="4224" href="Cat.Abelian.Base.html#2361" class="Function Operator">-</a> <a id="4226" href="Cat.Abelian.Base.html#4208" class="Bound">g</a> <a id="4228" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="4230" href="Cat.Abelian.Base.html#4210" class="Bound">h</a>               <span class="reasoning-step"><span class="as-written Function"><a id="4246" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="4249" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="4252" class="Symbol">(</a><a id="4253" href="Cat.Abelian.Base.html#4206" class="Bound">f</a> <a id="4255" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="4257" href="Cat.Abelian.Base.html#4210" class="Bound">h</a> <a id="4259" href="Cat.Abelian.Base.html#1445" data-type="(r : Ab-category C) → Hom r A B₁ → Hom r A B₁ → Hom r A B₁" class="Function Operator">+_</a><a id="4261" class="Symbol">)</a> <a id="4263" href="Cat.Abelian.Base.html#3594" data-type="(r : Ab-category C) → inverse r ((r ∘ g) h) ≡ (r ∘ inverse r g) h" class="Function">neg-∘-l</a> <a id="4271" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="4277" href="Cat.Abelian.Base.html#4206" class="Bound">f</a> <a id="4279" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="4281" href="Cat.Abelian.Base.html#4210" class="Bound">h</a> <a id="4283" href="Cat.Abelian.Base.html#1445" data-type="(r : Ab-category C) → Hom r A B₁ → Hom r A B₁ → Hom r A B₁" class="Function Operator">+</a> <a id="4285" class="Symbol">(</a><a id="4286" href="Algebra.Group.html#1320" data-type="is-group _*₁_ → A → A" class="Function">Hom.inverse</a> <a id="4298" href="Cat.Abelian.Base.html#4208" class="Bound">g</a> <a id="4300" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="4302" href="Cat.Abelian.Base.html#4210" class="Bound">h</a><a id="4303" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function"><a id="4305" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="4308" href="Cat.Abelian.Base.html#1800" data-type="(r : Ab-category C) (f g : Hom C B₁ C) (h : Hom C A B₁) →
r .Group-on-hom A C ._⋆_ ((C ∘ f) h) ((C ∘ g) h) ≡
(C ∘ r .Group-on-hom B₁ C ._⋆_ f g) h" class="Field">∘-linear-l</a> <a id="4319" class="Symbol">_</a> <a id="4321" class="Symbol">_</a> <a id="4323" class="Symbol">_</a> <a id="4325" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="4331" class="Symbol">(</a><a id="4332" href="Cat.Abelian.Base.html#4206" class="Bound">f</a> <a id="4334" href="Cat.Abelian.Base.html#2361" class="Function Operator">-</a> <a id="4336" href="Cat.Abelian.Base.html#4208" class="Bound">g</a><a id="4337" class="Symbol">)</a> <a id="4339" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="4341" href="Cat.Abelian.Base.html#4210" class="Bound">h</a>                 <a id="4359" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>

  <a id="Ab-category.∘-minus-r"></a><a id="4364" href="Cat.Abelian.Base.html#4364" data-type="(r : Ab-category C) (f : Hom r B₁ C) (g h : Hom r A B₁) →
(r - (r ∘ f) g) ((r ∘ f) h) ≡ (r ∘ f) ((r - g) h)" class="Function">∘-minus-r</a>
    <a id="4378" class="Symbol">:</a> <a id="4380" class="Symbol">∀</a> <a id="4382" class="Symbol">{</a><a id="4383" href="Cat.Abelian.Base.html#4383" class="Bound">A</a> <a id="4385" href="Cat.Abelian.Base.html#4385" class="Bound">B</a> <a id="4387" href="Cat.Abelian.Base.html#4387" class="Bound">C</a><a id="4388" class="Symbol">}</a> <a id="4390" class="Symbol">(</a><a id="4391" href="Cat.Abelian.Base.html#4391" class="Bound">f</a> <a id="4393" class="Symbol">:</a> <a id="4395" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">Hom</a> <a id="4399" href="Cat.Abelian.Base.html#4385" class="Bound">B</a> <a id="4401" href="Cat.Abelian.Base.html#4387" class="Bound">C</a><a id="4402" class="Symbol">)</a> <a id="4404" class="Symbol">(</a><a id="4405" href="Cat.Abelian.Base.html#4405" class="Bound">g</a> <a id="4407" href="Cat.Abelian.Base.html#4407" class="Bound">h</a> <a id="4409" class="Symbol">:</a> <a id="4411" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">Hom</a> <a id="4415" href="Cat.Abelian.Base.html#4383" class="Bound">A</a> <a id="4417" href="Cat.Abelian.Base.html#4385" class="Bound">B</a><a id="4418" class="Symbol">)</a>
    <a id="4424" class="Symbol">→</a> <a id="4426" class="Symbol">(</a><a id="4427" href="Cat.Abelian.Base.html#4391" class="Bound">f</a> <a id="4429" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="4431" href="Cat.Abelian.Base.html#4405" class="Bound">g</a><a id="4432" class="Symbol">)</a> <a id="4434" href="Cat.Abelian.Base.html#2361" class="Function Operator">-</a> <a id="4436" class="Symbol">(</a><a id="4437" href="Cat.Abelian.Base.html#4391" class="Bound">f</a> <a id="4439" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="4441" href="Cat.Abelian.Base.html#4407" class="Bound">h</a><a id="4442" class="Symbol">)</a> <a id="4444" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="4446" href="Cat.Abelian.Base.html#4391" class="Bound">f</a> <a id="4448" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="4450" class="Symbol">(</a><a id="4451" href="Cat.Abelian.Base.html#4405" class="Bound">g</a> <a id="4453" href="Cat.Abelian.Base.html#2361" class="Function Operator">-</a> <a id="4455" href="Cat.Abelian.Base.html#4407" class="Bound">h</a><a id="4456" class="Symbol">)</a>
  <a id="4460" href="Cat.Abelian.Base.html#4364" data-type="(r : Ab-category C) (f : Hom r B₁ C) (g h : Hom r A B₁) →
(r - (r ∘ f) g) ((r ∘ f) h) ≡ (r ∘ f) ((r - g) h)" class="Function">∘-minus-r</a> <a id="4470" href="Cat.Abelian.Base.html#4470" class="Bound">f</a> <a id="4472" href="Cat.Abelian.Base.html#4472" class="Bound">g</a> <a id="4474" href="Cat.Abelian.Base.html#4474" class="Bound">h</a> <a id="4476" class="Symbol">=</a>
    <a id="4482" href="Cat.Abelian.Base.html#4470" class="Bound">f</a> <a id="4484" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="4486" href="Cat.Abelian.Base.html#4472" class="Bound">g</a> <a id="4488" href="Cat.Abelian.Base.html#2361" class="Function Operator">-</a> <a id="4490" href="Cat.Abelian.Base.html#4470" class="Bound">f</a> <a id="4492" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="4494" href="Cat.Abelian.Base.html#4474" class="Bound">h</a>               <span class="reasoning-step"><span class="as-written Function"><a id="4510" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="4513" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="4516" class="Symbol">(</a><a id="4517" href="Cat.Abelian.Base.html#4470" class="Bound">f</a> <a id="4519" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="4521" href="Cat.Abelian.Base.html#4472" class="Bound">g</a> <a id="4523" href="Cat.Abelian.Base.html#1445" data-type="(r : Ab-category C) → Hom r A B₁ → Hom r A B₁ → Hom r A B₁" class="Function Operator">+_</a><a id="4525" class="Symbol">)</a> <a id="4527" href="Cat.Abelian.Base.html#3847" data-type="(r : Ab-category C) → inverse r ((r ∘ g) h) ≡ (r ∘ g) (inverse r h)" class="Function">neg-∘-r</a> <a id="4535" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="4541" href="Cat.Abelian.Base.html#4470" class="Bound">f</a> <a id="4543" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="4545" href="Cat.Abelian.Base.html#4472" class="Bound">g</a> <a id="4547" href="Cat.Abelian.Base.html#1445" data-type="(r : Ab-category C) → Hom r A B₁ → Hom r A B₁ → Hom r A B₁" class="Function Operator">+</a> <a id="4549" class="Symbol">(</a><a id="4550" href="Cat.Abelian.Base.html#4470" class="Bound">f</a> <a id="4552" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="4554" href="Algebra.Group.html#1320" data-type="is-group _*₁_ → A → A" class="Function">Hom.inverse</a> <a id="4566" href="Cat.Abelian.Base.html#4474" class="Bound">h</a><a id="4567" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function"><a id="4569" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="4572" href="Cat.Abelian.Base.html#1903" data-type="(r : Ab-category C) (f : Hom C B₁ C) (g h : Hom C A B₁) →
r .Group-on-hom A C ._⋆_ ((C ∘ f) g) ((C ∘ f) h) ≡
(C ∘ f) (r .Group-on-hom A B₁ ._⋆_ g h)" class="Field">∘-linear-r</a> <a id="4583" class="Symbol">_</a> <a id="4585" class="Symbol">_</a> <a id="4587" class="Symbol">_</a> <a id="4589" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="4595" href="Cat.Abelian.Base.html#4470" class="Bound">f</a> <a id="4597" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="4599" class="Symbol">(</a><a id="4600" href="Cat.Abelian.Base.html#4472" class="Bound">g</a> <a id="4602" href="Cat.Abelian.Base.html#2361" class="Function Operator">-</a> <a id="4604" href="Cat.Abelian.Base.html#4474" class="Bound">h</a><a id="4605" class="Symbol">)</a>                 <a id="4623" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
</pre>
</details>
<p>Before moving on, we note the following property of
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi><mi mathvariant="bold">b</mi></mrow><annotation encoding="application/x-tex">\Ab</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathbf">Ab</span></span></span></span></span>-categories:</span>
If
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>
is an object s.t.
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi></mrow><mi>A</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\id{id}_{A} = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">id</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>,</span>
then
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>
is a zero object.</p>
<pre class="Agda"><a id="4792" class="Keyword">module</a> <a id="4799" href="Cat.Abelian.Base.html#4799" class="Module">_</a> <a id="4801" class="Symbol">{</a><a id="4802" href="Cat.Abelian.Base.html#4802" class="Bound">o</a> <a id="4804" href="Cat.Abelian.Base.html#4804" class="Bound">ℓ</a><a id="4805" class="Symbol">}</a> <a id="4807" class="Symbol">{</a><a id="4808" href="Cat.Abelian.Base.html#4808" class="Bound">C</a> <a id="4810" class="Symbol">:</a> <a id="4812" href="Cat.Base.html#704" data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" class="Record">Precategory</a> <a id="4824" href="Cat.Abelian.Base.html#4802" class="Bound">o</a> <a id="4826" href="Cat.Abelian.Base.html#4804" class="Bound">ℓ</a><a id="4827" class="Symbol">}</a> <a id="4829" class="Symbol">(</a><a id="4830" href="Cat.Abelian.Base.html#4830" class="Bound">A</a> <a id="4832" class="Symbol">:</a> <a id="4834" href="Cat.Abelian.Base.html#1302" data-type="(C : Precategory o ℓ) → Type (o ⊔ lsuc ℓ)" class="Record">Ab-category</a> <a id="4846" href="Cat.Abelian.Base.html#4808" class="Bound">C</a><a id="4847" class="Symbol">)</a> <a id="4849" class="Keyword">where</a>
  <a id="4857" class="Keyword">private</a> <a id="4865" class="Keyword">module</a> <a id="4872" href="Cat.Abelian.Base.html#4872" class="Module">A</a> <a id="4874" class="Symbol">=</a> <a id="4876" href="Cat.Abelian.Base.html#1302" data-type="(C : Precategory o ℓ) → Type (o ⊔ lsuc ℓ)" class="Module">Ab-category</a> <a id="4888" href="Cat.Abelian.Base.html#4830" class="Bound">A</a>

  <a id="4893" href="Cat.Abelian.Base.html#4893" data-type="(A : Ab-category C) → id A ≡ 0m A → is-zero A A₁" class="Function">id-zero→zero</a> <a id="4906" class="Symbol">:</a> <a id="4908" class="Symbol">∀</a> <a id="4910" class="Symbol">{</a><a id="4911" href="Cat.Abelian.Base.html#4911" class="Bound">A</a><a id="4912" class="Symbol">}</a> <a id="4914" class="Symbol">→</a> <a id="4916" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">A.id</a> <a id="4921" class="Symbol">{</a><a id="4922" href="Cat.Abelian.Base.html#4911" class="Bound">A</a><a id="4923" class="Symbol">}</a> <a id="4925" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="4927" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">A.0m</a> <a id="4932" class="Symbol">→</a> <a id="4934" href="Cat.Diagram.Zero.html#408" data-type="(C : Precategory o h) (ob : Ob C) → Type (o ⊔ h)" class="Record">A.is-zero</a> <a id="4944" href="Cat.Abelian.Base.html#4911" class="Bound">A</a>
  <a id="4948" href="Cat.Abelian.Base.html#4893" data-type="(A : Ab-category C) → id A ≡ 0m A → is-zero A A₁" class="Function">id-zero→zero</a> <a id="4961" href="Cat.Abelian.Base.html#4961" class="Bound">idm</a> <a id="4965" class="Symbol">.</a><a id="4966" href="Cat.Diagram.Zero.html#459" data-type="is-zero C ob → is-initial C ob" class="Field">A.is-zero.has-is-initial</a> <a id="4991" href="Cat.Abelian.Base.html#4991" class="Bound">B</a> <a id="4993" class="Symbol">=</a> <a id="4995" href="1Lab.HLevel.html#1383" data-type="(centre₁ : A) (paths₁ : (x : A) → centre₁ ≡ x) → is-contr A" class="InductiveConstructor">contr</a> <a id="5001" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">A.0m</a> <a id="5006" class="Symbol">λ</a> <a id="5008" href="Cat.Abelian.Base.html#5008" class="Bound">h</a> <a id="5010" class="Symbol">→</a> <a id="5012" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="5016" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a>
    <a id="5022" href="Cat.Abelian.Base.html#5008" class="Bound">h</a>                                <span class="reasoning-step"><span class="as-written Function"><a id="5055" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="5058" href="Cat.Reasoning.html#1250" data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → f ≡ (C ∘ f) a" class="Function">A.intror</a> <a id="5067" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="5072" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="5078" href="Cat.Abelian.Base.html#5008" class="Bound">h</a> <a id="5080" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">A.∘</a> <a id="5084" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">A.id</a>                       <span class="reasoning-step"><span class="as-written Function"><a id="5111" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="5114" href="Cat.Reasoning.html#4627" data-type="(C : Precategory o ℓ) → g ≡ h → (C ∘ f) g ≡ (C ∘ f) h" class="Function Operator">A.refl⟩∘⟨</a> <a id="5124" href="Cat.Abelian.Base.html#4961" class="Bound">idm</a> <a id="5128" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="5134" href="Cat.Abelian.Base.html#5008" class="Bound">h</a> <a id="5136" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">A.∘</a> <a id="5140" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">A.0m</a>                       <span class="reasoning-step"><span class="as-written Function"><a id="5167" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="5170" href="Cat.Abelian.Base.html#2648" data-type="(r : Ab-category C) → (r ∘ f) (0m r) ≡ 0m r" class="Function">A.∘-zero-r</a> <a id="5181" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="5187" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">A.0m</a>                             <a id="5220" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
  <a id="5224" href="Cat.Abelian.Base.html#4893" data-type="(A : Ab-category C) → id A ≡ 0m A → is-zero A A₁" class="Function">id-zero→zero</a> <a id="5237" href="Cat.Abelian.Base.html#5237" class="Bound">idm</a> <a id="5241" class="Symbol">.</a><a id="5242" href="Cat.Diagram.Zero.html#495" data-type="is-zero C ob → is-terminal C ob" class="Field">A.is-zero.has-is-terminal</a> <a id="5268" href="Cat.Abelian.Base.html#5268" class="Bound">x</a> <a id="5270" class="Symbol">=</a> <a id="5272" href="1Lab.HLevel.html#1383" data-type="(centre₁ : A) (paths₁ : (x : A) → centre₁ ≡ x) → is-contr A" class="InductiveConstructor">contr</a> <a id="5278" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">A.0m</a> <a id="5283" class="Symbol">λ</a> <a id="5285" href="Cat.Abelian.Base.html#5285" class="Bound">h</a> <a id="5287" class="Symbol">→</a> <a id="5289" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="5293" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a>
    <a id="5299" href="Cat.Abelian.Base.html#5285" class="Bound">h</a>                              <span class="reasoning-step"><span class="as-written Function"><a id="5330" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="5333" href="Cat.Reasoning.html#1207" data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → f ≡ (C ∘ a) f" class="Function">A.introl</a> <a id="5342" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="5347" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="5353" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">A.id</a> <a id="5358" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">A.∘</a> <a id="5362" href="Cat.Abelian.Base.html#5285" class="Bound">h</a>                     <span class="reasoning-step"><span class="as-written Function"><a id="5384" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="5387" href="Cat.Abelian.Base.html#5237" class="Bound">idm</a> <a id="5391" href="Cat.Reasoning.html#4694" data-type="(C : Precategory o ℓ) → f ≡ h → (C ∘ f) g ≡ (C ∘ h) g" class="Function Operator">A.⟩∘⟨refl</a> <a id="5401" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="5407" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">A.0m</a> <a id="5412" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">A.∘</a> <a id="5416" href="Cat.Abelian.Base.html#5285" class="Bound">h</a>                     <span class="reasoning-step"><span class="as-written Function"><a id="5438" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="5441" href="Cat.Abelian.Base.html#3063" data-type="(r : Ab-category C) → (r ∘ 0m r) f ≡ 0m r" class="Function">A.∘-zero-l</a> <a id="5452" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="5458" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">A.0m</a>                           <a id="5489" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
</pre>
<p>Perhaps the simplest example of an
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi><mi mathvariant="bold">b</mi></mrow><annotation encoding="application/x-tex">\Ab</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathbf">Ab</span></span></span></span></span>-category</span>
is.. any ring! In the same way that a monoid is a category with one
object, and a group is a groupoid with one object, a ring is a
<em>ringoid</em> with one object; Ringoid being another word for
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi><mi mathvariant="bold">b</mi></mrow><annotation encoding="application/x-tex">\Ab</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathbf">Ab</span></span></span></span></span>-category,</span>
rather than a horizontal categorification of the drummer for the
Beatles. The next simplest example is
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi><mi mathvariant="bold">b</mi></mrow><annotation encoding="application/x-tex">\Ab</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathbf">Ab</span></span></span></span></span>
itself:</p>
<pre class="Agda"><a id="5877" class="Keyword">module</a> <a id="5884" href="Cat.Abelian.Base.html#5884" class="Module">_</a> <a id="5886" class="Keyword">where</a>
  <a id="5894" class="Keyword">open</a> <a id="5899" href="Cat.Abelian.Base.html#1302" data-type="(C : Precategory o ℓ) → Type (o ⊔ lsuc ℓ)" class="Module">Ab-category</a>
  <a id="5913" href="Cat.Abelian.Base.html#5913" data-type="Ab-category (Ab ℓ)" class="Function">Ab-ab-category</a> <a id="5928" class="Symbol">:</a> <a id="5930" class="Symbol">∀</a> <a id="5932" class="Symbol">{</a><a id="5933" href="Cat.Abelian.Base.html#5933" class="Bound">ℓ</a><a id="5934" class="Symbol">}</a> <a id="5936" class="Symbol">→</a> <a id="5938" href="Cat.Abelian.Base.html#1302" data-type="(C : Precategory o ℓ) → Type (o ⊔ lsuc ℓ)" class="Record">Ab-category</a> <a id="5950" class="Symbol">(</a><a id="5951" href="Algebra.Group.Ab.html#1491" data-type="(ℓ : Level) → Precategory (lsuc ℓ) ℓ" class="Function">Ab</a> <a id="5954" href="Cat.Abelian.Base.html#5933" class="Bound">ℓ</a><a id="5955" class="Symbol">)</a>
  <a id="5959" href="Cat.Abelian.Base.html#5913" data-type="Ab-category (Ab ℓ)" class="Function">Ab-ab-category</a> <a id="5974" class="Symbol">.</a><a id="5975" href="Cat.Abelian.Base.html#1400" data-type="Ab-category C → (A B₁ : C .Ob) → Group-on (Hom C A B₁)" class="Field">Group-on-hom</a> <a id="5988" href="Cat.Abelian.Base.html#5988" class="Bound">A</a> <a id="5990" href="Cat.Abelian.Base.html#5990" class="Bound">B</a> <a id="5992" class="Symbol">=</a> <a id="5994" href="Algebra.Group.Ab.html#3543" data-type="(A B₁ : AbGroup ℓ) → AbGroup ℓ" class="Function">Hom-group</a> <a id="6004" href="Cat.Abelian.Base.html#5988" class="Bound">A</a> <a id="6006" href="Cat.Abelian.Base.html#5990" class="Bound">B</a> <a id="6008" class="Symbol">.</a><a id="6009" href="Cat.Functor.FullSubcategory.html#1063" data-type="Restrict-ob P → Ob C" class="Field">object</a> <a id="6016" class="Symbol">.</a><a id="6017" href="Agda.Builtin.Sigma.html#264" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a>
  <a id="6023" href="Cat.Abelian.Base.html#5913" data-type="Ab-category (Ab ℓ)" class="Function">Ab-ab-category</a> <a id="6038" class="Symbol">.</a><a id="6039" href="Cat.Abelian.Base.html#1608" data-type="(r : Ab-category C) (A B₁ : C .Ob) (f g : Hom C A B₁) →
r .Group-on-hom A B₁ ._⋆_ f g ≡ r .Group-on-hom A B₁ ._⋆_ g f" class="Field">Hom-grp-ab</a> <a id="6050" href="Cat.Abelian.Base.html#6050" class="Bound">A</a> <a id="6052" href="Cat.Abelian.Base.html#6052" class="Bound">B</a> <a id="6054" class="Symbol">=</a> <a id="6056" href="Algebra.Group.Ab.html#3543" data-type="(A B₁ : AbGroup ℓ) → AbGroup ℓ" class="Function">Hom-group</a> <a id="6066" href="Cat.Abelian.Base.html#6050" class="Bound">A</a> <a id="6068" href="Cat.Abelian.Base.html#6052" class="Bound">B</a> <a id="6070" class="Symbol">.</a><a id="6071" href="Cat.Functor.FullSubcategory.html#1081" data-type="(r : Restrict-ob P) → P (r .object)" class="Field">witness</a>
  <a id="6081" href="Cat.Abelian.Base.html#5913" data-type="Ab-category (Ab ℓ)" class="Function">Ab-ab-category</a> <a id="6096" class="Symbol">.</a><a id="6097" href="Cat.Abelian.Base.html#1800" data-type="(r : Ab-category C) (f g : Hom C B₁ C) (h : Hom C A B₁) →
r .Group-on-hom A C ._⋆_ ((C ∘ f) h) ((C ∘ g) h) ≡
(C ∘ r .Group-on-hom B₁ C ._⋆_ f g) h" class="Field">∘-linear-l</a> <a id="6108" href="Cat.Abelian.Base.html#6108" class="Bound">f</a> <a id="6110" href="Cat.Abelian.Base.html#6110" class="Bound">g</a> <a id="6112" href="Cat.Abelian.Base.html#6112" class="Bound">h</a> <a id="6114" class="Symbol">=</a> <a id="6116" href="Algebra.Group.Cat.Base.html#1867" data-type="is-faithful Forget" class="Function">Grp.Forget-is-faithful</a> <a id="6139" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
  <a id="6146" href="Cat.Abelian.Base.html#5913" data-type="Ab-category (Ab ℓ)" class="Function">Ab-ab-category</a> <a id="6161" class="Symbol">.</a><a id="6162" href="Cat.Abelian.Base.html#1903" data-type="(r : Ab-category C) (f : Hom C B₁ C) (g h : Hom C A B₁) →
r .Group-on-hom A C ._⋆_ ((C ∘ f) g) ((C ∘ f) h) ≡
(C ∘ f) (r .Group-on-hom A B₁ ._⋆_ g h)" class="Field">∘-linear-r</a> <a id="6173" href="Cat.Abelian.Base.html#6173" class="Bound">f</a> <a id="6175" href="Cat.Abelian.Base.html#6175" class="Bound">g</a> <a id="6177" href="Cat.Abelian.Base.html#6177" class="Bound">h</a> <a id="6179" class="Symbol">=</a> <a id="6181" href="Algebra.Group.Cat.Base.html#1867" data-type="is-faithful Forget" class="Function">Grp.Forget-is-faithful</a> <a id="6204" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="6206" href="1Lab.Path.html#58486" data-type="((x : A) → f x ≡ g x) → f ≡ g" class="Function">funext</a> <a id="6213" class="Symbol">λ</a> <a id="6215" href="Cat.Abelian.Base.html#6215" class="Bound">x</a> <a id="6217" class="Symbol">→</a>
    <a id="6223" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="6227" class="Symbol">(</a><a id="6228" href="Cat.Abelian.Base.html#6173" class="Bound">f</a> <a id="6230" class="Symbol">.</a><a id="6231" href="Agda.Builtin.Sigma.html#264" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="6235" class="Symbol">.</a><a id="6236" href="Algebra.Group.html#6449" data-type="Group-hom A B₁ e →
(x y : A .fst) → e (A .snd ._⋆_ x y) ≡ B₁ .snd ._⋆_ (e x) (e y)" class="Field">Group-hom.pres-⋆</a> <a id="6253" class="Symbol">_</a> <a id="6255" class="Symbol">_)</a>
</pre>
<h1 id="additive-categories"><a href="#additive-categories" class="header-link">Additive
categories<span class="header-link-emoji">🔗</span></a></h1>
<p>An
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi><mi mathvariant="bold">b</mi></mrow><annotation encoding="application/x-tex">\Ab</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathbf">Ab</span></span></span></span></span>-category</span>
is <strong>additive</strong> when its underlying category has a terminal
object and finite products; By the yoga above, this implies that the
terminal object is also a zero object, and the finite products coincide
with finite coproducts.</p>
<pre class="Agda"><a id="6538" class="Keyword">record</a> <a id="is-additive"></a><a id="6545" href="Cat.Abelian.Base.html#6545" data-type="(C : Precategory o ℓ) → Type (o ⊔ lsuc ℓ)" class="Record">is-additive</a> <a id="6557" class="Symbol">{</a><a id="6558" href="Cat.Abelian.Base.html#6558" class="Bound">o</a> <a id="6560" href="Cat.Abelian.Base.html#6560" class="Bound">ℓ</a><a id="6561" class="Symbol">}</a> <a id="6563" class="Symbol">(</a><a id="6564" href="Cat.Abelian.Base.html#6564" class="Bound">C</a> <a id="6566" class="Symbol">:</a> <a id="6568" href="Cat.Base.html#704" data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" class="Record">Precategory</a> <a id="6580" href="Cat.Abelian.Base.html#6558" class="Bound">o</a> <a id="6582" href="Cat.Abelian.Base.html#6560" class="Bound">ℓ</a><a id="6583" class="Symbol">)</a> <a id="6585" class="Symbol">:</a> <a id="6587" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="6592" class="Symbol">(</a><a id="6593" href="Cat.Abelian.Base.html#6558" class="Bound">o</a> <a id="6595" href="Agda.Primitive.html#810" data-type="Level → Level → Level" class="Primitive Operator">⊔</a> <a id="6597" href="Agda.Primitive.html#780" data-type="Level → Level" class="Primitive">lsuc</a> <a id="6602" href="Cat.Abelian.Base.html#6560" class="Bound">ℓ</a><a id="6603" class="Symbol">)</a> <a id="6605" class="Keyword">where</a>
  <a id="6613" class="Keyword">field</a> <a id="is-additive.has-ab"></a><a id="6619" href="Cat.Abelian.Base.html#6619" data-type="is-additive C → Ab-category C" class="Field">has-ab</a> <a id="6626" class="Symbol">:</a> <a id="6628" href="Cat.Abelian.Base.html#1302" data-type="(C : Precategory o ℓ) → Type (o ⊔ lsuc ℓ)" class="Record">Ab-category</a> <a id="6640" href="Cat.Abelian.Base.html#6564" class="Bound">C</a>
  <a id="6644" class="Keyword">open</a> <a id="6649" href="Cat.Abelian.Base.html#1302" data-type="(C : Precategory o ℓ) → Type (o ⊔ lsuc ℓ)" class="Module">Ab-category</a> <a id="6661" href="Cat.Abelian.Base.html#6619" data-type="is-additive C → Ab-category C" class="Field">has-ab</a> <a id="6668" class="Keyword">public</a>

  <a id="6678" class="Keyword">field</a>
    <a id="is-additive.has-terminal"></a><a id="6688" href="Cat.Abelian.Base.html#6688" data-type="(r : is-additive C) → Terminal r" class="Field">has-terminal</a> <a id="6701" class="Symbol">:</a> <a id="6703" href="Cat.Diagram.Terminal.html#406" data-type="(C : Precategory o h) → Type (o ⊔ h)" class="Record">Terminal</a>
    <a id="is-additive.has-prods"></a><a id="6716" href="Cat.Abelian.Base.html#6716" data-type="(r : is-additive C) (A B₁ : Ob C) → Product r A B₁" class="Field">has-prods</a>    <a id="6729" class="Symbol">:</a> <a id="6731" class="Symbol">∀</a> <a id="6733" href="Cat.Abelian.Base.html#6733" class="Bound">A</a> <a id="6735" href="Cat.Abelian.Base.html#6735" class="Bound">B</a> <a id="6737" class="Symbol">→</a> <a id="6739" href="Cat.Diagram.Product.html#2703" data-type="(C : Precategory o h) (A B₁ : Ob C) → Type (o ⊔ h)" class="Record">Product</a> <a id="6747" href="Cat.Abelian.Base.html#6733" class="Bound">A</a> <a id="6749" href="Cat.Abelian.Base.html#6735" class="Bound">B</a>

  <a id="is-additive.∅"></a><a id="6754" href="Cat.Abelian.Base.html#6754" data-type="(r : is-additive C) → Zero r" class="Function">∅</a> <a id="6756" class="Symbol">:</a> <a id="6758" href="Cat.Diagram.Zero.html#536" data-type="(C : Precategory o h) → Type (o ⊔ h)" class="Record">Zero</a>
  <a id="6765" href="Cat.Abelian.Base.html#6754" data-type="(r : is-additive C) → Zero r" class="Function">∅</a> <a id="6767" class="Symbol">.</a><a id="6768" href="Cat.Diagram.Zero.html#574" data-type="Zero C → Ob C" class="Field">Zero.∅</a> <a id="6775" class="Symbol">=</a> <a id="6777" href="Cat.Abelian.Base.html#6688" data-type="(r : is-additive C) → Terminal r" class="Field">has-terminal</a> <a id="6790" class="Symbol">.</a><a id="6791" href="Cat.Diagram.Terminal.html#448" data-type="Terminal C → Ob C" class="Field">Terminal.top</a>
  <a id="6806" href="Cat.Abelian.Base.html#6754" data-type="(r : is-additive C) → Zero r" class="Function">∅</a> <a id="6808" class="Symbol">.</a><a id="6809" href="Cat.Diagram.Zero.html#591" data-type="(r : Zero C) → is-zero C (r .∅)" class="Field">Zero.has-is-zero</a> <a id="6826" class="Symbol">=</a> <a id="6828" href="Cat.Abelian.Base.html#4893" data-type="(A : Ab-category C) → id A ≡ 0m A → is-zero A A₁" class="Function">id-zero→zero</a> <a id="6841" href="Cat.Abelian.Base.html#6619" data-type="is-additive C → Ab-category C" class="Field">has-ab</a> <a id="6848" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a>
    <a id="6854" href="1Lab.HLevel.html#3818" data-type="is-contr A → is-prop A" class="Function">is-contr→is-prop</a> <a id="6871" class="Symbol">(</a><a id="6872" href="Cat.Abelian.Base.html#6688" data-type="(r : is-additive C) → Terminal r" class="Field">has-terminal</a> <a id="6885" class="Symbol">.</a><a id="6886" href="Cat.Diagram.Terminal.html#461" data-type="(r : Terminal C) → is-terminal C (r .top)" class="Field">Terminal.has⊤</a> <a id="6900" class="Symbol">_)</a> <a id="6903" class="Symbol">_</a> <a id="6905" class="Symbol">_</a>
  <a id="6909" class="Keyword">module</a> <a id="is-additive.∅"></a><a id="6916" href="Cat.Abelian.Base.html#6916" class="Module">∅</a> <a id="6918" class="Symbol">=</a> <a id="6920" href="Cat.Diagram.Zero.html#536" data-type="(C : Precategory o h) → Type (o ⊔ h)" class="Module">Zero</a> <a id="6925" href="Cat.Abelian.Base.html#6754" data-type="(r : is-additive C) → Zero r" class="Function">∅</a>

  <a id="is-additive.0m-unique"></a><a id="6930" href="Cat.Abelian.Base.html#6930" data-type="(r : is-additive C) → zero→ r ≡ 0m r" class="Function">0m-unique</a> <a id="6940" class="Symbol">:</a> <a id="6942" class="Symbol">∀</a> <a id="6944" class="Symbol">{</a><a id="6945" href="Cat.Abelian.Base.html#6945" class="Bound">A</a> <a id="6947" href="Cat.Abelian.Base.html#6947" class="Bound">B</a><a id="6948" class="Symbol">}</a> <a id="6950" class="Symbol">→</a> <a id="6952" href="Cat.Diagram.Zero.html#1010" data-type="Zero C → Hom C x y" class="Function">∅.zero→</a> <a id="6960" class="Symbol">{</a><a id="6961" href="Cat.Abelian.Base.html#6945" class="Bound">A</a><a id="6962" class="Symbol">}</a> <a id="6964" class="Symbol">{</a><a id="6965" href="Cat.Abelian.Base.html#6947" class="Bound">B</a><a id="6966" class="Symbol">}</a> <a id="6968" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="6970" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a>
  <a id="6975" href="Cat.Abelian.Base.html#6930" data-type="(r : is-additive C) → zero→ r ≡ 0m r" class="Function">0m-unique</a> <a id="6985" class="Symbol">=</a> <a id="6987" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="6991" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">_∘_</a> <a id="6995" class="Symbol">(</a><a id="6996" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Function">∅.has⊥</a> <a id="7003" class="Symbol">_</a> <a id="7005" class="Symbol">.</a><a id="7006" href="1Lab.HLevel.html#1416" data-type="(r : is-contr A) (x : A) → r .centre ≡ x" class="Field">paths</a> <a id="7012" class="Symbol">_)</a> <a id="7015" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="7020" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="7022" href="Cat.Abelian.Base.html#3063" data-type="(r : Ab-category C) → (r ∘ 0m r) f ≡ 0m r" class="Function">∘-zero-l</a>
</pre>
<p>Coincidence of finite products and finite coproducts leads to an
object commonly called a (finite) <strong>biproduct</strong>. The
coproduct coprojections are given by the pair of maps</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi></mrow><mo>×</mo><mn>0</mn><mo stretchy="false">)</mo><mo>:</mo><mi>A</mi><mo>→</mo><mi>A</mi><mo>×</mo><mi>B</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo stretchy="false">(</mo><mn>0</mn><mo>×</mo><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi></mrow><mo stretchy="false">)</mo><mo>:</mo><mi>B</mi><mo>→</mo><mi>A</mi><mo>×</mo><mi>B</mi><mtext>,</mtext></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{align*}
&amp;(\id{id} \times 0) : A \to A \times B \\
&amp;(0 \times \id{id}) : B \to A \times B\text{,}
\end{align*}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.75em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">id</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mopen">(</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathrm">id</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord text"><span class="mord">,</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>respectively, and the comultiplication of
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>
and
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span>
is given by
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><msub><mi>π</mi><mn>1</mn></msub><mo>+</mo><mi>g</mi><msub><mi>π</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">f\pi_1 + g\pi_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</span>
We can calculate, for the first coprojection followed by
comultiplication,</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo stretchy="false">(</mo><mi>f</mi><msub><mi>π</mi><mn>1</mn></msub><mo>+</mo><mi>g</mi><msub><mi>π</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi></mrow><mo>×</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mo lspace="0em" rspace="0em">=</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mi>f</mi><msub><mi>π</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi></mrow><mo>×</mo><mn>0</mn><mo stretchy="false">)</mo><mo>+</mo><mi>g</mi><msub><mi>π</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi></mrow><mo>×</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mo lspace="0em" rspace="0em">=</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mi>f</mi><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi></mrow><mo>+</mo><mi>g</mi><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mo lspace="0em" rspace="0em">=</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mi>f</mi><mtext>,</mtext></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{align*}
&amp; (f\pi_1+g\pi_2)(\id{id}\times 0) \\
=&amp; f\pi_1(\id{id}\times 0) + g\pi_2(\id{id}\times 0) \\
=&amp; f\id{id} + g0 \\
=&amp; f\text{,}
\end{align*}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:6em;vertical-align:-2.75em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.25em;"><span style="top:-5.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mrel">=</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mrel">=</span></span></span><span style="top:-0.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mrel">=</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.75em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.25em;"><span style="top:-5.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">id</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">id</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">id</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathrm">id</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord">0</span></span></span><span style="top:-0.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord text"><span class="mord">,</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.75em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>and analogously for the second coprojection followed by
comultiplication.</p>
<pre class="Agda">  <a id="is-additive.has-coprods"></a><a id="7741" href="Cat.Abelian.Base.html#7741" data-type="(r : is-additive C) (A B₁ : Ob C) → Coproduct r A B₁" class="Function">has-coprods</a> <a id="7753" class="Symbol">:</a> <a id="7755" class="Symbol">∀</a> <a id="7757" href="Cat.Abelian.Base.html#7757" class="Bound">A</a> <a id="7759" href="Cat.Abelian.Base.html#7759" class="Bound">B</a> <a id="7761" class="Symbol">→</a> <a id="7763" href="Cat.Diagram.Coproduct.html#1758" data-type="(C : Precategory o h) (A B₁ : Ob C) → Type (o ⊔ h)" class="Record">Coproduct</a> <a id="7773" href="Cat.Abelian.Base.html#7757" class="Bound">A</a> <a id="7775" href="Cat.Abelian.Base.html#7759" class="Bound">B</a>
  <a id="7779" href="Cat.Abelian.Base.html#7741" data-type="(r : is-additive C) (A B₁ : Ob C) → Coproduct r A B₁" class="Function">has-coprods</a> <a id="7791" href="Cat.Abelian.Base.html#7791" class="Bound">A</a> <a id="7793" href="Cat.Abelian.Base.html#7793" class="Bound">B</a> <a id="7795" class="Symbol">=</a> <a id="7797" href="Cat.Abelian.Base.html#7897" data-type="(r : is-additive C) (A B₁ : Ob C) → Coproduct r A B₁" class="Function">coprod</a> <a id="7804" class="Keyword">where</a>
    <a id="7814" class="Keyword">open</a> <a id="7819" href="Cat.Diagram.Coproduct.html#1758" data-type="(C : Precategory o h) (A B₁ : Ob C) → Type (o ⊔ h)" class="Module">Coproduct</a>
    <a id="7833" class="Keyword">open</a> <a id="7838" href="Cat.Diagram.Coproduct.html#924" data-type="(C : Precategory o h) (in₀ : Hom C A P) (in₁ : Hom C B₁ P) →
Type (o ⊔ h)" class="Module">is-coproduct</a>
    <a id="7855" class="Keyword">module</a> <a id="7862" href="Cat.Abelian.Base.html#7862" class="Module">Prod</a> <a id="7867" class="Symbol">=</a> <a id="7869" href="Cat.Diagram.Product.html#2703" data-type="(C : Precategory o h) (A B₁ : Ob C) → Type (o ⊔ h)" class="Module">Product</a> <a id="7877" class="Symbol">(</a><a id="7878" href="Cat.Abelian.Base.html#6716" data-type="(r : is-additive C) (A B₁ : Ob C) → Product r A B₁" class="Field">has-prods</a> <a id="7888" href="Cat.Abelian.Base.html#7791" class="Bound">A</a> <a id="7890" href="Cat.Abelian.Base.html#7793" class="Bound">B</a><a id="7891" class="Symbol">)</a>
    <a id="7897" href="Cat.Abelian.Base.html#7897" data-type="(r : is-additive C) (A B₁ : Ob C) → Coproduct r A B₁" class="Function">coprod</a> <a id="7904" class="Symbol">:</a> <a id="7906" href="Cat.Diagram.Coproduct.html#1758" data-type="(C : Precategory o h) (A B₁ : Ob C) → Type (o ⊔ h)" class="Record">Coproduct</a> <a id="7916" href="Cat.Abelian.Base.html#7791" class="Bound">A</a> <a id="7918" href="Cat.Abelian.Base.html#7793" class="Bound">B</a>
    <a id="7924" href="Cat.Abelian.Base.html#7897" data-type="(r : is-additive C) (A B₁ : Ob C) → Coproduct r A B₁" class="Function">coprod</a> <a id="7931" class="Symbol">.</a><a id="7932" href="Cat.Diagram.Coproduct.html#1812" data-type="Coproduct C A B₁ → Ob C" class="Field">coapex</a> <a id="7939" class="Symbol">=</a> <a id="7941" href="Cat.Diagram.Product.html#2773" data-type="Product C A B₁ → Ob C" class="Function">Prod.apex</a>
    <a id="7955" href="Cat.Abelian.Base.html#7897" data-type="(r : is-additive C) (A B₁ : Ob C) → Coproduct r A B₁" class="Function">coprod</a> <a id="7962" class="Symbol">.</a><a id="7963" href="Cat.Diagram.Coproduct.html#1828" data-type="(r : Coproduct C A B₁) → Hom C A (r .coapex)" class="Field">in₀</a> <a id="7967" class="Symbol">=</a> <span class="reasoning-step"><span class="as-written Function Operator"><a id="7969" href="Cat.Diagram.Product.html#1856" data-type="is-product C π₁ π₂ → Hom C Q A → Hom C Q B₁ → Hom C Q P" class="Function Operator">Prod.⟨</a> <a id="7976" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">id</a> <a id="7979" href="Cat.Diagram.Product.html#1856" data-type="is-product C π₁ π₂ → Hom C Q A → Hom C Q B₁ → Hom C Q P" class="Function Operator">,</a> <a id="7981" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a> <a id="7984" href="Cat.Diagram.Product.html#1856" data-type="is-product C π₁ π₂ → Hom C Q A → Hom C Q B₁ → Hom C Q P" class="Function Operator">⟩</a></span><span class="alternate Function Operator">Prod.</span></span>
    <a id="7990" href="Cat.Abelian.Base.html#7897" data-type="(r : is-additive C) (A B₁ : Ob C) → Coproduct r A B₁" class="Function">coprod</a> <a id="7997" class="Symbol">.</a><a id="7998" href="Cat.Diagram.Coproduct.html#1851" data-type="(r : Coproduct C A B₁) → Hom C B₁ (r .coapex)" class="Field">in₁</a> <a id="8002" class="Symbol">=</a> <span class="reasoning-step"><span class="as-written Function Operator"><a id="8004" href="Cat.Diagram.Product.html#1856" data-type="is-product C π₁ π₂ → Hom C Q A → Hom C Q B₁ → Hom C Q P" class="Function Operator">Prod.⟨</a> <a id="8011" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a> <a id="8014" href="Cat.Diagram.Product.html#1856" data-type="is-product C π₁ π₂ → Hom C Q A → Hom C Q B₁ → Hom C Q P" class="Function Operator">,</a> <a id="8016" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">id</a> <a id="8019" href="Cat.Diagram.Product.html#1856" data-type="is-product C π₁ π₂ → Hom C Q A → Hom C Q B₁ → Hom C Q P" class="Function Operator">⟩</a></span><span class="alternate Function Operator">Prod.</span></span>
    <a id="8025" href="Cat.Abelian.Base.html#7897" data-type="(r : is-additive C) (A B₁ : Ob C) → Coproduct r A B₁" class="Function">coprod</a> <a id="8032" class="Symbol">.</a><a id="8033" href="Cat.Diagram.Coproduct.html#1874" data-type="(r : Coproduct C A B₁) → is-coproduct C (r .in₀) (r .in₁)" class="Field">has-is-coproduct</a> <a id="8050" class="Symbol">.</a><a id="8051" href="Cat.Diagram.Coproduct.html#1010" data-type="is-coproduct C in₀ in₁ → Hom C A Q → Hom C B₁ Q → Hom C P Q" class="Field Operator">[_,_]</a> <a id="8057" href="Cat.Abelian.Base.html#8057" class="Bound">f</a> <a id="8059" href="Cat.Abelian.Base.html#8059" class="Bound">g</a> <a id="8061" class="Symbol">=</a> <a id="8063" href="Cat.Abelian.Base.html#8057" class="Bound">f</a> <a id="8065" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="8067" href="Cat.Diagram.Product.html#2787" data-type="(r : Product C A B₁) → Hom C (r .apex) A" class="Function">Prod.π₁</a> <a id="8075" href="Cat.Abelian.Base.html#1445" data-type="(r : Ab-category C) → Hom r A B₁ → Hom r A B₁ → Hom r A B₁" class="Function Operator">+</a> <a id="8077" href="Cat.Abelian.Base.html#8059" class="Bound">g</a> <a id="8079" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="8081" href="Cat.Diagram.Product.html#2807" data-type="(r : Product C A B₁) → Hom C (r .apex) B₁" class="Function">Prod.π₂</a>
    <a id="8093" href="Cat.Abelian.Base.html#7897" data-type="(r : is-additive C) (A B₁ : Ob C) → Coproduct r A B₁" class="Function">coprod</a> <a id="8100" class="Symbol">.</a><a id="8101" href="Cat.Diagram.Coproduct.html#1874" data-type="(r : Coproduct C A B₁) → is-coproduct C (r .in₀) (r .in₁)" class="Field">has-is-coproduct</a> <a id="8118" class="Symbol">.</a><a id="8119" href="Cat.Diagram.Coproduct.html#1077" data-type="(r : is-coproduct C in₀ in₁) → (C ∘ r .[_,_] inj0 inj1) in₀ ≡ inj0" class="Field">in₀∘factor</a> <a id="8130" class="Symbol">{</a><a id="8131" class="Argument">inj0</a> <a id="8136" class="Symbol">=</a> <a id="8138" href="Cat.Abelian.Base.html#8138" class="Bound">inj0</a><a id="8142" class="Symbol">}</a> <a id="8144" class="Symbol">{</a><a id="8145" href="Cat.Abelian.Base.html#8145" class="Bound">inj1</a><a id="8149" class="Symbol">}</a> <a id="8151" class="Symbol">=</a>
      <a id="8159" class="Symbol">(</a><a id="8160" href="Cat.Abelian.Base.html#8138" class="Bound">inj0</a> <a id="8165" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="8167" href="Cat.Diagram.Product.html#2787" data-type="(r : Product C A B₁) → Hom C (r .apex) A" class="Function">Prod.π₁</a> <a id="8175" href="Cat.Abelian.Base.html#1445" data-type="(r : Ab-category C) → Hom r A B₁ → Hom r A B₁ → Hom r A B₁" class="Function Operator">+</a> <a id="8177" href="Cat.Abelian.Base.html#8145" class="Bound">inj1</a> <a id="8182" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="8184" href="Cat.Diagram.Product.html#2807" data-type="(r : Product C A B₁) → Hom C (r .apex) B₁" class="Function">Prod.π₂</a><a id="8191" class="Symbol">)</a> <a id="8193" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <span class="reasoning-step"><span class="as-written Function Operator"><a id="8195" href="Cat.Diagram.Product.html#1856" data-type="is-product C π₁ π₂ → Hom C Q A → Hom C Q B₁ → Hom C Q P" class="Function Operator">Prod.⟨</a> <a id="8202" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">id</a> <a id="8205" href="Cat.Diagram.Product.html#1856" data-type="is-product C π₁ π₂ → Hom C Q A → Hom C Q B₁ → Hom C Q P" class="Function Operator">,</a> <a id="8207" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a> <a id="8210" href="Cat.Diagram.Product.html#1856" data-type="is-product C π₁ π₂ → Hom C Q A → Hom C Q B₁ → Hom C Q P" class="Function Operator">⟩</a></span><span class="alternate Function Operator">Prod.</span></span> <span class="reasoning-step"><span class="as-written Function"><a id="8212" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="8215" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="8219" class="Symbol">(</a><a id="8220" href="Cat.Abelian.Base.html#1800" data-type="(r : Ab-category C) (f g : Hom C B₁ C) (h : Hom C A B₁) →
r .Group-on-hom A C ._⋆_ ((C ∘ f) h) ((C ∘ g) h) ≡
(C ∘ r .Group-on-hom B₁ C ._⋆_ f g) h" class="Function">∘-linear-l</a> <a id="8231" class="Symbol">_</a> <a id="8233" class="Symbol">_</a> <a id="8235" class="Symbol">_)</a> <a id="8238" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="8246" class="Symbol">((</a><a id="8248" href="Cat.Abelian.Base.html#8138" class="Bound">inj0</a> <a id="8253" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="8255" href="Cat.Diagram.Product.html#2787" data-type="(r : Product C A B₁) → Hom C (r .apex) A" class="Function">Prod.π₁</a><a id="8262" class="Symbol">)</a> <a id="8264" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <span class="reasoning-step"><span class="as-written Function Operator"><a id="8266" href="Cat.Diagram.Product.html#1856" data-type="is-product C π₁ π₂ → Hom C Q A → Hom C Q B₁ → Hom C Q P" class="Function Operator">Prod.⟨</a> <a id="8273" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">id</a> <a id="8276" href="Cat.Diagram.Product.html#1856" data-type="is-product C π₁ π₂ → Hom C Q A → Hom C Q B₁ → Hom C Q P" class="Function Operator">,</a> <a id="8278" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a> <a id="8281" href="Cat.Diagram.Product.html#1856" data-type="is-product C π₁ π₂ → Hom C Q A → Hom C Q B₁ → Hom C Q P" class="Function Operator">⟩</a></span><span class="alternate Function Operator">Prod.</span></span> <a id="8283" href="Cat.Abelian.Base.html#1445" data-type="(r : Ab-category C) → Hom r A B₁ → Hom r A B₁ → Hom r A B₁" class="Function Operator">+</a> <a id="8285" class="Symbol">_)</a>            <span class="reasoning-step"><span class="as-written Function"><a id="8299" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="8302" href="Cat.Reasoning.html#1108" data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → (C ∘ f) a ≡ f" class="Function">Hom.elimr</a> <a id="8312" class="Symbol">(</a><a id="8313" href="Cat.Reasoning.html#1678" data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ (C ∘ f) a) b ≡ (C ∘ f) c" class="Function">pullr</a> <a id="8319" href="Cat.Diagram.Product.html#1984" data-type="(r : is-product C π₁ π₂) → (C ∘ π₂) (r .⟨_,_⟩ p1 p2) ≡ p2" class="Function">Prod.π₂∘factor</a> <a id="8334" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="8336" href="Cat.Abelian.Base.html#2648" data-type="(r : Ab-category C) → (r ∘ f) (0m r) ≡ 0m r" class="Function">∘-zero-r</a><a id="8344" class="Symbol">)</a> <a id="8346" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="8354" class="Symbol">(</a><a id="8355" href="Cat.Abelian.Base.html#8138" class="Bound">inj0</a> <a id="8360" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="8362" href="Cat.Diagram.Product.html#2787" data-type="(r : Product C A B₁) → Hom C (r .apex) A" class="Function">Prod.π₁</a><a id="8369" class="Symbol">)</a> <a id="8371" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <span class="reasoning-step"><span class="as-written Function Operator"><a id="8373" href="Cat.Diagram.Product.html#1856" data-type="is-product C π₁ π₂ → Hom C Q A → Hom C Q B₁ → Hom C Q P" class="Function Operator">Prod.⟨</a> <a id="8380" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">id</a> <a id="8383" href="Cat.Diagram.Product.html#1856" data-type="is-product C π₁ π₂ → Hom C Q A → Hom C Q B₁ → Hom C Q P" class="Function Operator">,</a> <a id="8385" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a> <a id="8388" href="Cat.Diagram.Product.html#1856" data-type="is-product C π₁ π₂ → Hom C Q A → Hom C Q B₁ → Hom C Q P" class="Function Operator">⟩</a></span><span class="alternate Function Operator">Prod.</span></span>                  <span class="reasoning-step"><span class="as-written Function"><a id="8407" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="8410" href="Cat.Reasoning.html#2731" data-type="(C : Precategory o ℓ) (inv₁ : (C ∘ h) i ≡ id C) →
(C ∘ (C ∘ f) h) i ≡ f" class="Function">cancelr</a> <a id="8418" href="Cat.Diagram.Product.html#1918" data-type="(r : is-product C π₁ π₂) → (C ∘ π₁) (r .⟨_,_⟩ p1 p2) ≡ p1" class="Function">Prod.π₁∘factor</a> <a id="8433" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="8441" href="Cat.Abelian.Base.html#8138" class="Bound">inj0</a>                                                <a id="8493" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
    <a id="8499" href="Cat.Abelian.Base.html#7897" data-type="(r : is-additive C) (A B₁ : Ob C) → Coproduct r A B₁" class="Function">coprod</a> <a id="8506" class="Symbol">.</a><a id="8507" href="Cat.Diagram.Coproduct.html#1874" data-type="(r : Coproduct C A B₁) → is-coproduct C (r .in₀) (r .in₁)" class="Field">has-is-coproduct</a> <a id="8524" class="Symbol">.</a><a id="8525" href="Cat.Diagram.Coproduct.html#1155" data-type="(r : is-coproduct C in₀ in₁) → (C ∘ r .[_,_] inj0 inj1) in₁ ≡ inj1" class="Field">in₁∘factor</a> <a id="8536" class="Symbol">{</a><a id="8537" class="Argument">inj0</a> <a id="8542" class="Symbol">=</a> <a id="8544" href="Cat.Abelian.Base.html#8544" class="Bound">inj0</a><a id="8548" class="Symbol">}</a> <a id="8550" class="Symbol">{</a><a id="8551" href="Cat.Abelian.Base.html#8551" class="Bound">inj1</a><a id="8555" class="Symbol">}</a> <a id="8557" class="Symbol">=</a>
      <a id="8565" class="Symbol">(</a><a id="8566" href="Cat.Abelian.Base.html#8544" class="Bound">inj0</a> <a id="8571" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="8573" href="Cat.Diagram.Product.html#2787" data-type="(r : Product C A B₁) → Hom C (r .apex) A" class="Function">Prod.π₁</a> <a id="8581" href="Cat.Abelian.Base.html#1445" data-type="(r : Ab-category C) → Hom r A B₁ → Hom r A B₁ → Hom r A B₁" class="Function Operator">+</a> <a id="8583" href="Cat.Abelian.Base.html#8551" class="Bound">inj1</a> <a id="8588" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="8590" href="Cat.Diagram.Product.html#2807" data-type="(r : Product C A B₁) → Hom C (r .apex) B₁" class="Function">Prod.π₂</a><a id="8597" class="Symbol">)</a> <a id="8599" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <span class="reasoning-step"><span class="as-written Function Operator"><a id="8601" href="Cat.Diagram.Product.html#1856" data-type="is-product C π₁ π₂ → Hom C Q A → Hom C Q B₁ → Hom C Q P" class="Function Operator">Prod.⟨</a> <a id="8608" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a> <a id="8611" href="Cat.Diagram.Product.html#1856" data-type="is-product C π₁ π₂ → Hom C Q A → Hom C Q B₁ → Hom C Q P" class="Function Operator">,</a> <a id="8613" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">id</a> <a id="8616" href="Cat.Diagram.Product.html#1856" data-type="is-product C π₁ π₂ → Hom C Q A → Hom C Q B₁ → Hom C Q P" class="Function Operator">⟩</a></span><span class="alternate Function Operator">Prod.</span></span> <span class="reasoning-step"><span class="as-written Function"><a id="8618" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="8621" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="8625" class="Symbol">(</a><a id="8626" href="Cat.Abelian.Base.html#1800" data-type="(r : Ab-category C) (f g : Hom C B₁ C) (h : Hom C A B₁) →
r .Group-on-hom A C ._⋆_ ((C ∘ f) h) ((C ∘ g) h) ≡
(C ∘ r .Group-on-hom B₁ C ._⋆_ f g) h" class="Function">∘-linear-l</a> <a id="8637" class="Symbol">_</a> <a id="8639" class="Symbol">_</a> <a id="8641" class="Symbol">_)</a> <a id="8644" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="8652" class="Symbol">(_</a> <a id="8655" href="Cat.Abelian.Base.html#1445" data-type="(r : Ab-category C) → Hom r A B₁ → Hom r A B₁ → Hom r A B₁" class="Function Operator">+</a> <a id="8657" class="Symbol">(</a><a id="8658" href="Cat.Abelian.Base.html#8551" class="Bound">inj1</a> <a id="8663" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="8665" href="Cat.Diagram.Product.html#2807" data-type="(r : Product C A B₁) → Hom C (r .apex) B₁" class="Function">Prod.π₂</a><a id="8672" class="Symbol">)</a> <a id="8674" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <span class="reasoning-step"><span class="as-written Function Operator"><a id="8676" href="Cat.Diagram.Product.html#1856" data-type="is-product C π₁ π₂ → Hom C Q A → Hom C Q B₁ → Hom C Q P" class="Function Operator">Prod.⟨</a> <a id="8683" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a> <a id="8686" href="Cat.Diagram.Product.html#1856" data-type="is-product C π₁ π₂ → Hom C Q A → Hom C Q B₁ → Hom C Q P" class="Function Operator">,</a> <a id="8688" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">id</a> <a id="8691" href="Cat.Diagram.Product.html#1856" data-type="is-product C π₁ π₂ → Hom C Q A → Hom C Q B₁ → Hom C Q P" class="Function Operator">⟩</a></span><span class="alternate Function Operator">Prod.</span></span><a id="8692" class="Symbol">)</a>            <span class="reasoning-step"><span class="as-written Function"><a id="8705" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="8708" href="Cat.Reasoning.html#1009" data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → (C ∘ a) f ≡ f" class="Function">Hom.eliml</a> <a id="8718" class="Symbol">(</a><a id="8719" href="Cat.Reasoning.html#1678" data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ (C ∘ f) a) b ≡ (C ∘ f) c" class="Function">pullr</a> <a id="8725" href="Cat.Diagram.Product.html#1918" data-type="(r : is-product C π₁ π₂) → (C ∘ π₁) (r .⟨_,_⟩ p1 p2) ≡ p1" class="Function">Prod.π₁∘factor</a> <a id="8740" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="8742" href="Cat.Abelian.Base.html#2648" data-type="(r : Ab-category C) → (r ∘ f) (0m r) ≡ 0m r" class="Function">∘-zero-r</a><a id="8750" class="Symbol">)</a> <a id="8752" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="8760" class="Symbol">(</a><a id="8761" href="Cat.Abelian.Base.html#8551" class="Bound">inj1</a> <a id="8766" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="8768" href="Cat.Diagram.Product.html#2807" data-type="(r : Product C A B₁) → Hom C (r .apex) B₁" class="Function">Prod.π₂</a><a id="8775" class="Symbol">)</a> <a id="8777" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <span class="reasoning-step"><span class="as-written Function Operator"><a id="8779" href="Cat.Diagram.Product.html#1856" data-type="is-product C π₁ π₂ → Hom C Q A → Hom C Q B₁ → Hom C Q P" class="Function Operator">Prod.⟨</a> <a id="8786" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a> <a id="8789" href="Cat.Diagram.Product.html#1856" data-type="is-product C π₁ π₂ → Hom C Q A → Hom C Q B₁ → Hom C Q P" class="Function Operator">,</a> <a id="8791" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">id</a> <a id="8794" href="Cat.Diagram.Product.html#1856" data-type="is-product C π₁ π₂ → Hom C Q A → Hom C Q B₁ → Hom C Q P" class="Function Operator">⟩</a></span><span class="alternate Function Operator">Prod.</span></span>                  <span class="reasoning-step"><span class="as-written Function"><a id="8813" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="8816" href="Cat.Reasoning.html#2731" data-type="(C : Precategory o ℓ) (inv₁ : (C ∘ h) i ≡ id C) →
(C ∘ (C ∘ f) h) i ≡ f" class="Function">cancelr</a> <a id="8824" href="Cat.Diagram.Product.html#1984" data-type="(r : is-product C π₁ π₂) → (C ∘ π₂) (r .⟨_,_⟩ p1 p2) ≡ p2" class="Function">Prod.π₂∘factor</a> <a id="8839" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="8847" href="Cat.Abelian.Base.html#8551" class="Bound">inj1</a>                                                 <a id="8900" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
</pre>
<p>For uniqueness, we use distributivity of composition over addition of
morphisms and the universal property of the product to establish the
desired equation. Check it out:</p>
<pre class="Agda">    <a id="9091" href="Cat.Abelian.Base.html#7897" data-type="(r : is-additive C) (A B₁ : Ob C) → Coproduct r A B₁" class="Function">coprod</a> <a id="9098" class="Symbol">.</a><a id="9099" href="Cat.Diagram.Coproduct.html#1874" data-type="(r : Coproduct C A B₁) → is-coproduct C (r .in₀) (r .in₁)" class="Field">has-is-coproduct</a> <a id="9116" class="Symbol">.</a><a id="9117" href="Cat.Diagram.Coproduct.html#1234" data-type="(r : is-coproduct C in₀ in₁) (other : Hom C P Q) →
(C ∘ other) in₀ ≡ inj0 →
(C ∘ other) in₁ ≡ inj1 → other ≡ r .[_,_] inj0 inj1" class="Field">unique</a> <a id="9124" class="Symbol">{</a><a id="9125" class="Argument">inj0</a> <a id="9130" class="Symbol">=</a> <a id="9132" href="Cat.Abelian.Base.html#9132" class="Bound">inj0</a><a id="9136" class="Symbol">}</a> <a id="9138" class="Symbol">{</a><a id="9139" href="Cat.Abelian.Base.html#9139" class="Bound">inj1</a><a id="9143" class="Symbol">}</a> <a id="9145" href="Cat.Abelian.Base.html#9145" class="Bound">other</a> <a id="9151" href="Cat.Abelian.Base.html#9151" class="Bound">p</a> <a id="9153" href="Cat.Abelian.Base.html#9153" class="Bound">q</a> <a id="9155" class="Symbol">=</a> <a id="9157" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="9161" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a>
      <a id="9169" href="Cat.Abelian.Base.html#9132" class="Bound">inj0</a> <a id="9174" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="9176" href="Cat.Diagram.Product.html#2787" data-type="(r : Product C A B₁) → Hom C (r .apex) A" class="Function">Prod.π₁</a> <a id="9184" href="Cat.Abelian.Base.html#1445" data-type="(r : Ab-category C) → Hom r A B₁ → Hom r A B₁ → Hom r A B₁" class="Function Operator">+</a> <a id="9186" href="Cat.Abelian.Base.html#9139" class="Bound">inj1</a> <a id="9191" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="9193" href="Cat.Diagram.Product.html#2807" data-type="(r : Product C A B₁) → Hom C (r .apex) B₁" class="Function">Prod.π₂</a>                                             <span class="reasoning-step"><span class="as-written Function"><a id="9245" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="9248" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="9252" href="Cat.Abelian.Base.html#1445" data-type="(r : Ab-category C) → Hom r A B₁ → Hom r A B₁ → Hom r A B₁" class="Function Operator">_+_</a> <a id="9256" class="Symbol">(</a><a id="9257" href="Cat.Reasoning.html#1844" data-type="(C : Precategory o ℓ) (c≡ab : c ≡ (C ∘ a) b) →
(C ∘ c) f ≡ (C ∘ a) ((C ∘ b) f)" class="Function">pushl</a> <a id="9263" class="Symbol">(</a><a id="9264" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="9268" href="Cat.Abelian.Base.html#9151" class="Bound">p</a><a id="9269" class="Symbol">))</a> <a id="9272" class="Symbol">(</a><a id="9273" href="Cat.Reasoning.html#1844" data-type="(C : Precategory o ℓ) (c≡ab : c ≡ (C ∘ a) b) →
(C ∘ c) f ≡ (C ∘ a) ((C ∘ b) f)" class="Function">pushl</a> <a id="9279" class="Symbol">(</a><a id="9280" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="9284" href="Cat.Abelian.Base.html#9153" class="Bound">q</a><a id="9285" class="Symbol">))</a> <a id="9288" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="9296" class="Symbol">(</a><a id="9297" href="Cat.Abelian.Base.html#9145" class="Bound">other</a> <a id="9303" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <span class="reasoning-step"><span class="as-written Function Operator"><a id="9305" href="Cat.Diagram.Product.html#1856" data-type="is-product C π₁ π₂ → Hom C Q A → Hom C Q B₁ → Hom C Q P" class="Function Operator">Prod.⟨</a> <a id="9312" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">id</a> <a id="9315" href="Cat.Diagram.Product.html#1856" data-type="is-product C π₁ π₂ → Hom C Q A → Hom C Q B₁ → Hom C Q P" class="Function Operator">,</a> <a id="9317" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a> <a id="9320" href="Cat.Diagram.Product.html#1856" data-type="is-product C π₁ π₂ → Hom C Q A → Hom C Q B₁ → Hom C Q P" class="Function Operator">⟩</a></span><span class="alternate Function Operator">Prod.</span></span> <a id="9322" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="9324" href="Cat.Diagram.Product.html#2787" data-type="(r : Product C A B₁) → Hom C (r .apex) A" class="Function">Prod.π₁</a><a id="9331" class="Symbol">)</a> <a id="9333" href="Cat.Abelian.Base.html#1445" data-type="(r : Ab-category C) → Hom r A B₁ → Hom r A B₁ → Hom r A B₁" class="Function Operator">+</a> <a id="9335" class="Symbol">(</a><a id="9336" href="Cat.Abelian.Base.html#9145" class="Bound">other</a> <a id="9342" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <span class="reasoning-step"><span class="as-written Function Operator"><a id="9344" href="Cat.Diagram.Product.html#1856" data-type="is-product C π₁ π₂ → Hom C Q A → Hom C Q B₁ → Hom C Q P" class="Function Operator">Prod.⟨</a> <a id="9351" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a> <a id="9354" href="Cat.Diagram.Product.html#1856" data-type="is-product C π₁ π₂ → Hom C Q A → Hom C Q B₁ → Hom C Q P" class="Function Operator">,</a> <a id="9356" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">id</a> <a id="9359" href="Cat.Diagram.Product.html#1856" data-type="is-product C π₁ π₂ → Hom C Q A → Hom C Q B₁ → Hom C Q P" class="Function Operator">⟩</a></span><span class="alternate Function Operator">Prod.</span></span> <a id="9361" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="9363" href="Cat.Diagram.Product.html#2807" data-type="(r : Product C A B₁) → Hom C (r .apex) B₁" class="Function">Prod.π₂</a><a id="9370" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function"><a id="9372" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="9375" href="Cat.Abelian.Base.html#1903" data-type="(r : Ab-category C) (f : Hom C B₁ C) (g h : Hom C A B₁) →
r .Group-on-hom A C ._⋆_ ((C ∘ f) g) ((C ∘ f) h) ≡
(C ∘ f) (r .Group-on-hom A B₁ ._⋆_ g h)" class="Function">∘-linear-r</a> <a id="9386" class="Symbol">_</a> <a id="9388" class="Symbol">_</a> <a id="9390" class="Symbol">_</a> <a id="9392" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="9400" href="Cat.Abelian.Base.html#9145" class="Bound">other</a> <a id="9406" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="9408" class="Symbol">(</a><span class="reasoning-step"><span class="as-written Function Operator"><a id="9409" href="Cat.Diagram.Product.html#1856" data-type="is-product C π₁ π₂ → Hom C Q A → Hom C Q B₁ → Hom C Q P" class="Function Operator">Prod.⟨</a> <a id="9416" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">id</a> <a id="9419" href="Cat.Diagram.Product.html#1856" data-type="is-product C π₁ π₂ → Hom C Q A → Hom C Q B₁ → Hom C Q P" class="Function Operator">,</a> <a id="9421" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a> <a id="9424" href="Cat.Diagram.Product.html#1856" data-type="is-product C π₁ π₂ → Hom C Q A → Hom C Q B₁ → Hom C Q P" class="Function Operator">⟩</a></span><span class="alternate Function Operator">Prod.</span></span> <a id="9426" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="9428" href="Cat.Diagram.Product.html#2787" data-type="(r : Product C A B₁) → Hom C (r .apex) A" class="Function">Prod.π₁</a> <a id="9436" href="Cat.Abelian.Base.html#1445" data-type="(r : Ab-category C) → Hom r A B₁ → Hom r A B₁ → Hom r A B₁" class="Function Operator">+</a> <span class="reasoning-step"><span class="as-written Function Operator"><a id="9438" href="Cat.Diagram.Product.html#1856" data-type="is-product C π₁ π₂ → Hom C Q A → Hom C Q B₁ → Hom C Q P" class="Function Operator">Prod.⟨</a> <a id="9445" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a> <a id="9448" href="Cat.Diagram.Product.html#1856" data-type="is-product C π₁ π₂ → Hom C Q A → Hom C Q B₁ → Hom C Q P" class="Function Operator">,</a> <a id="9450" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">id</a> <a id="9453" href="Cat.Diagram.Product.html#1856" data-type="is-product C π₁ π₂ → Hom C Q A → Hom C Q B₁ → Hom C Q P" class="Function Operator">⟩</a></span><span class="alternate Function Operator">Prod.</span></span> <a id="9455" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="9457" href="Cat.Diagram.Product.html#2807" data-type="(r : Product C A B₁) → Hom C (r .apex) B₁" class="Function">Prod.π₂</a><a id="9464" class="Symbol">)</a>           <span class="reasoning-step"><span class="as-written Function"><a id="9476" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="9479" href="Cat.Reasoning.html#1108" data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → (C ∘ f) a ≡ f" class="Function">elimr</a> <a id="9485" href="Cat.Abelian.Base.html#9597" data-type="(r : is-additive C) (A B₁ : Ob C)
(other : Hom C (coprod r A B₁ .coapex) Q)
(p : (C ∘ other) (coprod r A B₁ .in₀) ≡ inj0)
(q : (C ∘ other) (coprod r A B₁ .in₁) ≡ inj1) →
(r +
 (r ∘ ⟨ has-prods r A B₁ , id r ⟩ (0m r)) (has-prods r A B₁ .π₁))
((r ∘ ⟨ has-prods r A B₁ , 0m r ⟩ (id r)) (has-prods r A B₁ .π₂))
≡ id r" class="Function">lemma</a> <a id="9491" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="9499" href="Cat.Abelian.Base.html#9145" class="Bound">other</a>                                                                       <a id="9575" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
      <a id="9583" class="Keyword">where</a>
        <a id="9597" href="Cat.Abelian.Base.html#9597" data-type="(r : is-additive C) (A B₁ : Ob C)
(other : Hom C (coprod r A B₁ .coapex) Q)
(p : (C ∘ other) (coprod r A B₁ .in₀) ≡ inj0)
(q : (C ∘ other) (coprod r A B₁ .in₁) ≡ inj1) →
(r +
 (r ∘ ⟨ has-prods r A B₁ , id r ⟩ (0m r)) (has-prods r A B₁ .π₁))
((r ∘ ⟨ has-prods r A B₁ , 0m r ⟩ (id r)) (has-prods r A B₁ .π₂))
≡ id r" class="Function">lemma</a> <a id="9603" class="Symbol">:</a> <span class="reasoning-step"><span class="as-written Function Operator"><a id="9605" href="Cat.Diagram.Product.html#1856" data-type="is-product C π₁ π₂ → Hom C Q A → Hom C Q B₁ → Hom C Q P" class="Function Operator">Prod.⟨</a> <a id="9612" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">id</a> <a id="9615" href="Cat.Diagram.Product.html#1856" data-type="is-product C π₁ π₂ → Hom C Q A → Hom C Q B₁ → Hom C Q P" class="Function Operator">,</a> <a id="9617" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a> <a id="9620" href="Cat.Diagram.Product.html#1856" data-type="is-product C π₁ π₂ → Hom C Q A → Hom C Q B₁ → Hom C Q P" class="Function Operator">⟩</a></span><span class="alternate Function Operator">Prod.</span></span> <a id="9622" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="9624" href="Cat.Diagram.Product.html#2787" data-type="(r : Product C A B₁) → Hom C (r .apex) A" class="Function">Prod.π₁</a> <a id="9632" href="Cat.Abelian.Base.html#1445" data-type="(r : Ab-category C) → Hom r A B₁ → Hom r A B₁ → Hom r A B₁" class="Function Operator">+</a> <span class="reasoning-step"><span class="as-written Function Operator"><a id="9634" href="Cat.Diagram.Product.html#1856" data-type="is-product C π₁ π₂ → Hom C Q A → Hom C Q B₁ → Hom C Q P" class="Function Operator">Prod.⟨</a> <a id="9641" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a> <a id="9644" href="Cat.Diagram.Product.html#1856" data-type="is-product C π₁ π₂ → Hom C Q A → Hom C Q B₁ → Hom C Q P" class="Function Operator">,</a> <a id="9646" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">id</a> <a id="9649" href="Cat.Diagram.Product.html#1856" data-type="is-product C π₁ π₂ → Hom C Q A → Hom C Q B₁ → Hom C Q P" class="Function Operator">⟩</a></span><span class="alternate Function Operator">Prod.</span></span> <a id="9651" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="9653" href="Cat.Diagram.Product.html#2807" data-type="(r : Product C A B₁) → Hom C (r .apex) B₁" class="Function">Prod.π₂</a>
              <a id="9675" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="9677" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">id</a>
        <a id="9688" href="Cat.Abelian.Base.html#9597" data-type="(r : is-additive C) (A B₁ : Ob C)
(other : Hom C (coprod r A B₁ .coapex) Q)
(p : (C ∘ other) (coprod r A B₁ .in₀) ≡ inj0)
(q : (C ∘ other) (coprod r A B₁ .in₁) ≡ inj1) →
(r +
 (r ∘ ⟨ has-prods r A B₁ , id r ⟩ (0m r)) (has-prods r A B₁ .π₁))
((r ∘ ⟨ has-prods r A B₁ , 0m r ⟩ (id r)) (has-prods r A B₁ .π₂))
≡ id r" class="Function">lemma</a> <a id="9694" class="Symbol">=</a> <a id="9696" href="Cat.Diagram.Product.html#2211" data-type="is-product C π₁ π₂ →
(C ∘ π₁) o1 ≡ pr1 →
(C ∘ π₂) o1 ≡ pr2 → (C ∘ π₁) o2 ≡ pr1 → (C ∘ π₂) o2 ≡ pr2 → o1 ≡ o2" class="Function">Prod.unique₂</a> <a id="9709" class="Symbol">{</a><a id="9710" class="Argument">pr1</a> <a id="9714" class="Symbol">=</a> <a id="9716" href="Cat.Diagram.Product.html#2787" data-type="(r : Product C A B₁) → Hom C (r .apex) A" class="Function">Prod.π₁</a><a id="9723" class="Symbol">}</a> <a id="9725" class="Symbol">{</a><a id="9726" class="Argument">pr2</a> <a id="9730" class="Symbol">=</a> <a id="9732" href="Cat.Diagram.Product.html#2807" data-type="(r : Product C A B₁) → Hom C (r .apex) B₁" class="Function">Prod.π₂</a><a id="9739" class="Symbol">}</a>
          <a id="9751" class="Symbol">(</a><a id="9752" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="9756" class="Symbol">(</a><a id="9757" href="Cat.Abelian.Base.html#1903" data-type="(r : Ab-category C) (f : Hom C B₁ C) (g h : Hom C A B₁) →
r .Group-on-hom A C ._⋆_ ((C ∘ f) g) ((C ∘ f) h) ≡
(C ∘ f) (r .Group-on-hom A B₁ ._⋆_ g h)" class="Function">∘-linear-r</a> <a id="9768" class="Symbol">_</a> <a id="9770" class="Symbol">_</a> <a id="9772" class="Symbol">_)</a> <a id="9775" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="9777" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="9781" href="Cat.Abelian.Base.html#1445" data-type="(r : Ab-category C) → Hom r A B₁ → Hom r A B₁ → Hom r A B₁" class="Function Operator">_+_</a> <a id="9785" class="Symbol">(</a><a id="9786" href="Cat.Reasoning.html#2621" data-type="(C : Precategory o ℓ) (inv₁ : (C ∘ h) i ≡ id C) →
(C ∘ h) ((C ∘ i) f) ≡ f" class="Function">cancell</a> <a id="9794" href="Cat.Diagram.Product.html#1918" data-type="(r : is-product C π₁ π₂) → (C ∘ π₁) (r .⟨_,_⟩ p1 p2) ≡ p1" class="Function">Prod.π₁∘factor</a><a id="9808" class="Symbol">)</a> <a id="9810" class="Symbol">(</a><a id="9811" href="Cat.Reasoning.html#1548" data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ a) ((C ∘ b) f) ≡ (C ∘ c) f" class="Function">pulll</a> <a id="9817" href="Cat.Diagram.Product.html#1918" data-type="(r : is-product C π₁ π₂) → (C ∘ π₁) (r .⟨_,_⟩ p1 p2) ≡ p1" class="Function">Prod.π₁∘factor</a> <a id="9832" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="9834" href="Cat.Abelian.Base.html#3063" data-type="(r : Ab-category C) → (r ∘ 0m r) f ≡ 0m r" class="Function">∘-zero-l</a><a id="9842" class="Symbol">)</a> <a id="9844" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="9846" href="Cat.Reasoning.html#1108" data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → (C ∘ f) a ≡ f" class="Function">Hom.elimr</a> <a id="9856" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a><a id="9860" class="Symbol">)</a>
          <a id="9872" class="Symbol">(</a><a id="9873" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="9877" class="Symbol">(</a><a id="9878" href="Cat.Abelian.Base.html#1903" data-type="(r : Ab-category C) (f : Hom C B₁ C) (g h : Hom C A B₁) →
r .Group-on-hom A C ._⋆_ ((C ∘ f) g) ((C ∘ f) h) ≡
(C ∘ f) (r .Group-on-hom A B₁ ._⋆_ g h)" class="Function">∘-linear-r</a> <a id="9889" class="Symbol">_</a> <a id="9891" class="Symbol">_</a> <a id="9893" class="Symbol">_)</a> <a id="9896" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="9898" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="9902" href="Cat.Abelian.Base.html#1445" data-type="(r : Ab-category C) → Hom r A B₁ → Hom r A B₁ → Hom r A B₁" class="Function Operator">_+_</a> <a id="9906" class="Symbol">(</a><a id="9907" href="Cat.Reasoning.html#1548" data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ a) ((C ∘ b) f) ≡ (C ∘ c) f" class="Function">pulll</a> <a id="9913" href="Cat.Diagram.Product.html#1984" data-type="(r : is-product C π₁ π₂) → (C ∘ π₂) (r .⟨_,_⟩ p1 p2) ≡ p2" class="Function">Prod.π₂∘factor</a> <a id="9928" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="9930" href="Cat.Abelian.Base.html#3063" data-type="(r : Ab-category C) → (r ∘ 0m r) f ≡ 0m r" class="Function">∘-zero-l</a><a id="9938" class="Symbol">)</a> <a id="9940" class="Symbol">(</a><a id="9941" href="Cat.Reasoning.html#2621" data-type="(C : Precategory o ℓ) (inv₁ : (C ∘ h) i ≡ id C) →
(C ∘ h) ((C ∘ i) f) ≡ f" class="Function">cancell</a> <a id="9949" href="Cat.Diagram.Product.html#1984" data-type="(r : is-product C π₁ π₂) → (C ∘ π₂) (r .⟨_,_⟩ p1 p2) ≡ p2" class="Function">Prod.π₂∘factor</a><a id="9963" class="Symbol">)</a> <a id="9965" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="9967" href="Cat.Reasoning.html#1009" data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → (C ∘ a) f ≡ f" class="Function">Hom.eliml</a> <a id="9977" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a><a id="9981" class="Symbol">)</a>
          <a id="9993" class="Symbol">(</a><a id="9994" href="Cat.Reasoning.html#1108" data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → (C ∘ f) a ≡ f" class="Function">elimr</a> <a id="10000" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a><a id="10004" class="Symbol">)</a>
          <a id="10016" class="Symbol">(</a><a id="10017" href="Cat.Reasoning.html#1108" data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → (C ∘ f) a ≡ f" class="Function">elimr</a> <a id="10023" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a><a id="10027" class="Symbol">)</a>
</pre>
<h1 id="pre-abelian-abelian-categories"><a href="#pre-abelian-abelian-categories" class="header-link">Pre-abelian
&amp; abelian
categories<span class="header-link-emoji">🔗</span></a></h1>
<p>An additive category is <strong>pre-abelian</strong> when it
additionally has <a href="Cat.Diagram.Kernel.html">kernels</a> and
cokernels, hence binary <a href="Cat.Diagram.Equaliser.html">equalisers</a> and <a href="Cat.Diagram.Coequaliser.html">coequalisers</a> where one of the
maps is zero.</p>
<pre class="Agda"><a id="10367" class="Keyword">record</a> <a id="is-pre-abelian"></a><a id="10374" href="Cat.Abelian.Base.html#10374" data-type="(C : Precategory o ℓ) → Type (o ⊔ lsuc ℓ)" class="Record">is-pre-abelian</a> <a id="10389" class="Symbol">{</a><a id="10390" href="Cat.Abelian.Base.html#10390" class="Bound">o</a> <a id="10392" href="Cat.Abelian.Base.html#10392" class="Bound">ℓ</a><a id="10393" class="Symbol">}</a> <a id="10395" class="Symbol">(</a><a id="10396" href="Cat.Abelian.Base.html#10396" class="Bound">C</a> <a id="10398" class="Symbol">:</a> <a id="10400" href="Cat.Base.html#704" data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" class="Record">Precategory</a> <a id="10412" href="Cat.Abelian.Base.html#10390" class="Bound">o</a> <a id="10414" href="Cat.Abelian.Base.html#10392" class="Bound">ℓ</a><a id="10415" class="Symbol">)</a> <a id="10417" class="Symbol">:</a> <a id="10419" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="10424" class="Symbol">(</a><a id="10425" href="Cat.Abelian.Base.html#10390" class="Bound">o</a> <a id="10427" href="Agda.Primitive.html#810" data-type="Level → Level → Level" class="Primitive Operator">⊔</a> <a id="10429" href="Agda.Primitive.html#780" data-type="Level → Level" class="Primitive">lsuc</a> <a id="10434" href="Cat.Abelian.Base.html#10392" class="Bound">ℓ</a><a id="10435" class="Symbol">)</a> <a id="10437" class="Keyword">where</a>
  <a id="10445" class="Keyword">field</a> <a id="is-pre-abelian.has-additive"></a><a id="10451" href="Cat.Abelian.Base.html#10451" data-type="is-pre-abelian C → is-additive C" class="Field">has-additive</a> <a id="10464" class="Symbol">:</a> <a id="10466" href="Cat.Abelian.Base.html#6545" data-type="(C : Precategory o ℓ) → Type (o ⊔ lsuc ℓ)" class="Record">is-additive</a> <a id="10478" href="Cat.Abelian.Base.html#10396" class="Bound">C</a>
  <a id="10482" class="Keyword">open</a> <a id="10487" href="Cat.Abelian.Base.html#6545" data-type="(C : Precategory o ℓ) → Type (o ⊔ lsuc ℓ)" class="Module">is-additive</a> <a id="10499" href="Cat.Abelian.Base.html#10451" data-type="is-pre-abelian C → is-additive C" class="Field">has-additive</a> <a id="10512" class="Keyword">public</a>
  <a id="10521" class="Keyword">field</a>
    <a id="is-pre-abelian.kernel"></a><a id="10531" href="Cat.Abelian.Base.html#10531" data-type="(r : is-pre-abelian C) (f : Hom (r .has-additive) A B₁) →
Kernel C (∅ r) f" class="Field">kernel</a>   <a id="10540" class="Symbol">:</a> <a id="10542" class="Symbol">∀</a> <a id="10544" class="Symbol">{</a><a id="10545" href="Cat.Abelian.Base.html#10545" class="Bound">A</a> <a id="10547" href="Cat.Abelian.Base.html#10547" class="Bound">B</a><a id="10548" class="Symbol">}</a> <a id="10550" class="Symbol">(</a><a id="10551" href="Cat.Abelian.Base.html#10551" class="Bound">f</a> <a id="10553" class="Symbol">:</a> <a id="10555" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">Hom</a> <a id="10559" href="Cat.Abelian.Base.html#10545" class="Bound">A</a> <a id="10561" href="Cat.Abelian.Base.html#10547" class="Bound">B</a><a id="10562" class="Symbol">)</a> <a id="10564" class="Symbol">→</a> <a id="10566" href="Cat.Diagram.Equaliser.Kernel.html#1023" data-type="(C : Precategory o ℓ) (∅ : Zero C) (f : Hom C a b) → Type (o ⊔ ℓ)" class="Record">Kernel</a> <a id="10573" href="Cat.Abelian.Base.html#10396" class="Bound">C</a> <a id="10575" href="Cat.Abelian.Base.html#6754" data-type="(r : is-additive C) → Zero r" class="Function">∅</a> <a id="10577" href="Cat.Abelian.Base.html#10551" class="Bound">f</a>
    <a id="is-pre-abelian.cokernel"></a><a id="10583" href="Cat.Abelian.Base.html#10583" data-type="(r : is-pre-abelian C) (f : Hom (r .has-additive) A B₁) →
Coequaliser r (0m r) f" class="Field">cokernel</a> <a id="10592" class="Symbol">:</a> <a id="10594" class="Symbol">∀</a> <a id="10596" class="Symbol">{</a><a id="10597" href="Cat.Abelian.Base.html#10597" class="Bound">A</a> <a id="10599" href="Cat.Abelian.Base.html#10599" class="Bound">B</a><a id="10600" class="Symbol">}</a> <a id="10602" class="Symbol">(</a><a id="10603" href="Cat.Abelian.Base.html#10603" class="Bound">f</a> <a id="10605" class="Symbol">:</a> <a id="10607" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">Hom</a> <a id="10611" href="Cat.Abelian.Base.html#10597" class="Bound">A</a> <a id="10613" href="Cat.Abelian.Base.html#10599" class="Bound">B</a><a id="10614" class="Symbol">)</a> <a id="10616" class="Symbol">→</a> <a id="10618" href="Cat.Diagram.Coequaliser.html#1495" data-type="(C : Precategory o ℓ) (f g : Hom C A B₁) → Type (o ⊔ ℓ)" class="Record">Coequaliser</a> <a id="10630" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a> <a id="10633" href="Cat.Abelian.Base.html#10603" class="Bound">f</a>

  <a id="10638" class="Keyword">module</a> <a id="is-pre-abelian.Ker"></a><a id="10645" href="Cat.Abelian.Base.html#10645" class="Module">Ker</a> <a id="10649" class="Symbol">{</a><a id="10650" href="Cat.Abelian.Base.html#10650" class="Bound">A</a> <a id="10652" href="Cat.Abelian.Base.html#10652" class="Bound">B</a><a id="10653" class="Symbol">}</a> <a id="10655" class="Symbol">(</a><a id="10656" href="Cat.Abelian.Base.html#10656" class="Bound">f</a> <a id="10658" class="Symbol">:</a> <a id="10660" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">Hom</a> <a id="10664" href="Cat.Abelian.Base.html#10650" class="Bound">A</a> <a id="10666" href="Cat.Abelian.Base.html#10652" class="Bound">B</a><a id="10667" class="Symbol">)</a> <a id="10669" class="Symbol">=</a> <a id="10671" href="Cat.Diagram.Equaliser.Kernel.html#1023" data-type="(C : Precategory o ℓ) (∅ : Zero C) (f : Hom C a b) → Type (o ⊔ ℓ)" class="Module">Kernel</a> <a id="10678" class="Symbol">(</a><a id="10679" href="Cat.Abelian.Base.html#10531" data-type="(r : is-pre-abelian C) (f : Hom (r .has-additive) A B₁) →
Kernel C (∅ r) f" class="Field">kernel</a> <a id="10686" href="Cat.Abelian.Base.html#10656" class="Bound">f</a><a id="10687" class="Symbol">)</a>
  <a id="10691" class="Keyword">module</a> <a id="is-pre-abelian.Coker"></a><a id="10698" href="Cat.Abelian.Base.html#10698" class="Module">Coker</a> <a id="10704" class="Symbol">{</a><a id="10705" href="Cat.Abelian.Base.html#10705" class="Bound">A</a> <a id="10707" href="Cat.Abelian.Base.html#10707" class="Bound">B</a><a id="10708" class="Symbol">}</a> <a id="10710" class="Symbol">(</a><a id="10711" href="Cat.Abelian.Base.html#10711" class="Bound">f</a> <a id="10713" class="Symbol">:</a> <a id="10715" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">Hom</a> <a id="10719" href="Cat.Abelian.Base.html#10705" class="Bound">A</a> <a id="10721" href="Cat.Abelian.Base.html#10707" class="Bound">B</a><a id="10722" class="Symbol">)</a> <a id="10724" class="Symbol">=</a> <a id="10726" href="Cat.Diagram.Coequaliser.html#1495" data-type="(C : Precategory o ℓ) (f g : Hom C A B₁) → Type (o ⊔ ℓ)" class="Module">Coequaliser</a> <a id="10738" class="Symbol">(</a><a id="10739" href="Cat.Abelian.Base.html#10583" data-type="(r : is-pre-abelian C) (f : Hom (r .has-additive) A B₁) →
Coequaliser r (0m r) f" class="Field">cokernel</a> <a id="10748" href="Cat.Abelian.Base.html#10711" class="Bound">f</a><a id="10749" class="Symbol">)</a>
</pre>
<p>Every morphism
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mover><mo stretchy="true" minsize="3.0em">→</mo><mpadded width="+0.6em" lspace="0.3em"><mi>f</mi></mpadded></mover><mi>B</mi></mrow><annotation encoding="application/x-tex">A \xto{f} B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1191em;vertical-align:-0.011em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel x-arrow"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1081em;"><span style="top:-3.322em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="svg-align" style="top:-2.689em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.522em;min-width:1.469em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.522em" viewBox="0 0 400000 522" preserveAspectRatio="xMaxYMin slice"><path d="M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>
in a preabelian category admits a canonical decomposition as</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mover><mo stretchy="true" minsize="3.0em">↠</mo><mpadded width="+0.6em" lspace="0.3em"><mi>p</mi></mpadded></mover><mi mathvariant="normal">coker</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>ker</mi><mo>⁡</mo><mi>f</mi><mo stretchy="false">)</mo><mover><mo stretchy="true" minsize="3.0em">→</mo><mpadded width="+0.6em" lspace="0.3em"><msup><mi>f</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mpadded></mover><mi>ker</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="normal">coker</mi><mo>⁡</mo><mi>f</mi><mo stretchy="false">)</mo><mover><mo stretchy="true" minsize="3.0em">↪</mo><mpadded width="+0.6em" lspace="0.3em"><mi>i</mi></mpadded></mover><mi>B</mi><mtext>,</mtext></mrow><annotation encoding="application/x-tex">
A \xepi{p} \coker (\ker f) \xto{f&#39;} \ker (\coker f) \xmono{i} B\text{,}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8294em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel x-arrow"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8294em;"><span style="top:-3.228em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="svg-align" style="top:-2.783em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.334em;min-width:0.888em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.334em" viewBox="0 0 400000 334" preserveAspectRatio="xMaxYMin slice"><path d="M400000 167
c-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3
 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42
 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333
-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70
 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z"></path></svg></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.4515em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">coker</span></span><span class="mopen">(</span><span class="mop">ker</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel x-arrow"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2015em;"><span style="top:-3.322em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span><span class="svg-align" style="top:-2.689em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.522em;min-width:1.469em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.522em" viewBox="0 0 400000 522" preserveAspectRatio="xMaxYMin slice"><path d="M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3337em;vertical-align:-0.25em;"></span><span class="mop">ker</span><span class="mopen">(</span><span class="mop"><span class="mord mathrm">coker</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel x-arrow"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0837em;"><span style="top:-3.322em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="svg-align" style="top:-2.689em;"><span class="pstrut" style="height:2.7em;"></span><span class="stretchy" style="height:0.522em;min-width:1.08em;"><span class="halfarrow-left" style="height:0.522em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.522em" viewBox="0 0 400000 522" preserveAspectRatio="xMinYMin slice"><path d="M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5
-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3
-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21
 71.5 23h399859zM103 281v-40h399897v40z"></path></svg></span><span class="halfarrow-right" style="height:0.522em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.522em" viewBox="0 0 400000 522" preserveAspectRatio="xMaxYMin slice"><path d="M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z"></path></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord text"><span class="mord">,</span></span></span></span></span></span></p>
<p>where, as indicated, the map
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>
is an epimorphism (indeed a <a href="Cat.Diagram.Coequaliser.RegularEpi.html">regular epimorphism</a>,
since it is a cokernel) and the map
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>
is a <a href="Cat.Diagram.Equaliser.RegularMono.html">regular
monomorphism</a>.</p>
<pre class="Agda">  <a id="is-pre-abelian.decompose"></a><a id="11217" href="Cat.Abelian.Base.html#11217" data-type="(r : is-pre-abelian C) (f : Hom r A B₁) →
Σ
(λ f′ →
   f ≡ (r ∘ kernel r (coeq r f)) ((r ∘ f′) (coeq r (kernel r f))))" class="Function">decompose</a>
    <a id="11231" class="Symbol">:</a> <a id="11233" class="Symbol">∀</a> <a id="11235" class="Symbol">{</a><a id="11236" href="Cat.Abelian.Base.html#11236" class="Bound">A</a> <a id="11238" href="Cat.Abelian.Base.html#11238" class="Bound">B</a><a id="11239" class="Symbol">}</a> <a id="11241" class="Symbol">(</a><a id="11242" href="Cat.Abelian.Base.html#11242" class="Bound">f</a> <a id="11244" class="Symbol">:</a> <a id="11246" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">Hom</a> <a id="11250" href="Cat.Abelian.Base.html#11236" class="Bound">A</a> <a id="11252" href="Cat.Abelian.Base.html#11238" class="Bound">B</a><a id="11253" class="Symbol">)</a>
    <a id="11259" class="Symbol">→</a> <a id="11261" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">Σ[</a> <a id="11264" href="Cat.Abelian.Base.html#11264" class="Bound">f′</a> <a id="11267" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">∈</a> <a id="11269" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">Hom</a> <a id="11273" class="Symbol">(</a><a id="11274" href="Cat.Diagram.Coequaliser.html#1557" data-type="Coequaliser C f g → Ob C" class="Function">Coker.coapex</a> <a id="11287" class="Symbol">(</a><a id="11288" href="Cat.Diagram.Equaliser.Kernel.html#1104" data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" class="Function">Ker.kernel</a> <a id="11299" href="Cat.Abelian.Base.html#11242" class="Bound">f</a><a id="11300" class="Symbol">))</a> <a id="11303" class="Symbol">(</a><a id="11304" href="Cat.Diagram.Equaliser.Kernel.html#1088" data-type="Kernel C ∅ f → Ob C" class="Function">Ker.ker</a> <a id="11312" class="Symbol">(</a><a id="11313" href="Cat.Diagram.Coequaliser.html#1575" data-type="(r : Coequaliser C f g) → Hom C B₁ (r .coapex)" class="Function">Coker.coeq</a> <a id="11324" href="Cat.Abelian.Base.html#11242" class="Bound">f</a><a id="11325" class="Symbol">))</a> <a id="11328" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">]</a>
       <a id="11337" class="Symbol">(</a><a id="11338" href="Cat.Abelian.Base.html#11242" class="Bound">f</a> <a id="11340" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="11342" href="Cat.Diagram.Equaliser.Kernel.html#1104" data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" class="Function">Ker.kernel</a> <a id="11353" class="Symbol">(</a><a id="11354" href="Cat.Diagram.Coequaliser.html#1575" data-type="(r : Coequaliser C f g) → Hom C B₁ (r .coapex)" class="Function">Coker.coeq</a> <a id="11365" href="Cat.Abelian.Base.html#11242" class="Bound">f</a><a id="11366" class="Symbol">)</a> <a id="11368" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="11370" href="Cat.Abelian.Base.html#11264" class="Bound">f′</a> <a id="11373" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="11375" href="Cat.Diagram.Coequaliser.html#1575" data-type="(r : Coequaliser C f g) → Hom C B₁ (r .coapex)" class="Function">Coker.coeq</a> <a id="11386" class="Symbol">(</a><a id="11387" href="Cat.Diagram.Equaliser.Kernel.html#1104" data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" class="Function">Ker.kernel</a> <a id="11398" href="Cat.Abelian.Base.html#11242" class="Bound">f</a><a id="11399" class="Symbol">))</a>
  <a id="11404" href="Cat.Abelian.Base.html#11217" data-type="(r : is-pre-abelian C) (f : Hom r A B₁) →
Σ
(λ f′ →
   f ≡ (r ∘ kernel r (coeq r f)) ((r ∘ f′) (coeq r (kernel r f))))" class="Function">decompose</a> <a id="11414" class="Symbol">{</a><a id="11415" href="Cat.Abelian.Base.html#11415" class="Bound">A</a><a id="11416" class="Symbol">}</a> <a id="11418" class="Symbol">{</a><a id="11419" href="Cat.Abelian.Base.html#11419" class="Bound">B</a><a id="11420" class="Symbol">}</a> <a id="11422" href="Cat.Abelian.Base.html#11422" class="Bound">f</a> <a id="11424" class="Symbol">=</a> <a id="11426" href="Cat.Abelian.Base.html#11830" data-type="(r : is-pre-abelian C) (f : Hom r A B₁) →
Hom r (coapex r (kernel r f)) (ker r (coeq r f))" class="Function">map</a> <a id="11430" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="11432" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="11436" href="Cat.Abelian.Base.html#12707" data-type="(r : is-pre-abelian C) (f : Hom r A B₁) →
(has-ab (has-additive r) ∘ kernel r (cokernel r f .coeq) .kernel)
((has-ab (has-additive r) ∘ map r f)
 (cokernel r (kernel r f .kernel) .coeq))
≡ f" class="Function">path</a>
    <a id="11445" class="Keyword">where</a>
      <a id="11457" href="Cat.Abelian.Base.html#11457" data-type="(r : is-pre-abelian C) (f : Hom r A B₁) →
Hom r (coapex r (kernel r f)) B₁" class="Function">proj′</a> <a id="11463" class="Symbol">:</a> <a id="11465" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">Hom</a> <a id="11469" class="Symbol">(</a><a id="11470" href="Cat.Diagram.Coequaliser.html#1557" data-type="Coequaliser C f g → Ob C" class="Function">Coker.coapex</a> <a id="11483" class="Symbol">(</a><a id="11484" href="Cat.Diagram.Equaliser.Kernel.html#1104" data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" class="Function">Ker.kernel</a> <a id="11495" href="Cat.Abelian.Base.html#11422" class="Bound">f</a><a id="11496" class="Symbol">))</a> <a id="11499" href="Cat.Abelian.Base.html#11419" class="Bound">B</a>
      <a id="11507" href="Cat.Abelian.Base.html#11457" data-type="(r : is-pre-abelian C) (f : Hom r A B₁) →
Hom r (coapex r (kernel r f)) B₁" class="Function">proj′</a> <a id="11513" class="Symbol">=</a> <a id="11515" href="Cat.Diagram.Coequaliser.html#764" data-type="is-coequaliser C f g coeq → (C ∘ e′) f ≡ (C ∘ e′) g → Hom C E F" class="Function">Coker.coequalise</a> <a id="11532" class="Symbol">(</a><a id="11533" href="Cat.Diagram.Equaliser.Kernel.html#1104" data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" class="Function">Ker.kernel</a> <a id="11544" href="Cat.Abelian.Base.html#11422" class="Bound">f</a><a id="11545" class="Symbol">)</a> <a id="11547" class="Symbol">{</a><a id="11548" class="Argument">e′</a> <a id="11551" class="Symbol">=</a> <a id="11553" href="Cat.Abelian.Base.html#11422" class="Bound">f</a><a id="11554" class="Symbol">}</a> <a id="11556" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="11558" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="11562" href="Cat.Abelian.Base.html#11618" data-type="(r : is-pre-abelian C) (f : Hom r A B₁) →
(r ∘ f) (kernel r f .kernel) ≡ (r ∘ f) (0m r)" class="Function">path</a>
</pre>
<!--
<pre class="Agda">        <a id="11593" class="Keyword">where</a> <a id="11599" class="Keyword">abstract</a>
          <a id="11618" href="Cat.Abelian.Base.html#11618" data-type="(r : is-pre-abelian C) (f : Hom r A B₁) →
(r ∘ f) (kernel r f .kernel) ≡ (r ∘ f) (0m r)" class="Function">path</a> <a id="11623" class="Symbol">:</a> <a id="11625" href="Cat.Abelian.Base.html#11422" class="Bound">f</a> <a id="11627" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="11629" href="Cat.Abelian.Base.html#10531" data-type="(r : is-pre-abelian C) (f : Hom (r .has-additive) A B₁) →
Kernel C (∅ r) f" class="Field">kernel</a> <a id="11636" href="Cat.Abelian.Base.html#11422" class="Bound">f</a> <a id="11638" class="Symbol">.</a><a id="11639" href="Cat.Diagram.Equaliser.Kernel.html#1104" data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" class="Field">Kernel.kernel</a> <a id="11653" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="11655" href="Cat.Abelian.Base.html#11422" class="Bound">f</a> <a id="11657" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="11659" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a>
          <a id="11672" href="Cat.Abelian.Base.html#11618" data-type="(r : is-pre-abelian C) (f : Hom r A B₁) →
(r ∘ f) (kernel r f .kernel) ≡ (r ∘ f) (0m r)" class="Function">path</a> <a id="11677" class="Symbol">=</a> <a id="11679" href="Cat.Diagram.Equaliser.html#687" data-type="is-equaliser C f g equ → (C ∘ f) equ ≡ (C ∘ g) equ" class="Function">Ker.equal</a> <a id="11689" href="Cat.Abelian.Base.html#11422" class="Bound">f</a>
            <a id="11703" href="1Lab.Path.html#38305" data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" class="Function Operator">··</a> <a id="11706" href="Cat.Diagram.Zero.html#1167" data-type="(r : Zero C) (f : Hom C x y) → (C ∘ zero→ r) f ≡ zero→ r" class="Function">∅.zero-∘r</a> <a id="11716" class="Symbol">_</a>
            <a id="11730" href="1Lab.Path.html#38305" data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" class="Function Operator">··</a> <a id="11733" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="11737" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">_∘_</a> <a id="11741" class="Symbol">(</a><a id="11742" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Function">∅.has⊥</a> <a id="11749" class="Symbol">_</a> <a id="11751" class="Symbol">.</a><a id="11752" href="1Lab.HLevel.html#1416" data-type="(r : is-contr A) (x : A) → r .centre ≡ x" class="Field">paths</a> <a id="11758" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a><a id="11760" class="Symbol">)</a> <a id="11762" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
            <a id="11779" href="1Lab.Path.html#38305" data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" class="Function Operator">··</a> <a id="11782" href="Cat.Abelian.Base.html#3063" data-type="(r : Ab-category C) → (r ∘ 0m r) f ≡ 0m r" class="Function">∘-zero-l</a> <a id="11791" href="1Lab.Path.html#38305" data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" class="Function Operator">··</a> <a id="11794" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="11798" href="Cat.Abelian.Base.html#2648" data-type="(r : Ab-category C) → (r ∘ f) (0m r) ≡ 0m r" class="Function">∘-zero-r</a>
</pre>-->
<pre class="Agda">      <a id="11830" href="Cat.Abelian.Base.html#11830" data-type="(r : is-pre-abelian C) (f : Hom r A B₁) →
Hom r (coapex r (kernel r f)) (ker r (coeq r f))" class="Function">map</a> <a id="11834" class="Symbol">:</a> <a id="11836" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">Hom</a> <a id="11840" class="Symbol">(</a><a id="11841" href="Cat.Diagram.Coequaliser.html#1557" data-type="Coequaliser C f g → Ob C" class="Function">Coker.coapex</a> <a id="11854" class="Symbol">(</a><a id="11855" href="Cat.Diagram.Equaliser.Kernel.html#1104" data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" class="Function">Ker.kernel</a> <a id="11866" href="Cat.Abelian.Base.html#11422" class="Bound">f</a><a id="11867" class="Symbol">))</a> <a id="11870" class="Symbol">(</a><a id="11871" href="Cat.Diagram.Equaliser.Kernel.html#1088" data-type="Kernel C ∅ f → Ob C" class="Function">Ker.ker</a> <a id="11879" class="Symbol">(</a><a id="11880" href="Cat.Diagram.Coequaliser.html#1575" data-type="(r : Coequaliser C f g) → Hom C B₁ (r .coapex)" class="Function">Coker.coeq</a> <a id="11891" href="Cat.Abelian.Base.html#11422" class="Bound">f</a><a id="11892" class="Symbol">))</a>
      <a id="11901" href="Cat.Abelian.Base.html#11830" data-type="(r : is-pre-abelian C) (f : Hom r A B₁) →
Hom r (coapex r (kernel r f)) (ker r (coeq r f))" class="Function">map</a> <a id="11905" class="Symbol">=</a> <a id="11907" href="Cat.Diagram.Equaliser.html#721" data-type="is-equaliser C f g equ → (C ∘ f) e′ ≡ (C ∘ g) e′ → Hom C F E" class="Function">Ker.limiting</a> <a id="11920" class="Symbol">(</a><a id="11921" href="Cat.Diagram.Coequaliser.html#1575" data-type="(r : Coequaliser C f g) → Hom C B₁ (r .coapex)" class="Function">Coker.coeq</a> <a id="11932" href="Cat.Abelian.Base.html#11422" class="Bound">f</a><a id="11933" class="Symbol">)</a> <a id="11935" class="Symbol">{</a><a id="11936" class="Argument">e′</a> <a id="11939" class="Symbol">=</a> <a id="11941" href="Cat.Abelian.Base.html#11457" data-type="(r : is-pre-abelian C) (f : Hom r A B₁) →
Hom r (coapex r (kernel r f)) B₁" class="Function">proj′</a><a id="11946" class="Symbol">}</a> <a id="11948" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="11950" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="11954" href="Cat.Abelian.Base.html#12272" data-type="(r : is-pre-abelian C) (f : Hom r A B₁) →
(r ∘ zero→ r) (proj′ r f) ≡ (r ∘ coeq r f) (proj′ r f)" class="Function">path</a>
</pre>
<p>The existence of the map
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">f&#39;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>,</span>
and indeed of the maps
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>
and
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>,</span>
follow from the universal properties of kernels and cokernels. The map
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>
is the canonical quotient map
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi mathvariant="normal">coker</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A \to \coker(f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">coker</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span>,</span>
and the map
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>
is the canonical subobject inclusion
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ker</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">\ker(f) \to B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">ker</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>.</span></p>
<!--
<pre class="Agda">        <a id="12247" class="Keyword">where</a> <a id="12253" class="Keyword">abstract</a>
          <a id="12272" href="Cat.Abelian.Base.html#12272" data-type="(r : is-pre-abelian C) (f : Hom r A B₁) →
(r ∘ zero→ r) (proj′ r f) ≡ (r ∘ coeq r f) (proj′ r f)" class="Function">path</a> <a id="12277" class="Symbol">:</a> <a id="12279" href="Cat.Diagram.Zero.html#1010" data-type="Zero C → Hom C x y" class="Function">∅.zero→</a> <a id="12287" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="12289" href="Cat.Abelian.Base.html#11457" data-type="(r : is-pre-abelian C) (f : Hom r A B₁) →
Hom r (coapex r (kernel r f)) B₁" class="Function">proj′</a> <a id="12295" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="12297" href="Cat.Diagram.Coequaliser.html#1575" data-type="(r : Coequaliser C f g) → Hom C B₁ (r .coapex)" class="Function">Coker.coeq</a> <a id="12308" href="Cat.Abelian.Base.html#11422" class="Bound">f</a> <a id="12310" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="12312" href="Cat.Abelian.Base.html#11457" data-type="(r : is-pre-abelian C) (f : Hom r A B₁) →
Hom r (coapex r (kernel r f)) B₁" class="Function">proj′</a>
          <a id="12328" href="Cat.Abelian.Base.html#12272" data-type="(r : is-pre-abelian C) (f : Hom r A B₁) →
(r ∘ zero→ r) (proj′ r f) ≡ (r ∘ coeq r f) (proj′ r f)" class="Function">path</a> <a id="12333" class="Symbol">=</a> <a id="12335" href="Cat.Diagram.Coequaliser.html#1087" data-type="is-coequaliser C f g coeq →
e′ ≡ (C ∘ colim&#39;) coeq → e′ ≡ (C ∘ colim&#39;&#39;) coeq → colim&#39; ≡ colim&#39;&#39;" class="Function">Coker.unique₂</a> <a id="12349" class="Symbol">(</a><a id="12350" href="Cat.Diagram.Equaliser.Kernel.html#1104" data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" class="Function">Ker.kernel</a> <a id="12361" href="Cat.Abelian.Base.html#11422" class="Bound">f</a><a id="12362" class="Symbol">)</a>
            <a id="12376" class="Symbol">{</a><a id="12377" class="Argument">e′</a> <a id="12380" class="Symbol">=</a> <a id="12382" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a><a id="12384" class="Symbol">}</a> <a id="12386" class="Symbol">{</a><a id="12387" class="Argument">p</a> <a id="12389" class="Symbol">=</a> <a id="12391" href="Cat.Abelian.Base.html#2648" data-type="(r : Ab-category C) → (r ∘ f) (0m r) ≡ 0m r" class="Function">∘-zero-r</a> <a id="12400" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="12402" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="12406" href="Cat.Abelian.Base.html#3063" data-type="(r : Ab-category C) → (r ∘ 0m r) f ≡ 0m r" class="Function">∘-zero-l</a><a id="12414" class="Symbol">}</a>
            <a id="12428" class="Symbol">(</a><a id="12429" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="12433" class="Symbol">(</a> <a id="12435" href="Cat.Reasoning.html#1844" data-type="(C : Precategory o ℓ) (c≡ab : c ≡ (C ∘ a) b) →
(C ∘ c) f ≡ (C ∘ a) ((C ∘ b) f)" class="Function">pushl</a> <a id="12441" class="Symbol">(</a><a id="12442" href="Cat.Diagram.Zero.html#1167" data-type="(r : Zero C) (f : Hom C x y) → (C ∘ zero→ r) f ≡ zero→ r" class="Function">∅.zero-∘r</a> <a id="12452" class="Symbol">_)</a> <a id="12455" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="12457" href="Cat.Reasoning.html#1548" data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ a) ((C ∘ b) f) ≡ (C ∘ c) f" class="Function">pulll</a> <a id="12463" class="Symbol">(</a> <a id="12465" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="12469" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">_∘_</a> <a id="12473" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="12478" class="Symbol">(</a><a id="12479" href="Cat.Diagram.Terminal.html#461" data-type="(r : Terminal C) → is-terminal C (r .top)" class="Function">∅.has⊤</a> <a id="12486" class="Symbol">_</a> <a id="12488" class="Symbol">.</a><a id="12489" href="1Lab.HLevel.html#1416" data-type="(r : is-contr A) (x : A) → r .centre ≡ x" class="Field">paths</a> <a id="12495" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a><a id="12497" class="Symbol">)</a>
                                               <a id="12546" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="12548" href="Cat.Abelian.Base.html#2648" data-type="(r : Ab-category C) → (r ∘ f) (0m r) ≡ 0m r" class="Function">∘-zero-r</a><a id="12556" class="Symbol">)</a>
                 <a id="12575" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="12577" href="Cat.Abelian.Base.html#3063" data-type="(r : Ab-category C) → (r ∘ 0m r) f ≡ 0m r" class="Function">∘-zero-l</a><a id="12585" class="Symbol">))</a>
            <a id="12600" class="Symbol">(</a><a id="12601" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="12605" class="Symbol">(</a> <a id="12607" href="Cat.Reasoning.html#1678" data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ (C ∘ f) a) b ≡ (C ∘ f) c" class="Function">pullr</a> <a id="12613" class="Symbol">(</a><a id="12614" href="Cat.Diagram.Coequaliser.html#834" data-type="(r : is-coequaliser C f g coeq) → (C ∘ r .coequalise p) coeq ≡ e′" class="Function">Coker.universal</a> <a id="12630" class="Symbol">(</a><a id="12631" href="Cat.Diagram.Equaliser.Kernel.html#1104" data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" class="Function">Ker.kernel</a> <a id="12642" href="Cat.Abelian.Base.html#11422" class="Bound">f</a><a id="12643" class="Symbol">))</a> <a id="12646" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="12648" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="12652" class="Symbol">(</a><a id="12653" href="Cat.Diagram.Coequaliser.html#727" data-type="is-coequaliser C f g coeq → (C ∘ coeq) f ≡ (C ∘ coeq) g" class="Function">Coker.coequal</a> <a id="12667" class="Symbol">_)</a>
                 <a id="12687" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="12689" href="Cat.Abelian.Base.html#2648" data-type="(r : Ab-category C) → (r ∘ f) (0m r) ≡ 0m r" class="Function">∘-zero-r</a><a id="12697" class="Symbol">))</a>

      <a id="12707" href="Cat.Abelian.Base.html#12707" data-type="(r : is-pre-abelian C) (f : Hom r A B₁) →
(has-ab (has-additive r) ∘ kernel r (cokernel r f .coeq) .kernel)
((has-ab (has-additive r) ∘ map r f)
 (cokernel r (kernel r f .kernel) .coeq))
≡ f" class="Function">path</a> <a id="12712" class="Symbol">=</a>
        <a id="12722" href="Cat.Diagram.Equaliser.Kernel.html#1104" data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" class="Function">Ker.kernel</a> <a id="12733" class="Symbol">(</a><a id="12734" href="Cat.Diagram.Coequaliser.html#1575" data-type="(r : Coequaliser C f g) → Hom C B₁ (r .coapex)" class="Function">Coker.coeq</a> <a id="12745" href="Cat.Abelian.Base.html#11422" class="Bound">f</a><a id="12746" class="Symbol">)</a> <a id="12748" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="12750" href="Cat.Abelian.Base.html#11830" data-type="(r : is-pre-abelian C) (f : Hom r A B₁) →
Hom r (coapex r (kernel r f)) (ker r (coeq r f))" class="Function">map</a> <a id="12754" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="12756" href="Cat.Diagram.Coequaliser.html#1575" data-type="(r : Coequaliser C f g) → Hom C B₁ (r .coapex)" class="Function">Coker.coeq</a> <a id="12767" class="Symbol">(</a><a id="12768" href="Cat.Diagram.Equaliser.Kernel.html#1104" data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" class="Function">Ker.kernel</a> <a id="12779" href="Cat.Abelian.Base.html#11422" class="Bound">f</a><a id="12780" class="Symbol">)</a> <a id="12782" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="12785" href="Cat.Reasoning.html#1548" data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ a) ((C ∘ b) f) ≡ (C ∘ c) f" class="Function">pulll</a> <a id="12791" class="Symbol">(</a><a id="12792" href="Cat.Diagram.Equaliser.html#790" data-type="(r : is-equaliser C f g equ) → (C ∘ equ) (r .limiting p) ≡ e′" class="Function">Ker.universal</a> <a id="12806" class="Symbol">_)</a> <a id="12809" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
        <a id="12819" href="Cat.Abelian.Base.html#11457" data-type="(r : is-pre-abelian C) (f : Hom r A B₁) →
Hom r (coapex r (kernel r f)) B₁" class="Function">proj′</a> <a id="12825" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="12827" href="Cat.Diagram.Coequaliser.html#1575" data-type="(r : Coequaliser C f g) → Hom C B₁ (r .coapex)" class="Function">Coker.coeq</a> <a id="12838" class="Symbol">(</a><a id="12839" href="Cat.Diagram.Equaliser.Kernel.html#1104" data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" class="Function">Ker.kernel</a> <a id="12850" href="Cat.Abelian.Base.html#11422" class="Bound">f</a><a id="12851" class="Symbol">)</a>                           <a id="12879" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="12882" href="Cat.Diagram.Coequaliser.html#834" data-type="(r : is-coequaliser C f g coeq) → (C ∘ r .coequalise p) coeq ≡ e′" class="Function">Coker.universal</a> <a id="12898" class="Symbol">_</a> <a id="12900" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
        <a id="12910" href="Cat.Abelian.Base.html#11422" class="Bound">f</a>                                                           <a id="12970" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
</pre>-->
<p>A pre-abelian category is <strong>abelian</strong> when the map
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">f&#39;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>
in the above decomposition is an isomorphism.</p>
<pre class="Agda"><a id="13092" class="Keyword">record</a> <a id="is-abelian"></a><a id="13099" href="Cat.Abelian.Base.html#13099" data-type="(C : Precategory o ℓ) → Type (o ⊔ lsuc ℓ)" class="Record">is-abelian</a> <a id="13110" class="Symbol">{</a><a id="13111" href="Cat.Abelian.Base.html#13111" class="Bound">o</a> <a id="13113" href="Cat.Abelian.Base.html#13113" class="Bound">ℓ</a><a id="13114" class="Symbol">}</a> <a id="13116" class="Symbol">(</a><a id="13117" href="Cat.Abelian.Base.html#13117" class="Bound">C</a> <a id="13119" class="Symbol">:</a> <a id="13121" href="Cat.Base.html#704" data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" class="Record">Precategory</a> <a id="13133" href="Cat.Abelian.Base.html#13111" class="Bound">o</a> <a id="13135" href="Cat.Abelian.Base.html#13113" class="Bound">ℓ</a><a id="13136" class="Symbol">)</a> <a id="13138" class="Symbol">:</a> <a id="13140" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="13145" class="Symbol">(</a><a id="13146" href="Cat.Abelian.Base.html#13111" class="Bound">o</a> <a id="13148" href="Agda.Primitive.html#810" data-type="Level → Level → Level" class="Primitive Operator">⊔</a> <a id="13150" href="Agda.Primitive.html#780" data-type="Level → Level" class="Primitive">lsuc</a> <a id="13155" href="Cat.Abelian.Base.html#13113" class="Bound">ℓ</a><a id="13156" class="Symbol">)</a> <a id="13158" class="Keyword">where</a>
  <a id="13166" class="Keyword">field</a> <a id="is-abelian.has-is-preab"></a><a id="13172" href="Cat.Abelian.Base.html#13172" data-type="is-abelian C → is-pre-abelian C" class="Field">has-is-preab</a> <a id="13185" class="Symbol">:</a> <a id="13187" href="Cat.Abelian.Base.html#10374" data-type="(C : Precategory o ℓ) → Type (o ⊔ lsuc ℓ)" class="Record">is-pre-abelian</a> <a id="13202" href="Cat.Abelian.Base.html#13117" class="Bound">C</a>
  <a id="13206" class="Keyword">open</a> <a id="13211" href="Cat.Abelian.Base.html#10374" data-type="(C : Precategory o ℓ) → Type (o ⊔ lsuc ℓ)" class="Module">is-pre-abelian</a> <a id="13226" href="Cat.Abelian.Base.html#13172" data-type="is-abelian C → is-pre-abelian C" class="Field">has-is-preab</a> <a id="13239" class="Keyword">public</a>
  <a id="13248" class="Keyword">field</a>
    <a id="is-abelian.coker-ker≃ker-coker"></a><a id="13258" href="Cat.Abelian.Base.html#13258" data-type="(r : is-abelian C) (f : Hom (r .has-is-preab) A B₁) →
is-invertible r (decompose r f .fst)" class="Field">coker-ker≃ker-coker</a>
      <a id="13284" class="Symbol">:</a> <a id="13286" class="Symbol">∀</a> <a id="13288" class="Symbol">{</a><a id="13289" href="Cat.Abelian.Base.html#13289" class="Bound">A</a> <a id="13291" href="Cat.Abelian.Base.html#13291" class="Bound">B</a><a id="13292" class="Symbol">}</a> <a id="13294" class="Symbol">(</a><a id="13295" href="Cat.Abelian.Base.html#13295" class="Bound">f</a> <a id="13297" class="Symbol">:</a> <a id="13299" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">Hom</a> <a id="13303" href="Cat.Abelian.Base.html#13289" class="Bound">A</a> <a id="13305" href="Cat.Abelian.Base.html#13291" class="Bound">B</a><a id="13306" class="Symbol">)</a> <a id="13308" class="Symbol">→</a> <a id="13310" href="Cat.Morphism.html#1930" data-type="(C : Precategory o h) (f : Hom C a b) → Type h" class="Record">is-invertible</a> <a id="13324" class="Symbol">(</a><a id="13325" href="Cat.Abelian.Base.html#11217" data-type="(r : is-pre-abelian C) (f : Hom r A B₁) →
Σ
(λ f′ →
   f ≡ (r ∘ kernel r (coeq r f)) ((r ∘ f′) (coeq r (kernel r f))))" class="Function">decompose</a> <a id="13335" href="Cat.Abelian.Base.html#13295" class="Bound">f</a> <a id="13337" class="Symbol">.</a><a id="13338" href="Agda.Builtin.Sigma.html#252" data-type="∑ A B₁ → A" class="Field">fst</a><a id="13341" class="Symbol">)</a>
</pre>
<p>This implies in particular that any monomorphism is a kernel, and
every epimorphism is a cokernel. Let’s investigate the case for “every
mono is a kernel” first: Suppose that
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>A</mi><mo>↪</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">f : A \mono B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6943em;vertical-align:-0.011em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↪</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>
is some monomorphism; We’ll show that it’s isomorphic to
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ker</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="normal">coker</mi><mo>⁡</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\ker (\coker f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">ker</span><span class="mopen">(</span><span class="mop"><span class="mord mathrm">coker</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span>
in the slice category
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">A</mi><mi mathvariant="normal">/</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">\ca{A}/B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal">A</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>.</span></p>
<pre class="Agda">  <a id="13659" class="Keyword">module</a> <a id="13666" href="Cat.Abelian.Base.html#13666" class="Module">_</a> <a id="13668" class="Symbol">{</a><a id="13669" href="Cat.Abelian.Base.html#13669" class="Bound">A</a> <a id="13671" href="Cat.Abelian.Base.html#13671" class="Bound">B</a><a id="13672" class="Symbol">}</a> <a id="13674" class="Symbol">(</a><a id="13675" href="Cat.Abelian.Base.html#13675" class="Bound">f</a> <a id="13677" class="Symbol">:</a> <a id="13679" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">Hom</a> <a id="13683" href="Cat.Abelian.Base.html#13669" class="Bound">A</a> <a id="13685" href="Cat.Abelian.Base.html#13671" class="Bound">B</a><a id="13686" class="Symbol">)</a> <a id="13688" class="Symbol">(</a><a id="13689" href="Cat.Abelian.Base.html#13689" class="Bound">monic</a> <a id="13695" class="Symbol">:</a> <a id="13697" href="Cat.Morphism.html#590" data-type="(C : Precategory o h) → Hom C a b → Type (o ⊔ h)" class="Function">is-monic</a> <a id="13706" href="Cat.Abelian.Base.html#13675" class="Bound">f</a><a id="13707" class="Symbol">)</a> <a id="13709" class="Keyword">where</a>
    <a id="13719" class="Keyword">private</a>
      <a id="13733" class="Keyword">module</a> <a id="13740" href="Cat.Abelian.Base.html#13740" class="Module">m</a> <a id="13742" class="Symbol">=</a> <a id="13744" href="Algebra.Prelude.html#883" class="Module">Cat</a> <a id="13748" class="Symbol">(</a><a id="13749" href="Cat.Instances.Slice.html#4479" data-type="(C : Precategory o ℓ) → Ob C → Precategory (o ⊔ ℓ) ℓ" class="Function">Slice</a> <a id="13755" href="Cat.Abelian.Base.html#13117" class="Bound">C</a> <a id="13757" href="Cat.Abelian.Base.html#13671" class="Bound">B</a><a id="13758" class="Symbol">)</a>
</pre>
<p>The map
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>ker</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="normal">coker</mi><mo>⁡</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A \to \ker (\coker f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">ker</span><span class="mopen">(</span><span class="mop"><span class="mord mathrm">coker</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span>
is obtained as the composite</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mover><mo stretchy="true" minsize="3.0em">↠</mo><mpadded width="+0.6em" lspace="0.3em"><mi>p</mi></mpadded></mover><mi mathvariant="normal">coker</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>ker</mi><mo>⁡</mo><mi>f</mi><mo stretchy="false">)</mo><mo>≅</mo><mi>ker</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="normal">coker</mi><mo>⁡</mo><mi>f</mi><mo stretchy="false">)</mo><mtext>,</mtext></mrow><annotation encoding="application/x-tex">
A \xepi{p} \coker (\ker f) \cong \ker (\coker f)\text{,}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8294em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel x-arrow"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8294em;"><span style="top:-3.228em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="svg-align" style="top:-2.783em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.334em;min-width:0.888em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.334em" viewBox="0 0 400000 334" preserveAspectRatio="xMaxYMin slice"><path d="M400000 167
c-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3
 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42
 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333
-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70
 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z"></path></svg></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">coker</span></span><span class="mopen">(</span><span class="mop">ker</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">ker</span><span class="mopen">(</span><span class="mop"><span class="mord mathrm">coker</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mord text"><span class="mord">,</span></span></span></span></span></span></p>
<p>where the isomorphism is our canonical map from before.</p>
<pre class="Agda">      <a id="13962" href="Cat.Abelian.Base.html#13962" data-type="(r : is-abelian C) (f : Hom r A B₁) (monic : is-monic r f) →
Slice C B₁ .Hom (cut f) (cut (kernel r (coeq r f)))" class="Function">f→kercoker</a> <a id="13973" class="Symbol">:</a> <a id="13975" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">m.Hom</a> <a id="13981" class="Symbol">(</a><a id="13982" href="Cat.Instances.Slice.html#2264" data-type="(map₁ : Hom C domain c) → /-Obj c" class="InductiveConstructor">cut</a> <a id="13986" href="Cat.Abelian.Base.html#13675" class="Bound">f</a><a id="13987" class="Symbol">)</a> <a id="13989" class="Symbol">(</a><a id="13990" href="Cat.Instances.Slice.html#2264" data-type="(map₁ : Hom C domain c) → /-Obj c" class="InductiveConstructor">cut</a> <a id="13994" class="Symbol">(</a><a id="13995" href="Cat.Diagram.Equaliser.Kernel.html#1104" data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" class="Function">Ker.kernel</a> <a id="14006" class="Symbol">(</a><a id="14007" href="Cat.Diagram.Coequaliser.html#1575" data-type="(r : Coequaliser C f g) → Hom C B₁ (r .coapex)" class="Function">Coker.coeq</a> <a id="14018" href="Cat.Abelian.Base.html#13675" class="Bound">f</a><a id="14019" class="Symbol">)))</a>
      <a id="14029" href="Cat.Abelian.Base.html#13962" data-type="(r : is-abelian C) (f : Hom r A B₁) (monic : is-monic r f) →
Slice C B₁ .Hom (cut f) (cut (kernel r (coeq r f)))" class="Function">f→kercoker</a> <a id="14040" class="Symbol">.</a><a id="14041" href="Cat.Instances.Slice.html#2951" data-type="/-Hom a b → Hom C (a .domain) (domain b)" class="Field">/-Hom.map</a> <a id="14051" class="Symbol">=</a> <a id="14053" href="Cat.Abelian.Base.html#11217" data-type="(r : is-pre-abelian C) (f : Hom r A B₁) →
Σ
(λ f′ →
   f ≡ (r ∘ kernel r (coeq r f)) ((r ∘ f′) (coeq r (kernel r f))))" class="Function">decompose</a> <a id="14063" href="Cat.Abelian.Base.html#13675" class="Bound">f</a> <a id="14065" class="Symbol">.</a><a id="14066" href="Agda.Builtin.Sigma.html#252" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="14070" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="14072" href="Cat.Diagram.Coequaliser.html#1575" data-type="(r : Coequaliser C f g) → Hom C B₁ (r .coapex)" class="Function">Coker.coeq</a> <a id="14083" class="Symbol">(</a><a id="14084" href="Cat.Diagram.Equaliser.Kernel.html#1104" data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" class="Function">Ker.kernel</a> <a id="14095" href="Cat.Abelian.Base.html#13675" class="Bound">f</a><a id="14096" class="Symbol">)</a>
      <a id="14104" href="Cat.Abelian.Base.html#13962" data-type="(r : is-abelian C) (f : Hom r A B₁) (monic : is-monic r f) →
Slice C B₁ .Hom (cut f) (cut (kernel r (coeq r f)))" class="Function">f→kercoker</a> <a id="14115" class="Symbol">.</a><a id="14116" href="Cat.Instances.Slice.html#2992" data-type="(r : /-Hom a b) → (C ∘ map b) (r .map) ≡ a .map" class="Field">/-Hom.commutes</a> <a id="14131" class="Symbol">=</a> <a id="14133" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="14137" class="Symbol">(</a><a id="14138" href="Cat.Abelian.Base.html#11217" data-type="(r : is-pre-abelian C) (f : Hom r A B₁) →
Σ
(λ f′ →
   f ≡ (r ∘ kernel r (coeq r f)) ((r ∘ f′) (coeq r (kernel r f))))" class="Function">decompose</a> <a id="14148" href="Cat.Abelian.Base.html#13675" class="Bound">f</a> <a id="14150" class="Symbol">.</a><a id="14151" href="Agda.Builtin.Sigma.html#264" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a><a id="14154" class="Symbol">)</a>
</pre>
<p>Conversely, map
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ker</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="normal">coker</mi><mo>⁡</mo><mi>f</mi><mo stretchy="false">)</mo><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\ker (\coker f) \to A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">ker</span><span class="mopen">(</span><span class="mop"><span class="mord mathrm">coker</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>
is the composite</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>ker</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="normal">coker</mi><mo>⁡</mo><mi>f</mi><mo stretchy="false">)</mo><mo>≅</mo><mi mathvariant="normal">coker</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>ker</mi><mo>⁡</mo><mi>f</mi><mo stretchy="false">)</mo><mo>→</mo><mi>A</mi><mtext>,</mtext></mrow><annotation encoding="application/x-tex">
\ker (\coker f) \cong \coker (\ker f) \to A\text{,}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">ker</span><span class="mopen">(</span><span class="mop"><span class="mord mathrm">coker</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">coker</span></span><span class="mopen">(</span><span class="mop">ker</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">A</span><span class="mord text"><span class="mord">,</span></span></span></span></span></span></p>
<p>where the second map arises from the universal property of the
cokernel: We can map out of it with the map
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ker</mi><mo>⁡</mo><mi>f</mi><mo>↪</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\ker f \mono A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mop">ker</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↪</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>,</span>
since (using that
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>
is mono), we have
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>=</mo><mi>ker</mi><mo>⁡</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">0 = \ker f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mop">ker</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>
from
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mn>0</mn><mo>=</mo><mi>f</mi><mi>ker</mi><mo>⁡</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">f0 = f\ker f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">ker</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>.</span></p>
<pre class="Agda">      <a id="14492" href="Cat.Abelian.Base.html#14492" data-type="(r : is-abelian C) (f : Hom r A B₁) (monic : is-monic r f) →
Slice C B₁ .Hom (cut (kernel r (coeq r f))) (cut f)" class="Function">kercoker→f</a> <a id="14503" class="Symbol">:</a> <a id="14505" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">m.Hom</a> <a id="14511" class="Symbol">(</a><a id="14512" href="Cat.Instances.Slice.html#2264" data-type="(map₁ : Hom C domain c) → /-Obj c" class="InductiveConstructor">cut</a> <a id="14516" class="Symbol">(</a><a id="14517" href="Cat.Diagram.Equaliser.Kernel.html#1104" data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" class="Function">Ker.kernel</a> <a id="14528" class="Symbol">(</a><a id="14529" href="Cat.Diagram.Coequaliser.html#1575" data-type="(r : Coequaliser C f g) → Hom C B₁ (r .coapex)" class="Function">Coker.coeq</a> <a id="14540" href="Cat.Abelian.Base.html#13675" class="Bound">f</a><a id="14541" class="Symbol">)))</a> <a id="14545" class="Symbol">(</a><a id="14546" href="Cat.Instances.Slice.html#2264" data-type="(map₁ : Hom C domain c) → /-Obj c" class="InductiveConstructor">cut</a> <a id="14550" href="Cat.Abelian.Base.html#13675" class="Bound">f</a><a id="14551" class="Symbol">)</a>
      <a id="14559" href="Cat.Abelian.Base.html#14492" data-type="(r : is-abelian C) (f : Hom r A B₁) (monic : is-monic r f) →
Slice C B₁ .Hom (cut (kernel r (coeq r f))) (cut f)" class="Function">kercoker→f</a> <a id="14570" class="Symbol">.</a><a id="14571" href="Cat.Instances.Slice.html#2951" data-type="/-Hom a b → Hom C (a .domain) (domain b)" class="Field">/-Hom.map</a> <a id="14581" class="Symbol">=</a>
        <a id="14591" href="Cat.Diagram.Coequaliser.html#764" data-type="is-coequaliser C f g coeq → (C ∘ e′) f ≡ (C ∘ e′) g → Hom C E F" class="Function">Coker.coequalise</a> <a id="14608" class="Symbol">(</a><a id="14609" href="Cat.Diagram.Equaliser.Kernel.html#1104" data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" class="Function">Ker.kernel</a> <a id="14620" href="Cat.Abelian.Base.html#13675" class="Bound">f</a><a id="14621" class="Symbol">)</a> <a id="14623" class="Symbol">{</a><a id="14624" class="Argument">e′</a> <a id="14627" class="Symbol">=</a> <a id="14629" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">id</a><a id="14631" class="Symbol">}</a> <a id="14633" class="Symbol">(</a><a id="14634" href="Cat.Abelian.Base.html#13689" class="Bound">monic</a> <a id="14640" class="Symbol">_</a> <a id="14642" class="Symbol">_</a> <a id="14644" href="Cat.Abelian.Base.html#14736" data-type="(r : is-abelian C) (f : Hom r A B₁) (monic : is-monic r f) →
(r ∘ f) ((r ∘ id r) (0m r)) ≡ (r ∘ f) ((r ∘ id r) (kernel r f))" class="Function">path</a><a id="14648" class="Symbol">)</a> <a id="14650" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a>
          <a id="14662" href="Cat.Abelian.Base.html#13258" data-type="(r : is-abelian C) (f : Hom (r .has-is-preab) A B₁) →
is-invertible r (decompose r f .fst)" class="Field">coker-ker≃ker-coker</a> <a id="14682" href="Cat.Abelian.Base.html#13675" class="Bound">f</a> <a id="14684" class="Symbol">.</a><a id="14685" href="Cat.Morphism.html#1985" data-type="is-invertible C f → Hom C b a" class="Field">is-invertible.inv</a>
        <a id="14711" class="Keyword">where</a> <a id="14717" class="Keyword">abstract</a>
          <a id="14736" href="Cat.Abelian.Base.html#14736" data-type="(r : is-abelian C) (f : Hom r A B₁) (monic : is-monic r f) →
(r ∘ f) ((r ∘ id r) (0m r)) ≡ (r ∘ f) ((r ∘ id r) (kernel r f))" class="Function">path</a> <a id="14741" class="Symbol">:</a> <a id="14743" href="Cat.Abelian.Base.html#13675" class="Bound">f</a> <a id="14745" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="14747" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">id</a> <a id="14750" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="14752" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a> <a id="14755" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="14757" href="Cat.Abelian.Base.html#13675" class="Bound">f</a> <a id="14759" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="14761" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">id</a> <a id="14764" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="14766" href="Cat.Diagram.Equaliser.Kernel.html#1104" data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" class="Function">Ker.kernel</a> <a id="14777" href="Cat.Abelian.Base.html#13675" class="Bound">f</a>
          <a id="14789" href="Cat.Abelian.Base.html#14736" data-type="(r : is-abelian C) (f : Hom r A B₁) (monic : is-monic r f) →
(r ∘ f) ((r ∘ id r) (0m r)) ≡ (r ∘ f) ((r ∘ id r) (kernel r f))" class="Function">path</a> <a id="14794" class="Symbol">=</a>
            <a id="14808" href="Cat.Abelian.Base.html#13675" class="Bound">f</a> <a id="14810" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="14812" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">id</a> <a id="14815" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="14817" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a>              <span class="reasoning-step"><span class="as-written Function"><a id="14833" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="14836" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="14839" class="Symbol">(</a><a id="14840" href="Cat.Abelian.Base.html#13675" class="Bound">f</a> <a id="14842" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘_</a><a id="14844" class="Symbol">)</a> <a id="14846" class="Symbol">(</a><a id="14847" href="Cat.Reasoning.html#1009" data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → (C ∘ a) f ≡ f" class="Function">eliml</a> <a id="14853" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a><a id="14857" class="Symbol">)</a> <a id="14859" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="14861" href="Cat.Abelian.Base.html#2648" data-type="(r : Ab-category C) → (r ∘ f) (0m r) ≡ 0m r" class="Function">∘-zero-r</a> <a id="14870" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
            <a id="14884" href="Cat.Abelian.Base.html#1533" data-type="(r : Ab-category C) → Hom r A B₁" class="Function">0m</a>                       <span class="reasoning-step"><span class="as-written Function Operator"><a id="14909" href="1Lab.Path.html#46783" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">≡˘⟨</a> <a id="14913" href="Cat.Diagram.Zero.html#1167" data-type="(r : Zero C) (f : Hom C x y) → (C ∘ zero→ r) f ≡ zero→ r" class="Function">∅.zero-∘r</a> <a id="14923" class="Symbol">_</a> <a id="14925" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="14927" href="Cat.Abelian.Base.html#6930" data-type="(r : is-additive C) → zero→ r ≡ 0m r" class="Function">0m-unique</a> <a id="14937" href="1Lab.Path.html#46783" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡˘</span></span>
            <a id="14951" class="Symbol">(</a><a id="14952" href="Cat.Diagram.Zero.html#1010" data-type="Zero C → Hom C x y" class="Function">∅.zero→</a> <a id="14960" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="14962" href="Cat.Diagram.Equaliser.Kernel.html#1104" data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" class="Function">Ker.kernel</a> <a id="14973" href="Cat.Abelian.Base.html#13675" class="Bound">f</a><a id="14974" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function Operator"><a id="14976" href="1Lab.Path.html#46783" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">≡˘⟨</a> <a id="14980" href="Cat.Diagram.Equaliser.html#687" data-type="is-equaliser C f g equ → (C ∘ f) equ ≡ (C ∘ g) equ" class="Function">Ker.equal</a> <a id="14990" href="Cat.Abelian.Base.html#13675" class="Bound">f</a> <a id="14992" href="1Lab.Path.html#46783" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡˘</span></span>
            <a id="15006" href="Cat.Abelian.Base.html#13675" class="Bound">f</a> <a id="15008" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="15010" href="Cat.Diagram.Equaliser.Kernel.html#1104" data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" class="Function">Ker.kernel</a> <a id="15021" href="Cat.Abelian.Base.html#13675" class="Bound">f</a>         <span class="reasoning-step"><span class="as-written Function"><a id="15031" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="15034" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="15037" class="Symbol">(</a><a id="15038" href="Cat.Abelian.Base.html#13675" class="Bound">f</a> <a id="15040" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘_</a><a id="15042" class="Symbol">)</a> <a id="15044" class="Symbol">(</a><a id="15045" href="Cat.Reasoning.html#1207" data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → f ≡ (C ∘ a) f" class="Function">introl</a> <a id="15052" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a><a id="15056" class="Symbol">)</a> <a id="15058" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
            <a id="15072" href="Cat.Abelian.Base.html#13675" class="Bound">f</a> <a id="15074" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="15076" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">id</a> <a id="15079" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="15081" href="Cat.Diagram.Equaliser.Kernel.html#1104" data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" class="Function">Ker.kernel</a> <a id="15092" href="Cat.Abelian.Base.html#13675" class="Bound">f</a>    <a id="15097" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
</pre>
<p>This is indeed a map in the slice using that both isomorphisms and
coequalisers are epic to make progress.</p>
<pre class="Agda">      <a id="15226" href="Cat.Abelian.Base.html#14492" data-type="(r : is-abelian C) (f : Hom r A B₁) (monic : is-monic r f) →
Slice C B₁ .Hom (cut (kernel r (coeq r f))) (cut f)" class="Function">kercoker→f</a> <a id="15237" class="Symbol">.</a><a id="15238" href="Cat.Instances.Slice.html#2992" data-type="(r : /-Hom a b) → (C ∘ map b) (r .map) ≡ a .map" class="Field">/-Hom.commutes</a> <a id="15253" class="Symbol">=</a> <a id="15255" href="Cat.Abelian.Base.html#15482" data-type="(r : is-abelian C) (f : Hom r A B₁) (monic : is-monic r f) →
(r ∘ f)
((r ∘
  coequalise (cokernel (has-is-preab r) (kernel (r .has-is-preab) f))
  (monic ((r ∘ id r) (0m r)) ((r ∘ id r) (kernel r f))
   (path r f monic)))
 (coker-ker≃ker-coker r f .inv))
≡ kernel (has-is-preab r) (coeq (has-is-preab r) f) .kernel" class="Function">path</a> <a id="15260" class="Keyword">where</a>
        <a id="15274" href="Cat.Abelian.Base.html#15274" data-type="(r : is-abelian C) (f : Hom r A B₁) (monic : is-monic r f) →
(C ∘ f)
(has-is-coeq
 (cokernel (has-is-preab r) (kernel (has-is-preab r) f)) .coequalise
 (monic ((r ∘ id r) (0m r)) ((r ∘ id r) (kernel r f))
  (path r f monic)))
≡
C ._∘_ (kernel (has-is-preab r) (coeq (has-is-preab r) f))
(decompose r f .fst)" class="Function">lemma</a> <a id="15280" class="Symbol">=</a>
          <a id="15292" href="Cat.Diagram.Coequaliser.html#1870" data-type="(C : Precategory o ℓ) (coequ : Hom C A E) →
is-coequaliser C f g coequ → is-epic C coequ" class="Function">is-coequaliser→is-epic</a> <a id="15315" class="Symbol">(</a><a id="15316" href="Cat.Diagram.Coequaliser.html#1575" data-type="(r : Coequaliser C f g) → Hom C B₁ (r .coapex)" class="Function">Coker.coeq</a> <a id="15327" class="Symbol">_)</a> <a id="15330" class="Symbol">(</a><a id="15331" href="Cat.Diagram.Coequaliser.html#1604" data-type="(r : Coequaliser C f g) → is-coequaliser C f g (r .coeq)" class="Function">Coker.has-is-coeq</a> <a id="15349" class="Symbol">_)</a> <a id="15352" class="Symbol">_</a> <a id="15354" class="Symbol">_</a> <a id="15356" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a>
               <a id="15373" href="Cat.Reasoning.html#1678" data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ (C ∘ f) a) b ≡ (C ∘ f) c" class="Function">pullr</a> <a id="15379" class="Symbol">(</a><a id="15380" href="Cat.Diagram.Coequaliser.html#834" data-type="(r : is-coequaliser C f g coeq) → (C ∘ r .coequalise p) coeq ≡ e′" class="Function">Coker.universal</a> <a id="15396" class="Symbol">_)</a>
            <a id="15411" href="1Lab.Path.html#38305" data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" class="Function Operator">··</a> <a id="15414" href="Cat.Reasoning.html#1108" data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → (C ∘ f) a ≡ f" class="Function">elimr</a> <a id="15420" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
            <a id="15437" href="1Lab.Path.html#38305" data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" class="Function Operator">··</a> <a id="15440" class="Symbol">(</a><a id="15441" href="Cat.Abelian.Base.html#11217" data-type="(r : is-pre-abelian C) (f : Hom r A B₁) →
Σ
(λ f′ →
   f ≡ (r ∘ kernel r (coeq r f)) ((r ∘ f′) (coeq r (kernel r f))))" class="Function">decompose</a> <a id="15451" href="Cat.Abelian.Base.html#13675" class="Bound">f</a> <a id="15453" class="Symbol">.</a><a id="15454" href="Agda.Builtin.Sigma.html#264" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="15458" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="15460" href="Cat.Base.html#3857" data-type="(r : Precategory o h) (f : r .Hom y z) (g : r .Hom x y)
(h : r .Hom w x) →
r ._∘_ f (r ._∘_ g h) ≡ r ._∘_ (r ._∘_ f g) h" class="Function">assoc</a> <a id="15466" class="Symbol">_</a> <a id="15468" class="Symbol">_</a> <a id="15470" class="Symbol">_)</a>

        <a id="15482" href="Cat.Abelian.Base.html#15482" data-type="(r : is-abelian C) (f : Hom r A B₁) (monic : is-monic r f) →
(r ∘ f)
((r ∘
  coequalise (cokernel (has-is-preab r) (kernel (r .has-is-preab) f))
  (monic ((r ∘ id r) (0m r)) ((r ∘ id r) (kernel r f))
   (path r f monic)))
 (coker-ker≃ker-coker r f .inv))
≡ kernel (has-is-preab r) (coeq (has-is-preab r) f) .kernel" class="Function">path</a> <a id="15487" class="Symbol">=</a>
          <a id="15499" href="Cat.Morphism.html#8401" data-type="(C : Precategory o h) → is-invertible C f → is-epic C f" class="Function">invertible→epic</a> <a id="15515" class="Symbol">(</a><a id="15516" href="Cat.Abelian.Base.html#13258" data-type="(r : is-abelian C) (f : Hom (r .has-is-preab) A B₁) →
is-invertible r (decompose r f .fst)" class="Field">coker-ker≃ker-coker</a> <a id="15536" class="Symbol">_)</a> <a id="15539" class="Symbol">_</a> <a id="15541" class="Symbol">_</a> <a id="15543" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a>
            <a id="15557" class="Symbol">(</a><a id="15558" href="Cat.Abelian.Base.html#13675" class="Bound">f</a> <a id="15560" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="15562" href="Cat.Diagram.Coequaliser.html#764" data-type="is-coequaliser C f g coeq → (C ∘ e′) f ≡ (C ∘ e′) g → Hom C E F" class="Function">Coker.coequalise</a> <a id="15579" class="Symbol">_</a> <a id="15581" class="Symbol">_</a> <a id="15583" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="15585" class="Symbol">_)</a> <a id="15588" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="15590" href="Cat.Abelian.Base.html#11217" data-type="(r : is-pre-abelian C) (f : Hom r A B₁) →
Σ
(λ f′ →
   f ≡ (r ∘ kernel r (coeq r f)) ((r ∘ f′) (coeq r (kernel r f))))" class="Function">decompose</a> <a id="15600" href="Cat.Abelian.Base.html#13675" class="Bound">f</a> <a id="15602" class="Symbol">.</a><a id="15603" href="Agda.Builtin.Sigma.html#252" data-type="∑ A B₁ → A" class="Field">fst</a>   <span class="reasoning-step"><span class="as-written Function"><a id="15609" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="15612" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="15616" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">_∘_</a> <a id="15620" class="Symbol">(</a><a id="15621" href="Cat.Base.html#3857" data-type="(r : Precategory o h) (f : r .Hom y z) (g : r .Hom x y)
(h : r .Hom w x) →
r ._∘_ f (r ._∘_ g h) ≡ r ._∘_ (r ._∘_ f g) h" class="Function">assoc</a> <a id="15627" class="Symbol">_</a> <a id="15629" class="Symbol">_</a> <a id="15631" class="Symbol">_)</a> <a id="15634" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="15639" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
            <a id="15653" class="Symbol">((</a><a id="15655" href="Cat.Abelian.Base.html#13675" class="Bound">f</a> <a id="15657" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="15659" href="Cat.Diagram.Coequaliser.html#764" data-type="is-coequaliser C f g coeq → (C ∘ e′) f ≡ (C ∘ e′) g → Hom C E F" class="Function">Coker.coequalise</a> <a id="15676" class="Symbol">_</a> <a id="15678" class="Symbol">_)</a> <a id="15681" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="15683" class="Symbol">_)</a> <a id="15686" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="15688" href="Cat.Abelian.Base.html#11217" data-type="(r : is-pre-abelian C) (f : Hom r A B₁) →
Σ
(λ f′ →
   f ≡ (r ∘ kernel r (coeq r f)) ((r ∘ f′) (coeq r (kernel r f))))" class="Function">decompose</a> <a id="15698" href="Cat.Abelian.Base.html#13675" class="Bound">f</a> <a id="15700" class="Symbol">.</a><a id="15701" href="Agda.Builtin.Sigma.html#252" data-type="∑ A B₁ → A" class="Field">fst</a> <span class="reasoning-step"><span class="as-written Function"><a id="15705" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="15708" href="Cat.Reasoning.html#2731" data-type="(C : Precategory o ℓ) (inv₁ : (C ∘ h) i ≡ id C) →
(C ∘ (C ∘ f) h) i ≡ f" class="Function">cancelr</a> <a id="15716" class="Symbol">(</a><a id="15717" href="Cat.Abelian.Base.html#13258" data-type="(r : is-abelian C) (f : Hom (r .has-is-preab) A B₁) →
is-invertible r (decompose r f .fst)" class="Field">coker-ker≃ker-coker</a> <a id="15737" class="Symbol">_</a> <a id="15739" class="Symbol">.</a><a id="15740" href="Cat.Morphism.html#1889" data-type="Inverses C f g → (C ∘ g) f ≡ id C" class="Function">is-invertible.invr</a><a id="15758" class="Symbol">)</a> <a id="15760" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
            <a id="15774" href="Cat.Abelian.Base.html#13675" class="Bound">f</a> <a id="15776" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="15778" href="Cat.Diagram.Coequaliser.html#764" data-type="is-coequaliser C f g coeq → (C ∘ e′) f ≡ (C ∘ e′) g → Hom C E F" class="Function">Coker.coequalise</a> <a id="15795" class="Symbol">_</a> <a id="15797" class="Symbol">_</a>                            <span class="reasoning-step"><span class="as-written Function"><a id="15826" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="15829" href="Cat.Abelian.Base.html#15274" data-type="(r : is-abelian C) (f : Hom r A B₁) (monic : is-monic r f) →
(C ∘ f)
(has-is-coeq
 (cokernel (has-is-preab r) (kernel (has-is-preab r) f)) .coequalise
 (monic ((r ∘ id r) (0m r)) ((r ∘ id r) (kernel r f))
  (path r f monic)))
≡
C ._∘_ (kernel (has-is-preab r) (coeq (has-is-preab r) f))
(decompose r f .fst)" class="Function">lemma</a> <a id="15835" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
            <a id="15849" href="Cat.Diagram.Equaliser.Kernel.html#1104" data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" class="Function">Ker.kernel</a> <a id="15860" class="Symbol">_</a> <a id="15862" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="15864" href="Cat.Abelian.Base.html#11217" data-type="(r : is-pre-abelian C) (f : Hom r A B₁) →
Σ
(λ f′ →
   f ≡ (r ∘ kernel r (coeq r f)) ((r ∘ f′) (coeq r (kernel r f))))" class="Function">decompose</a> <a id="15874" href="Cat.Abelian.Base.html#13675" class="Bound">f</a> <a id="15876" class="Symbol">.</a><a id="15877" href="Agda.Builtin.Sigma.html#252" data-type="∑ A B₁ → A" class="Field">fst</a>                     <a id="15901" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
</pre>
<p>Using the universal property of the cokernel (both uniqueness and
universality), we establish that the maps defined above are inverses in
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">A</mi></mrow><annotation encoding="application/x-tex">\ca{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal">A</span></span></span></span>,</span>
thus assemble into an isomorphism in the slice.</p>
<pre class="Agda">    <a id="16117" href="Cat.Abelian.Base.html#16117" data-type="(r : is-abelian C) (f : Hom r A B₁) (monic : is-monic r f) →
(Slice C B₁ ≅ cut f) (cut (kernel r (coeq r f)))" class="Function">mono→kernel</a> <a id="16129" class="Symbol">:</a> <a id="16131" href="Cat.Instances.Slice.html#2264" data-type="(map₁ : Hom C domain c) → /-Obj c" class="InductiveConstructor">cut</a> <a id="16135" href="Cat.Abelian.Base.html#13675" class="Bound">f</a> <a id="16137" href="Cat.Morphism.html#2202" data-type="(C : Precategory o h) (a b : Ob C) → Type h" class="Record Operator">m.≅</a> <a id="16141" href="Cat.Instances.Slice.html#2264" data-type="(map₁ : Hom C domain c) → /-Obj c" class="InductiveConstructor">cut</a> <a id="16145" class="Symbol">(</a><a id="16146" href="Cat.Diagram.Equaliser.Kernel.html#1104" data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" class="Function">Ker.kernel</a> <a id="16157" class="Symbol">(</a><a id="16158" href="Cat.Diagram.Coequaliser.html#1575" data-type="(r : Coequaliser C f g) → Hom C B₁ (r .coapex)" class="Function">Coker.coeq</a> <a id="16169" href="Cat.Abelian.Base.html#13675" class="Bound">f</a><a id="16170" class="Symbol">))</a>
    <a id="16177" href="Cat.Abelian.Base.html#16117" data-type="(r : is-abelian C) (f : Hom r A B₁) (monic : is-monic r f) →
(Slice C B₁ ≅ cut f) (cut (kernel r (coeq r f)))" class="Function">mono→kernel</a> <a id="16189" class="Symbol">=</a> <a id="16191" href="Cat.Morphism.html#3707" data-type="(C : Precategory o h) (f : Hom C a b) (g : Hom C b a) →
(C ∘ f) g ≡ id C → (C ∘ g) f ≡ id C → (C ≅ a) b" class="Function">m.make-iso</a> <a id="16202" href="Cat.Abelian.Base.html#13962" data-type="(r : is-abelian C) (f : Hom r A B₁) (monic : is-monic r f) →
Slice C B₁ .Hom (cut f) (cut (kernel r (coeq r f)))" class="Function">f→kercoker</a> <a id="16213" href="Cat.Abelian.Base.html#14492" data-type="(r : is-abelian C) (f : Hom r A B₁) (monic : is-monic r f) →
Slice C B₁ .Hom (cut (kernel r (coeq r f))) (cut f)" class="Function">kercoker→f</a> <a id="16224" href="Cat.Abelian.Base.html#16251" data-type="(r : is-abelian C) (f : Hom r A B₁) (monic : is-monic r f) →
Slice C B₁ ._∘_ (f→kercoker r f monic) (kercoker→f r f monic) ≡
Slice C B₁ .id" class="Function">f→kc→f</a> <a id="16231" href="Cat.Abelian.Base.html#16867" data-type="(r : is-abelian C) (f : Hom r A B₁) (monic : is-monic r f) →
Slice C B₁ ._∘_ (kercoker→f r f monic) (f→kercoker r f monic) ≡
Slice C B₁ .id" class="Function">kc→f→kc</a> <a id="16239" class="Keyword">where</a>
      <a id="16251" href="Cat.Abelian.Base.html#16251" data-type="(r : is-abelian C) (f : Hom r A B₁) (monic : is-monic r f) →
Slice C B₁ ._∘_ (f→kercoker r f monic) (kercoker→f r f monic) ≡
Slice C B₁ .id" class="Function">f→kc→f</a> <a id="16258" class="Symbol">:</a> <a id="16260" href="Cat.Abelian.Base.html#13962" data-type="(r : is-abelian C) (f : Hom r A B₁) (monic : is-monic r f) →
Slice C B₁ .Hom (cut f) (cut (kernel r (coeq r f)))" class="Function">f→kercoker</a> <a id="16271" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">m.∘</a> <a id="16275" href="Cat.Abelian.Base.html#14492" data-type="(r : is-abelian C) (f : Hom r A B₁) (monic : is-monic r f) →
Slice C B₁ .Hom (cut (kernel r (coeq r f))) (cut f)" class="Function">kercoker→f</a> <a id="16286" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="16288" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">m.id</a>
      <a id="16299" href="Cat.Abelian.Base.html#16251" data-type="(r : is-abelian C) (f : Hom r A B₁) (monic : is-monic r f) →
Slice C B₁ ._∘_ (f→kercoker r f monic) (kercoker→f r f monic) ≡
Slice C B₁ .id" class="Function">f→kc→f</a> <a id="16306" class="Symbol">=</a> <a id="16308" href="Cat.Instances.Slice.html#3929" data-type="x .map ≡ y .map → x ≡ y" class="Function">/-Hom-path</a> <a id="16319" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a>
        <a id="16329" class="Symbol">(</a><a id="16330" href="Cat.Abelian.Base.html#11217" data-type="(r : is-pre-abelian C) (f : Hom r A B₁) →
Σ
(λ f′ →
   f ≡ (r ∘ kernel r (coeq r f)) ((r ∘ f′) (coeq r (kernel r f))))" class="Function">decompose</a> <a id="16340" href="Cat.Abelian.Base.html#13675" class="Bound">f</a> <a id="16342" class="Symbol">.</a><a id="16343" href="Agda.Builtin.Sigma.html#252" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="16347" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="16349" href="Cat.Diagram.Coequaliser.html#1575" data-type="(r : Coequaliser C f g) → Hom C B₁ (r .coapex)" class="Function">Coker.coeq</a> <a id="16360" class="Symbol">_)</a> <a id="16363" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="16365" href="Cat.Diagram.Coequaliser.html#764" data-type="is-coequaliser C f g coeq → (C ∘ e′) f ≡ (C ∘ e′) g → Hom C E F" class="Function">Coker.coequalise</a> <a id="16382" class="Symbol">_</a> <a id="16384" class="Symbol">_</a> <a id="16386" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="16388" class="Symbol">_</a> <span class="reasoning-step"><span class="as-written Function"><a id="16390" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="16393" href="Cat.Reasoning.html#2947" data-type="(C : Precategory o ℓ) (inv₁ : (C ∘ h) i ≡ id C) →
(C ∘ (C ∘ f) h) ((C ∘ i) g) ≡ (C ∘ f) g" class="Function">cancel-inner</a> <a id="16406" href="Cat.Abelian.Base.html#16625" data-type="(r : is-abelian C) (f : Hom r A B₁) (monic : is-monic r f) →
(C ∘
 cokernel (has-is-preab r) (kernel (has-is-preab r) f .kernel)
 .coeq)
(has-is-coeq
 (cokernel (has-is-preab r) (kernel (has-is-preab r) f .kernel))
 .coequalise
 (monic ((r ∘ id r) (0m r)) ((r ∘ id r) (kernel r f))
  (path r f monic)))
≡ id C" class="Function">lemma</a> <a id="16412" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
        <a id="16422" href="Cat.Abelian.Base.html#11217" data-type="(r : is-pre-abelian C) (f : Hom r A B₁) →
Σ
(λ f′ →
   f ≡ (r ∘ kernel r (coeq r f)) ((r ∘ f′) (coeq r (kernel r f))))" class="Function">decompose</a> <a id="16432" href="Cat.Abelian.Base.html#13675" class="Bound">f</a> <a id="16434" class="Symbol">.</a><a id="16435" href="Agda.Builtin.Sigma.html#252" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="16439" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="16441" class="Symbol">_</a>                                         <span class="reasoning-step"><span class="as-written Function"><a id="16483" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="16486" href="Cat.Abelian.Base.html#13258" data-type="(r : is-abelian C) (f : Hom (r .has-is-preab) A B₁) →
is-invertible r (decompose r f .fst)" class="Field">coker-ker≃ker-coker</a> <a id="16506" href="Cat.Abelian.Base.html#13675" class="Bound">f</a> <a id="16508" class="Symbol">.</a><a id="16509" href="Cat.Morphism.html#1867" data-type="Inverses C f g → (C ∘ f) g ≡ id C" class="Function">is-invertible.invl</a> <a id="16528" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
        <a id="16538" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">id</a>                                                           <a id="16599" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
        <a id="16609" class="Keyword">where</a>
          <a id="16625" href="Cat.Abelian.Base.html#16625" data-type="(r : is-abelian C) (f : Hom r A B₁) (monic : is-monic r f) →
(C ∘
 cokernel (has-is-preab r) (kernel (has-is-preab r) f .kernel)
 .coeq)
(has-is-coeq
 (cokernel (has-is-preab r) (kernel (has-is-preab r) f .kernel))
 .coequalise
 (monic ((r ∘ id r) (0m r)) ((r ∘ id r) (kernel r f))
  (path r f monic)))
≡ id C" class="Function">lemma</a> <a id="16631" class="Symbol">=</a> <a id="16633" href="Cat.Diagram.Coequaliser.html#1087" data-type="is-coequaliser C f g coeq →
e′ ≡ (C ∘ colim&#39;) coeq → e′ ≡ (C ∘ colim&#39;&#39;) coeq → colim&#39; ≡ colim&#39;&#39;" class="Function">Coker.unique₂</a> <a id="16647" class="Symbol">_</a>
            <a id="16661" class="Symbol">{</a><a id="16662" class="Argument">e′</a> <a id="16665" class="Symbol">=</a> <a id="16667" href="Cat.Diagram.Coequaliser.html#1575" data-type="(r : Coequaliser C f g) → Hom C B₁ (r .coapex)" class="Function">Coker.coeq</a> <a id="16678" class="Symbol">(</a><a id="16679" href="Cat.Diagram.Equaliser.Kernel.html#1104" data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" class="Function">Ker.kernel</a> <a id="16690" href="Cat.Abelian.Base.html#13675" class="Bound">f</a><a id="16691" class="Symbol">)}</a>
            <a id="16706" class="Symbol">{</a><a id="16707" class="Argument">p</a> <a id="16709" class="Symbol">=</a> <a id="16711" href="Cat.Abelian.Base.html#2648" data-type="(r : Ab-category C) → (r ∘ f) (0m r) ≡ 0m r" class="Function">∘-zero-r</a> <a id="16720" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="16722" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="16726" class="Symbol">(</a><a id="16727" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="16731" class="Symbol">(</a><a id="16732" href="Cat.Diagram.Coequaliser.html#727" data-type="is-coequaliser C f g coeq → (C ∘ coeq) f ≡ (C ∘ coeq) g" class="Function">Coker.coequal</a> <a id="16746" class="Symbol">_)</a> <a id="16749" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="16751" href="Cat.Abelian.Base.html#2648" data-type="(r : Ab-category C) → (r ∘ f) (0m r) ≡ 0m r" class="Function">∘-zero-r</a><a id="16759" class="Symbol">)}</a>
            <a id="16774" class="Symbol">(</a><a id="16775" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="16779" class="Symbol">(</a><a id="16780" href="Cat.Reasoning.html#1678" data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ (C ∘ f) a) b ≡ (C ∘ f) c" class="Function">pullr</a> <a id="16786" class="Symbol">(</a><a id="16787" href="Cat.Diagram.Coequaliser.html#834" data-type="(r : is-coequaliser C f g coeq) → (C ∘ r .coequalise p) coeq ≡ e′" class="Function">Coker.universal</a> <a id="16803" class="Symbol">(</a><a id="16804" href="Cat.Diagram.Equaliser.Kernel.html#1104" data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" class="Function">Ker.kernel</a> <a id="16815" href="Cat.Abelian.Base.html#13675" class="Bound">f</a><a id="16816" class="Symbol">))</a> <a id="16819" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="16821" href="Cat.Reasoning.html#1108" data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → (C ∘ f) a ≡ f" class="Function">elimr</a> <a id="16827" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a><a id="16831" class="Symbol">))</a>
            <a id="16846" class="Symbol">(</a><a id="16847" href="Cat.Reasoning.html#1207" data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → f ≡ (C ∘ a) f" class="Function">introl</a> <a id="16854" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a><a id="16858" class="Symbol">)</a>

      <a id="16867" href="Cat.Abelian.Base.html#16867" data-type="(r : is-abelian C) (f : Hom r A B₁) (monic : is-monic r f) →
Slice C B₁ ._∘_ (kercoker→f r f monic) (f→kercoker r f monic) ≡
Slice C B₁ .id" class="Function">kc→f→kc</a> <a id="16875" class="Symbol">:</a> <a id="16877" href="Cat.Abelian.Base.html#14492" data-type="(r : is-abelian C) (f : Hom r A B₁) (monic : is-monic r f) →
Slice C B₁ .Hom (cut (kernel r (coeq r f))) (cut f)" class="Function">kercoker→f</a> <a id="16888" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">m.∘</a> <a id="16892" href="Cat.Abelian.Base.html#13962" data-type="(r : is-abelian C) (f : Hom r A B₁) (monic : is-monic r f) →
Slice C B₁ .Hom (cut f) (cut (kernel r (coeq r f)))" class="Function">f→kercoker</a> <a id="16903" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="16905" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">m.id</a>
      <a id="16916" href="Cat.Abelian.Base.html#16867" data-type="(r : is-abelian C) (f : Hom r A B₁) (monic : is-monic r f) →
Slice C B₁ ._∘_ (kercoker→f r f monic) (f→kercoker r f monic) ≡
Slice C B₁ .id" class="Function">kc→f→kc</a> <a id="16924" class="Symbol">=</a> <a id="16926" href="Cat.Instances.Slice.html#3929" data-type="x .map ≡ y .map → x ≡ y" class="Function">/-Hom-path</a> <a id="16937" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a>
        <a id="16947" class="Symbol">(</a><a id="16948" href="Cat.Diagram.Coequaliser.html#764" data-type="is-coequaliser C f g coeq → (C ∘ e′) f ≡ (C ∘ e′) g → Hom C E F" class="Function">Coker.coequalise</a> <a id="16965" class="Symbol">_</a> <a id="16967" class="Symbol">_</a> <a id="16969" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="16971" class="Symbol">_)</a> <a id="16974" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="16976" href="Cat.Abelian.Base.html#11217" data-type="(r : is-pre-abelian C) (f : Hom r A B₁) →
Σ
(λ f′ →
   f ≡ (r ∘ kernel r (coeq r f)) ((r ∘ f′) (coeq r (kernel r f))))" class="Function">decompose</a> <a id="16986" href="Cat.Abelian.Base.html#13675" class="Bound">f</a> <a id="16988" class="Symbol">.</a><a id="16989" href="Agda.Builtin.Sigma.html#252" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="16993" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="16995" href="Cat.Diagram.Coequaliser.html#1575" data-type="(r : Coequaliser C f g) → Hom C B₁ (r .coapex)" class="Function">Coker.coeq</a> <a id="17006" class="Symbol">_</a> <span class="reasoning-step"><span class="as-written Function"><a id="17008" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="17011" href="Cat.Reasoning.html#2947" data-type="(C : Precategory o ℓ) (inv₁ : (C ∘ h) i ≡ id C) →
(C ∘ (C ∘ f) h) ((C ∘ i) g) ≡ (C ∘ f) g" class="Function">cancel-inner</a> <a id="17024" class="Symbol">(</a><a id="17025" href="Cat.Abelian.Base.html#13258" data-type="(r : is-abelian C) (f : Hom (r .has-is-preab) A B₁) →
is-invertible r (decompose r f .fst)" class="Field">coker-ker≃ker-coker</a> <a id="17045" href="Cat.Abelian.Base.html#13675" class="Bound">f</a> <a id="17047" class="Symbol">.</a><a id="17048" href="Cat.Morphism.html#1889" data-type="Inverses C f g → (C ∘ g) f ≡ id C" class="Function">is-invertible.invr</a><a id="17066" class="Symbol">)</a> <a id="17068" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
        <a id="17078" href="Cat.Diagram.Coequaliser.html#764" data-type="is-coequaliser C f g coeq → (C ∘ e′) f ≡ (C ∘ e′) g → Hom C E F" class="Function">Coker.coequalise</a> <a id="17095" class="Symbol">_</a> <a id="17097" class="Symbol">_</a> <a id="17099" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">∘</a> <a id="17101" href="Cat.Diagram.Coequaliser.html#1575" data-type="(r : Coequaliser C f g) → Hom C B₁ (r .coapex)" class="Function">Coker.coeq</a> <a id="17112" class="Symbol">_</a>                          <span class="reasoning-step"><span class="as-written Function"><a id="17139" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="17142" href="Cat.Diagram.Coequaliser.html#834" data-type="(r : is-coequaliser C f g coeq) → (C ∘ r .coequalise p) coeq ≡ e′" class="Function">Coker.universal</a> <a id="17158" class="Symbol">_</a> <a id="17160" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
        <a id="17170" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">id</a>                                                           <a id="17231" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
</pre>
<section class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>“multiplication”<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
  </article>
</div>
</main>
</body>
</html>
