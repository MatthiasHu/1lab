<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="keywords" content="Agda,categories,topos" />

  <title>…ebra.Group.Homotopy.BAut - 1Lab</title>

  <link rel="stylesheet" href="/css/default.css" />
  <link rel="stylesheet" href="/css/katex.min.css" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="…ebra.Group.Homotopy.BAut - 1Lab" />
  <meta name="twitter:image" content="https://1lab.dev/static/cube-128x.png" />

  <meta name="og:title" content="…ebra.Group.Homotopy.BAut - 1Lab" />
  <meta name="og:image" content="https://1lab.dev/static/cube-128x.png" />
  <meta name="og:site-name" content="1Lab" />
  <meta name="og:type" content="website" />

    <meta name="og:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="twitter:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  
  <script defer src="/main.js"></script>

  <noscript>
    <style>
      body span.reasoning-step .as-written {
        display: inline;
      }

      body span.reasoning-step .alternate {
        display: none;
      }
    </style>
  </noscript>

  <!-- Google font embeds -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;0,800;1,400;1,500;1,600;1,700;1,800&amp;family=Inria+Sans:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&amp;display=swap" rel="stylesheet">
</head>

<body class="text-page">
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <!-- Table of contents (only if the page has a table of contents) -->
    <aside id="toc">
    <div id="toc-container" style="min-width: 10em; font-size: 15pt;">
      <!-- Title for the page -->
      <h3 class="Agda" style="margin-top: 0; margin-bottom: 0; white-space: pre;">
                <a class="Module">…ebra.Group.Homotopy.BAut</a>
              </h3>

      <!-- Cube logo -->
      <a id="logo" href="/">
        <img alt="1Lab" src="/static/cube-72x.png" style="display: block; margin-bottom: 1em; margin: auto;" width="32px" height="32px" />
      </a>

      <!-- Actual table of contents (separated from the rest by
      horizontal rules) -->
      <hr />
      <ul>
      <li><a href="#deloopings-of-automorphism-groups"><a href="#deloopings-of-automorphism-groups" class="header-link">Deloopings
      of automorphism
      groups<span class="header-link-emoji">🔗</span></a></a></li>
      </ul>
      <hr />

      <!-- Sidebar controls -->
      <div style="display: flex; gap: 0.25em; flex-flow: row wrap;">
        <!-- Sidebar equations control -->
        <span class="equations" style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-eqns" type="checkbox" class="equations" id="sidebar-eqns">
          <label for="sidebar-eqns">Equations</label>
        </span>

        <!-- Sidebar fonts control -->
        <span style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-font" type="checkbox" id="toggle-fonts">
          <label for="toggle-fonts">Serif Font</label>
        </span>

        <!-- Sidebar footnotes control -->
        <span class="inline-footnotes" style="display: none; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-fns" type="checkbox" class="inline-footnotes" id="sidebar-fns">
          <label for="sidebar-fns">Inline Footnotes</label>
        </span>
      </div>

      <hr />

      <!-- Navbar navigation (lol) -->
      <div id="return" style="white-space: nowrap;">
        <div class="search-form search-form-proxy" role="form">
          <input id="search-box-proxy" type_="text" placeholder="Search..." autocomplete="off" tabindex="0"></input>
        </div>

              <a href="/">back to index</a> <br />
              <a href="all-pages.html">view all pages</a> <br />
        <a href="https://github.com/plt-amy/cubical-1lab/blob/def110bea1506038da90629e52d3fc84c7afe9b4/src/Algebra/Group/Homotopy/BAut.lagda.md">link to source</a> <br />
                <hr /> <div class="author-list">Written by Amélia Liao</div> <br />
              </div>
    </div>
  </aside>
  
  <article>
    <!-- Article navigation (narrow screens only) -->
    <div class="narrow-only" id="article-nav">
      <!-- Index return anchor (only if the page is not the index) -->
            <div id="return">
        <a href="/">back to index</a>
      </div>
      
      <!-- Navbar equations control -->
      <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-eqns" type="checkbox" class="equations" id="navbar-eqns">
        <label for="navbar-eqns">Equations</label>
      </span>

      <!-- Navbar footnotes control -->
      <span class="inline-footnotes" style="display: none; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-fns" type="checkbox" class="inline-footnotes" id="navbar-fns">
        <label for="navbar-fns">Inline Footnotes</label>
      </span>
    </div>

<pre class="Agda"><a id="9" class="Keyword">open</a> <a id="14" class="Keyword">import</a> <a id="21" href="1Lab.Prelude.html" class="Module">1Lab.Prelude</a>

<a id="35" class="Keyword">open</a> <a id="40" class="Keyword">import</a> <a id="47" href="Algebra.Group.html" class="Module">Algebra.Group</a>

<a id="62" class="Keyword">open</a> <a id="67" class="Keyword">import</a> <a id="74" href="Data.Set.Truncation.html" class="Module">Data.Set.Truncation</a>

<a id="95" class="Keyword">module</a> <a id="102" href="Algebra.Group.Homotopy.BAut.html" class="Module">Algebra.Group.Homotopy.BAut</a> <a id="130" class="Keyword">where</a>
</pre>
<h1 id="deloopings-of-automorphism-groups"><a href="#deloopings-of-automorphism-groups" class="header-link">Deloopings
of automorphism groups<span class="header-link-emoji">🔗</span></a></h1>
<p>Recall that any set
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>
generates a group <a href="Algebra.Group.html#symmetric-groups"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">S</mi><mi mathvariant="normal">y</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\id{Sym}(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">Sym</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span></a>,
given by the automorphisms
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>≃</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">X \simeq X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≃</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>.</span>
We also have a generic construction of <a href="Algebra.Group.Homotopy.html#deloopings">deloopings</a>: special
spaces
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo stretchy="false">(</mo><mi>G</mi><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K(G,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>
(for a group
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span>),</span>
where the <a href="Algebra.Group.Homotopy.html#homotopy-groups.">fundamental
group</a>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>K</mi><mo stretchy="false">(</mo><mi>G</mi><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_1(K(G,1))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">))</span></span></span></span>
recovers
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span>.</span>
For the specific case of deloping automorphism groups, we can give an
alternative construction: The type of small types <a href="1Lab.HIT.Truncation.html">merely</a> equivalent to
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>
has a fundamental group of
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">S</mi><mi mathvariant="normal">y</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\id{Sym}(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">Sym</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span>.</span></p>
<pre class="Agda"><a id="837" class="Keyword">module</a> <a id="844" href="Algebra.Group.Homotopy.BAut.html#844" class="Module">_</a> <a id="846" class="Symbol">{</a><a id="847" href="Algebra.Group.Homotopy.BAut.html#847" class="Bound">ℓ</a><a id="848" class="Symbol">}</a> <a id="850" class="Symbol">(</a><a id="851" href="Algebra.Group.Homotopy.BAut.html#851" class="Bound">T</a> <a id="853" class="Symbol">:</a> <a id="855" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="860" href="Algebra.Group.Homotopy.BAut.html#847" class="Bound">ℓ</a><a id="861" class="Symbol">)</a> <a id="863" class="Keyword">where</a>
  <a id="871" href="Algebra.Group.Homotopy.BAut.html#871" data-type="Type ℓ → Type (lsuc ℓ)" class="Function">BAut</a> <a id="876" class="Symbol">:</a> <a id="878" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="883" class="Symbol">(</a><a id="884" href="Agda.Primitive.html#765" data-type="Level → Level" class="Primitive">lsuc</a> <a id="889" href="Algebra.Group.Homotopy.BAut.html#847" class="Bound">ℓ</a><a id="890" class="Symbol">)</a>
  <a id="894" href="Algebra.Group.Homotopy.BAut.html#871" data-type="Type ℓ → Type (lsuc ℓ)" class="Function">BAut</a> <a id="899" class="Symbol">=</a> <a id="901" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">Σ[</a> <a id="904" href="Algebra.Group.Homotopy.BAut.html#904" class="Bound">B</a> <a id="906" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">∈</a> <a id="908" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="913" href="Algebra.Group.Homotopy.BAut.html#847" class="Bound">ℓ</a> <a id="915" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">]</a> <a id="917" href="1Lab.HIT.Truncation.html#736" data-type="Type ℓ → Type ℓ" class="Datatype Operator">∥</a> <a id="919" href="Algebra.Group.Homotopy.BAut.html#851" class="Bound">T</a> <a id="921" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="923" href="Algebra.Group.Homotopy.BAut.html#904" class="Bound">B</a> <a id="925" href="1Lab.HIT.Truncation.html#736" data-type="Type ℓ → Type ℓ" class="Datatype Operator">∥</a>

  <a id="930" href="Algebra.Group.Homotopy.BAut.html#930" data-type="(T : Type ℓ) → BAut T" class="Function">base</a> <a id="935" class="Symbol">:</a> <a id="937" href="Algebra.Group.Homotopy.BAut.html#871" data-type="Type ℓ → Type (lsuc ℓ)" class="Function">BAut</a>
  <a id="944" href="Algebra.Group.Homotopy.BAut.html#930" data-type="(T : Type ℓ) → BAut T" class="Function">base</a> <a id="949" class="Symbol">=</a> <a id="951" href="Algebra.Group.Homotopy.BAut.html#851" class="Bound">T</a> <a id="953" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="955" href="1Lab.HIT.Truncation.html#774" data-type="A → ∥ A ∥" class="InductiveConstructor">inc</a> <a id="959" class="Symbol">(</a><a id="960" href="1Lab.Type.html#2424" data-type="A → A" class="Function">id</a> <a id="963" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="965" href="1Lab.Equiv.html#2524" data-type="is-equiv (λ x → x)" class="Function">id-equiv</a><a id="973" class="Symbol">)</a>
</pre>
<p>The first thing we note is that
<span class="Agda"><a href="Algebra.Group.Homotopy.BAut.html#871" class="Function">BAut</a></span>
is a <em>connected</em> type, meaning that it only has “a single point”,
or, more precisely, that all of its interesting information is in its
(higher) path spaces:</p>
<pre class="Agda">  <a id="1195" href="Algebra.Group.Homotopy.BAut.html#1195" data-type="(T : Type ℓ) (b : ∑ (Type ℓ) (λ B₁ → ∥ T ≃ B₁ ∥)) → ∥ b ≡ base T ∥" class="Function">connected</a> <a id="1205" class="Symbol">:</a> <a id="1207" class="Symbol">∀</a> <a id="1209" href="Algebra.Group.Homotopy.BAut.html#1209" class="Bound">b</a> <a id="1211" class="Symbol">→</a> <a id="1213" href="1Lab.HIT.Truncation.html#736" data-type="Type ℓ → Type ℓ" class="Datatype Operator">∥</a> <a id="1215" href="Algebra.Group.Homotopy.BAut.html#1209" class="Bound">b</a> <a id="1217" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="1219" href="Algebra.Group.Homotopy.BAut.html#930" data-type="(T : Type ℓ) → BAut T" class="Function">base</a> <a id="1224" href="1Lab.HIT.Truncation.html#736" data-type="Type ℓ → Type ℓ" class="Datatype Operator">∥</a>
  <a id="1228" href="Algebra.Group.Homotopy.BAut.html#1195" data-type="(T : Type ℓ) (b : ∑ (Type ℓ) (λ B₁ → ∥ T ≃ B₁ ∥)) → ∥ b ≡ base T ∥" class="Function">connected</a> <a id="1238" class="Symbol">(</a><a id="1239" href="Algebra.Group.Homotopy.BAut.html#1239" class="Bound">b</a> <a id="1241" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="1243" href="Algebra.Group.Homotopy.BAut.html#1243" class="Bound">x</a><a id="1244" class="Symbol">)</a> <a id="1246" class="Symbol">=</a>
    <a id="1252" href="1Lab.HIT.Truncation.html#1408" data-type="((x : ∥ A ∥) → is-prop (P x)) →
((x : A) → P (inc x)) → (x : ∥ A ∥) → P x" class="Function">∥-∥-elim</a> <a id="1261" class="Symbol">{</a><a id="1262" class="Argument">P</a> <a id="1264" class="Symbol">=</a> <a id="1266" class="Symbol">λ</a> <a id="1268" href="Algebra.Group.Homotopy.BAut.html#1268" class="Bound">x</a> <a id="1270" class="Symbol">→</a> <a id="1272" href="1Lab.HIT.Truncation.html#736" data-type="Type ℓ → Type ℓ" class="Datatype Operator">∥</a> <a id="1274" class="Symbol">(</a><a id="1275" href="Algebra.Group.Homotopy.BAut.html#1239" class="Bound">b</a> <a id="1277" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="1279" href="Algebra.Group.Homotopy.BAut.html#1268" class="Bound">x</a><a id="1280" class="Symbol">)</a> <a id="1282" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="1284" href="Algebra.Group.Homotopy.BAut.html#930" data-type="(T : Type ℓ) → BAut T" class="Function">base</a> <a id="1289" href="1Lab.HIT.Truncation.html#736" data-type="Type ℓ → Type ℓ" class="Datatype Operator">∥</a><a id="1290" class="Symbol">}</a> <a id="1292" class="Symbol">(λ</a> <a id="1295" href="Algebra.Group.Homotopy.BAut.html#1295" class="Bound">_</a> <a id="1297" class="Symbol">→</a> <a id="1299" href="1Lab.HIT.Truncation.html#795" data-type="is-prop ∥ A ∥" class="InductiveConstructor">squash</a><a id="1305" class="Symbol">)</a> <a id="1307" class="Symbol">(λ</a> <a id="1310" href="Algebra.Group.Homotopy.BAut.html#1310" class="Bound">e</a> <a id="1312" class="Symbol">→</a> <a id="1314" href="1Lab.HIT.Truncation.html#774" data-type="A → ∥ A ∥" class="InductiveConstructor">inc</a> <a id="1318" class="Symbol">(</a><a id="1319" href="Algebra.Group.Homotopy.BAut.html#1345" data-type="(T : Type ℓ) (b : Type ℓ) →
∥ T ≃ b ∥ → (b₁ : Type ℓ) (e : T ≃ b₁) → (b₁ , inc e) ≡ base T" class="Function">p</a> <a id="1321" class="Symbol">_</a> <a id="1323" class="Symbol">_))</a> <a id="1327" href="Algebra.Group.Homotopy.BAut.html#1243" class="Bound">x</a>
    <a id="1333" class="Keyword">where</a>
      <a id="1345" href="Algebra.Group.Homotopy.BAut.html#1345" data-type="(T : Type ℓ) (b : Type ℓ) →
∥ T ≃ b ∥ → (b₁ : Type ℓ) (e : T ≃ b₁) → (b₁ , inc e) ≡ base T" class="Function">p</a> <a id="1347" class="Symbol">:</a> <a id="1349" class="Symbol">∀</a> <a id="1351" href="Algebra.Group.Homotopy.BAut.html#1351" class="Bound">b</a> <a id="1353" href="Algebra.Group.Homotopy.BAut.html#1353" class="Bound">e</a> <a id="1355" class="Symbol">→</a> <a id="1357" class="Symbol">(</a><a id="1358" href="Algebra.Group.Homotopy.BAut.html#1351" class="Bound">b</a> <a id="1360" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="1362" href="1Lab.HIT.Truncation.html#774" data-type="A → ∥ A ∥" class="InductiveConstructor">inc</a> <a id="1366" href="Algebra.Group.Homotopy.BAut.html#1353" class="Bound">e</a><a id="1367" class="Symbol">)</a> <a id="1369" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="1371" href="Algebra.Group.Homotopy.BAut.html#930" data-type="(T : Type ℓ) → BAut T" class="Function">base</a>
      <a id="1382" href="Algebra.Group.Homotopy.BAut.html#1345" data-type="(T : Type ℓ) (b : Type ℓ) →
∥ T ≃ b ∥ → (b₁ : Type ℓ) (e : T ≃ b₁) → (b₁ , inc e) ≡ base T" class="Function">p</a> <a id="1384" class="Symbol">_</a> <a id="1386" class="Symbol">=</a> <a id="1388" href="1Lab.Univalence.html#19821" data-type="(P : (B₁ : Type ℓ) → A ≃ B₁ → Type ℓ&#39;) →
P A ((λ x → x) , id-equiv) → (e : A ≃ B₁) → P B₁ e" class="Function">EquivJ</a> <a id="1395" class="Symbol">(λ</a> <a id="1398" href="Algebra.Group.Homotopy.BAut.html#1398" class="Bound">B</a> <a id="1400" href="Algebra.Group.Homotopy.BAut.html#1400" class="Bound">e</a> <a id="1402" class="Symbol">→</a> <a id="1404" class="Symbol">(</a><a id="1405" href="Algebra.Group.Homotopy.BAut.html#1398" class="Bound">B</a> <a id="1407" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="1409" href="1Lab.HIT.Truncation.html#774" data-type="A → ∥ A ∥" class="InductiveConstructor">inc</a> <a id="1413" href="Algebra.Group.Homotopy.BAut.html#1400" class="Bound">e</a><a id="1414" class="Symbol">)</a> <a id="1416" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="1418" href="Algebra.Group.Homotopy.BAut.html#930" data-type="(T : Type ℓ) → BAut T" class="Function">base</a><a id="1422" class="Symbol">)</a> <a id="1424" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
</pre>
<p>We now turn to proving that
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi mathvariant="normal">B</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>≃</mo><mo stretchy="false">(</mo><mi>X</mi><mo>≃</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_1(\baut(X)) \simeq (X \simeq X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mop"><span class="mord mathbf">B</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≃</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≃</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span>.</span>
We will define a type family
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">C</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">e</mi></mrow><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\id{Code}(b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">Code</span></span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>,</span>
where a value
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>:</mo><mrow><mi mathvariant="normal">C</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">e</mi></mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p : \id{Code}(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">Code</span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>
codes for an identification
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>≡</mo><mrow><mi mathvariant="normal">b</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">e</mi></mrow></mrow><annotation encoding="application/x-tex">p \equiv \id{base}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6582em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">base</span></span></span></span></span>.</span>
Correspondingly, there are functions to and from these types: The core
of the proof is showing that these functions,
<span class="Agda"><a href="Algebra.Group.Homotopy.BAut.html#1854" class="Function">encode</a></span>
and
<span class="Agda"><a href="Algebra.Group.Homotopy.BAut.html#1927" class="Function">decode</a></span>,
are inverses.</p>
<pre class="Agda">  <a id="1808" href="Algebra.Group.Homotopy.BAut.html#1808" data-type="(T : Type ℓ) → BAut T → Type ℓ" class="Function">Code</a> <a id="1813" class="Symbol">:</a> <a id="1815" href="Algebra.Group.Homotopy.BAut.html#871" data-type="Type ℓ → Type (lsuc ℓ)" class="Function">BAut</a> <a id="1820" class="Symbol">→</a> <a id="1822" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="1827" href="Algebra.Group.Homotopy.BAut.html#847" class="Bound">ℓ</a>
  <a id="1831" href="Algebra.Group.Homotopy.BAut.html#1808" data-type="(T : Type ℓ) → BAut T → Type ℓ" class="Function">Code</a> <a id="1836" href="Algebra.Group.Homotopy.BAut.html#1836" class="Bound">b</a> <a id="1838" class="Symbol">=</a> <a id="1840" href="Algebra.Group.Homotopy.BAut.html#851" class="Bound">T</a> <a id="1842" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="1844" href="Algebra.Group.Homotopy.BAut.html#1836" class="Bound">b</a> <a id="1846" class="Symbol">.</a><a id="1847" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a>

  <a id="1854" href="Algebra.Group.Homotopy.BAut.html#1854" data-type="(T : Type ℓ) (b : ∑ (Type ℓ) (λ B₁ → ∥ T ≃ B₁ ∥)) →
base T ≡ b → Code T b" class="Function">encode</a> <a id="1861" class="Symbol">:</a> <a id="1863" class="Symbol">∀</a> <a id="1865" href="Algebra.Group.Homotopy.BAut.html#1865" class="Bound">b</a> <a id="1867" class="Symbol">→</a> <a id="1869" href="Algebra.Group.Homotopy.BAut.html#930" data-type="(T : Type ℓ) → BAut T" class="Function">base</a> <a id="1874" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="1876" href="Algebra.Group.Homotopy.BAut.html#1865" class="Bound">b</a> <a id="1878" class="Symbol">→</a> <a id="1880" href="Algebra.Group.Homotopy.BAut.html#1808" data-type="(T : Type ℓ) → BAut T → Type ℓ" class="Function">Code</a> <a id="1885" href="Algebra.Group.Homotopy.BAut.html#1865" class="Bound">b</a>
  <a id="1889" href="Algebra.Group.Homotopy.BAut.html#1854" data-type="(T : Type ℓ) (b : ∑ (Type ℓ) (λ B₁ → ∥ T ≃ B₁ ∥)) →
base T ≡ b → Code T b" class="Function">encode</a> <a id="1896" href="Algebra.Group.Homotopy.BAut.html#1896" class="Bound">x</a> <a id="1898" href="Algebra.Group.Homotopy.BAut.html#1898" class="Bound">p</a> <a id="1900" class="Symbol">=</a> <a id="1902" href="1Lab.Univalence.html#15486" data-type="A ≡ B₁ → A ≃ B₁" class="Function">path→equiv</a> <a id="1913" class="Symbol">(</a><a id="1914" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="1917" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="1921" href="Algebra.Group.Homotopy.BAut.html#1898" class="Bound">p</a><a id="1922" class="Symbol">)</a>

  <a id="1927" href="Algebra.Group.Homotopy.BAut.html#1927" data-type="(T : Type ℓ) (b : BAut T) → Code T b → base T ≡ b" class="Function">decode</a> <a id="1934" class="Symbol">:</a> <a id="1936" class="Symbol">∀</a> <a id="1938" href="Algebra.Group.Homotopy.BAut.html#1938" class="Bound">b</a> <a id="1940" class="Symbol">→</a> <a id="1942" href="Algebra.Group.Homotopy.BAut.html#1808" data-type="(T : Type ℓ) → BAut T → Type ℓ" class="Function">Code</a> <a id="1947" href="Algebra.Group.Homotopy.BAut.html#1938" class="Bound">b</a> <a id="1949" class="Symbol">→</a> <a id="1951" href="Algebra.Group.Homotopy.BAut.html#930" data-type="(T : Type ℓ) → BAut T" class="Function">base</a> <a id="1956" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="1958" href="Algebra.Group.Homotopy.BAut.html#1938" class="Bound">b</a>
  <a id="1962" href="Algebra.Group.Homotopy.BAut.html#1927" data-type="(T : Type ℓ) (b : BAut T) → Code T b → base T ≡ b" class="Function">decode</a> <a id="1969" class="Symbol">(</a><a id="1970" href="Algebra.Group.Homotopy.BAut.html#1970" class="Bound">b</a> <a id="1972" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="1974" href="Algebra.Group.Homotopy.BAut.html#1974" class="Bound">eqv</a><a id="1977" class="Symbol">)</a> <a id="1979" href="Algebra.Group.Homotopy.BAut.html#1979" class="Bound">rot</a> <a id="1983" class="Symbol">=</a> <a id="1985" href="1Lab.Path.html#57276" data-type="(p : x .fst ≡ y .fst) →
PathP (λ i → B₁ (p i)) (x .snd) (y .snd) → x ≡ y" class="Function">Σ-pathp</a> <a id="1993" class="Symbol">(</a><a id="1994" href="1Lab.Univalence.html#8818" data-type="A ≃ B₁ → A ≡ B₁" class="Function">ua</a> <a id="1997" href="Algebra.Group.Homotopy.BAut.html#1979" class="Bound">rot</a><a id="2000" class="Symbol">)</a> <a id="2002" class="Symbol">(</a><a id="2003" href="1Lab.HLevel.html#13498" data-type="((i : I) → is-prop (B₁ i)) →
(b0 : B₁ i0) (b1 : B₁ i1) → PathP B₁ b0 b1" class="Function">is-prop→pathp</a> <a id="2017" class="Symbol">(λ</a> <a id="2020" href="Algebra.Group.Homotopy.BAut.html#2020" class="Bound">_</a> <a id="2022" class="Symbol">→</a> <a id="2024" href="1Lab.HIT.Truncation.html#795" data-type="is-prop ∥ A ∥" class="InductiveConstructor">squash</a><a id="2030" class="Symbol">)</a> <a id="2032" class="Symbol">_</a> <a id="2034" class="Symbol">_)</a>
</pre>
<p>Recall that
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">b</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">e</mi></mrow><annotation encoding="application/x-tex">\id{base}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">base</span></span></span></span></span>
is the type
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>
itself, equipped with the identity equivalence. Hence, to code for an
identification
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">b</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">e</mi></mrow><mo>≡</mo><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\id{base} \equiv (X, e)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">base</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">e</span><span class="mclose">)</span></span></span></span>,</span>
it suffices to record
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span>
— which by univalence corresponds to a path
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">u</mi><mi mathvariant="normal">a</mi></mrow><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo><mo>:</mo><mi>T</mi><mo>≡</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">\id{ua}(e) : T \equiv X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">ua</span></span><span class="mopen">(</span><span class="mord mathnormal">e</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>.</span>
We can not directly extract the equivalence from a given point
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>e</mi><mo stretchy="false">)</mo><mo>:</mo><mi mathvariant="normal">B</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(X, e) : \baut(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">e</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathbf">B</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span>:</span>
it is “hidden away” under a truncation. But, given an identification
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>:</mo><mi>b</mi><mo>≡</mo><mrow><mi mathvariant="normal">b</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">e</mi></mrow></mrow><annotation encoding="application/x-tex">p : b \equiv \id{base}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">base</span></span></span></span></span>,</span>
we can recover the equivalence by seeing <em>how</em>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>
identifies
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>≡</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">X \equiv T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>.</span></p>
<pre class="Agda">  <a id="2560" href="Algebra.Group.Homotopy.BAut.html#2560" data-type="(T : Type ℓ) (b : ∑ (Type ℓ) (λ B₁ → ∥ T ≃ B₁ ∥))
(p : base T ≡ b) →
decode T b (encode T b p) ≡ p" class="Function">decode∘encode</a> <a id="2574" class="Symbol">:</a> <a id="2576" class="Symbol">∀</a> <a id="2578" href="Algebra.Group.Homotopy.BAut.html#2578" class="Bound">b</a> <a id="2580" class="Symbol">(</a><a id="2581" href="Algebra.Group.Homotopy.BAut.html#2581" class="Bound">p</a> <a id="2583" class="Symbol">:</a> <a id="2585" href="Algebra.Group.Homotopy.BAut.html#930" data-type="(T : Type ℓ) → BAut T" class="Function">base</a> <a id="2590" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="2592" href="Algebra.Group.Homotopy.BAut.html#2578" class="Bound">b</a><a id="2593" class="Symbol">)</a> <a id="2595" class="Symbol">→</a> <a id="2597" href="Algebra.Group.Homotopy.BAut.html#1927" data-type="(T : Type ℓ) (b : BAut T) → Code T b → base T ≡ b" class="Function">decode</a> <a id="2604" href="Algebra.Group.Homotopy.BAut.html#2578" class="Bound">b</a> <a id="2606" class="Symbol">(</a><a id="2607" href="Algebra.Group.Homotopy.BAut.html#1854" data-type="(T : Type ℓ) (b : ∑ (Type ℓ) (λ B₁ → ∥ T ≃ B₁ ∥)) →
base T ≡ b → Code T b" class="Function">encode</a> <a id="2614" href="Algebra.Group.Homotopy.BAut.html#2578" class="Bound">b</a> <a id="2616" href="Algebra.Group.Homotopy.BAut.html#2581" class="Bound">p</a><a id="2617" class="Symbol">)</a> <a id="2619" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="2621" href="Algebra.Group.Homotopy.BAut.html#2581" class="Bound">p</a>
  <a id="2625" href="Algebra.Group.Homotopy.BAut.html#2560" data-type="(T : Type ℓ) (b : ∑ (Type ℓ) (λ B₁ → ∥ T ≃ B₁ ∥))
(p : base T ≡ b) →
decode T b (encode T b p) ≡ p" class="Function">decode∘encode</a> <a id="2639" href="Algebra.Group.Homotopy.BAut.html#2639" class="Bound">b</a> <a id="2641" class="Symbol">=</a>
    <a id="2647" href="1Lab.Path.html#19544" data-type="(P : (y : A) → x ≡ y → Type ℓ₂) → P x refl → (p : x ≡ y) → P y p" class="Function">J</a> <a id="2649" class="Symbol">(λ</a> <a id="2652" href="Algebra.Group.Homotopy.BAut.html#2652" class="Bound">b</a> <a id="2654" href="Algebra.Group.Homotopy.BAut.html#2654" class="Bound">p</a> <a id="2656" class="Symbol">→</a> <a id="2658" href="Algebra.Group.Homotopy.BAut.html#1927" data-type="(T : Type ℓ) (b : BAut T) → Code T b → base T ≡ b" class="Function">decode</a> <a id="2665" href="Algebra.Group.Homotopy.BAut.html#2652" class="Bound">b</a> <a id="2667" class="Symbol">(</a><a id="2668" href="Algebra.Group.Homotopy.BAut.html#1854" data-type="(T : Type ℓ) (b : ∑ (Type ℓ) (λ B₁ → ∥ T ≃ B₁ ∥)) →
base T ≡ b → Code T b" class="Function">encode</a> <a id="2675" href="Algebra.Group.Homotopy.BAut.html#2652" class="Bound">b</a> <a id="2677" href="Algebra.Group.Homotopy.BAut.html#2654" class="Bound">p</a><a id="2678" class="Symbol">)</a> <a id="2680" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="2682" href="Algebra.Group.Homotopy.BAut.html#2654" class="Bound">p</a><a id="2683" class="Symbol">)</a>
      <a id="2691" class="Symbol">(</a><a id="2692" href="1Lab.Type.Sigma.html#7023" data-type="((x : A) → is-prop (B₁ x)) →
Square (ap fst p) (ap fst q) (ap fst s) (ap fst r) → Square p q s r" class="Function">Σ-prop-square</a> <a id="2706" class="Symbol">(λ</a> <a id="2709" href="Algebra.Group.Homotopy.BAut.html#2709" class="Bound">_</a> <a id="2711" class="Symbol">→</a> <a id="2713" href="1Lab.HIT.Truncation.html#795" data-type="is-prop ∥ A ∥" class="InductiveConstructor">squash</a><a id="2719" class="Symbol">)</a> <a id="2721" href="Algebra.Group.Homotopy.BAut.html#2741" data-type="(T : Type ℓ) (b : ∑ (Type ℓ) (λ B₁ → ∥ T ≃ B₁ ∥)) →
ua (encode T (base T) refl) ≡ refl" class="Function">sq</a><a id="2723" class="Symbol">)</a>
    <a id="2729" class="Keyword">where</a>
      <a id="2741" href="Algebra.Group.Homotopy.BAut.html#2741" data-type="(T : Type ℓ) (b : ∑ (Type ℓ) (λ B₁ → ∥ T ≃ B₁ ∥)) →
ua (encode T (base T) refl) ≡ refl" class="Function">sq</a> <a id="2744" class="Symbol">:</a> <a id="2746" href="1Lab.Univalence.html#8818" data-type="A ≃ B₁ → A ≡ B₁" class="Function">ua</a> <a id="2749" class="Symbol">(</a><a id="2750" href="Algebra.Group.Homotopy.BAut.html#1854" data-type="(T : Type ℓ) (b : ∑ (Type ℓ) (λ B₁ → ∥ T ≃ B₁ ∥)) →
base T ≡ b → Code T b" class="Function">encode</a> <a id="2757" href="Algebra.Group.Homotopy.BAut.html#930" data-type="(T : Type ℓ) → BAut T" class="Function">base</a> <a id="2762" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a><a id="2766" class="Symbol">)</a> <a id="2768" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="2770" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
      <a id="2781" href="Algebra.Group.Homotopy.BAut.html#2741" data-type="(T : Type ℓ) (b : ∑ (Type ℓ) (λ B₁ → ∥ T ≃ B₁ ∥)) →
ua (encode T (base T) refl) ≡ refl" class="Function">sq</a> <a id="2784" class="Symbol">=</a> <a id="2786" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="2789" href="1Lab.Univalence.html#8818" data-type="A ≃ B₁ → A ≡ B₁" class="Function">ua</a> <a id="2792" href="1Lab.Univalence.html#15838" data-type="path→equiv refl ≡ (id , id-equiv)" class="Function">path→equiv-refl</a> <a id="2808" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="2810" href="1Lab.Univalence.html#16267" data-type="ua ((λ x → x) , id-equiv) ≡ refl" class="Function">ua-id-equiv</a>
</pre>
<p><span class="Agda"><a href="Algebra.Group.Homotopy.BAut.html#1854" class="Function">Encode</a></span>
and
<span class="Agda"><a href="Algebra.Group.Homotopy.BAut.html#1927" class="Function">decode</a></span>
are inverses by a direct application of
<span class="Agda"><a href="1Lab.Univalence.html#16772" class="Function">univalence</a></span>.</p>
<pre class="Agda">  <a id="2948" href="Algebra.Group.Homotopy.BAut.html#2948" data-type="(T : Type ℓ) (b : BAut T) (p : Code T b) →
encode T b (decode T b p) ≡ p" class="Function">encode∘decode</a> <a id="2962" class="Symbol">:</a> <a id="2964" class="Symbol">∀</a> <a id="2966" href="Algebra.Group.Homotopy.BAut.html#2966" class="Bound">b</a> <a id="2968" class="Symbol">(</a><a id="2969" href="Algebra.Group.Homotopy.BAut.html#2969" class="Bound">p</a> <a id="2971" class="Symbol">:</a> <a id="2973" href="Algebra.Group.Homotopy.BAut.html#1808" data-type="(T : Type ℓ) → BAut T → Type ℓ" class="Function">Code</a> <a id="2978" href="Algebra.Group.Homotopy.BAut.html#2966" class="Bound">b</a><a id="2979" class="Symbol">)</a> <a id="2981" class="Symbol">→</a> <a id="2983" href="Algebra.Group.Homotopy.BAut.html#1854" data-type="(T : Type ℓ) (b : ∑ (Type ℓ) (λ B₁ → ∥ T ≃ B₁ ∥)) →
base T ≡ b → Code T b" class="Function">encode</a> <a id="2990" href="Algebra.Group.Homotopy.BAut.html#2966" class="Bound">b</a> <a id="2992" class="Symbol">(</a><a id="2993" href="Algebra.Group.Homotopy.BAut.html#1927" data-type="(T : Type ℓ) (b : BAut T) → Code T b → base T ≡ b" class="Function">decode</a> <a id="3000" href="Algebra.Group.Homotopy.BAut.html#2966" class="Bound">b</a> <a id="3002" href="Algebra.Group.Homotopy.BAut.html#2969" class="Bound">p</a><a id="3003" class="Symbol">)</a> <a id="3005" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="3007" href="Algebra.Group.Homotopy.BAut.html#2969" class="Bound">p</a>
  <a id="3011" href="Algebra.Group.Homotopy.BAut.html#2948" data-type="(T : Type ℓ) (b : BAut T) (p : Code T b) →
encode T b (decode T b p) ≡ p" class="Function">encode∘decode</a> <a id="3025" href="Algebra.Group.Homotopy.BAut.html#3025" class="Bound">b</a> <a id="3027" href="Algebra.Group.Homotopy.BAut.html#3027" class="Bound">p</a> <a id="3029" class="Symbol">=</a> <a id="3031" href="1Lab.Equiv.html#6548" data-type="(eqv : is-equiv f) → is-right-inverse (equiv→inverse eqv) f" class="Function">equiv→section</a> <a id="3045" href="1Lab.Univalence.html#16772" data-type="is-equiv path→equiv" class="Function">univalence</a> <a id="3056" class="Symbol">_</a>
</pre>
<p>We now have the core result: Specialising
<span class="Agda"><a href="Algebra.Group.Homotopy.BAut.html#1854" class="Function">encode</a></span>
and
<span class="Agda"><a href="Algebra.Group.Homotopy.BAut.html#1927" class="Function">decode</a></span>
to the <code class="sourceCode agda">basepoint</code>, we conclude that
loop space
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">b</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">e</mi></mrow><mo>≡</mo><mrow><mi mathvariant="normal">b</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">e</mi></mrow></mrow><annotation encoding="application/x-tex">\id{base} \equiv \id{base}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">base</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">base</span></span></span></span></span>
is equivalent to
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">S</mi><mi mathvariant="normal">y</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\id{Sym}(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">Sym</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span>.</span></p>
<pre class="Agda">  <a id="3268" href="Algebra.Group.Homotopy.BAut.html#3268" data-type="(T : Type ℓ) → (base T ≡ base T) ≃ (T ≃ T)" class="Function">Ω¹BAut</a> <a id="3275" class="Symbol">:</a> <a id="3277" class="Symbol">(</a><a id="3278" href="Algebra.Group.Homotopy.BAut.html#930" data-type="(T : Type ℓ) → BAut T" class="Function">base</a> <a id="3283" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="3285" href="Algebra.Group.Homotopy.BAut.html#930" data-type="(T : Type ℓ) → BAut T" class="Function">base</a><a id="3289" class="Symbol">)</a> <a id="3291" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="3293" class="Symbol">(</a><a id="3294" href="Algebra.Group.Homotopy.BAut.html#851" class="Bound">T</a> <a id="3296" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="3298" href="Algebra.Group.Homotopy.BAut.html#851" class="Bound">T</a><a id="3299" class="Symbol">)</a>
  <a id="3303" href="Algebra.Group.Homotopy.BAut.html#3268" data-type="(T : Type ℓ) → (base T ≡ base T) ≃ (T ≃ T)" class="Function">Ω¹BAut</a> <a id="3310" class="Symbol">=</a> <a id="3312" href="1Lab.Equiv.html#20161" data-type="Iso A B₁ → A ≃ B₁" class="Function">Iso→Equiv</a>
    <a id="3326" class="Symbol">(</a><a id="3327" href="Algebra.Group.Homotopy.BAut.html#1854" data-type="(T : Type ℓ) (b : ∑ (Type ℓ) (λ B₁ → ∥ T ≃ B₁ ∥)) →
base T ≡ b → Code T b" class="Function">encode</a> <a id="3334" href="Algebra.Group.Homotopy.BAut.html#930" data-type="(T : Type ℓ) → BAut T" class="Function">base</a> <a id="3339" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="3341" href="1Lab.Equiv.html#6116" data-type="(inv₁ : B₁ → A) (rinv₁ : is-right-inverse inv₁ f)
(linv₁ : is-left-inverse inv₁ f) →
is-iso f" class="InductiveConstructor">iso</a> <a id="3345" class="Symbol">(</a><a id="3346" href="Algebra.Group.Homotopy.BAut.html#1927" data-type="(T : Type ℓ) (b : BAut T) → Code T b → base T ≡ b" class="Function">decode</a> <a id="3353" href="Algebra.Group.Homotopy.BAut.html#930" data-type="(T : Type ℓ) → BAut T" class="Function">base</a><a id="3357" class="Symbol">)</a> <a id="3359" class="Symbol">(</a><a id="3360" href="Algebra.Group.Homotopy.BAut.html#2948" data-type="(T : Type ℓ) (b : BAut T) (p : Code T b) →
encode T b (decode T b p) ≡ p" class="Function">encode∘decode</a> <a id="3374" href="Algebra.Group.Homotopy.BAut.html#930" data-type="(T : Type ℓ) → BAut T" class="Function">base</a><a id="3378" class="Symbol">)</a> <a id="3380" class="Symbol">(</a><a id="3381" href="Algebra.Group.Homotopy.BAut.html#2560" data-type="(T : Type ℓ) (b : ∑ (Type ℓ) (λ B₁ → ∥ T ≃ B₁ ∥))
(p : base T ≡ b) →
decode T b (encode T b p) ≡ p" class="Function">decode∘encode</a> <a id="3395" href="Algebra.Group.Homotopy.BAut.html#930" data-type="(T : Type ℓ) → BAut T" class="Function">base</a><a id="3399" class="Symbol">))</a>
</pre>
<p>We can also characterise the h-level of these connected components.
Intuitively the h-level should be one more than that of the type we’re
delooping, because
<span class="Agda"><a href="Algebra.Group.Homotopy.BAut.html#871" class="Function">BAut</a></span>
“only has one point” (it’s connected), and as we established right
above, the space of loops of that point is the automorphism group we
delooped. The trouble here is that
<span class="Agda"><a href="Algebra.Group.Homotopy.BAut.html#871" class="Function">BAut</a></span>
has many points, and while we can pick paths between any two of them, we
can not do so <em>continuously</em> (otherwise
<span class="Agda"><a href="Algebra.Group.Homotopy.BAut.html#871" class="Function">BAut</a></span>
would be a proposition).</p>
<p>This turns out not to matter! Since “being of h-level
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>”
is a proposition, our discontinuous (i.e.: truncated) method of picking
paths is just excellent. In the case when
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>
is contractible, we can directly get at the underlying equivalences, but
for the higher h-levels, we proceed exactly by using connectedness.</p>
<pre class="Agda">  <a id="4246" href="Algebra.Group.Homotopy.BAut.html#4246" data-type="(T : Type ℓ) (n : Nat) → is-hlevel T n → is-hlevel (BAut T) (1 + n)" class="Function">BAut-is-hlevel</a> <a id="4261" class="Symbol">:</a> <a id="4263" class="Symbol">∀</a> <a id="4265" href="Algebra.Group.Homotopy.BAut.html#4265" class="Bound">n</a> <a id="4267" class="Symbol">→</a> <a id="4269" href="1Lab.HLevel.html#2813" data-type="Type ℓ → Nat → Type ℓ" class="Function">is-hlevel</a> <a id="4279" href="Algebra.Group.Homotopy.BAut.html#851" class="Bound">T</a> <a id="4281" href="Algebra.Group.Homotopy.BAut.html#4265" class="Bound">n</a> <a id="4283" class="Symbol">→</a> <a id="4285" href="1Lab.HLevel.html#2813" data-type="Type ℓ → Nat → Type ℓ" class="Function">is-hlevel</a> <a id="4295" href="Algebra.Group.Homotopy.BAut.html#871" data-type="Type ℓ → Type (lsuc ℓ)" class="Function">BAut</a> <a id="4300" class="Symbol">(</a><a id="4301" class="Number">1</a> <a id="4303" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="4305" href="Algebra.Group.Homotopy.BAut.html#4265" class="Bound">n</a><a id="4306" class="Symbol">)</a>
  <a id="4310" href="Algebra.Group.Homotopy.BAut.html#4246" data-type="(T : Type ℓ) (n : Nat) → is-hlevel T n → is-hlevel (BAut T) (1 + n)" class="Function">BAut-is-hlevel</a> <a id="4325" href="Agda.Builtin.Nat.html#195" data-type="Nat" class="InductiveConstructor">zero</a> <a id="4330" href="Algebra.Group.Homotopy.BAut.html#4330" class="Bound">hl</a> <a id="4333" class="Symbol">(</a><a id="4334" href="Algebra.Group.Homotopy.BAut.html#4334" class="Bound">x</a> <a id="4336" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="4338" href="Algebra.Group.Homotopy.BAut.html#4338" class="Bound">f</a><a id="4339" class="Symbol">)</a> <a id="4341" class="Symbol">(</a><a id="4342" href="Algebra.Group.Homotopy.BAut.html#4342" class="Bound">y</a> <a id="4344" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="4346" href="Algebra.Group.Homotopy.BAut.html#4346" class="Bound">g</a><a id="4347" class="Symbol">)</a> <a id="4349" class="Symbol">=</a>
    <a id="4355" href="1Lab.Type.Sigma.html#5139" data-type="((x : A) → is-prop (B₁ x)) → x .fst ≡ y .fst → x ≡ y" class="Function">Σ-prop-path</a> <a id="4367" class="Symbol">(λ</a> <a id="4370" href="Algebra.Group.Homotopy.BAut.html#4370" class="Bound">_</a> <a id="4372" class="Symbol">→</a> <a id="4374" href="1Lab.HIT.Truncation.html#795" data-type="is-prop ∥ A ∥" class="InductiveConstructor">squash</a><a id="4380" class="Symbol">)</a> <a id="4382" class="Symbol">(</a><a id="4383" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="4387" class="Symbol">(</a><a id="4388" href="1Lab.Univalence.html#8818" data-type="A ≃ B₁ → A ≡ B₁" class="Function">ua</a> <a id="4391" href="Algebra.Group.Homotopy.BAut.html#4689" data-type="(T : Type ℓ) (hl : is-hlevel T zero) (x : Type ℓ) (f : ∥ T ≃ x ∥)
(y : Type ℓ) (g : ∥ T ≃ y ∥) →
T ≃ x" class="Function">f′</a><a id="4393" class="Symbol">)</a> <a id="4395" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="4397" href="1Lab.Univalence.html#8818" data-type="A ≃ B₁ → A ≡ B₁" class="Function">ua</a> <a id="4400" href="Algebra.Group.Homotopy.BAut.html#4728" data-type="(T : Type ℓ) (hl : is-hlevel T zero) (x : Type ℓ) (f : ∥ T ≃ x ∥)
(y : Type ℓ) (g : ∥ T ≃ y ∥) →
T ≃ y" class="Function">g′</a><a id="4402" class="Symbol">)</a>
    <a id="4408" class="Keyword">where</a>
      <a id="4420" href="Algebra.Group.Homotopy.BAut.html#4420" data-type="(T : Type ℓ) (hl : is-hlevel T zero) (x : Type ℓ) (f : ∥ T ≃ x ∥)
(y : Type ℓ) (g : ∥ T ≃ y ∥) →
is-prop (T ≃ X)" class="Function">extract</a> <a id="4428" class="Symbol">:</a> <a id="4430" class="Symbol">∀</a> <a id="4432" class="Symbol">{</a><a id="4433" href="Algebra.Group.Homotopy.BAut.html#4433" class="Bound">X</a><a id="4434" class="Symbol">}</a> <a id="4436" class="Symbol">→</a> <a id="4438" href="1Lab.HLevel.html#2597" data-type="Type ℓ → Type ℓ" class="Function">is-prop</a> <a id="4446" class="Symbol">(</a><a id="4447" href="Algebra.Group.Homotopy.BAut.html#851" class="Bound">T</a> <a id="4449" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="4451" href="Algebra.Group.Homotopy.BAut.html#4433" class="Bound">X</a><a id="4452" class="Symbol">)</a>
      <a id="4460" href="Algebra.Group.Homotopy.BAut.html#4420" data-type="(T : Type ℓ) (hl : is-hlevel T zero) (x : Type ℓ) (f : ∥ T ≃ x ∥)
(y : Type ℓ) (g : ∥ T ≃ y ∥) →
is-prop (T ≃ X)" class="Function">extract</a> <a id="4468" href="Algebra.Group.Homotopy.BAut.html#4468" class="Bound">f</a> <a id="4470" href="Algebra.Group.Homotopy.BAut.html#4470" class="Bound">g</a> <a id="4472" class="Symbol">=</a> <a id="4474" href="1Lab.Type.Sigma.html#5139" data-type="((x : A) → is-prop (B₁ x)) → x .fst ≡ y .fst → x ≡ y" class="Function">Σ-prop-path</a> <a id="4486" href="1Lab.Equiv.html#4916" data-type="(f : A → B₁) → is-prop (is-equiv f)" class="Function">is-equiv-is-prop</a> <a id="4503" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="4505" href="1Lab.Path.html#58474" data-type="((x : A) → f x ≡ g x) → f ≡ g" class="Function">funext</a> <a id="4512" class="Symbol">λ</a> <a id="4514" href="Algebra.Group.Homotopy.BAut.html#4514" class="Bound">x</a> <a id="4516" class="Symbol">→</a>
        <a id="4526" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="4529" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="4533" class="Symbol">(</a><a id="4534" href="1Lab.HLevel.html#3818" data-type="is-contr A → is-prop A" class="Function">is-contr→is-prop</a> <a id="4551" class="Symbol">((</a><a id="4553" href="Algebra.Group.Homotopy.BAut.html#4468" class="Bound">f</a> <a id="4555" href="1Lab.Equiv.html#21355" data-type="A ≃ B₁ → B₁ ≃ A" class="Function Operator">e⁻¹</a><a id="4558" class="Symbol">)</a> <a id="4560" class="Symbol">.</a><a id="4561" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="4565" class="Symbol">.</a><a id="4566" href="1Lab.Equiv.html#2376" data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" class="Field">is-eqv</a> <a id="4573" class="Symbol">(</a><a id="4574" href="Algebra.Group.Homotopy.BAut.html#4330" class="Bound">hl</a> <a id="4577" class="Symbol">.</a><a id="4578" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a><a id="4584" class="Symbol">))</a>
          <a id="4597" class="Symbol">(</a><a id="4598" href="Algebra.Group.Homotopy.BAut.html#4468" class="Bound">f</a> <a id="4600" class="Symbol">.</a><a id="4601" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="4605" href="Algebra.Group.Homotopy.BAut.html#4514" class="Bound">x</a> <a id="4607" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="4609" href="1Lab.HLevel.html#3818" data-type="is-contr A → is-prop A" class="Function">is-contr→is-prop</a> <a id="4626" href="Algebra.Group.Homotopy.BAut.html#4330" class="Bound">hl</a> <a id="4629" class="Symbol">_</a> <a id="4631" class="Symbol">_)</a>
          <a id="4644" class="Symbol">(</a><a id="4645" href="Algebra.Group.Homotopy.BAut.html#4470" class="Bound">g</a> <a id="4647" class="Symbol">.</a><a id="4648" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="4652" href="Algebra.Group.Homotopy.BAut.html#4514" class="Bound">x</a> <a id="4654" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="4656" href="1Lab.HLevel.html#3818" data-type="is-contr A → is-prop A" class="Function">is-contr→is-prop</a> <a id="4673" href="Algebra.Group.Homotopy.BAut.html#4330" class="Bound">hl</a> <a id="4676" class="Symbol">_</a> <a id="4678" class="Symbol">_))</a>

      <a id="4689" href="Algebra.Group.Homotopy.BAut.html#4689" data-type="(T : Type ℓ) (hl : is-hlevel T zero) (x : Type ℓ) (f : ∥ T ≃ x ∥)
(y : Type ℓ) (g : ∥ T ≃ y ∥) →
T ≃ x" class="Function">f′</a> <a id="4692" class="Symbol">=</a> <a id="4694" href="1Lab.HIT.Truncation.html#2416" data-type="is-prop P → (A → P) → ∥ A ∥ → P" class="Function">∥-∥-rec</a> <a id="4702" href="Algebra.Group.Homotopy.BAut.html#4420" data-type="(T : Type ℓ) (hl : is-hlevel T zero) (x : Type ℓ) (f : ∥ T ≃ x ∥)
(y : Type ℓ) (g : ∥ T ≃ y ∥) →
is-prop (T ≃ X)" class="Function">extract</a> <a id="4710" class="Symbol">(λ</a> <a id="4713" href="Algebra.Group.Homotopy.BAut.html#4713" class="Bound">x</a> <a id="4715" class="Symbol">→</a> <a id="4717" href="Algebra.Group.Homotopy.BAut.html#4713" class="Bound">x</a><a id="4718" class="Symbol">)</a> <a id="4720" href="Algebra.Group.Homotopy.BAut.html#4338" class="Bound">f</a>
      <a id="4728" href="Algebra.Group.Homotopy.BAut.html#4728" data-type="(T : Type ℓ) (hl : is-hlevel T zero) (x : Type ℓ) (f : ∥ T ≃ x ∥)
(y : Type ℓ) (g : ∥ T ≃ y ∥) →
T ≃ y" class="Function">g′</a> <a id="4731" class="Symbol">=</a> <a id="4733" href="1Lab.HIT.Truncation.html#2416" data-type="is-prop P → (A → P) → ∥ A ∥ → P" class="Function">∥-∥-rec</a> <a id="4741" href="Algebra.Group.Homotopy.BAut.html#4420" data-type="(T : Type ℓ) (hl : is-hlevel T zero) (x : Type ℓ) (f : ∥ T ≃ x ∥)
(y : Type ℓ) (g : ∥ T ≃ y ∥) →
is-prop (T ≃ X)" class="Function">extract</a> <a id="4749" class="Symbol">(λ</a> <a id="4752" href="Algebra.Group.Homotopy.BAut.html#4752" class="Bound">x</a> <a id="4754" class="Symbol">→</a> <a id="4756" href="Algebra.Group.Homotopy.BAut.html#4752" class="Bound">x</a><a id="4757" class="Symbol">)</a> <a id="4759" href="Algebra.Group.Homotopy.BAut.html#4346" class="Bound">g</a>
  <a id="4763" href="Algebra.Group.Homotopy.BAut.html#4246" data-type="(T : Type ℓ) (n : Nat) → is-hlevel T n → is-hlevel (BAut T) (1 + n)" class="Function">BAut-is-hlevel</a> <a id="4778" class="Symbol">(</a><a id="4779" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="4783" href="Algebra.Group.Homotopy.BAut.html#4783" class="Bound">n</a><a id="4784" class="Symbol">)</a> <a id="4786" href="Algebra.Group.Homotopy.BAut.html#4786" class="Bound">hl</a> <a id="4789" href="Algebra.Group.Homotopy.BAut.html#4789" class="Bound">x</a> <a id="4791" href="Algebra.Group.Homotopy.BAut.html#4791" class="Bound">y</a> <a id="4793" class="Symbol">=</a>
    <a id="4799" href="1Lab.HIT.Truncation.html#1852" data-type="((x : ∥ A ∥) (y : ∥ B₁ ∥) → is-prop (P x y)) →
((x : A) (y : B₁) → P (inc x) (inc y)) →
(x : ∥ A ∥) (y : ∥ B₁ ∥) → P x y" class="Function">∥-∥-elim₂</a> <a id="4809" class="Symbol">{</a><a id="4810" class="Argument">P</a> <a id="4812" class="Symbol">=</a> <a id="4814" class="Symbol">λ</a> <a id="4816" href="Algebra.Group.Homotopy.BAut.html#4816" class="Bound">_</a> <a id="4818" href="Algebra.Group.Homotopy.BAut.html#4818" class="Bound">_</a> <a id="4820" class="Symbol">→</a> <a id="4822" href="1Lab.HLevel.html#2813" data-type="Type ℓ → Nat → Type ℓ" class="Function">is-hlevel</a> <a id="4832" class="Symbol">(</a><a id="4833" href="Algebra.Group.Homotopy.BAut.html#4789" class="Bound">x</a> <a id="4835" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="4837" href="Algebra.Group.Homotopy.BAut.html#4791" class="Bound">y</a><a id="4838" class="Symbol">)</a> <a id="4840" class="Symbol">(</a><a id="4841" class="Number">1</a> <a id="4843" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="4845" href="Algebra.Group.Homotopy.BAut.html#4783" class="Bound">n</a><a id="4846" class="Symbol">)}</a>
      <a id="4855" class="Symbol">(λ</a> <a id="4858" href="Algebra.Group.Homotopy.BAut.html#4858" class="Bound">_</a> <a id="4860" href="Algebra.Group.Homotopy.BAut.html#4860" class="Bound">_</a> <a id="4862" class="Symbol">→</a> <a id="4864" href="1Lab.HLevel.html#12473" data-type="(n : Nat) → is-prop (is-hlevel A n)" class="Function">is-hlevel-is-prop</a> <a id="4882" class="Symbol">_)</a>
      <a id="4891" class="Symbol">(λ</a> <a id="4894" href="Algebra.Group.Homotopy.BAut.html#4894" class="Bound">p</a> <a id="4896" href="Algebra.Group.Homotopy.BAut.html#4896" class="Bound">q</a> <a id="4898" class="Symbol">→</a> <a id="4900" href="1Lab.Path.html#11776" data-type="A ≡ B₁ → A → B₁" class="Function">transport</a> <a id="4910" class="Symbol">(</a><a id="4911" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="4915" class="Symbol">(λ</a> <a id="4918" href="Algebra.Group.Homotopy.BAut.html#4918" class="Bound">a</a> <a id="4920" href="Algebra.Group.Homotopy.BAut.html#4920" class="Bound">b</a> <a id="4922" class="Symbol">→</a> <a id="4924" href="1Lab.HLevel.html#2813" data-type="Type ℓ → Nat → Type ℓ" class="Function">is-hlevel</a> <a id="4934" class="Symbol">(</a><a id="4935" href="Algebra.Group.Homotopy.BAut.html#4918" class="Bound">a</a> <a id="4937" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="4939" href="Algebra.Group.Homotopy.BAut.html#4920" class="Bound">b</a><a id="4940" class="Symbol">)</a> <a id="4942" class="Symbol">(</a><a id="4943" class="Number">1</a> <a id="4945" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="4947" href="Algebra.Group.Homotopy.BAut.html#4783" class="Bound">n</a><a id="4948" class="Symbol">))</a> <a id="4951" class="Symbol">(</a><a id="4952" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="4956" href="Algebra.Group.Homotopy.BAut.html#4894" class="Bound">p</a><a id="4957" class="Symbol">)</a> <a id="4959" class="Symbol">(</a><a id="4960" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="4964" href="Algebra.Group.Homotopy.BAut.html#4896" class="Bound">q</a><a id="4965" class="Symbol">))</a>
        <a id="4976" class="Symbol">(</a><a id="4977" href="1Lab.HLevel.Retracts.html#4220" data-type="(n : Nat) → A ≃ B₁ → is-hlevel A n → is-hlevel B₁ n" class="Function">is-hlevel≃</a> <a id="4988" class="Symbol">(</a><a id="4989" class="Number">1</a> <a id="4991" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="4993" href="Algebra.Group.Homotopy.BAut.html#4783" class="Bound">n</a><a id="4994" class="Symbol">)</a> <a id="4996" class="Symbol">(</a><a id="4997" href="Algebra.Group.Homotopy.BAut.html#3268" data-type="(T : Type ℓ) → (base T ≡ base T) ≃ (T ≃ T)" class="Function">Ω¹BAut</a> <a id="5004" href="1Lab.Equiv.html#21355" data-type="A ≃ B₁ → B₁ ≃ A" class="Function Operator">e⁻¹</a><a id="5007" class="Symbol">)</a> <a id="5009" class="Symbol">(</a><a id="5010" href="1Lab.HLevel.Universe.html#1312" data-type="(n : Nat) → is-hlevel A n → is-hlevel B₁ n → is-hlevel (A ≃ B₁) n" class="Function">≃-is-hlevel</a> <a id="5022" class="Symbol">(</a><a id="5023" class="Number">1</a> <a id="5025" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="5027" href="Algebra.Group.Homotopy.BAut.html#4783" class="Bound">n</a><a id="5028" class="Symbol">)</a> <a id="5030" href="Algebra.Group.Homotopy.BAut.html#4786" class="Bound">hl</a> <a id="5033" href="Algebra.Group.Homotopy.BAut.html#4786" class="Bound">hl</a><a id="5035" class="Symbol">)))</a>
      <a id="5045" class="Symbol">(</a><a id="5046" href="Algebra.Group.Homotopy.BAut.html#1195" data-type="(T : Type ℓ) (b : ∑ (Type ℓ) (λ B₁ → ∥ T ≃ B₁ ∥)) → ∥ b ≡ base T ∥" class="Function">connected</a> <a id="5056" href="Algebra.Group.Homotopy.BAut.html#4789" class="Bound">x</a><a id="5057" class="Symbol">)</a> <a id="5059" class="Symbol">(</a><a id="5060" href="Algebra.Group.Homotopy.BAut.html#1195" data-type="(T : Type ℓ) (b : ∑ (Type ℓ) (λ B₁ → ∥ T ≃ B₁ ∥)) → ∥ b ≡ base T ∥" class="Function">connected</a> <a id="5070" href="Algebra.Group.Homotopy.BAut.html#4791" class="Bound">y</a><a id="5071" class="Symbol">)</a>
</pre>
  </article>
</div>
</main>
</body>
<style>.equations { display: none !important; }</style></html>
