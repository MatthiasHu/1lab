<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="keywords" content="Agda,categories,topos" />

  <title>…ebra.Group.Homotopy.BAut - 1Lab</title>

  <link rel="stylesheet" href="/css/default.css" />
  <link rel="stylesheet" href="/css/katex.min.css" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="…ebra.Group.Homotopy.BAut - 1Lab" />
  <meta name="twitter:image" content="https://1lab.dev/static/cube-128x.png" />

  <meta name="og:title" content="…ebra.Group.Homotopy.BAut - 1Lab" />
  <meta name="og:image" content="https://1lab.dev/static/cube-128x.png" />
  <meta name="og:site-name" content="1Lab" />
  <meta name="og:type" content="website" />

    <meta name="og:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="twitter:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  
  <script defer src="/main.js"></script>

  <noscript>
    <style>
      body span.reasoning-step .as-written {
        display: inline;
      }

      body span.reasoning-step .alternate {
        display: none;
      }
    </style>
  </noscript>

  <!-- Google font embeds -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;0,800;1,400;1,500;1,600;1,700;1,800&amp;family=Inria+Sans:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&amp;display=swap" rel="stylesheet">
</head>

<body class="text-page">
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <!-- Table of contents (only if the page has a table of contents) -->
    <aside id="toc">
    <div id="toc-container" style="min-width: 10em; font-size: 15pt;">
      <!-- Title for the page -->
      <h3 class="Agda" style="margin-top: 0; margin-bottom: 0; white-space: pre;">
                <a class="Module">…ebra.Group.Homotopy.BAut</a>
              </h3>

      <!-- Cube logo -->
      <a id="logo" href="/">
        <img alt="1Lab" src="/static/cube-72x.png" style="display: block; margin-bottom: 1em; margin: auto;" width="32px" height="32px" />
      </a>

      <!-- Actual table of contents (separated from the rest by
      horizontal rules) -->
      <hr />
      <ul>
      <li><a href="#deloopings-of-automorphism-groups"><a href="#deloopings-of-automorphism-groups" class="header-link">Deloopings
      of automorphism
      groups<span class="header-link-emoji">🔗</span></a></a></li>
      </ul>
      <hr />

      <!-- Sidebar controls -->
      <div style="display: flex; gap: 0.25em; flex-flow: row wrap;">
        <!-- Sidebar equations control -->
        <span class="equations" style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-eqns" type="checkbox" class="equations" id="sidebar-eqns">
          <label for="sidebar-eqns">Equations</label>
        </span>

        <!-- Sidebar fonts control -->
        <span style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-font" type="checkbox" id="toggle-fonts">
          <label for="toggle-fonts">Serif Font</label>
        </span>

        <!-- Sidebar footnotes control -->
        <span class="inline-footnotes" style="display: none; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-fns" type="checkbox" class="inline-footnotes" id="sidebar-fns">
          <label for="sidebar-fns">Inline Footnotes</label>
        </span>
      </div>

      <hr />

      <!-- Navbar navigation (lol) -->
      <div id="return" style="white-space: nowrap;">
        <div class="search-form search-form-proxy" role="form">
          <input id="search-box-proxy" type_="text" placeholder="Search..." autocomplete="off" tabindex="0"></input>
        </div>

              <a href="/">back to index</a> <br />
              <a href="all-pages.html">view all pages</a> <br />
        <a href="https://github.com/plt-amy/cubical-1lab/blob/74d5ca6567ce774a1936458b7fa83502c8f34f20/src/Algebra/Group/Homotopy/BAut.lagda.md">link to source</a> <br />
                <hr /> <div class="author-list">Written by Amélia Liao</div> <br />
              </div>
    </div>
  </aside>
  
  <article>
    <!-- Article navigation (narrow screens only) -->
    <div class="narrow-only" id="article-nav">
      <!-- Index return anchor (only if the page is not the index) -->
            <div id="return">
        <a href="/">back to index</a>
      </div>
      
      <!-- Navbar equations control -->
      <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-eqns" type="checkbox" class="equations" id="navbar-eqns">
        <label for="navbar-eqns">Equations</label>
      </span>

      <!-- Navbar footnotes control -->
      <span class="inline-footnotes" style="display: none; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-fns" type="checkbox" class="inline-footnotes" id="navbar-fns">
        <label for="navbar-fns">Inline Footnotes</label>
      </span>
    </div>

<pre class="Agda"><a id="9" class="Keyword">open</a> <a id="14" class="Keyword">import</a> <a id="21" href="1Lab.Prelude.html" class="Module">1Lab.Prelude</a>

<a id="35" class="Keyword">open</a> <a id="40" class="Keyword">import</a> <a id="47" href="Algebra.Group.html" class="Module">Algebra.Group</a>

<a id="62" class="Keyword">open</a> <a id="67" class="Keyword">import</a> <a id="74" href="Data.Set.Truncation.html" class="Module">Data.Set.Truncation</a>

<a id="95" class="Keyword">module</a> <a id="102" href="Algebra.Group.Homotopy.BAut.html" class="Module">Algebra.Group.Homotopy.BAut</a> <a id="130" class="Keyword">where</a>
</pre>
<h1 id="deloopings-of-automorphism-groups"><a href="#deloopings-of-automorphism-groups" class="header-link">Deloopings
of automorphism groups<span class="header-link-emoji">🔗</span></a></h1>
<p>Recall that any set
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>
generates a group <a href="Algebra.Group.html#symmetric-groups"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">S</mi><mi mathvariant="normal">y</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\id{Sym}(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">Sym</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span></a>,
given by the automorphisms
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>≃</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">X \simeq X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≃</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>.</span>
We also have a generic construction of <a href="Algebra.Group.Homotopy.html#deloopings">deloopings</a>: special
spaces
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo stretchy="false">(</mo><mi>G</mi><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K(G,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>
(for a group
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span>),</span>
where the <a href="Algebra.Group.Homotopy.html#homotopy-groups.">fundamental
group</a>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>K</mi><mo stretchy="false">(</mo><mi>G</mi><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_1(K(G,1))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">))</span></span></span></span>
recovers
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span>.</span>
For the specific case of deloping automorphism groups, we can give an
alternative construction: The type of small types <a href="1Lab.HIT.Truncation.html">merely</a> equivalent to
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>
has a fundamental group of
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">S</mi><mi mathvariant="normal">y</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\id{Sym}(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">Sym</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span>.</span></p>
<pre class="Agda"><a id="837" class="Keyword">module</a> <a id="844" href="Algebra.Group.Homotopy.BAut.html#844" class="Module">_</a> <a id="846" class="Symbol">{</a><a id="847" href="Algebra.Group.Homotopy.BAut.html#847" class="Bound">ℓ</a><a id="848" class="Symbol">}</a> <a id="850" class="Symbol">(</a><a id="851" href="Algebra.Group.Homotopy.BAut.html#851" class="Bound">T</a> <a id="853" class="Symbol">:</a> <a id="855" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="860" href="Algebra.Group.Homotopy.BAut.html#847" class="Bound">ℓ</a><a id="861" class="Symbol">)</a> <a id="863" class="Keyword">where</a>
  <a id="871" href="Algebra.Group.Homotopy.BAut.html#871" data-type="Type ℓ → Type (lsuc ℓ)" class="Function">BAut</a> <a id="876" class="Symbol">:</a> <a id="878" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="883" class="Symbol">(</a><a id="884" href="Agda.Primitive.html#765" data-type="Level → Level" class="Primitive">lsuc</a> <a id="889" href="Algebra.Group.Homotopy.BAut.html#847" class="Bound">ℓ</a><a id="890" class="Symbol">)</a>
  <a id="894" href="Algebra.Group.Homotopy.BAut.html#871" data-type="Type ℓ → Type (lsuc ℓ)" class="Function">BAut</a> <a id="899" class="Symbol">=</a> <a id="901" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">Σ[</a> <a id="904" href="Algebra.Group.Homotopy.BAut.html#904" class="Bound">B</a> <a id="906" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">∈</a> <a id="908" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="913" href="Algebra.Group.Homotopy.BAut.html#847" class="Bound">ℓ</a> <a id="915" href="1Lab.Type.html#1573" data-type="(B₁ : A → Type b) → Type (a ⊔ b)" class="Function">]</a> <a id="917" href="1Lab.HIT.Truncation.html#736" data-type="Type ℓ → Type ℓ" class="Datatype Operator">∥</a> <a id="919" href="Algebra.Group.Homotopy.BAut.html#851" class="Bound">T</a> <a id="921" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="923" href="Algebra.Group.Homotopy.BAut.html#904" class="Bound">B</a> <a id="925" href="1Lab.HIT.Truncation.html#736" data-type="Type ℓ → Type ℓ" class="Datatype Operator">∥</a>

  <a id="930" href="Algebra.Group.Homotopy.BAut.html#930" data-type="(T : Type ℓ) → BAut T" class="Function">base</a> <a id="935" class="Symbol">:</a> <a id="937" href="Algebra.Group.Homotopy.BAut.html#871" data-type="Type ℓ → Type (lsuc ℓ)" class="Function">BAut</a>
  <a id="944" href="Algebra.Group.Homotopy.BAut.html#930" data-type="(T : Type ℓ) → BAut T" class="Function">base</a> <a id="949" class="Symbol">=</a> <a id="951" href="Algebra.Group.Homotopy.BAut.html#851" class="Bound">T</a> <a id="953" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="955" href="1Lab.HIT.Truncation.html#774" data-type="A → ∥ A ∥" class="InductiveConstructor">inc</a> <a id="959" class="Symbol">(</a><a id="960" href="1Lab.Type.html#2424" data-type="A → A" class="Function">id</a> <a id="963" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="965" href="1Lab.Equiv.html#2524" data-type="is-equiv (λ x → x)" class="Function">id-equiv</a><a id="973" class="Symbol">)</a>
</pre>
<p>The first thing we note is that
<span class="Agda"><a href="Algebra.Group.Homotopy.BAut.html#871" class="Function">BAut</a></span>
is a <em>connected</em> type, meaning that it only has “a single point”,
or, more precisely, that all of its interesting information is in its
(higher) path spaces:</p>
<pre class="Agda">  <a id="1195" href="Algebra.Group.Homotopy.BAut.html#1195" data-type="(T : Type ℓ) (b : ∑ (Type ℓ) (λ B₁ → ∥ T ≃ B₁ ∥)) → ∥ b ≡ base T ∥" class="Function">connected</a> <a id="1205" class="Symbol">:</a> <a id="1207" class="Symbol">∀</a> <a id="1209" href="Algebra.Group.Homotopy.BAut.html#1209" class="Bound">b</a> <a id="1211" class="Symbol">→</a> <a id="1213" href="1Lab.HIT.Truncation.html#736" data-type="Type ℓ → Type ℓ" class="Datatype Operator">∥</a> <a id="1215" href="Algebra.Group.Homotopy.BAut.html#1209" class="Bound">b</a> <a id="1217" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="1219" href="Algebra.Group.Homotopy.BAut.html#930" data-type="(T : Type ℓ) → BAut T" class="Function">base</a> <a id="1224" href="1Lab.HIT.Truncation.html#736" data-type="Type ℓ → Type ℓ" class="Datatype Operator">∥</a>
  <a id="1228" href="Algebra.Group.Homotopy.BAut.html#1195" data-type="(T : Type ℓ) (b : ∑ (Type ℓ) (λ B₁ → ∥ T ≃ B₁ ∥)) → ∥ b ≡ base T ∥" class="Function">connected</a> <a id="1238" class="Symbol">(</a><a id="1239" href="Algebra.Group.Homotopy.BAut.html#1239" class="Bound">b</a> <a id="1241" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="1243" href="Algebra.Group.Homotopy.BAut.html#1243" class="Bound">x</a><a id="1244" class="Symbol">)</a> <a id="1246" class="Symbol">=</a>
    <a id="1252" href="1Lab.HIT.Truncation.html#1408" data-type="((x : ∥ A ∥) → is-prop (P x)) →
((x : A) → P (inc x)) → (x : ∥ A ∥) → P x" class="Function">∥-∥-elim</a> <a id="1261" class="Symbol">{</a><a id="1262" class="Argument">P</a> <a id="1264" class="Symbol">=</a> <a id="1266" class="Symbol">λ</a> <a id="1268" href="Algebra.Group.Homotopy.BAut.html#1268" class="Bound">x</a> <a id="1270" class="Symbol">→</a> <a id="1272" href="1Lab.HIT.Truncation.html#736" data-type="Type ℓ → Type ℓ" class="Datatype Operator">∥</a> <a id="1274" class="Symbol">(</a><a id="1275" href="Algebra.Group.Homotopy.BAut.html#1239" class="Bound">b</a> <a id="1277" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="1279" href="Algebra.Group.Homotopy.BAut.html#1268" class="Bound">x</a><a id="1280" class="Symbol">)</a> <a id="1282" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="1284" href="Algebra.Group.Homotopy.BAut.html#930" data-type="(T : Type ℓ) → BAut T" class="Function">base</a> <a id="1289" href="1Lab.HIT.Truncation.html#736" data-type="Type ℓ → Type ℓ" class="Datatype Operator">∥</a><a id="1290" class="Symbol">}</a> <a id="1292" class="Symbol">(λ</a> <a id="1295" href="Algebra.Group.Homotopy.BAut.html#1295" class="Bound">_</a> <a id="1297" class="Symbol">→</a> <a id="1299" href="1Lab.HIT.Truncation.html#795" data-type="is-prop ∥ A ∥" class="InductiveConstructor">squash</a><a id="1305" class="Symbol">)</a> <a id="1307" class="Symbol">(λ</a> <a id="1310" href="Algebra.Group.Homotopy.BAut.html#1310" class="Bound">e</a> <a id="1312" class="Symbol">→</a> <a id="1314" href="1Lab.HIT.Truncation.html#774" data-type="A → ∥ A ∥" class="InductiveConstructor">inc</a> <a id="1318" class="Symbol">(</a><a id="1319" href="Algebra.Group.Homotopy.BAut.html#1345" data-type="(T : Type ℓ) (b : Type ℓ) →
∥ T ≃ b ∥ → (b₁ : Type ℓ) (e : T ≃ b₁) → (b₁ , inc e) ≡ base T" class="Function">p</a> <a id="1321" class="Symbol">_</a> <a id="1323" class="Symbol">_))</a> <a id="1327" href="Algebra.Group.Homotopy.BAut.html#1243" class="Bound">x</a>
    <a id="1333" class="Keyword">where</a>
      <a id="1345" href="Algebra.Group.Homotopy.BAut.html#1345" data-type="(T : Type ℓ) (b : Type ℓ) →
∥ T ≃ b ∥ → (b₁ : Type ℓ) (e : T ≃ b₁) → (b₁ , inc e) ≡ base T" class="Function">p</a> <a id="1347" class="Symbol">:</a> <a id="1349" class="Symbol">∀</a> <a id="1351" href="Algebra.Group.Homotopy.BAut.html#1351" class="Bound">b</a> <a id="1353" href="Algebra.Group.Homotopy.BAut.html#1353" class="Bound">e</a> <a id="1355" class="Symbol">→</a> <a id="1357" class="Symbol">(</a><a id="1358" href="Algebra.Group.Homotopy.BAut.html#1351" class="Bound">b</a> <a id="1360" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="1362" href="1Lab.HIT.Truncation.html#774" data-type="A → ∥ A ∥" class="InductiveConstructor">inc</a> <a id="1366" href="Algebra.Group.Homotopy.BAut.html#1353" class="Bound">e</a><a id="1367" class="Symbol">)</a> <a id="1369" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="1371" href="Algebra.Group.Homotopy.BAut.html#930" data-type="(T : Type ℓ) → BAut T" class="Function">base</a>
      <a id="1382" href="Algebra.Group.Homotopy.BAut.html#1345" data-type="(T : Type ℓ) (b : Type ℓ) →
∥ T ≃ b ∥ → (b₁ : Type ℓ) (e : T ≃ b₁) → (b₁ , inc e) ≡ base T" class="Function">p</a> <a id="1384" class="Symbol">_</a> <a id="1386" class="Symbol">=</a> <a id="1388" href="1Lab.Univalence.html#20072" data-type="(P : (B₁ : Type ℓ) → A ≃ B₁ → Type ℓ&#39;) →
P A ((λ x → x) , id-equiv) → (e : A ≃ B₁) → P B₁ e" class="Function">EquivJ</a> <a id="1395" class="Symbol">(λ</a> <a id="1398" href="Algebra.Group.Homotopy.BAut.html#1398" class="Bound">B</a> <a id="1400" href="Algebra.Group.Homotopy.BAut.html#1400" class="Bound">e</a> <a id="1402" class="Symbol">→</a> <a id="1404" class="Symbol">(</a><a id="1405" href="Algebra.Group.Homotopy.BAut.html#1398" class="Bound">B</a> <a id="1407" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="1409" href="1Lab.HIT.Truncation.html#774" data-type="A → ∥ A ∥" class="InductiveConstructor">inc</a> <a id="1413" href="Algebra.Group.Homotopy.BAut.html#1400" class="Bound">e</a><a id="1414" class="Symbol">)</a> <a id="1416" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="1418" href="Algebra.Group.Homotopy.BAut.html#930" data-type="(T : Type ℓ) → BAut T" class="Function">base</a><a id="1422" class="Symbol">)</a> <a id="1424" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
</pre>
<p>We now turn to proving that
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi mathvariant="normal">B</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>≃</mo><mo stretchy="false">(</mo><mi>X</mi><mo>≃</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_1(\baut(X)) \simeq (X \simeq X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mop"><span class="mord mathbf">B</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≃</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≃</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span>.</span>
We will define a type family
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">C</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">e</mi></mrow><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\id{Code}(b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">Code</span></span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>,</span>
where a value
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>:</mo><mrow><mi mathvariant="normal">C</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">e</mi></mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p : \id{Code}(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">Code</span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>
codes for an identification
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>≡</mo><mrow><mi mathvariant="normal">b</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">e</mi></mrow></mrow><annotation encoding="application/x-tex">p \equiv \id{base}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6582em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">base</span></span></span></span></span>.</span>
Correspondingly, there are functions to and from these types: The core
of the proof is showing that these functions,
<span class="Agda"><a href="Algebra.Group.Homotopy.BAut.html#1854" class="Function">encode</a></span>
and
<span class="Agda"><a href="Algebra.Group.Homotopy.BAut.html#1927" class="Function">decode</a></span>,
are inverses.</p>
<pre class="Agda">  <a id="1808" href="Algebra.Group.Homotopy.BAut.html#1808" data-type="(T : Type ℓ) → BAut T → Type ℓ" class="Function">Code</a> <a id="1813" class="Symbol">:</a> <a id="1815" href="Algebra.Group.Homotopy.BAut.html#871" data-type="Type ℓ → Type (lsuc ℓ)" class="Function">BAut</a> <a id="1820" class="Symbol">→</a> <a id="1822" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="1827" href="Algebra.Group.Homotopy.BAut.html#847" class="Bound">ℓ</a>
  <a id="1831" href="Algebra.Group.Homotopy.BAut.html#1808" data-type="(T : Type ℓ) → BAut T → Type ℓ" class="Function">Code</a> <a id="1836" href="Algebra.Group.Homotopy.BAut.html#1836" class="Bound">b</a> <a id="1838" class="Symbol">=</a> <a id="1840" href="Algebra.Group.Homotopy.BAut.html#851" class="Bound">T</a> <a id="1842" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="1844" href="Algebra.Group.Homotopy.BAut.html#1836" class="Bound">b</a> <a id="1846" class="Symbol">.</a><a id="1847" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a>

  <a id="1854" href="Algebra.Group.Homotopy.BAut.html#1854" data-type="(T : Type ℓ) (b : ∑ (Type ℓ) (λ B₁ → ∥ T ≃ B₁ ∥)) →
base T ≡ b → Code T b" class="Function">encode</a> <a id="1861" class="Symbol">:</a> <a id="1863" class="Symbol">∀</a> <a id="1865" href="Algebra.Group.Homotopy.BAut.html#1865" class="Bound">b</a> <a id="1867" class="Symbol">→</a> <a id="1869" href="Algebra.Group.Homotopy.BAut.html#930" data-type="(T : Type ℓ) → BAut T" class="Function">base</a> <a id="1874" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="1876" href="Algebra.Group.Homotopy.BAut.html#1865" class="Bound">b</a> <a id="1878" class="Symbol">→</a> <a id="1880" href="Algebra.Group.Homotopy.BAut.html#1808" data-type="(T : Type ℓ) → BAut T → Type ℓ" class="Function">Code</a> <a id="1885" href="Algebra.Group.Homotopy.BAut.html#1865" class="Bound">b</a>
  <a id="1889" href="Algebra.Group.Homotopy.BAut.html#1854" data-type="(T : Type ℓ) (b : ∑ (Type ℓ) (λ B₁ → ∥ T ≃ B₁ ∥)) →
base T ≡ b → Code T b" class="Function">encode</a> <a id="1896" href="Algebra.Group.Homotopy.BAut.html#1896" class="Bound">x</a> <a id="1898" href="Algebra.Group.Homotopy.BAut.html#1898" class="Bound">p</a> <a id="1900" class="Symbol">=</a> <a id="1902" href="1Lab.Univalence.html#15737" data-type="A ≡ B₁ → A ≃ B₁" class="Function">path→equiv</a> <a id="1913" class="Symbol">(</a><a id="1914" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="1917" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="1921" href="Algebra.Group.Homotopy.BAut.html#1898" class="Bound">p</a><a id="1922" class="Symbol">)</a>

  <a id="1927" href="Algebra.Group.Homotopy.BAut.html#1927" data-type="(T : Type ℓ) (b : BAut T) → Code T b → base T ≡ b" class="Function">decode</a> <a id="1934" class="Symbol">:</a> <a id="1936" class="Symbol">∀</a> <a id="1938" href="Algebra.Group.Homotopy.BAut.html#1938" class="Bound">b</a> <a id="1940" class="Symbol">→</a> <a id="1942" href="Algebra.Group.Homotopy.BAut.html#1808" data-type="(T : Type ℓ) → BAut T → Type ℓ" class="Function">Code</a> <a id="1947" href="Algebra.Group.Homotopy.BAut.html#1938" class="Bound">b</a> <a id="1949" class="Symbol">→</a> <a id="1951" href="Algebra.Group.Homotopy.BAut.html#930" data-type="(T : Type ℓ) → BAut T" class="Function">base</a> <a id="1956" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="1958" href="Algebra.Group.Homotopy.BAut.html#1938" class="Bound">b</a>
  <a id="1962" href="Algebra.Group.Homotopy.BAut.html#1927" data-type="(T : Type ℓ) (b : BAut T) → Code T b → base T ≡ b" class="Function">decode</a> <a id="1969" class="Symbol">(</a><a id="1970" href="Algebra.Group.Homotopy.BAut.html#1970" class="Bound">b</a> <a id="1972" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="1974" href="Algebra.Group.Homotopy.BAut.html#1974" class="Bound">eqv</a><a id="1977" class="Symbol">)</a> <a id="1979" href="Algebra.Group.Homotopy.BAut.html#1979" class="Bound">rot</a> <a id="1983" class="Symbol">=</a> <a id="1985" href="1Lab.Path.html#57276" data-type="(p : x .fst ≡ y .fst) →
PathP (λ i → B₁ (p i)) (x .snd) (y .snd) → x ≡ y" class="Function">Σ-pathp</a> <a id="1993" class="Symbol">(</a><a id="1994" href="1Lab.Univalence.html#9069" data-type="A ≃ B₁ → A ≡ B₁" class="Function">ua</a> <a id="1997" href="Algebra.Group.Homotopy.BAut.html#1979" class="Bound">rot</a><a id="2000" class="Symbol">)</a> <a id="2002" class="Symbol">(</a><a id="2003" href="1Lab.HLevel.html#13498" data-type="((i : I) → is-prop (B₁ i)) →
(b0 : B₁ i0) (b1 : B₁ i1) → PathP B₁ b0 b1" class="Function">is-prop→pathp</a> <a id="2017" class="Symbol">(λ</a> <a id="2020" href="Algebra.Group.Homotopy.BAut.html#2020" class="Bound">_</a> <a id="2022" class="Symbol">→</a> <a id="2024" href="1Lab.HIT.Truncation.html#795" data-type="is-prop ∥ A ∥" class="InductiveConstructor">squash</a><a id="2030" class="Symbol">)</a> <a id="2032" class="Symbol">_</a> <a id="2034" class="Symbol">_)</a>
</pre>
<p>Recall that
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">b</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">e</mi></mrow><annotation encoding="application/x-tex">\id{base}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">base</span></span></span></span></span>
is the type
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>
itself, equipped with the identity equivalence. Hence, to code for an
identification
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">b</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">e</mi></mrow><mo>≡</mo><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\id{base} \equiv (X, e)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">base</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">e</span><span class="mclose">)</span></span></span></span>,</span>
it suffices to record
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span>
— which by univalence corresponds to a path
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">u</mi><mi mathvariant="normal">a</mi></mrow><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo><mo>:</mo><mi>T</mi><mo>≡</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">\id{ua}(e) : T \equiv X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">ua</span></span><span class="mopen">(</span><span class="mord mathnormal">e</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>.</span>
We can not directly extract the equivalence from a given point
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>e</mi><mo stretchy="false">)</mo><mo>:</mo><mi mathvariant="normal">B</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(X, e) : \baut(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">e</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathbf">B</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span>:</span>
it is “hidden away” under a truncation. But, given an identification
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>:</mo><mi>b</mi><mo>≡</mo><mrow><mi mathvariant="normal">b</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">e</mi></mrow></mrow><annotation encoding="application/x-tex">p : b \equiv \id{base}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">base</span></span></span></span></span>,</span>
we can recover the equivalence by seeing <em>how</em>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>
identifies
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>≡</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">X \equiv T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>.</span></p>
<pre class="Agda">  <a id="2560" href="Algebra.Group.Homotopy.BAut.html#2560" data-type="(T : Type ℓ) (b : ∑ (Type ℓ) (λ B₁ → ∥ T ≃ B₁ ∥))
(p : base T ≡ b) →
decode T b (encode T b p) ≡ p" class="Function">decode∘encode</a> <a id="2574" class="Symbol">:</a> <a id="2576" class="Symbol">∀</a> <a id="2578" href="Algebra.Group.Homotopy.BAut.html#2578" class="Bound">b</a> <a id="2580" class="Symbol">(</a><a id="2581" href="Algebra.Group.Homotopy.BAut.html#2581" class="Bound">p</a> <a id="2583" class="Symbol">:</a> <a id="2585" href="Algebra.Group.Homotopy.BAut.html#930" data-type="(T : Type ℓ) → BAut T" class="Function">base</a> <a id="2590" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="2592" href="Algebra.Group.Homotopy.BAut.html#2578" class="Bound">b</a><a id="2593" class="Symbol">)</a> <a id="2595" class="Symbol">→</a> <a id="2597" href="Algebra.Group.Homotopy.BAut.html#1927" data-type="(T : Type ℓ) (b : BAut T) → Code T b → base T ≡ b" class="Function">decode</a> <a id="2604" href="Algebra.Group.Homotopy.BAut.html#2578" class="Bound">b</a> <a id="2606" class="Symbol">(</a><a id="2607" href="Algebra.Group.Homotopy.BAut.html#1854" data-type="(T : Type ℓ) (b : ∑ (Type ℓ) (λ B₁ → ∥ T ≃ B₁ ∥)) →
base T ≡ b → Code T b" class="Function">encode</a> <a id="2614" href="Algebra.Group.Homotopy.BAut.html#2578" class="Bound">b</a> <a id="2616" href="Algebra.Group.Homotopy.BAut.html#2581" class="Bound">p</a><a id="2617" class="Symbol">)</a> <a id="2619" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="2621" href="Algebra.Group.Homotopy.BAut.html#2581" class="Bound">p</a>
  <a id="2625" href="Algebra.Group.Homotopy.BAut.html#2560" data-type="(T : Type ℓ) (b : ∑ (Type ℓ) (λ B₁ → ∥ T ≃ B₁ ∥))
(p : base T ≡ b) →
decode T b (encode T b p) ≡ p" class="Function">decode∘encode</a> <a id="2639" href="Algebra.Group.Homotopy.BAut.html#2639" class="Bound">b</a> <a id="2641" class="Symbol">=</a>
    <a id="2647" href="1Lab.Path.html#19544" data-type="(P : (y : A) → x ≡ y → Type ℓ₂) → P x refl → (p : x ≡ y) → P y p" class="Function">J</a> <a id="2649" class="Symbol">(λ</a> <a id="2652" href="Algebra.Group.Homotopy.BAut.html#2652" class="Bound">b</a> <a id="2654" href="Algebra.Group.Homotopy.BAut.html#2654" class="Bound">p</a> <a id="2656" class="Symbol">→</a> <a id="2658" href="Algebra.Group.Homotopy.BAut.html#1927" data-type="(T : Type ℓ) (b : BAut T) → Code T b → base T ≡ b" class="Function">decode</a> <a id="2665" href="Algebra.Group.Homotopy.BAut.html#2652" class="Bound">b</a> <a id="2667" class="Symbol">(</a><a id="2668" href="Algebra.Group.Homotopy.BAut.html#1854" data-type="(T : Type ℓ) (b : ∑ (Type ℓ) (λ B₁ → ∥ T ≃ B₁ ∥)) →
base T ≡ b → Code T b" class="Function">encode</a> <a id="2675" href="Algebra.Group.Homotopy.BAut.html#2652" class="Bound">b</a> <a id="2677" href="Algebra.Group.Homotopy.BAut.html#2654" class="Bound">p</a><a id="2678" class="Symbol">)</a> <a id="2680" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="2682" href="Algebra.Group.Homotopy.BAut.html#2654" class="Bound">p</a><a id="2683" class="Symbol">)</a>
      <a id="2691" class="Symbol">(</a><a id="2692" href="1Lab.Type.Sigma.html#7023" data-type="((x : A) → is-prop (B₁ x)) →
Square (ap fst p) (ap fst q) (ap fst s) (ap fst r) → Square p q s r" class="Function">Σ-prop-square</a> <a id="2706" class="Symbol">(λ</a> <a id="2709" href="Algebra.Group.Homotopy.BAut.html#2709" class="Bound">_</a> <a id="2711" class="Symbol">→</a> <a id="2713" href="1Lab.HIT.Truncation.html#795" data-type="is-prop ∥ A ∥" class="InductiveConstructor">squash</a><a id="2719" class="Symbol">)</a> <a id="2721" href="Algebra.Group.Homotopy.BAut.html#2741" data-type="(T : Type ℓ) (b : ∑ (Type ℓ) (λ B₁ → ∥ T ≃ B₁ ∥)) →
ua (encode T (base T) refl) ≡ refl" class="Function">sq</a><a id="2723" class="Symbol">)</a>
    <a id="2729" class="Keyword">where</a>
      <a id="2741" href="Algebra.Group.Homotopy.BAut.html#2741" data-type="(T : Type ℓ) (b : ∑ (Type ℓ) (λ B₁ → ∥ T ≃ B₁ ∥)) →
ua (encode T (base T) refl) ≡ refl" class="Function">sq</a> <a id="2744" class="Symbol">:</a> <a id="2746" href="1Lab.Univalence.html#9069" data-type="A ≃ B₁ → A ≡ B₁" class="Function">ua</a> <a id="2749" class="Symbol">(</a><a id="2750" href="Algebra.Group.Homotopy.BAut.html#1854" data-type="(T : Type ℓ) (b : ∑ (Type ℓ) (λ B₁ → ∥ T ≃ B₁ ∥)) →
base T ≡ b → Code T b" class="Function">encode</a> <a id="2757" href="Algebra.Group.Homotopy.BAut.html#930" data-type="(T : Type ℓ) → BAut T" class="Function">base</a> <a id="2762" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a><a id="2766" class="Symbol">)</a> <a id="2768" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="2770" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
      <a id="2781" href="Algebra.Group.Homotopy.BAut.html#2741" data-type="(T : Type ℓ) (b : ∑ (Type ℓ) (λ B₁ → ∥ T ≃ B₁ ∥)) →
ua (encode T (base T) refl) ≡ refl" class="Function">sq</a> <a id="2784" class="Symbol">=</a> <a id="2786" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="2789" href="1Lab.Univalence.html#9069" data-type="A ≃ B₁ → A ≡ B₁" class="Function">ua</a> <a id="2792" href="1Lab.Univalence.html#16089" data-type="path→equiv refl ≡ (id , id-equiv)" class="Function">path→equiv-refl</a> <a id="2808" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="2810" href="1Lab.Univalence.html#16518" data-type="ua ((λ x → x) , id-equiv) ≡ refl" class="Function">ua-id-equiv</a>
</pre>
<p><span class="Agda"><a href="Algebra.Group.Homotopy.BAut.html#1854" class="Function">Encode</a></span>
and
<span class="Agda"><a href="Algebra.Group.Homotopy.BAut.html#1927" class="Function">decode</a></span>
are inverses by a direct application of
<span class="Agda"><a href="1Lab.Univalence.html#17023" class="Function">univalence</a></span>.</p>
<pre class="Agda">  <a id="2948" href="Algebra.Group.Homotopy.BAut.html#2948" data-type="(T : Type ℓ) (b : BAut T) (p : Code T b) →
encode T b (decode T b p) ≡ p" class="Function">encode∘decode</a> <a id="2962" class="Symbol">:</a> <a id="2964" class="Symbol">∀</a> <a id="2966" href="Algebra.Group.Homotopy.BAut.html#2966" class="Bound">b</a> <a id="2968" class="Symbol">(</a><a id="2969" href="Algebra.Group.Homotopy.BAut.html#2969" class="Bound">p</a> <a id="2971" class="Symbol">:</a> <a id="2973" href="Algebra.Group.Homotopy.BAut.html#1808" data-type="(T : Type ℓ) → BAut T → Type ℓ" class="Function">Code</a> <a id="2978" href="Algebra.Group.Homotopy.BAut.html#2966" class="Bound">b</a><a id="2979" class="Symbol">)</a> <a id="2981" class="Symbol">→</a> <a id="2983" href="Algebra.Group.Homotopy.BAut.html#1854" data-type="(T : Type ℓ) (b : ∑ (Type ℓ) (λ B₁ → ∥ T ≃ B₁ ∥)) →
base T ≡ b → Code T b" class="Function">encode</a> <a id="2990" href="Algebra.Group.Homotopy.BAut.html#2966" class="Bound">b</a> <a id="2992" class="Symbol">(</a><a id="2993" href="Algebra.Group.Homotopy.BAut.html#1927" data-type="(T : Type ℓ) (b : BAut T) → Code T b → base T ≡ b" class="Function">decode</a> <a id="3000" href="Algebra.Group.Homotopy.BAut.html#2966" class="Bound">b</a> <a id="3002" href="Algebra.Group.Homotopy.BAut.html#2969" class="Bound">p</a><a id="3003" class="Symbol">)</a> <a id="3005" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="3007" href="Algebra.Group.Homotopy.BAut.html#2969" class="Bound">p</a>
  <a id="3011" href="Algebra.Group.Homotopy.BAut.html#2948" data-type="(T : Type ℓ) (b : BAut T) (p : Code T b) →
encode T b (decode T b p) ≡ p" class="Function">encode∘decode</a> <a id="3025" href="Algebra.Group.Homotopy.BAut.html#3025" class="Bound">b</a> <a id="3027" href="Algebra.Group.Homotopy.BAut.html#3027" class="Bound">p</a> <a id="3029" class="Symbol">=</a> <a id="3031" href="1Lab.Equiv.html#6548" data-type="(eqv : is-equiv f) (x : B₁) → f (equiv→inverse eqv x) ≡ x" class="Function">equiv→counit</a> <a id="3044" href="1Lab.Univalence.html#17023" data-type="is-equiv path→equiv" class="Function">univalence</a> <a id="3055" class="Symbol">_</a>
</pre>
<p>We now have the core result: Specialising
<span class="Agda"><a href="Algebra.Group.Homotopy.BAut.html#1854" class="Function">encode</a></span>
and
<span class="Agda"><a href="Algebra.Group.Homotopy.BAut.html#1927" class="Function">decode</a></span>
to the <code class="sourceCode agda">basepoint</code>, we conclude that
loop space
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">b</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">e</mi></mrow><mo>≡</mo><mrow><mi mathvariant="normal">b</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">e</mi></mrow></mrow><annotation encoding="application/x-tex">\id{base} \equiv \id{base}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">base</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">base</span></span></span></span></span>
is equivalent to
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">S</mi><mi mathvariant="normal">y</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\id{Sym}(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">Sym</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span>.</span></p>
<pre class="Agda">  <a id="3267" href="Algebra.Group.Homotopy.BAut.html#3267" data-type="(T : Type ℓ) → (base T ≡ base T) ≃ (T ≃ T)" class="Function">Ω¹BAut</a> <a id="3274" class="Symbol">:</a> <a id="3276" class="Symbol">(</a><a id="3277" href="Algebra.Group.Homotopy.BAut.html#930" data-type="(T : Type ℓ) → BAut T" class="Function">base</a> <a id="3282" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="3284" href="Algebra.Group.Homotopy.BAut.html#930" data-type="(T : Type ℓ) → BAut T" class="Function">base</a><a id="3288" class="Symbol">)</a> <a id="3290" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="3292" class="Symbol">(</a><a id="3293" href="Algebra.Group.Homotopy.BAut.html#851" class="Bound">T</a> <a id="3295" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="3297" href="Algebra.Group.Homotopy.BAut.html#851" class="Bound">T</a><a id="3298" class="Symbol">)</a>
  <a id="3302" href="Algebra.Group.Homotopy.BAut.html#3267" data-type="(T : Type ℓ) → (base T ≡ base T) ≃ (T ≃ T)" class="Function">Ω¹BAut</a> <a id="3309" class="Symbol">=</a> <a id="3311" href="1Lab.Equiv.html#20503" data-type="Iso A B₁ → A ≃ B₁" class="Function">Iso→Equiv</a>
    <a id="3325" class="Symbol">(</a><a id="3326" href="Algebra.Group.Homotopy.BAut.html#1854" data-type="(T : Type ℓ) (b : ∑ (Type ℓ) (λ B₁ → ∥ T ≃ B₁ ∥)) →
base T ≡ b → Code T b" class="Function">encode</a> <a id="3333" href="Algebra.Group.Homotopy.BAut.html#930" data-type="(T : Type ℓ) → BAut T" class="Function">base</a> <a id="3338" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="3340" href="1Lab.Equiv.html#6116" data-type="(inv₁ : B₁ → A) (rinv₁ : is-right-inverse inv₁ f)
(linv₁ : is-left-inverse inv₁ f) →
is-iso f" class="InductiveConstructor">iso</a> <a id="3344" class="Symbol">(</a><a id="3345" href="Algebra.Group.Homotopy.BAut.html#1927" data-type="(T : Type ℓ) (b : BAut T) → Code T b → base T ≡ b" class="Function">decode</a> <a id="3352" href="Algebra.Group.Homotopy.BAut.html#930" data-type="(T : Type ℓ) → BAut T" class="Function">base</a><a id="3356" class="Symbol">)</a> <a id="3358" class="Symbol">(</a><a id="3359" href="Algebra.Group.Homotopy.BAut.html#2948" data-type="(T : Type ℓ) (b : BAut T) (p : Code T b) →
encode T b (decode T b p) ≡ p" class="Function">encode∘decode</a> <a id="3373" href="Algebra.Group.Homotopy.BAut.html#930" data-type="(T : Type ℓ) → BAut T" class="Function">base</a><a id="3377" class="Symbol">)</a> <a id="3379" class="Symbol">(</a><a id="3380" href="Algebra.Group.Homotopy.BAut.html#2560" data-type="(T : Type ℓ) (b : ∑ (Type ℓ) (λ B₁ → ∥ T ≃ B₁ ∥))
(p : base T ≡ b) →
decode T b (encode T b p) ≡ p" class="Function">decode∘encode</a> <a id="3394" href="Algebra.Group.Homotopy.BAut.html#930" data-type="(T : Type ℓ) → BAut T" class="Function">base</a><a id="3398" class="Symbol">))</a>
</pre>
<p>We can also characterise the h-level of these connected components.
Intuitively the h-level should be one more than that of the type we’re
delooping, because
<span class="Agda"><a href="Algebra.Group.Homotopy.BAut.html#871" class="Function">BAut</a></span>
“only has one point” (it’s connected), and as we established right
above, the space of loops of that point is the automorphism group we
delooped. The trouble here is that
<span class="Agda"><a href="Algebra.Group.Homotopy.BAut.html#871" class="Function">BAut</a></span>
has many points, and while we can pick paths between any two of them, we
can not do so <em>continuously</em> (otherwise
<span class="Agda"><a href="Algebra.Group.Homotopy.BAut.html#871" class="Function">BAut</a></span>
would be a proposition).</p>
<p>This turns out not to matter! Since “being of h-level
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>”
is a proposition, our discontinuous (i.e.: truncated) method of picking
paths is just excellent. In the case when
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>
is contractible, we can directly get at the underlying equivalences, but
for the higher h-levels, we proceed exactly by using connectedness.</p>
<pre class="Agda">  <a id="4245" href="Algebra.Group.Homotopy.BAut.html#4245" data-type="(T : Type ℓ) (n : Nat) → is-hlevel T n → is-hlevel (BAut T) (1 + n)" class="Function">BAut-is-hlevel</a> <a id="4260" class="Symbol">:</a> <a id="4262" class="Symbol">∀</a> <a id="4264" href="Algebra.Group.Homotopy.BAut.html#4264" class="Bound">n</a> <a id="4266" class="Symbol">→</a> <a id="4268" href="1Lab.HLevel.html#2813" data-type="Type ℓ → Nat → Type ℓ" class="Function">is-hlevel</a> <a id="4278" href="Algebra.Group.Homotopy.BAut.html#851" class="Bound">T</a> <a id="4280" href="Algebra.Group.Homotopy.BAut.html#4264" class="Bound">n</a> <a id="4282" class="Symbol">→</a> <a id="4284" href="1Lab.HLevel.html#2813" data-type="Type ℓ → Nat → Type ℓ" class="Function">is-hlevel</a> <a id="4294" href="Algebra.Group.Homotopy.BAut.html#871" data-type="Type ℓ → Type (lsuc ℓ)" class="Function">BAut</a> <a id="4299" class="Symbol">(</a><a id="4300" class="Number">1</a> <a id="4302" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="4304" href="Algebra.Group.Homotopy.BAut.html#4264" class="Bound">n</a><a id="4305" class="Symbol">)</a>
  <a id="4309" href="Algebra.Group.Homotopy.BAut.html#4245" data-type="(T : Type ℓ) (n : Nat) → is-hlevel T n → is-hlevel (BAut T) (1 + n)" class="Function">BAut-is-hlevel</a> <a id="4324" href="Agda.Builtin.Nat.html#195" data-type="Nat" class="InductiveConstructor">zero</a> <a id="4329" href="Algebra.Group.Homotopy.BAut.html#4329" class="Bound">hl</a> <a id="4332" class="Symbol">(</a><a id="4333" href="Algebra.Group.Homotopy.BAut.html#4333" class="Bound">x</a> <a id="4335" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="4337" href="Algebra.Group.Homotopy.BAut.html#4337" class="Bound">f</a><a id="4338" class="Symbol">)</a> <a id="4340" class="Symbol">(</a><a id="4341" href="Algebra.Group.Homotopy.BAut.html#4341" class="Bound">y</a> <a id="4343" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="4345" href="Algebra.Group.Homotopy.BAut.html#4345" class="Bound">g</a><a id="4346" class="Symbol">)</a> <a id="4348" class="Symbol">=</a>
    <a id="4354" href="1Lab.Type.Sigma.html#5139" data-type="((x : A) → is-prop (B₁ x)) → x .fst ≡ y .fst → x ≡ y" class="Function">Σ-prop-path</a> <a id="4366" class="Symbol">(λ</a> <a id="4369" href="Algebra.Group.Homotopy.BAut.html#4369" class="Bound">_</a> <a id="4371" class="Symbol">→</a> <a id="4373" href="1Lab.HIT.Truncation.html#795" data-type="is-prop ∥ A ∥" class="InductiveConstructor">squash</a><a id="4379" class="Symbol">)</a> <a id="4381" class="Symbol">(</a><a id="4382" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="4386" class="Symbol">(</a><a id="4387" href="1Lab.Univalence.html#9069" data-type="A ≃ B₁ → A ≡ B₁" class="Function">ua</a> <a id="4390" href="Algebra.Group.Homotopy.BAut.html#4688" data-type="(T : Type ℓ) (hl : is-hlevel T zero) (x : Type ℓ) (f : ∥ T ≃ x ∥)
(y : Type ℓ) (g : ∥ T ≃ y ∥) →
T ≃ x" class="Function">f′</a><a id="4392" class="Symbol">)</a> <a id="4394" href="1Lab.Path.html#39460" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="4396" href="1Lab.Univalence.html#9069" data-type="A ≃ B₁ → A ≡ B₁" class="Function">ua</a> <a id="4399" href="Algebra.Group.Homotopy.BAut.html#4727" data-type="(T : Type ℓ) (hl : is-hlevel T zero) (x : Type ℓ) (f : ∥ T ≃ x ∥)
(y : Type ℓ) (g : ∥ T ≃ y ∥) →
T ≃ y" class="Function">g′</a><a id="4401" class="Symbol">)</a>
    <a id="4407" class="Keyword">where</a>
      <a id="4419" href="Algebra.Group.Homotopy.BAut.html#4419" data-type="(T : Type ℓ) (hl : is-hlevel T zero) (x : Type ℓ) (f : ∥ T ≃ x ∥)
(y : Type ℓ) (g : ∥ T ≃ y ∥) →
is-prop (T ≃ X)" class="Function">extract</a> <a id="4427" class="Symbol">:</a> <a id="4429" class="Symbol">∀</a> <a id="4431" class="Symbol">{</a><a id="4432" href="Algebra.Group.Homotopy.BAut.html#4432" class="Bound">X</a><a id="4433" class="Symbol">}</a> <a id="4435" class="Symbol">→</a> <a id="4437" href="1Lab.HLevel.html#2597" data-type="Type ℓ → Type ℓ" class="Function">is-prop</a> <a id="4445" class="Symbol">(</a><a id="4446" href="Algebra.Group.Homotopy.BAut.html#851" class="Bound">T</a> <a id="4448" href="1Lab.Equiv.html#2439" data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" class="Function Operator">≃</a> <a id="4450" href="Algebra.Group.Homotopy.BAut.html#4432" class="Bound">X</a><a id="4451" class="Symbol">)</a>
      <a id="4459" href="Algebra.Group.Homotopy.BAut.html#4419" data-type="(T : Type ℓ) (hl : is-hlevel T zero) (x : Type ℓ) (f : ∥ T ≃ x ∥)
(y : Type ℓ) (g : ∥ T ≃ y ∥) →
is-prop (T ≃ X)" class="Function">extract</a> <a id="4467" href="Algebra.Group.Homotopy.BAut.html#4467" class="Bound">f</a> <a id="4469" href="Algebra.Group.Homotopy.BAut.html#4469" class="Bound">g</a> <a id="4471" class="Symbol">=</a> <a id="4473" href="1Lab.Type.Sigma.html#5139" data-type="((x : A) → is-prop (B₁ x)) → x .fst ≡ y .fst → x ≡ y" class="Function">Σ-prop-path</a> <a id="4485" href="1Lab.Equiv.html#4916" data-type="(f : A → B₁) → is-prop (is-equiv f)" class="Function">is-equiv-is-prop</a> <a id="4502" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="4504" href="1Lab.Path.html#58474" data-type="((x : A) → f x ≡ g x) → f ≡ g" class="Function">funext</a> <a id="4511" class="Symbol">λ</a> <a id="4513" href="Algebra.Group.Homotopy.BAut.html#4513" class="Bound">x</a> <a id="4515" class="Symbol">→</a>
        <a id="4525" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="4528" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="4532" class="Symbol">(</a><a id="4533" href="1Lab.HLevel.html#3818" data-type="is-contr A → is-prop A" class="Function">is-contr→is-prop</a> <a id="4550" class="Symbol">((</a><a id="4552" href="Algebra.Group.Homotopy.BAut.html#4467" class="Bound">f</a> <a id="4554" href="1Lab.Equiv.html#21697" data-type="A ≃ B₁ → B₁ ≃ A" class="Function Operator">e⁻¹</a><a id="4557" class="Symbol">)</a> <a id="4559" class="Symbol">.</a><a id="4560" href="Agda.Builtin.Sigma.html#237" data-type="(r : ∑ A B₁) → B₁ (fst r)" class="Field">snd</a> <a id="4564" class="Symbol">.</a><a id="4565" href="1Lab.Equiv.html#2376" data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" class="Field">is-eqv</a> <a id="4572" class="Symbol">(</a><a id="4573" href="Algebra.Group.Homotopy.BAut.html#4329" class="Bound">hl</a> <a id="4576" class="Symbol">.</a><a id="4577" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a><a id="4583" class="Symbol">))</a>
          <a id="4596" class="Symbol">(</a><a id="4597" href="Algebra.Group.Homotopy.BAut.html#4467" class="Bound">f</a> <a id="4599" class="Symbol">.</a><a id="4600" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="4604" href="Algebra.Group.Homotopy.BAut.html#4513" class="Bound">x</a> <a id="4606" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="4608" href="1Lab.HLevel.html#3818" data-type="is-contr A → is-prop A" class="Function">is-contr→is-prop</a> <a id="4625" href="Algebra.Group.Homotopy.BAut.html#4329" class="Bound">hl</a> <a id="4628" class="Symbol">_</a> <a id="4630" class="Symbol">_)</a>
          <a id="4643" class="Symbol">(</a><a id="4644" href="Algebra.Group.Homotopy.BAut.html#4469" class="Bound">g</a> <a id="4646" class="Symbol">.</a><a id="4647" href="Agda.Builtin.Sigma.html#225" data-type="∑ A B₁ → A" class="Field">fst</a> <a id="4651" href="Algebra.Group.Homotopy.BAut.html#4513" class="Bound">x</a> <a id="4653" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="4655" href="1Lab.HLevel.html#3818" data-type="is-contr A → is-prop A" class="Function">is-contr→is-prop</a> <a id="4672" href="Algebra.Group.Homotopy.BAut.html#4329" class="Bound">hl</a> <a id="4675" class="Symbol">_</a> <a id="4677" class="Symbol">_))</a>

      <a id="4688" href="Algebra.Group.Homotopy.BAut.html#4688" data-type="(T : Type ℓ) (hl : is-hlevel T zero) (x : Type ℓ) (f : ∥ T ≃ x ∥)
(y : Type ℓ) (g : ∥ T ≃ y ∥) →
T ≃ x" class="Function">f′</a> <a id="4691" class="Symbol">=</a> <a id="4693" href="1Lab.HIT.Truncation.html#2416" data-type="is-prop P → (A → P) → ∥ A ∥ → P" class="Function">∥-∥-rec</a> <a id="4701" href="Algebra.Group.Homotopy.BAut.html#4419" data-type="(T : Type ℓ) (hl : is-hlevel T zero) (x : Type ℓ) (f : ∥ T ≃ x ∥)
(y : Type ℓ) (g : ∥ T ≃ y ∥) →
is-prop (T ≃ X)" class="Function">extract</a> <a id="4709" class="Symbol">(λ</a> <a id="4712" href="Algebra.Group.Homotopy.BAut.html#4712" class="Bound">x</a> <a id="4714" class="Symbol">→</a> <a id="4716" href="Algebra.Group.Homotopy.BAut.html#4712" class="Bound">x</a><a id="4717" class="Symbol">)</a> <a id="4719" href="Algebra.Group.Homotopy.BAut.html#4337" class="Bound">f</a>
      <a id="4727" href="Algebra.Group.Homotopy.BAut.html#4727" data-type="(T : Type ℓ) (hl : is-hlevel T zero) (x : Type ℓ) (f : ∥ T ≃ x ∥)
(y : Type ℓ) (g : ∥ T ≃ y ∥) →
T ≃ y" class="Function">g′</a> <a id="4730" class="Symbol">=</a> <a id="4732" href="1Lab.HIT.Truncation.html#2416" data-type="is-prop P → (A → P) → ∥ A ∥ → P" class="Function">∥-∥-rec</a> <a id="4740" href="Algebra.Group.Homotopy.BAut.html#4419" data-type="(T : Type ℓ) (hl : is-hlevel T zero) (x : Type ℓ) (f : ∥ T ≃ x ∥)
(y : Type ℓ) (g : ∥ T ≃ y ∥) →
is-prop (T ≃ X)" class="Function">extract</a> <a id="4748" class="Symbol">(λ</a> <a id="4751" href="Algebra.Group.Homotopy.BAut.html#4751" class="Bound">x</a> <a id="4753" class="Symbol">→</a> <a id="4755" href="Algebra.Group.Homotopy.BAut.html#4751" class="Bound">x</a><a id="4756" class="Symbol">)</a> <a id="4758" href="Algebra.Group.Homotopy.BAut.html#4345" class="Bound">g</a>
  <a id="4762" href="Algebra.Group.Homotopy.BAut.html#4245" data-type="(T : Type ℓ) (n : Nat) → is-hlevel T n → is-hlevel (BAut T) (1 + n)" class="Function">BAut-is-hlevel</a> <a id="4777" class="Symbol">(</a><a id="4778" href="Agda.Builtin.Nat.html#208" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="4782" href="Algebra.Group.Homotopy.BAut.html#4782" class="Bound">n</a><a id="4783" class="Symbol">)</a> <a id="4785" href="Algebra.Group.Homotopy.BAut.html#4785" class="Bound">hl</a> <a id="4788" href="Algebra.Group.Homotopy.BAut.html#4788" class="Bound">x</a> <a id="4790" href="Algebra.Group.Homotopy.BAut.html#4790" class="Bound">y</a> <a id="4792" class="Symbol">=</a>
    <a id="4798" href="1Lab.HIT.Truncation.html#1852" data-type="((x : ∥ A ∥) (y : ∥ B₁ ∥) → is-prop (P x y)) →
((x : A) (y : B₁) → P (inc x) (inc y)) →
(x : ∥ A ∥) (y : ∥ B₁ ∥) → P x y" class="Function">∥-∥-elim₂</a> <a id="4808" class="Symbol">{</a><a id="4809" class="Argument">P</a> <a id="4811" class="Symbol">=</a> <a id="4813" class="Symbol">λ</a> <a id="4815" href="Algebra.Group.Homotopy.BAut.html#4815" class="Bound">_</a> <a id="4817" href="Algebra.Group.Homotopy.BAut.html#4817" class="Bound">_</a> <a id="4819" class="Symbol">→</a> <a id="4821" href="1Lab.HLevel.html#2813" data-type="Type ℓ → Nat → Type ℓ" class="Function">is-hlevel</a> <a id="4831" class="Symbol">(</a><a id="4832" href="Algebra.Group.Homotopy.BAut.html#4788" class="Bound">x</a> <a id="4834" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="4836" href="Algebra.Group.Homotopy.BAut.html#4790" class="Bound">y</a><a id="4837" class="Symbol">)</a> <a id="4839" class="Symbol">(</a><a id="4840" class="Number">1</a> <a id="4842" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="4844" href="Algebra.Group.Homotopy.BAut.html#4782" class="Bound">n</a><a id="4845" class="Symbol">)}</a>
      <a id="4854" class="Symbol">(λ</a> <a id="4857" href="Algebra.Group.Homotopy.BAut.html#4857" class="Bound">_</a> <a id="4859" href="Algebra.Group.Homotopy.BAut.html#4859" class="Bound">_</a> <a id="4861" class="Symbol">→</a> <a id="4863" href="1Lab.HLevel.html#12473" data-type="(n : Nat) → is-prop (is-hlevel A n)" class="Function">is-hlevel-is-prop</a> <a id="4881" class="Symbol">_)</a>
      <a id="4890" class="Symbol">(λ</a> <a id="4893" href="Algebra.Group.Homotopy.BAut.html#4893" class="Bound">p</a> <a id="4895" href="Algebra.Group.Homotopy.BAut.html#4895" class="Bound">q</a> <a id="4897" class="Symbol">→</a> <a id="4899" href="1Lab.Path.html#11776" data-type="A ≡ B₁ → A → B₁" class="Function">transport</a> <a id="4909" class="Symbol">(</a><a id="4910" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="4914" class="Symbol">(λ</a> <a id="4917" href="Algebra.Group.Homotopy.BAut.html#4917" class="Bound">a</a> <a id="4919" href="Algebra.Group.Homotopy.BAut.html#4919" class="Bound">b</a> <a id="4921" class="Symbol">→</a> <a id="4923" href="1Lab.HLevel.html#2813" data-type="Type ℓ → Nat → Type ℓ" class="Function">is-hlevel</a> <a id="4933" class="Symbol">(</a><a id="4934" href="Algebra.Group.Homotopy.BAut.html#4917" class="Bound">a</a> <a id="4936" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="4938" href="Algebra.Group.Homotopy.BAut.html#4919" class="Bound">b</a><a id="4939" class="Symbol">)</a> <a id="4941" class="Symbol">(</a><a id="4942" class="Number">1</a> <a id="4944" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="4946" href="Algebra.Group.Homotopy.BAut.html#4782" class="Bound">n</a><a id="4947" class="Symbol">))</a> <a id="4950" class="Symbol">(</a><a id="4951" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="4955" href="Algebra.Group.Homotopy.BAut.html#4893" class="Bound">p</a><a id="4956" class="Symbol">)</a> <a id="4958" class="Symbol">(</a><a id="4959" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="4963" href="Algebra.Group.Homotopy.BAut.html#4895" class="Bound">q</a><a id="4964" class="Symbol">))</a>
        <a id="4975" class="Symbol">(</a><a id="4976" href="1Lab.HLevel.Retracts.html#4220" data-type="(n : Nat) → A ≃ B₁ → is-hlevel A n → is-hlevel B₁ n" class="Function">is-hlevel≃</a> <a id="4987" class="Symbol">(</a><a id="4988" class="Number">1</a> <a id="4990" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="4992" href="Algebra.Group.Homotopy.BAut.html#4782" class="Bound">n</a><a id="4993" class="Symbol">)</a> <a id="4995" class="Symbol">(</a><a id="4996" href="Algebra.Group.Homotopy.BAut.html#3267" data-type="(T : Type ℓ) → (base T ≡ base T) ≃ (T ≃ T)" class="Function">Ω¹BAut</a> <a id="5003" href="1Lab.Equiv.html#21697" data-type="A ≃ B₁ → B₁ ≃ A" class="Function Operator">e⁻¹</a><a id="5006" class="Symbol">)</a> <a id="5008" class="Symbol">(</a><a id="5009" href="1Lab.HLevel.Universe.html#1312" data-type="(n : Nat) → is-hlevel A n → is-hlevel B₁ n → is-hlevel (A ≃ B₁) n" class="Function">≃-is-hlevel</a> <a id="5021" class="Symbol">(</a><a id="5022" class="Number">1</a> <a id="5024" href="Agda.Builtin.Nat.html#310" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="5026" href="Algebra.Group.Homotopy.BAut.html#4782" class="Bound">n</a><a id="5027" class="Symbol">)</a> <a id="5029" href="Algebra.Group.Homotopy.BAut.html#4785" class="Bound">hl</a> <a id="5032" href="Algebra.Group.Homotopy.BAut.html#4785" class="Bound">hl</a><a id="5034" class="Symbol">)))</a>
      <a id="5044" class="Symbol">(</a><a id="5045" href="Algebra.Group.Homotopy.BAut.html#1195" data-type="(T : Type ℓ) (b : ∑ (Type ℓ) (λ B₁ → ∥ T ≃ B₁ ∥)) → ∥ b ≡ base T ∥" class="Function">connected</a> <a id="5055" href="Algebra.Group.Homotopy.BAut.html#4788" class="Bound">x</a><a id="5056" class="Symbol">)</a> <a id="5058" class="Symbol">(</a><a id="5059" href="Algebra.Group.Homotopy.BAut.html#1195" data-type="(T : Type ℓ) (b : ∑ (Type ℓ) (λ B₁ → ∥ T ≃ B₁ ∥)) → ∥ b ≡ base T ∥" class="Function">connected</a> <a id="5069" href="Algebra.Group.Homotopy.BAut.html#4790" class="Bound">y</a><a id="5070" class="Symbol">)</a>
</pre>
  </article>
</div>
</main>
</body>
<style>.equations { display: none !important; }</style></html>
