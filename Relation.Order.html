<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="keywords" content="Agda,categories,topos" />

  <title>Relation.Order - 1Lab</title>

  <link rel="stylesheet" href="/css/default.css" />
  <link rel="stylesheet" href="/css/katex.min.css" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Relation.Order - 1Lab" />
  <meta name="twitter:image" content="https://1lab.dev/static/cube-128x.png" />

  <meta name="og:title" content="Relation.Order - 1Lab" />
  <meta name="og:image" content="https://1lab.dev/static/cube-128x.png" />
  <meta name="og:site-name" content="1Lab" />
  <meta name="og:type" content="website" />

    <meta name="og:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="twitter:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  
  <script defer src="/main.js"></script>

  <noscript>
    <style>
      body span.reasoning-step .as-written {
        display: inline;
      }

      body span.reasoning-step .alternate {
        display: none;
      }
    </style>
  </noscript>

  <!-- Google font embeds -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;0,800;1,400;1,500;1,600;1,700;1,800&amp;family=Inria+Sans:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&amp;display=swap" rel="stylesheet">
</head>

<body class="text-page">
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <!-- Table of contents (only if the page has a table of contents) -->
    <aside id="toc">
    <div id="toc-container" style="min-width: 10em; font-size: 15pt;">
      <!-- Title for the page -->
      <h3 class="Agda" style="margin-top: 0; margin-bottom: 0; white-space: pre;">
                <a class="Module">Relation.Order</a>
              </h3>

      <!-- Cube logo -->
      <a id="logo" href="/">
        <img alt="1Lab" src="/static/cube-72x.png" style="display: block; margin-bottom: 1em; margin: auto;" width="32px" height="32px" />
      </a>

      <!-- Actual table of contents (separated from the rest by
      horizontal rules) -->
      <hr />
      <ul>
      <li><a href="#order-relations"><a href="#order-relations" class="header-link">Order
      relations<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#partial-orders"><a href="#partial-orders" class="header-link">Partial
      Orders<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#trichotomous-orders"><a href="#trichotomous-orders" class="header-link">Trichotomous
      orders<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      </ul>
      <hr />

      <!-- Sidebar controls -->
      <div style="display: flex; gap: 0.25em; flex-flow: row wrap;">
        <!-- Sidebar equations control -->
        <span class="equations" style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-eqns" type="checkbox" class="equations" id="sidebar-eqns">
          <label for="sidebar-eqns">Equations</label>
        </span>

        <!-- Sidebar fonts control -->
        <span style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-font" type="checkbox" id="toggle-fonts">
          <label for="toggle-fonts">Serif Font</label>
        </span>

        <!-- Sidebar footnotes control -->
        <span class="inline-footnotes" style="display: none; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-fns" type="checkbox" class="inline-footnotes" id="sidebar-fns">
          <label for="sidebar-fns">Inline Footnotes</label>
        </span>
      </div>

      <hr />

      <!-- Navbar navigation (lol) -->
      <div id="return" style="white-space: nowrap;">
        <div class="search-form search-form-proxy" role="form">
          <input id="search-box-proxy" type_="text" placeholder="Search..." autocomplete="off" tabindex="0"></input>
        </div>

              <a href="/">back to index</a> <br />
              <a href="all-pages.html">view all pages</a> <br />
        <a href="https://github.com/plt-amy/cubical-1lab/blob/704956a7ffb07e5a5193134a2f74949f3338d39f/src/Relation/Order.lagda.md">link to source</a> <br />
                <hr /> <div class="author-list">Written by Amélia Liao and uni</div> <br />
              </div>
    </div>
  </aside>
  
  <article>
    <!-- Article navigation (narrow screens only) -->
    <div class="narrow-only" id="article-nav">
      <!-- Index return anchor (only if the page is not the index) -->
            <div id="return">
        <a href="/">back to index</a>
      </div>
      
      <!-- Navbar equations control -->
      <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-eqns" type="checkbox" class="equations" id="navbar-eqns">
        <label for="navbar-eqns">Equations</label>
      </span>

      <!-- Navbar footnotes control -->
      <span class="inline-footnotes" style="display: none; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-fns" type="checkbox" class="inline-footnotes" id="navbar-fns">
        <label for="navbar-fns">Inline Footnotes</label>
      </span>
    </div>

<pre class="Agda"><a id="9" class="Keyword">open</a> <a id="14" class="Keyword">import</a> <a id="21" href="1Lab.HLevel.Sets.html" class="Module">1Lab.HLevel.Sets</a>
<a id="38" class="Keyword">open</a> <a id="43" class="Keyword">import</a> <a id="50" href="1Lab.Type.Dec.html" class="Module">1Lab.Type.Dec</a>
<a id="64" class="Keyword">open</a> <a id="69" class="Keyword">import</a> <a id="76" href="1Lab.HLevel.html" class="Module">1Lab.HLevel</a>
<a id="88" class="Keyword">open</a> <a id="93" class="Keyword">import</a> <a id="100" href="1Lab.Path.html" class="Module">1Lab.Path</a>
<a id="110" class="Keyword">open</a> <a id="115" class="Keyword">import</a> <a id="122" href="1Lab.Type.html" class="Module">1Lab.Type</a>

<a id="133" class="Keyword">module</a> <a id="140" href="Relation.Order.html" class="Module">Relation.Order</a> <a id="155" class="Keyword">where</a>
</pre>
<h1 id="order-relations"><a href="#order-relations" class="header-link">Order
relations<span class="header-link-emoji">🔗</span></a></h1>
<p>This module characterises different types of binary relations, and,
in particular, ordering relations.</p>
<!--
<pre class="Agda"><a id="298" class="Keyword">private</a> <a id="306" class="Keyword">variable</a>
  <a id="317" href="Relation.Order.html#317" class="Generalizable">ℓ</a> <a id="319" href="Relation.Order.html#319" class="Generalizable">ℓ&#39;</a> <a id="322" class="Symbol">:</a> <a id="324" href="Agda.Primitive.html#582" data-type="Type" class="Postulate">Level</a>
  <a id="332" href="Relation.Order.html#332" class="Generalizable">A</a> <a id="334" class="Symbol">:</a> <a id="336" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="341" href="Relation.Order.html#317" class="Generalizable">ℓ</a>
  <a id="345" href="Relation.Order.html#345" class="Generalizable">R</a> <a id="347" class="Symbol">:</a> <a id="349" href="Relation.Order.html#332" class="Generalizable">A</a> <a id="351" class="Symbol">→</a> <a id="353" href="Relation.Order.html#332" class="Generalizable">A</a> <a id="355" class="Symbol">→</a> <a id="357" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="362" href="Relation.Order.html#319" class="Generalizable">ℓ&#39;</a>
</pre>-->
<p>A relation is <em>reflexive</em> if we have <code>R x x</code>, for
any <code>x</code>:</p>
<pre class="Agda"><a id="is-reflexive"></a><a id="442" href="Relation.Order.html#442" data-type="(R₁ : A → A → Type ℓ) → Type (A.ℓ ⊔ ℓ)" class="Function">is-reflexive</a> <a id="455" class="Symbol">:</a> <a id="457" class="Symbol">(</a><a id="458" href="Relation.Order.html#458" class="Bound">R</a> <a id="460" class="Symbol">:</a> <a id="462" href="Relation.Order.html#332" class="Generalizable">A</a> <a id="464" class="Symbol">→</a> <a id="466" href="Relation.Order.html#332" class="Generalizable">A</a> <a id="468" class="Symbol">→</a> <a id="470" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="475" href="Relation.Order.html#317" class="Generalizable">ℓ</a><a id="476" class="Symbol">)</a> <a id="478" class="Symbol">→</a> <a id="480" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="485" class="Symbol">_</a>
<a id="487" href="Relation.Order.html#442" data-type="(R₁ : A → A → Type ℓ) → Type (A.ℓ ⊔ ℓ)" class="Function">is-reflexive</a> <a id="500" href="Relation.Order.html#500" class="Bound">R</a> <a id="502" class="Symbol">=</a> <a id="504" class="Symbol">{</a><a id="505" href="Relation.Order.html#505" class="Bound">x</a> <a id="507" class="Symbol">:</a> <a id="509" class="Symbol">_}</a> <a id="512" class="Symbol">→</a> <a id="514" href="Relation.Order.html#500" class="Bound">R</a> <a id="516" href="Relation.Order.html#505" class="Bound">x</a> <a id="518" href="Relation.Order.html#505" class="Bound">x</a>
</pre>
<p>A relation is <em>transitive</em> if <code>R x y</code> and
<code>R y z</code> implies <code>R x z</code>.</p>
<pre class="Agda"><a id="is-transitive"></a><a id="601" href="Relation.Order.html#601" data-type="(R₁ : A → A → Type ℓ) → Type (A.ℓ ⊔ ℓ)" class="Function">is-transitive</a> <a id="615" class="Symbol">:</a> <a id="617" class="Symbol">(</a><a id="618" href="Relation.Order.html#618" class="Bound">R</a> <a id="620" class="Symbol">:</a> <a id="622" href="Relation.Order.html#332" class="Generalizable">A</a> <a id="624" class="Symbol">→</a> <a id="626" href="Relation.Order.html#332" class="Generalizable">A</a> <a id="628" class="Symbol">→</a> <a id="630" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="635" href="Relation.Order.html#317" class="Generalizable">ℓ</a><a id="636" class="Symbol">)</a> <a id="638" class="Symbol">→</a> <a id="640" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="645" class="Symbol">_</a>
<a id="647" href="Relation.Order.html#601" data-type="(R₁ : A → A → Type ℓ) → Type (A.ℓ ⊔ ℓ)" class="Function">is-transitive</a> <a id="661" href="Relation.Order.html#661" class="Bound">R</a> <a id="663" class="Symbol">=</a> <a id="665" class="Symbol">{</a><a id="666" href="Relation.Order.html#666" class="Bound">x</a> <a id="668" href="Relation.Order.html#668" class="Bound">y</a> <a id="670" href="Relation.Order.html#670" class="Bound">z</a> <a id="672" class="Symbol">:</a> <a id="674" class="Symbol">_}</a> <a id="677" class="Symbol">→</a> <a id="679" href="Relation.Order.html#661" class="Bound">R</a> <a id="681" href="Relation.Order.html#666" class="Bound">x</a> <a id="683" href="Relation.Order.html#668" class="Bound">y</a> <a id="685" class="Symbol">→</a> <a id="687" href="Relation.Order.html#661" class="Bound">R</a> <a id="689" href="Relation.Order.html#668" class="Bound">y</a> <a id="691" href="Relation.Order.html#670" class="Bound">z</a> <a id="693" class="Symbol">→</a> <a id="695" href="Relation.Order.html#661" class="Bound">R</a> <a id="697" href="Relation.Order.html#666" class="Bound">x</a> <a id="699" href="Relation.Order.html#670" class="Bound">z</a>
</pre>
<p>A <strong>preorder</strong> is a reflexive, transitive relation.
Furthermore, we impose that a preorder take value in propositions.</p>
<pre class="Agda"><a id="834" class="Keyword">record</a> <a id="is-preorder"></a><a id="841" href="Relation.Order.html#841" data-type="(R₁ : A → A → Type ℓ&#39;) → Type (ℓ ⊔ ℓ&#39;)" class="Record">is-preorder</a> <a id="853" class="Symbol">{</a><a id="854" href="Relation.Order.html#854" class="Bound">A</a> <a id="856" class="Symbol">:</a> <a id="858" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="863" href="Relation.Order.html#317" class="Generalizable">ℓ</a><a id="864" class="Symbol">}</a> <a id="866" class="Symbol">(</a><a id="867" href="Relation.Order.html#867" class="Bound">R</a> <a id="869" class="Symbol">:</a> <a id="871" href="Relation.Order.html#854" class="Bound">A</a> <a id="873" class="Symbol">→</a> <a id="875" href="Relation.Order.html#854" class="Bound">A</a> <a id="877" class="Symbol">→</a> <a id="879" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="884" href="Relation.Order.html#319" class="Generalizable">ℓ&#39;</a><a id="886" class="Symbol">)</a> <a id="888" class="Symbol">:</a> <a id="890" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="895" class="Symbol">(</a><a id="896" href="Relation.Order.html#863" class="Bound">ℓ</a> <a id="898" href="Agda.Primitive.html#795" data-type="Level → Level → Level" class="Primitive Operator">⊔</a> <a id="900" href="Relation.Order.html#884" class="Bound">ℓ&#39;</a><a id="902" class="Symbol">)</a> <a id="904" class="Keyword">where</a>
  <a id="912" class="Keyword">field</a>
    <a id="is-preorder.reflexive"></a><a id="922" href="Relation.Order.html#922" data-type="is-preorder R₁ → is-reflexive R₁" class="Field">reflexive</a>     <a id="936" class="Symbol">:</a> <a id="938" href="Relation.Order.html#442" data-type="(R₁ : A → A → Type ℓ) → Type (A.ℓ ⊔ ℓ)" class="Function">is-reflexive</a> <a id="951" href="Relation.Order.html#867" class="Bound">R</a>
    <a id="is-preorder.transitive"></a><a id="957" href="Relation.Order.html#957" data-type="is-preorder R₁ → is-transitive R₁" class="Field">transitive</a>    <a id="971" class="Symbol">:</a> <a id="973" href="Relation.Order.html#601" data-type="(R₁ : A → A → Type ℓ) → Type (A.ℓ ⊔ ℓ)" class="Function">is-transitive</a> <a id="987" href="Relation.Order.html#867" class="Bound">R</a>
    <a id="is-preorder.propositional"></a><a id="993" href="Relation.Order.html#993" data-type="is-preorder R₁ → is-prop (R₁ x y)" class="Field">propositional</a> <a id="1007" class="Symbol">:</a> <a id="1009" class="Symbol">{</a><a id="1010" href="Relation.Order.html#1010" class="Bound">x</a> <a id="1012" href="Relation.Order.html#1012" class="Bound">y</a> <a id="1014" class="Symbol">:</a> <a id="1016" href="Relation.Order.html#854" class="Bound">A</a><a id="1017" class="Symbol">}</a> <a id="1019" class="Symbol">→</a> <a id="1021" href="1Lab.HLevel.html#2597" data-type="Type ℓ → Type ℓ" class="Function">is-prop</a> <a id="1029" class="Symbol">(</a><a id="1030" href="Relation.Order.html#867" class="Bound">R</a> <a id="1032" href="Relation.Order.html#1010" class="Bound">x</a> <a id="1034" href="Relation.Order.html#1012" class="Bound">y</a><a id="1035" class="Symbol">)</a>
</pre>
<h2 id="partial-orders"><a href="#partial-orders" class="header-link">Partial
Orders<span class="header-link-emoji">🔗</span></a></h2>
<p>A <strong>partial order</strong> is a preorder which, in addition, is
antisymmetric:</p>
<pre class="Agda"><a id="is-anti-symmetric"></a><a id="1142" href="Relation.Order.html#1142" data-type="(R₁ : A → A → Type ℓ) → Type (A.ℓ ⊔ ℓ)" class="Function">is-anti-symmetric</a> <a id="1160" class="Symbol">:</a> <a id="1162" class="Symbol">(</a><a id="1163" href="Relation.Order.html#1163" class="Bound">R</a> <a id="1165" class="Symbol">:</a> <a id="1167" href="Relation.Order.html#332" class="Generalizable">A</a> <a id="1169" class="Symbol">→</a> <a id="1171" href="Relation.Order.html#332" class="Generalizable">A</a> <a id="1173" class="Symbol">→</a> <a id="1175" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="1180" href="Relation.Order.html#317" class="Generalizable">ℓ</a><a id="1181" class="Symbol">)</a> <a id="1183" class="Symbol">→</a> <a id="1185" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="1190" class="Symbol">_</a>
<a id="1192" href="Relation.Order.html#1142" data-type="(R₁ : A → A → Type ℓ) → Type (A.ℓ ⊔ ℓ)" class="Function">is-anti-symmetric</a> <a id="1210" href="Relation.Order.html#1210" class="Bound">R</a> <a id="1212" class="Symbol">=</a> <a id="1214" class="Symbol">{</a><a id="1215" href="Relation.Order.html#1215" class="Bound">x</a> <a id="1217" href="Relation.Order.html#1217" class="Bound">y</a> <a id="1219" class="Symbol">:</a> <a id="1221" class="Symbol">_}</a> <a id="1224" class="Symbol">→</a> <a id="1226" href="Relation.Order.html#1210" class="Bound">R</a> <a id="1228" href="Relation.Order.html#1215" class="Bound">x</a> <a id="1230" href="Relation.Order.html#1217" class="Bound">y</a> <a id="1232" class="Symbol">→</a> <a id="1234" href="Relation.Order.html#1210" class="Bound">R</a> <a id="1236" href="Relation.Order.html#1217" class="Bound">y</a> <a id="1238" href="Relation.Order.html#1215" class="Bound">x</a> <a id="1240" class="Symbol">→</a> <a id="1242" href="Relation.Order.html#1215" class="Bound">x</a> <a id="1244" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="1246" href="Relation.Order.html#1217" class="Bound">y</a>

<a id="1249" class="Keyword">record</a> <a id="is-partial-order"></a><a id="1256" href="Relation.Order.html#1256" data-type="(R₁ : A → A → Type ℓ&#39;) → Type (ℓ ⊔ ℓ&#39;)" class="Record">is-partial-order</a> <a id="1273" class="Symbol">{</a><a id="1274" href="Relation.Order.html#1274" class="Bound">A</a> <a id="1276" class="Symbol">:</a> <a id="1278" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="1283" href="Relation.Order.html#317" class="Generalizable">ℓ</a><a id="1284" class="Symbol">}</a> <a id="1286" class="Symbol">(</a><a id="1287" href="Relation.Order.html#1287" class="Bound">R</a> <a id="1289" class="Symbol">:</a> <a id="1291" href="Relation.Order.html#1274" class="Bound">A</a> <a id="1293" class="Symbol">→</a> <a id="1295" href="Relation.Order.html#1274" class="Bound">A</a> <a id="1297" class="Symbol">→</a> <a id="1299" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="1304" href="Relation.Order.html#319" class="Generalizable">ℓ&#39;</a><a id="1306" class="Symbol">)</a> <a id="1308" class="Symbol">:</a> <a id="1310" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="1315" class="Symbol">(</a><a id="1316" href="Relation.Order.html#1283" class="Bound">ℓ</a> <a id="1318" href="Agda.Primitive.html#795" data-type="Level → Level → Level" class="Primitive Operator">⊔</a> <a id="1320" href="Relation.Order.html#1304" class="Bound">ℓ&#39;</a><a id="1322" class="Symbol">)</a> <a id="1324" class="Keyword">where</a>
  <a id="1332" class="Keyword">field</a>
    <a id="is-partial-order.preorder"></a><a id="1342" href="Relation.Order.html#1342" data-type="is-partial-order R₁ → is-preorder R₁" class="Field">preorder</a> <a id="1351" class="Symbol">:</a> <a id="1353" href="Relation.Order.html#841" data-type="(R₁ : A → A → Type ℓ&#39;) → Type (ℓ ⊔ ℓ&#39;)" class="Record">is-preorder</a> <a id="1365" href="Relation.Order.html#1287" class="Bound">R</a>
    <a id="is-partial-order.antisym"></a><a id="1371" href="Relation.Order.html#1371" data-type="is-partial-order R₁ → is-anti-symmetric R₁" class="Field">antisym</a> <a id="1379" class="Symbol">:</a> <a id="1381" href="Relation.Order.html#1142" data-type="(R₁ : A → A → Type ℓ) → Type (A.ℓ ⊔ ℓ)" class="Function">is-anti-symmetric</a> <a id="1399" href="Relation.Order.html#1287" class="Bound">R</a>

  <a id="1404" class="Keyword">open</a> <a id="1409" href="Relation.Order.html#841" data-type="(R₁ : A → A → Type ℓ&#39;) → Type (ℓ ⊔ ℓ&#39;)" class="Module">is-preorder</a> <a id="1421" href="Relation.Order.html#1342" data-type="is-partial-order R₁ → is-preorder R₁" class="Field">preorder</a> <a id="1430" class="Keyword">public</a>
</pre>
<p>Any type with a choice of partial order is a set. This is because of
<span class="Agda"><a href="1Lab.HLevel.Sets.html#2391" class="Function">Rijke&#39;s theorem</a></span>:
Any type with a reflexive relation implying equality is a set.</p>
<pre class="Agda"><a id="has-partial-order→is-set"></a><a id="1628" href="Relation.Order.html#1628" data-type="is-partial-order R₁ → is-set A" class="Function">has-partial-order→is-set</a> <a id="1653" class="Symbol">:</a> <a id="1655" class="Symbol">{</a><a id="1656" href="Relation.Order.html#1656" class="Bound">A</a> <a id="1658" class="Symbol">:</a> <a id="1660" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="1665" href="Relation.Order.html#317" class="Generalizable">ℓ</a><a id="1666" class="Symbol">}</a> <a id="1668" class="Symbol">{</a><a id="1669" href="Relation.Order.html#1669" class="Bound">R</a> <a id="1671" class="Symbol">:</a> <a id="1673" href="Relation.Order.html#1656" class="Bound">A</a> <a id="1675" class="Symbol">→</a> <a id="1677" href="Relation.Order.html#1656" class="Bound">A</a> <a id="1679" class="Symbol">→</a> <a id="1681" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="1686" href="Relation.Order.html#319" class="Generalizable">ℓ&#39;</a><a id="1688" class="Symbol">}</a>
                      <a id="1712" class="Symbol">→</a> <a id="1714" href="Relation.Order.html#1256" data-type="(R₁ : A → A → Type ℓ&#39;) → Type (ℓ ⊔ ℓ&#39;)" class="Record">is-partial-order</a> <a id="1731" href="Relation.Order.html#1669" class="Bound">R</a>
                      <a id="1755" class="Symbol">→</a> <a id="1757" href="1Lab.HLevel.html#3356" data-type="Type ℓ → Type ℓ" class="Function">is-set</a> <a id="1764" href="Relation.Order.html#1656" class="Bound">A</a>
<a id="1766" href="Relation.Order.html#1628" data-type="is-partial-order R₁ → is-set A" class="Function">has-partial-order→is-set</a> <a id="1791" class="Symbol">{</a><a id="1792" class="Argument">A</a> <a id="1794" class="Symbol">=</a> <a id="1796" href="Relation.Order.html#1796" class="Bound">A</a><a id="1797" class="Symbol">}</a> <a id="1799" class="Symbol">{</a><a id="1800" href="Relation.Order.html#1800" class="Bound Operator">_≤_</a><a id="1803" class="Symbol">}</a> <a id="1805" href="Relation.Order.html#1805" class="Bound">ispo</a> <a id="1810" class="Symbol">=</a>
  <a id="1814" href="1Lab.HLevel.Sets.html#2391" data-type="R₁ x x → (R₁ x y → x ≡ y) → is-prop (R₁ x y) → is-set A" class="Function">Rijke-is-set</a> <a id="1827" class="Symbol">{</a><a id="1828" class="Argument">R</a> <a id="1830" class="Symbol">=</a> <a id="1832" href="Relation.Order.html#2116" data-type="(ispo : is-partial-order _≤₁_) → A → A → Type ℓ&#39;" class="Function">R&#39;</a><a id="1834" class="Symbol">}</a> <a id="1836" href="Relation.Order.html#2172" data-type="(ispo : is-partial-order _≤₁_) → R&#39; ispo x x" class="Function">reflexive&#39;</a> <a id="1847" class="Symbol">(λ</a> <a id="1850" class="Symbol">{</a> <a id="1852" class="Symbol">(</a><a id="1853" href="Relation.Order.html#1853" class="Bound">x</a> <a id="1855" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="1857" href="Relation.Order.html#1857" class="Bound">y</a><a id="1858" class="Symbol">)</a> <a id="1860" class="Symbol">→</a> <a id="1862" href="Relation.Order.html#1371" data-type="is-partial-order R₁ → is-anti-symmetric R₁" class="Field">antisym</a> <a id="1870" href="Relation.Order.html#1853" class="Bound">x</a> <a id="1872" href="Relation.Order.html#1857" class="Bound">y</a> <a id="1874" class="Symbol">})</a> <a id="1877" href="Relation.Order.html#2246" data-type="(ispo : is-partial-order _≤₁_) → is-prop (R&#39; ispo x y)" class="Function">is-prop&#39;</a>
  <a id="1888" class="Keyword">where</a>
    <a id="1898" class="Keyword">open</a> <a id="1903" href="Relation.Order.html#1256" data-type="(R₁ : A → A → Type ℓ&#39;) → Type (ℓ ⊔ ℓ&#39;)" class="Module">is-partial-order</a> <a id="1920" href="Relation.Order.html#1805" class="Bound">ispo</a>
</pre>
<p>For the relation, we take
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>x</mi><mo>≤</mo><mi>y</mi><mo stretchy="false">)</mo><mo>∧</mo><mo stretchy="false">(</mo><mi>y</mi><mo>≤</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R(x, y) = (x \le y) \land (y \le x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>.</span>
By antisymmetry, this implies
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x = y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>.</span>
Since propositions are closed under products, this is a proposition.</p>
<pre class="Agda">    <a id="2116" href="Relation.Order.html#2116" data-type="(ispo : is-partial-order _≤₁_) → A → A → Type ℓ&#39;" class="Function">R&#39;</a> <a id="2119" class="Symbol">:</a> <a id="2121" href="Relation.Order.html#1796" class="Bound">A</a> <a id="2123" class="Symbol">→</a> <a id="2125" href="Relation.Order.html#1796" class="Bound">A</a> <a id="2127" class="Symbol">→</a> <a id="2129" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="2134" class="Symbol">_</a>
    <a id="2140" href="Relation.Order.html#2116" data-type="(ispo : is-partial-order _≤₁_) → A → A → Type ℓ&#39;" class="Function">R&#39;</a> <a id="2143" href="Relation.Order.html#2143" class="Bound">x</a> <a id="2145" href="Relation.Order.html#2145" class="Bound">y</a> <a id="2147" class="Symbol">=</a> <a id="2149" class="Symbol">(</a><a id="2150" href="Relation.Order.html#2143" class="Bound">x</a> <a id="2152" href="Relation.Order.html#1800" class="Bound Operator">≤</a> <a id="2154" href="Relation.Order.html#2145" class="Bound">y</a><a id="2155" class="Symbol">)</a> <a id="2157" href="1Lab.Type.html#1846" data-type="Type a → Type b → Type (a ⊔ b)" class="Function Operator">×</a> <a id="2159" class="Symbol">(</a><a id="2160" href="Relation.Order.html#2145" class="Bound">y</a> <a id="2162" href="Relation.Order.html#1800" class="Bound Operator">≤</a> <a id="2164" href="Relation.Order.html#2143" class="Bound">x</a><a id="2165" class="Symbol">)</a>

    <a id="2172" href="Relation.Order.html#2172" data-type="(ispo : is-partial-order _≤₁_) → R&#39; ispo x x" class="Function">reflexive&#39;</a> <a id="2183" class="Symbol">:</a> <a id="2185" class="Symbol">{</a><a id="2186" href="Relation.Order.html#2186" class="Bound">x</a> <a id="2188" class="Symbol">:</a> <a id="2190" href="Relation.Order.html#1796" class="Bound">A</a><a id="2191" class="Symbol">}</a> <a id="2193" class="Symbol">→</a> <a id="2195" href="Relation.Order.html#2116" data-type="(ispo : is-partial-order _≤₁_) → A → A → Type ℓ&#39;" class="Function">R&#39;</a> <a id="2198" href="Relation.Order.html#2186" class="Bound">x</a> <a id="2200" href="Relation.Order.html#2186" class="Bound">x</a>
    <a id="2206" href="Relation.Order.html#2172" data-type="(ispo : is-partial-order _≤₁_) → R&#39; ispo x x" class="Function">reflexive&#39;</a> <a id="2217" class="Symbol">=</a> <a id="2219" href="Relation.Order.html#922" data-type="is-preorder R₁ → is-reflexive R₁" class="Function">reflexive</a> <a id="2229" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="2231" href="Relation.Order.html#922" data-type="is-preorder R₁ → is-reflexive R₁" class="Function">reflexive</a>

    <a id="2246" href="Relation.Order.html#2246" data-type="(ispo : is-partial-order _≤₁_) → is-prop (R&#39; ispo x y)" class="Function">is-prop&#39;</a> <a id="2255" class="Symbol">:</a> <a id="2257" class="Symbol">{</a><a id="2258" href="Relation.Order.html#2258" class="Bound">x</a> <a id="2260" href="Relation.Order.html#2260" class="Bound">y</a> <a id="2262" class="Symbol">:</a> <a id="2264" href="Relation.Order.html#1796" class="Bound">A</a><a id="2265" class="Symbol">}</a> <a id="2267" class="Symbol">→</a> <a id="2269" href="1Lab.HLevel.html#2597" data-type="Type ℓ → Type ℓ" class="Function">is-prop</a> <a id="2277" class="Symbol">(</a><a id="2278" href="Relation.Order.html#2116" data-type="(ispo : is-partial-order _≤₁_) → A → A → Type ℓ&#39;" class="Function">R&#39;</a> <a id="2281" href="Relation.Order.html#2258" class="Bound">x</a> <a id="2283" href="Relation.Order.html#2260" class="Bound">y</a><a id="2284" class="Symbol">)</a>
    <a id="2290" href="Relation.Order.html#2246" data-type="(ispo : is-partial-order _≤₁_) → is-prop (R&#39; ispo x y)" class="Function">is-prop&#39;</a> <a id="2299" class="Symbol">(</a><a id="2300" href="Relation.Order.html#2300" class="Bound">a</a> <a id="2302" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="2304" href="Relation.Order.html#2304" class="Bound">b</a><a id="2305" class="Symbol">)</a> <a id="2307" class="Symbol">(</a><a id="2308" href="Relation.Order.html#2308" class="Bound">a&#39;</a> <a id="2311" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="2313" href="Relation.Order.html#2313" class="Bound">b&#39;</a><a id="2315" class="Symbol">)</a> <a id="2317" href="Relation.Order.html#2317" class="Bound">i</a> <a id="2319" class="Symbol">=</a> <a id="2321" href="Relation.Order.html#993" data-type="is-preorder R₁ → is-prop (R₁ x y)" class="Function">propositional</a> <a id="2335" href="Relation.Order.html#2300" class="Bound">a</a> <a id="2337" href="Relation.Order.html#2308" class="Bound">a&#39;</a> <a id="2340" href="Relation.Order.html#2317" class="Bound">i</a> <a id="2342" href="Agda.Builtin.Sigma.html#209" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="2344" href="Relation.Order.html#993" data-type="is-preorder R₁ → is-prop (R₁ x y)" class="Function">propositional</a> <a id="2358" href="Relation.Order.html#2304" class="Bound">b</a> <a id="2360" href="Relation.Order.html#2313" class="Bound">b&#39;</a> <a id="2363" href="Relation.Order.html#2317" class="Bound">i</a>
</pre>
<p>With this theorem, we can prove that being a partial order is a
proposition. We do this by the characterisation of propositions as those
types which are
<span class="Agda"><a href="1Lab.HLevel.html#4742" class="Function">contractible when inhabited</a></span>,
since then we’re free to assume A is a set.</p>
<pre class="Agda"><a id="is-partial-order-is-prop"></a><a id="2646" href="Relation.Order.html#2646" data-type="is-prop (is-partial-order R₁)" class="Function">is-partial-order-is-prop</a> <a id="2671" class="Symbol">:</a> <a id="2673" class="Symbol">{</a><a id="2674" href="Relation.Order.html#2674" class="Bound">A</a> <a id="2676" class="Symbol">:</a> <a id="2678" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="2683" href="Relation.Order.html#317" class="Generalizable">ℓ</a><a id="2684" class="Symbol">}</a> <a id="2686" class="Symbol">{</a><a id="2687" href="Relation.Order.html#2687" class="Bound">R</a> <a id="2689" class="Symbol">:</a> <a id="2691" href="Relation.Order.html#2674" class="Bound">A</a> <a id="2693" class="Symbol">→</a> <a id="2695" href="Relation.Order.html#2674" class="Bound">A</a> <a id="2697" class="Symbol">→</a> <a id="2699" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="2704" href="Relation.Order.html#319" class="Generalizable">ℓ&#39;</a><a id="2706" class="Symbol">}</a>
                      <a id="2730" class="Symbol">→</a> <a id="2732" href="1Lab.HLevel.html#2597" data-type="Type ℓ → Type ℓ" class="Function">is-prop</a> <a id="2740" class="Symbol">(</a><a id="2741" href="Relation.Order.html#1256" data-type="(R₁ : A → A → Type ℓ&#39;) → Type (ℓ ⊔ ℓ&#39;)" class="Record">is-partial-order</a> <a id="2758" href="Relation.Order.html#2687" class="Bound">R</a><a id="2759" class="Symbol">)</a>
<a id="2761" href="Relation.Order.html#2646" data-type="is-prop (is-partial-order R₁)" class="Function">is-partial-order-is-prop</a> <a id="2786" class="Symbol">{</a><a id="2787" class="Argument">A</a> <a id="2789" class="Symbol">=</a> <a id="2791" href="Relation.Order.html#2791" class="Bound">A</a><a id="2792" class="Symbol">}</a> <a id="2794" class="Symbol">{</a><a id="2795" href="Relation.Order.html#2795" class="Bound">R</a><a id="2796" class="Symbol">}</a> <a id="2798" class="Symbol">=</a> <a id="2800" href="1Lab.HLevel.html#4742" data-type="(A → is-contr A) → is-prop A" class="Function">contractible-if-inhabited</a> <a id="2826" href="Relation.Order.html#2895" data-type="is-partial-order R₁ → is-contr (is-partial-order R₁)" class="Function">contract</a>
  <a id="2837" class="Keyword">where</a>
    <a id="2847" class="Keyword">open</a> <a id="2852" href="Relation.Order.html#1256" data-type="(R₁ : A → A → Type ℓ&#39;) → Type (ℓ ⊔ ℓ&#39;)" class="Module">is-partial-order</a>
    <a id="2873" class="Keyword">open</a> <a id="2878" href="Relation.Order.html#841" data-type="(R₁ : A → A → Type ℓ&#39;) → Type (ℓ ⊔ ℓ&#39;)" class="Module">is-preorder</a>

    <a id="2895" href="Relation.Order.html#2895" data-type="is-partial-order R₁ → is-contr (is-partial-order R₁)" class="Function">contract</a> <a id="2904" class="Symbol">:</a> <a id="2906" href="Relation.Order.html#1256" data-type="(R₁ : A → A → Type ℓ&#39;) → Type (ℓ ⊔ ℓ&#39;)" class="Record">is-partial-order</a> <a id="2923" href="Relation.Order.html#2795" class="Bound">R</a> <a id="2925" class="Symbol">→</a> <a id="2927" href="1Lab.HLevel.html#1328" data-type="(A : Type ℓ) → Type ℓ" class="Record">is-contr</a> <a id="2936" class="Symbol">(</a><a id="2937" href="Relation.Order.html#1256" data-type="(R₁ : A → A → Type ℓ&#39;) → Type (ℓ ⊔ ℓ&#39;)" class="Record">is-partial-order</a> <a id="2954" href="Relation.Order.html#2795" class="Bound">R</a><a id="2955" class="Symbol">)</a>
    <a id="2961" href="Relation.Order.html#2895" data-type="is-partial-order R₁ → is-contr (is-partial-order R₁)" class="Function">contract</a> <a id="2970" href="Relation.Order.html#2970" class="Bound">order</a> <a id="2976" class="Symbol">=</a> <a id="2978" href="1Lab.HLevel.html#1383" data-type="(centre₁ : A) (paths₁ : (x : A) → centre₁ ≡ x) → is-contr A" class="InductiveConstructor">contr</a> <a id="2984" href="Relation.Order.html#2970" class="Bound">order</a> <a id="2990" href="Relation.Order.html#3338" data-type="(order x : is-partial-order R₁) → order ≡ x" class="Function">deform</a> <a id="2997" class="Keyword">where</a>
      <a id="3009" href="Relation.Order.html#3009" data-type="(order : is-partial-order R₁) → is-set A" class="Function">A-set</a> <a id="3015" class="Symbol">:</a> <a id="3017" href="1Lab.HLevel.html#3356" data-type="Type ℓ → Type ℓ" class="Function">is-set</a> <a id="3024" href="Relation.Order.html#2791" class="Bound">A</a>
      <a id="3032" href="Relation.Order.html#3009" data-type="(order : is-partial-order R₁) → is-set A" class="Function">A-set</a> <a id="3038" class="Symbol">=</a> <a id="3040" href="Relation.Order.html#1628" data-type="is-partial-order R₁ → is-set A" class="Function">has-partial-order→is-set</a> <a id="3065" href="Relation.Order.html#2970" class="Bound">order</a>
</pre>
<p>For the centre of contraction, we’re free to use the given witness.
Since the paths end up being a big product of propositions, most of the
construction follows directly from the fact that
<span class="Agda"><a href="Relation.Order.html#993" class="Field">preorders are propositional</a></span>.</p>
<pre class="Agda">      <a id="3338" href="Relation.Order.html#3338" data-type="(order x : is-partial-order R₁) → order ≡ x" class="Function">deform</a> <a id="3345" class="Symbol">:</a> <a id="3347" class="Symbol">(</a><a id="3348" href="Relation.Order.html#3348" class="Bound">x</a> <a id="3350" class="Symbol">:</a> <a id="3352" href="Relation.Order.html#1256" data-type="(R₁ : A → A → Type ℓ&#39;) → Type (ℓ ⊔ ℓ&#39;)" class="Record">is-partial-order</a> <a id="3369" href="Relation.Order.html#2795" class="Bound">R</a><a id="3370" class="Symbol">)</a> <a id="3372" class="Symbol">→</a> <a id="3374" href="Relation.Order.html#2970" class="Bound">order</a> <a id="3380" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="3382" href="Relation.Order.html#3348" class="Bound">x</a>
      <a id="3390" href="Relation.Order.html#3338" data-type="(order x : is-partial-order R₁) → order ≡ x" class="Function">deform</a> <a id="3397" href="Relation.Order.html#3397" class="Bound">x</a> <a id="3399" href="Relation.Order.html#3399" class="Bound">i</a> <a id="3401" class="Symbol">.</a><a id="3402" href="Relation.Order.html#1342" data-type="is-partial-order R₁ → is-preorder R₁" class="Field">preorder</a> <a id="3411" class="Symbol">.</a><a id="3412" href="Relation.Order.html#922" data-type="is-preorder R₁ → is-reflexive R₁" class="Field">reflexive</a> <a id="3422" class="Symbol">=</a>
        <a id="3432" href="Relation.Order.html#3397" class="Bound">x</a> <a id="3434" class="Symbol">.</a><a id="3435" href="Relation.Order.html#993" data-type="is-preorder R₁ → is-prop (R₁ x y)" class="Field">propositional</a> <a id="3449" class="Symbol">(</a><a id="3450" href="Relation.Order.html#2970" class="Bound">order</a> <a id="3456" class="Symbol">.</a><a id="3457" href="Relation.Order.html#1342" data-type="is-partial-order R₁ → is-preorder R₁" class="Field">preorder</a> <a id="3466" class="Symbol">.</a><a id="3467" href="Relation.Order.html#922" data-type="is-preorder R₁ → is-reflexive R₁" class="Field">reflexive</a><a id="3476" class="Symbol">)</a>
                         <a id="3503" class="Symbol">(</a><a id="3504" href="Relation.Order.html#3397" class="Bound">x</a> <a id="3506" class="Symbol">.</a><a id="3507" href="Relation.Order.html#1342" data-type="is-partial-order R₁ → is-preorder R₁" class="Field">preorder</a> <a id="3516" class="Symbol">.</a><a id="3517" href="Relation.Order.html#922" data-type="is-preorder R₁ → is-reflexive R₁" class="Field">reflexive</a><a id="3526" class="Symbol">)</a>
                         <a id="3553" href="Relation.Order.html#3399" class="Bound">i</a>
      <a id="3561" href="Relation.Order.html#3338" data-type="(order x : is-partial-order R₁) → order ≡ x" class="Function">deform</a> <a id="3568" href="Relation.Order.html#3568" class="Bound">x</a> <a id="3570" href="Relation.Order.html#3570" class="Bound">i</a> <a id="3572" class="Symbol">.</a><a id="3573" href="Relation.Order.html#1342" data-type="is-partial-order R₁ → is-preorder R₁" class="Field">preorder</a> <a id="3582" class="Symbol">.</a><a id="3583" href="Relation.Order.html#957" data-type="is-preorder R₁ → is-transitive R₁" class="Field">transitive</a> <a id="3594" href="Relation.Order.html#3594" class="Bound">p</a> <a id="3596" href="Relation.Order.html#3596" class="Bound">q</a> <a id="3598" class="Symbol">=</a>
        <a id="3608" href="Relation.Order.html#3568" class="Bound">x</a> <a id="3610" class="Symbol">.</a><a id="3611" href="Relation.Order.html#993" data-type="is-preorder R₁ → is-prop (R₁ x y)" class="Field">propositional</a> <a id="3625" class="Symbol">(</a><a id="3626" href="Relation.Order.html#2970" class="Bound">order</a> <a id="3632" class="Symbol">.</a><a id="3633" href="Relation.Order.html#1342" data-type="is-partial-order R₁ → is-preorder R₁" class="Field">preorder</a> <a id="3642" class="Symbol">.</a><a id="3643" href="Relation.Order.html#957" data-type="is-preorder R₁ → is-transitive R₁" class="Field">transitive</a> <a id="3654" href="Relation.Order.html#3594" class="Bound">p</a> <a id="3656" href="Relation.Order.html#3596" class="Bound">q</a><a id="3657" class="Symbol">)</a>
                         <a id="3684" class="Symbol">(</a><a id="3685" href="Relation.Order.html#3568" class="Bound">x</a> <a id="3687" class="Symbol">.</a><a id="3688" href="Relation.Order.html#1342" data-type="is-partial-order R₁ → is-preorder R₁" class="Field">preorder</a> <a id="3697" class="Symbol">.</a><a id="3698" href="Relation.Order.html#957" data-type="is-preorder R₁ → is-transitive R₁" class="Field">transitive</a> <a id="3709" href="Relation.Order.html#3594" class="Bound">p</a> <a id="3711" href="Relation.Order.html#3596" class="Bound">q</a><a id="3712" class="Symbol">)</a>
                         <a id="3739" href="Relation.Order.html#3570" class="Bound">i</a>
</pre>
<p>To connect the propositionality witnesses, we use the fact that
<span class="Agda"><a href="1Lab.HLevel.html#12235" class="Function">is-prop is a proposition</a></span>.</p>
<pre class="Agda">      <a id="3882" href="Relation.Order.html#3338" data-type="(order x : is-partial-order R₁) → order ≡ x" class="Function">deform</a> <a id="3889" href="Relation.Order.html#3889" class="Bound">x</a> <a id="3891" href="Relation.Order.html#3891" class="Bound">i</a> <a id="3893" class="Symbol">.</a><a id="3894" href="Relation.Order.html#1342" data-type="is-partial-order R₁ → is-preorder R₁" class="Field">preorder</a> <a id="3903" class="Symbol">.</a><a id="3904" href="Relation.Order.html#993" data-type="is-preorder R₁ → is-prop (R₁ x y)" class="Field">propositional</a> <a id="3918" class="Symbol">=</a>
        <a id="3928" href="1Lab.HLevel.html#12235" data-type="is-prop (is-prop A)" class="Function">is-prop-is-prop</a> <a id="3944" class="Symbol">(</a><a id="3945" href="Relation.Order.html#2970" class="Bound">order</a> <a id="3951" class="Symbol">.</a><a id="3952" href="Relation.Order.html#1342" data-type="is-partial-order R₁ → is-preorder R₁" class="Field">preorder</a> <a id="3961" class="Symbol">.</a><a id="3962" href="Relation.Order.html#993" data-type="is-preorder R₁ → is-prop (R₁ x y)" class="Field">propositional</a><a id="3975" class="Symbol">)</a>
                        <a id="4001" class="Symbol">(</a><a id="4002" href="Relation.Order.html#3889" class="Bound">x</a> <a id="4004" class="Symbol">.</a><a id="4005" href="Relation.Order.html#1342" data-type="is-partial-order R₁ → is-preorder R₁" class="Field">preorder</a> <a id="4014" class="Symbol">.</a><a id="4015" href="Relation.Order.html#993" data-type="is-preorder R₁ → is-prop (R₁ x y)" class="Field">propositional</a><a id="4028" class="Symbol">)</a>
                        <a id="4054" href="Relation.Order.html#3891" class="Bound">i</a>
</pre>
<p>The construction is finished by relating the antisymmetry witnesses.
Since <code>A</code> admits a partial order, and thus is a set, all of
its path spaces are propositions:</p>
<pre class="Agda">      <a id="4239" href="Relation.Order.html#3338" data-type="(order x : is-partial-order R₁) → order ≡ x" class="Function">deform</a> <a id="4246" href="Relation.Order.html#4246" class="Bound">x</a> <a id="4248" href="Relation.Order.html#4248" class="Bound">i</a> <a id="4250" class="Symbol">.</a><a id="4251" href="Relation.Order.html#1371" data-type="is-partial-order R₁ → is-anti-symmetric R₁" class="Field">antisym</a> <a id="4259" href="Relation.Order.html#4259" class="Bound">p</a> <a id="4261" href="Relation.Order.html#4261" class="Bound">q</a> <a id="4263" class="Symbol">=</a> <a id="4265" href="Relation.Order.html#3009" data-type="(order : is-partial-order R₁) → is-set A" class="Function">A-set</a> <a id="4271" class="Symbol">_</a> <a id="4273" class="Symbol">_</a> <a id="4275" class="Symbol">(</a><a id="4276" href="Relation.Order.html#2970" class="Bound">order</a> <a id="4282" class="Symbol">.</a><a id="4283" href="Relation.Order.html#1371" data-type="is-partial-order R₁ → is-anti-symmetric R₁" class="Field">antisym</a> <a id="4291" href="Relation.Order.html#4259" class="Bound">p</a> <a id="4293" href="Relation.Order.html#4261" class="Bound">q</a><a id="4294" class="Symbol">)</a> <a id="4296" class="Symbol">(</a><a id="4297" href="Relation.Order.html#4246" class="Bound">x</a> <a id="4299" class="Symbol">.</a><a id="4300" href="Relation.Order.html#1371" data-type="is-partial-order R₁ → is-anti-symmetric R₁" class="Field">antisym</a> <a id="4308" href="Relation.Order.html#4259" class="Bound">p</a> <a id="4310" href="Relation.Order.html#4261" class="Bound">q</a><a id="4311" class="Symbol">)</a> <a id="4313" href="Relation.Order.html#4248" class="Bound">i</a>
</pre>
<h2 id="trichotomous-orders"><a href="#trichotomous-orders" class="header-link">Trichotomous
orders<span class="header-link-emoji">🔗</span></a></h2>
<p>We say a relation is <strong>trichotomous</strong> for all
<code>x,y</code> if exactly <em>one</em> of <code>R x y</code>,
<code>x ≡ y</code>, or <code>R y x</code> holds. We define this in two
parts: First we define what trichotomy means for 2 elements via
<code>Tri</code>, then <code>Trichotomous</code> in terms of
<code>Tri</code>.</p>
<pre class="Agda"><a id="4594" class="Keyword">data</a> <a id="Tri"></a><a id="4599" href="Relation.Order.html#4599" data-type="(A → A → Type ℓ&#39;) → A → A → Type (ℓ ⊔ ℓ&#39;)" class="Datatype">Tri</a> <a id="4603" class="Symbol">{</a><a id="4604" href="Relation.Order.html#4604" class="Bound">A</a> <a id="4606" class="Symbol">:</a> <a id="4608" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="4613" href="Relation.Order.html#317" class="Generalizable">ℓ</a><a id="4614" class="Symbol">}</a> <a id="4616" class="Symbol">(</a><a id="4617" href="Relation.Order.html#4617" class="Bound">R</a> <a id="4619" class="Symbol">:</a> <a id="4621" href="Relation.Order.html#4604" class="Bound">A</a> <a id="4623" class="Symbol">→</a> <a id="4625" href="Relation.Order.html#4604" class="Bound">A</a> <a id="4627" class="Symbol">→</a> <a id="4629" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="4634" href="Relation.Order.html#319" class="Generalizable">ℓ&#39;</a><a id="4636" class="Symbol">)</a> <a id="4638" class="Symbol">(</a><a id="4639" href="Relation.Order.html#4639" class="Bound">x</a> <a id="4641" href="Relation.Order.html#4641" class="Bound">y</a> <a id="4643" class="Symbol">:</a> <a id="4645" href="Relation.Order.html#4604" class="Bound">A</a><a id="4646" class="Symbol">)</a> <a id="4648" class="Symbol">:</a> <a id="4650" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="4655" class="Symbol">(</a><a id="4656" href="Relation.Order.html#4613" class="Bound">ℓ</a> <a id="4658" href="Agda.Primitive.html#795" data-type="Level → Level → Level" class="Primitive Operator">⊔</a> <a id="4660" href="Relation.Order.html#4634" class="Bound">ℓ&#39;</a><a id="4662" class="Symbol">)</a> <a id="4664" class="Keyword">where</a>
  <a id="Tri.lt"></a><a id="4672" href="Relation.Order.html#4672" data-type="R₁ x y → (x ≡ y → ⊥) → (R₁ y x → ⊥) → Tri R₁ x y" class="InductiveConstructor">lt</a> <a id="4675" class="Symbol">:</a> <a id="4677" href="Relation.Order.html#4617" class="Bound">R</a> <a id="4679" href="Relation.Order.html#4639" class="Bound">x</a> <a id="4681" href="Relation.Order.html#4641" class="Bound">y</a>       <a id="4689" class="Symbol">→</a> <a id="4691" class="Symbol">(</a><a id="4692" href="Relation.Order.html#4639" class="Bound">x</a> <a id="4694" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="4696" href="Relation.Order.html#4641" class="Bound">y</a> <a id="4698" class="Symbol">→</a> <a id="4700" href="1Lab.Type.html#1336" data-type="Type" class="Datatype">⊥</a><a id="4701" class="Symbol">)</a> <a id="4703" class="Symbol">→</a> <a id="4705" class="Symbol">(</a><a id="4706" href="Relation.Order.html#4617" class="Bound">R</a> <a id="4708" href="Relation.Order.html#4641" class="Bound">y</a> <a id="4710" href="Relation.Order.html#4639" class="Bound">x</a> <a id="4712" class="Symbol">→</a> <a id="4714" href="1Lab.Type.html#1336" data-type="Type" class="Datatype">⊥</a><a id="4715" class="Symbol">)</a> <a id="4717" class="Symbol">→</a> <a id="4719" href="Relation.Order.html#4599" data-type="(A → A → Type ℓ&#39;) → A → A → Type (ℓ ⊔ ℓ&#39;)" class="Datatype">Tri</a> <a id="4723" href="Relation.Order.html#4617" class="Bound">R</a> <a id="4725" href="Relation.Order.html#4639" class="Bound">x</a> <a id="4727" href="Relation.Order.html#4641" class="Bound">y</a>
  <a id="Tri.eq"></a><a id="4731" href="Relation.Order.html#4731" data-type="(R₁ x y → ⊥) → x ≡ y → (R₁ y x → ⊥) → Tri R₁ x y" class="InductiveConstructor">eq</a> <a id="4734" class="Symbol">:</a> <a id="4736" class="Symbol">(</a><a id="4737" href="Relation.Order.html#4617" class="Bound">R</a> <a id="4739" href="Relation.Order.html#4639" class="Bound">x</a> <a id="4741" href="Relation.Order.html#4641" class="Bound">y</a> <a id="4743" class="Symbol">→</a> <a id="4745" href="1Lab.Type.html#1336" data-type="Type" class="Datatype">⊥</a><a id="4746" class="Symbol">)</a> <a id="4748" class="Symbol">→</a> <a id="4750" href="Relation.Order.html#4639" class="Bound">x</a> <a id="4752" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="4754" href="Relation.Order.html#4641" class="Bound">y</a>       <a id="4762" class="Symbol">→</a> <a id="4764" class="Symbol">(</a><a id="4765" href="Relation.Order.html#4617" class="Bound">R</a> <a id="4767" href="Relation.Order.html#4641" class="Bound">y</a> <a id="4769" href="Relation.Order.html#4639" class="Bound">x</a> <a id="4771" class="Symbol">→</a> <a id="4773" href="1Lab.Type.html#1336" data-type="Type" class="Datatype">⊥</a><a id="4774" class="Symbol">)</a> <a id="4776" class="Symbol">→</a> <a id="4778" href="Relation.Order.html#4599" data-type="(A → A → Type ℓ&#39;) → A → A → Type (ℓ ⊔ ℓ&#39;)" class="Datatype">Tri</a> <a id="4782" href="Relation.Order.html#4617" class="Bound">R</a> <a id="4784" href="Relation.Order.html#4639" class="Bound">x</a> <a id="4786" href="Relation.Order.html#4641" class="Bound">y</a>
  <a id="Tri.gt"></a><a id="4790" href="Relation.Order.html#4790" data-type="(R₁ x y → ⊥) → (x ≡ y → ⊥) → R₁ y x → Tri R₁ x y" class="InductiveConstructor">gt</a> <a id="4793" class="Symbol">:</a> <a id="4795" class="Symbol">(</a><a id="4796" href="Relation.Order.html#4617" class="Bound">R</a> <a id="4798" href="Relation.Order.html#4639" class="Bound">x</a> <a id="4800" href="Relation.Order.html#4641" class="Bound">y</a> <a id="4802" class="Symbol">→</a> <a id="4804" href="1Lab.Type.html#1336" data-type="Type" class="Datatype">⊥</a><a id="4805" class="Symbol">)</a> <a id="4807" class="Symbol">→</a> <a id="4809" class="Symbol">(</a><a id="4810" href="Relation.Order.html#4639" class="Bound">x</a> <a id="4812" href="Agda.Builtin.Cubical.Path.html#272" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="4814" href="Relation.Order.html#4641" class="Bound">y</a> <a id="4816" class="Symbol">→</a> <a id="4818" href="1Lab.Type.html#1336" data-type="Type" class="Datatype">⊥</a><a id="4819" class="Symbol">)</a> <a id="4821" class="Symbol">→</a> <a id="4823" href="Relation.Order.html#4617" class="Bound">R</a> <a id="4825" href="Relation.Order.html#4641" class="Bound">y</a> <a id="4827" href="Relation.Order.html#4639" class="Bound">x</a>       <a id="4835" class="Symbol">→</a> <a id="4837" href="Relation.Order.html#4599" data-type="(A → A → Type ℓ&#39;) → A → A → Type (ℓ ⊔ ℓ&#39;)" class="Datatype">Tri</a> <a id="4841" href="Relation.Order.html#4617" class="Bound">R</a> <a id="4843" href="Relation.Order.html#4639" class="Bound">x</a> <a id="4845" href="Relation.Order.html#4641" class="Bound">y</a>

<a id="is-trichotomous"></a><a id="4848" href="Relation.Order.html#4848" data-type="(A → A → Type ℓ&#39;) → Type (ℓ ⊔ ℓ&#39;)" class="Function">is-trichotomous</a> <a id="4864" class="Symbol">:</a> <a id="4866" class="Symbol">{</a><a id="4867" href="Relation.Order.html#4867" class="Bound">A</a> <a id="4869" class="Symbol">:</a> <a id="4871" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="4876" href="Relation.Order.html#317" class="Generalizable">ℓ</a><a id="4877" class="Symbol">}</a> <a id="4879" class="Symbol">→</a> <a id="4881" class="Symbol">(</a><a id="4882" href="Relation.Order.html#4882" class="Bound">R</a> <a id="4884" class="Symbol">:</a> <a id="4886" href="Relation.Order.html#4867" class="Bound">A</a> <a id="4888" class="Symbol">→</a> <a id="4890" href="Relation.Order.html#4867" class="Bound">A</a> <a id="4892" class="Symbol">→</a> <a id="4894" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="4899" href="Relation.Order.html#319" class="Generalizable">ℓ&#39;</a><a id="4901" class="Symbol">)</a> <a id="4903" class="Symbol">→</a> <a id="4905" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="4910" class="Symbol">(</a><a id="4911" href="Relation.Order.html#317" class="Generalizable">ℓ</a> <a id="4913" href="Agda.Primitive.html#795" data-type="Level → Level → Level" class="Primitive Operator">⊔</a> <a id="4915" href="Relation.Order.html#319" class="Generalizable">ℓ&#39;</a><a id="4917" class="Symbol">)</a>
<a id="4919" href="Relation.Order.html#4848" data-type="(A → A → Type ℓ&#39;) → Type (ℓ ⊔ ℓ&#39;)" class="Function">is-trichotomous</a> <a id="4935" href="Relation.Order.html#4935" class="Bound">R</a> <a id="4937" class="Symbol">=</a> <a id="4939" class="Symbol">∀</a> <a id="4941" href="Relation.Order.html#4941" class="Bound">x</a> <a id="4943" href="Relation.Order.html#4943" class="Bound">y</a> <a id="4945" class="Symbol">→</a> <a id="4947" href="Relation.Order.html#4599" data-type="(A → A → Type ℓ&#39;) → A → A → Type (ℓ ⊔ ℓ&#39;)" class="Datatype">Tri</a> <a id="4951" href="Relation.Order.html#4935" class="Bound">R</a> <a id="4953" href="Relation.Order.html#4941" class="Bound">x</a> <a id="4955" href="Relation.Order.html#4943" class="Bound">y</a>
</pre>
<p>Trichotomy is a very powerful property, and we can derive a lot of
useful results from it!</p>
<p>To start, trichotomy immediately implies discreteness:</p>
<pre class="Agda"><a id="trichotomous-discrete"></a><a id="5118" href="Relation.Order.html#5118" data-type="is-trichotomous R₁ → Discrete A" class="Function">trichotomous-discrete</a> <a id="5140" class="Symbol">:</a> <a id="5142" class="Symbol">∀</a> <a id="5144" class="Symbol">{</a><a id="5145" href="Relation.Order.html#5145" class="Bound">A</a> <a id="5147" class="Symbol">:</a> <a id="5149" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="5154" href="Relation.Order.html#317" class="Generalizable">ℓ</a><a id="5155" class="Symbol">}</a> <a id="5157" class="Symbol">{</a><a id="5158" href="Relation.Order.html#5158" class="Bound">R</a> <a id="5160" class="Symbol">:</a> <a id="5162" href="Relation.Order.html#5145" class="Bound">A</a> <a id="5164" class="Symbol">→</a> <a id="5166" href="Relation.Order.html#5145" class="Bound">A</a> <a id="5168" class="Symbol">→</a> <a id="5170" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="5175" href="Relation.Order.html#319" class="Generalizable">ℓ&#39;</a><a id="5177" class="Symbol">}</a>
                      <a id="5201" class="Symbol">→</a> <a id="5203" href="Relation.Order.html#4848" data-type="(A → A → Type ℓ&#39;) → Type (ℓ ⊔ ℓ&#39;)" class="Function">is-trichotomous</a> <a id="5219" href="Relation.Order.html#5158" class="Bound">R</a> <a id="5221" class="Symbol">→</a> <a id="5223" href="1Lab.Type.Dec.html#585" data-type="Type ℓ → Type ℓ" class="Function">Discrete</a> <a id="5232" href="Relation.Order.html#5145" class="Bound">A</a>
<a id="5234" href="Relation.Order.html#5118" data-type="is-trichotomous R₁ → Discrete A" class="Function">trichotomous-discrete</a> <a id="5256" href="Relation.Order.html#5256" class="Bound">compare</a> <a id="5264" href="Relation.Order.html#5264" class="Bound">x</a> <a id="5266" href="Relation.Order.html#5266" class="Bound">y</a> <a id="5268" class="Keyword">with</a> <a id="5273" href="Relation.Order.html#5256" class="Bound">compare</a> <a id="5281" href="Relation.Order.html#5264" class="Bound">x</a> <a id="5283" href="Relation.Order.html#5266" class="Bound">y</a>
<a id="5285" class="Symbol">...</a> <a id="5289" class="Symbol">|</a> <a id="5291" href="Relation.Order.html#4672" data-type="R₁ x y → (x ≡ y → ⊥) → (R₁ y x → ⊥) → Tri R₁ x y" class="InductiveConstructor">lt</a> <a id="5294" class="Symbol">_</a> <a id="5296" href="Relation.Order.html#5296" class="Bound">¬x≡y</a> <a id="5301" class="Symbol">_</a> <a id="5303" class="Symbol">=</a> <a id="5305" href="1Lab.Type.Dec.html#310" data-type="(A → ⊥) → Dec A" class="InductiveConstructor">no</a> <a id="5308" href="Relation.Order.html#5296" class="Bound">¬x≡y</a>
<a id="5313" class="Symbol">...</a> <a id="5317" class="Symbol">|</a> <a id="5319" href="Relation.Order.html#4731" data-type="(R₁ x y → ⊥) → x ≡ y → (R₁ y x → ⊥) → Tri R₁ x y" class="InductiveConstructor">eq</a> <a id="5322" class="Symbol">_</a>  <a id="5325" href="Relation.Order.html#5325" class="Bound">x≡y</a> <a id="5329" class="Symbol">_</a> <a id="5331" class="Symbol">=</a> <a id="5333" href="1Lab.Type.Dec.html#292" data-type="A → Dec A" class="InductiveConstructor">yes</a> <a id="5337" href="Relation.Order.html#5325" class="Bound">x≡y</a>
<a id="5341" class="Symbol">...</a> <a id="5345" class="Symbol">|</a> <a id="5347" href="Relation.Order.html#4790" data-type="(R₁ x y → ⊥) → (x ≡ y → ⊥) → R₁ y x → Tri R₁ x y" class="InductiveConstructor">gt</a> <a id="5350" class="Symbol">_</a> <a id="5352" href="Relation.Order.html#5352" class="Bound">¬x≡y</a> <a id="5357" class="Symbol">_</a> <a id="5359" class="Symbol">=</a> <a id="5361" href="1Lab.Type.Dec.html#310" data-type="(A → ⊥) → Dec A" class="InductiveConstructor">no</a> <a id="5364" href="Relation.Order.html#5352" class="Bound">¬x≡y</a>
</pre>
<p>These results aren’t particularly deep, but are useful nonetheless.
If <code>x</code> and <code>y</code> are trichotomous with respect to
one another, then we can flip everything around without consequence.</p>
<pre class="Agda"><a id="tri-sym"></a><a id="5568" href="Relation.Order.html#5568" data-type="Tri R₁ x y → Tri R₁ y x" class="Function">tri-sym</a> <a id="5576" class="Symbol">:</a> <a id="5578" class="Symbol">∀</a> <a id="5580" class="Symbol">{</a><a id="5581" href="Relation.Order.html#5581" class="Bound">x</a> <a id="5583" href="Relation.Order.html#5583" class="Bound">y</a><a id="5584" class="Symbol">}</a> <a id="5586" class="Symbol">→</a> <a id="5588" href="Relation.Order.html#4599" data-type="(A → A → Type ℓ&#39;) → A → A → Type (ℓ ⊔ ℓ&#39;)" class="Datatype">Tri</a> <a id="5592" href="Relation.Order.html#345" class="Generalizable">R</a> <a id="5594" href="Relation.Order.html#5581" class="Bound">x</a> <a id="5596" href="Relation.Order.html#5583" class="Bound">y</a> <a id="5598" class="Symbol">→</a> <a id="5600" href="Relation.Order.html#4599" data-type="(A → A → Type ℓ&#39;) → A → A → Type (ℓ ⊔ ℓ&#39;)" class="Datatype">Tri</a> <a id="5604" href="Relation.Order.html#345" class="Generalizable">R</a> <a id="5606" href="Relation.Order.html#5583" class="Bound">y</a> <a id="5608" href="Relation.Order.html#5581" class="Bound">x</a>
<a id="5610" href="Relation.Order.html#5568" data-type="Tri R₁ x y → Tri R₁ y x" class="Function">tri-sym</a> <a id="5618" class="Symbol">(</a><a id="5619" href="Relation.Order.html#4672" data-type="R₁ x y → (x ≡ y → ⊥) → (R₁ y x → ⊥) → Tri R₁ x y" class="InductiveConstructor">lt</a>  <a id="5623" href="Relation.Order.html#5623" class="Bound">x≺y</a> <a id="5627" href="Relation.Order.html#5627" class="Bound">¬x≡y</a> <a id="5632" href="Relation.Order.html#5632" class="Bound">¬y≺x</a><a id="5636" class="Symbol">)</a> <a id="5638" class="Symbol">=</a> <a id="5640" href="Relation.Order.html#4790" data-type="(R₁ x y → ⊥) → (x ≡ y → ⊥) → R₁ y x → Tri R₁ x y" class="InductiveConstructor">gt</a> <a id="5643" href="Relation.Order.html#5632" class="Bound">¬y≺x</a> <a id="5648" class="Symbol">(</a><a id="5649" href="Relation.Order.html#5627" class="Bound">¬x≡y</a> <a id="5654" href="1Lab.Type.html#2227" data-type="((y : B₁ x) → C x y) → (f : (x : A) → B₁ x) (x : A) → C x (f x)" class="Function Operator">∘</a> <a id="5656" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a><a id="5659" class="Symbol">)</a>  <a id="5662" href="Relation.Order.html#5623" class="Bound">x≺y</a>
<a id="5666" href="Relation.Order.html#5568" data-type="Tri R₁ x y → Tri R₁ y x" class="Function">tri-sym</a> <a id="5674" class="Symbol">(</a><a id="5675" href="Relation.Order.html#4731" data-type="(R₁ x y → ⊥) → x ≡ y → (R₁ y x → ⊥) → Tri R₁ x y" class="InductiveConstructor">eq</a> <a id="5678" href="Relation.Order.html#5678" class="Bound">¬x≺y</a>  <a id="5684" href="Relation.Order.html#5684" class="Bound">x≡y</a> <a id="5688" href="Relation.Order.html#5688" class="Bound">¬y≺x</a><a id="5692" class="Symbol">)</a> <a id="5694" class="Symbol">=</a> <a id="5696" href="Relation.Order.html#4731" data-type="(R₁ x y → ⊥) → x ≡ y → (R₁ y x → ⊥) → Tri R₁ x y" class="InductiveConstructor">eq</a> <a id="5699" href="Relation.Order.html#5688" class="Bound">¬y≺x</a> <a id="5704" class="Symbol">(</a><a id="5705" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="5709" href="Relation.Order.html#5684" class="Bound">x≡y</a><a id="5712" class="Symbol">)</a>    <a id="5717" href="Relation.Order.html#5678" class="Bound">¬x≺y</a>
<a id="5722" href="Relation.Order.html#5568" data-type="Tri R₁ x y → Tri R₁ y x" class="Function">tri-sym</a> <a id="5730" class="Symbol">(</a><a id="5731" href="Relation.Order.html#4790" data-type="(R₁ x y → ⊥) → (x ≡ y → ⊥) → R₁ y x → Tri R₁ x y" class="InductiveConstructor">gt</a> <a id="5734" href="Relation.Order.html#5734" class="Bound">¬x≺y</a> <a id="5739" href="Relation.Order.html#5739" class="Bound">¬x≡y</a>  <a id="5745" href="Relation.Order.html#5745" class="Bound">y≺x</a><a id="5748" class="Symbol">)</a> <a id="5750" class="Symbol">=</a> <a id="5752" href="Relation.Order.html#4672" data-type="R₁ x y → (x ≡ y → ⊥) → (R₁ y x → ⊥) → Tri R₁ x y" class="InductiveConstructor">lt</a>  <a id="5756" href="Relation.Order.html#5745" class="Bound">y≺x</a> <a id="5760" class="Symbol">(</a><a id="5761" href="Relation.Order.html#5739" class="Bound">¬x≡y</a> <a id="5766" href="1Lab.Type.html#2227" data-type="((y : B₁ x) → C x y) → (f : (x : A) → B₁ x) (x : A) → C x (f x)" class="Function Operator">∘</a> <a id="5768" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a><a id="5771" class="Symbol">)</a> <a id="5773" href="Relation.Order.html#5734" class="Bound">¬x≺y</a>
</pre>
  </article>
</div>
</main>
</body>
<style>.equations { display: none !important; }</style></html>
